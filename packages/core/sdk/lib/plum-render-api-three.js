import * as THREE$2 from 'three';
import { REVISION, Vector3, Color, Matrix3, ColorManagement, SRGBColorSpace, Vector2, Sphere, Matrix4, Quaternion, BufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Loader, LoaderUtils, FileLoader, MeshPhysicalMaterial, LinearSRGBColorSpace, SpotLight, PointLight, DirectionalLight, InstancedMesh, InstancedBufferAttribute, Object3D, TextureLoader, ImageBitmapLoader, InterleavedBuffer, InterleavedBufferAttribute, LinearMipmapLinearFilter, NearestMipmapLinearFilter, LinearMipmapNearestFilter, NearestMipmapNearestFilter, LinearFilter, NearestFilter, RepeatWrapping, MirroredRepeatWrapping, ClampToEdgeWrapping, PointsMaterial, Material, LineBasicMaterial, MeshStandardMaterial, DoubleSide, MeshBasicMaterial, PropertyBinding, BufferGeometry, SkinnedMesh, Mesh, LineSegments, Line as Line$1, LineLoop, Points, Group, PerspectiveCamera, MathUtils, OrthographicCamera, Skeleton, AnimationClip, Bone, InterpolateDiscrete, InterpolateLinear, Texture, VectorKeyframeTrack, NumberKeyframeTrack, QuaternionKeyframeTrack, FrontSide, Interpolant, Box3, DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, RedFormat, NoColorSpace, DataUtils, Scene, PlaneGeometry, WebGLRenderTarget, UVMapping, WebGLRenderer, DataTexture, ShaderMaterial, IntType, ShortType, ByteType, UnsignedIntType, UnsignedByteType, LoadingManager, LinearMipMapLinearFilter, NoBlending, CompressedCubeTexture, CompressedArrayTexture, CompressedTexture, RGBA_ASTC_6x6_Format, RGBA_ASTC_4x4_Format, RGFormat, Data3DTexture, RGBA_S3TC_DXT1_Format, RGB_PVRTC_4BPPV1_Format, RGB_ETC2_Format, RGB_ETC1_Format, RGBA_S3TC_DXT5_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_ETC2_EAC_Format, RGBA_BPTC_Format, RGB_BPTC_UNSIGNED_Format, Float32BufferAttribute, Int32BufferAttribute, Ray, BufferGeometryLoader, RectAreaLight, CanvasTexture, SpriteMaterial, Sprite as Sprite$1, MeshPhongMaterial, CubeTextureLoader, ObjectLoader, AudioLoader, EventDispatcher as EventDispatcher$1, DepthTexture, DepthStencilFormat, UnsignedInt248Type, RGBADepthPacking, EqualDepth, NotEqualDepth, BasicDepthPacking, Uniform, Vector4, Camera, BackSide, MeshDepthMaterial, LessDepth, LuminanceFormat, GreaterDepth, GreaterEqualDepth, LessEqualDepth, AlwaysDepth, NeverDepth, Controls, Raycaster, CylinderGeometry, BoxGeometry, OctahedronGeometry, TorusGeometry, SphereGeometry, Euler, UniformsUtils, UniformsLib, ShaderLib, InstancedBufferGeometry, InstancedInterleavedBuffer, WireframeGeometry, Line3, Shape, CatmullRomCurve3, ExtrudeGeometry, CubicBezierCurve3, QuadraticBezierCurve3, Clock, Spherical } from 'three';
import axios from 'axios';

function buildGraph(object) {
  const data = { nodes: {}, materials: {} };
  if (object) {
    object.traverse((obj) => {
      if (obj.name) data.nodes[obj.name] = obj;
      if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;
    });
  }
  return data;
}

const getVersion = () => parseInt(REVISION.replace(/\D+/g, ""));
const version = /* @__PURE__ */ getVersion();

let link = document.createElement("a");
class DownloadTool {
  static save(blob, filename) {
    if (link.href) {
      URL.revokeObjectURL(link.href);
    }
    link.href = URL.createObjectURL(blob);
    link.download = filename || "data.json";
    link.dispatchEvent(new MouseEvent("click"));
  }
  static saveImg(img, filename) {
    if (link.href) {
      URL.revokeObjectURL(link.href);
    }
    link.href = img;
    link.download = filename || "render.json";
    link.dispatchEvent(new MouseEvent("click"));
  }
  static saveArrayBuffer(buffer, filename) {
    DownloadTool.save(new Blob([buffer], { type: "application/octet-stream" }), filename);
  }
  static saveString(text, filename) {
    DownloadTool.save(new Blob([text], { type: "text/plain" }), filename);
  }
}

/**
 * Usage:
 *  const exporter = new STLExporter();
 *
 *  // second argument is a list of options
 *  const data = exporter.parse( mesh, { binary: true } );
 *
 */

class STLExporter {

	parse( scene, options = {} ) {

		options = Object.assign( {
			binary: false
		}, options );

		const binary = options.binary;

		//

		const objects = [];
		let triangles = 0;

		scene.traverse( function ( object ) {

			if ( object.isMesh ) {

				const geometry = object.geometry;

				const index = geometry.index;
				const positionAttribute = geometry.getAttribute( 'position' );

				triangles += ( index !== null ) ? ( index.count / 3 ) : ( positionAttribute.count / 3 );

				objects.push( {
					object3d: object,
					geometry: geometry
				} );

			}

		} );

		let output;
		let offset = 80; // skip header

		if ( binary === true ) {

			const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;
			const arrayBuffer = new ArrayBuffer( bufferLength );
			output = new DataView( arrayBuffer );
			output.setUint32( offset, triangles, true ); offset += 4;

		} else {

			output = '';
			output += 'solid exported\n';

		}

		const vA = new Vector3();
		const vB = new Vector3();
		const vC = new Vector3();
		const cb = new Vector3();
		const ab = new Vector3();
		const normal = new Vector3();

		for ( let i = 0, il = objects.length; i < il; i ++ ) {

			const object = objects[ i ].object3d;
			const geometry = objects[ i ].geometry;

			const index = geometry.index;
			const positionAttribute = geometry.getAttribute( 'position' );

			if ( index !== null ) {

				// indexed geometry

				for ( let j = 0; j < index.count; j += 3 ) {

					const a = index.getX( j + 0 );
					const b = index.getX( j + 1 );
					const c = index.getX( j + 2 );

					writeFace( a, b, c, positionAttribute, object );

				}

			} else {

				// non-indexed geometry

				for ( let j = 0; j < positionAttribute.count; j += 3 ) {

					const a = j + 0;
					const b = j + 1;
					const c = j + 2;

					writeFace( a, b, c, positionAttribute, object );

				}

			}

		}

		if ( binary === false ) {

			output += 'endsolid exported\n';

		}

		return output;

		function writeFace( a, b, c, positionAttribute, object ) {

			vA.fromBufferAttribute( positionAttribute, a );
			vB.fromBufferAttribute( positionAttribute, b );
			vC.fromBufferAttribute( positionAttribute, c );

			if ( object.isSkinnedMesh === true ) {

				object.applyBoneTransform( a, vA );
				object.applyBoneTransform( b, vB );
				object.applyBoneTransform( c, vC );

			}

			vA.applyMatrix4( object.matrixWorld );
			vB.applyMatrix4( object.matrixWorld );
			vC.applyMatrix4( object.matrixWorld );

			writeNormal( vA, vB, vC );

			writeVertex( vA );
			writeVertex( vB );
			writeVertex( vC );

			if ( binary === true ) {

				output.setUint16( offset, 0, true ); offset += 2;

			} else {

				output += '\t\tendloop\n';
				output += '\tendfacet\n';

			}

		}

		function writeNormal( vA, vB, vC ) {

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab ).normalize();

			normal.copy( cb ).normalize();

			if ( binary === true ) {

				output.setFloat32( offset, normal.x, true ); offset += 4;
				output.setFloat32( offset, normal.y, true ); offset += 4;
				output.setFloat32( offset, normal.z, true ); offset += 4;

			} else {

				output += '\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\n';
				output += '\t\touter loop\n';

			}

		}

		function writeVertex( vertex ) {

			if ( binary === true ) {

				output.setFloat32( offset, vertex.x, true ); offset += 4;
				output.setFloat32( offset, vertex.y, true ); offset += 4;
				output.setFloat32( offset, vertex.z, true ); offset += 4;

			} else {

				output += '\t\t\tvertex ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';

			}

		}

	}

}

/**
 * https://github.com/gkjohnson/ply-exporter-js
 *
 * Usage:
 *  const exporter = new PLYExporter();
 *
 *  // second argument is a list of options
 *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });
 *
 * Format Definition:
 * http://paulbourke.net/dataformats/ply/
 */

class PLYExporter {

	parse( object, onDone, options = {} ) {

		// Iterate over the valid meshes in the object
		function traverseMeshes( cb ) {

			object.traverse( function ( child ) {

				if ( child.isMesh === true || child.isPoints ) {

					const mesh = child;
					const geometry = mesh.geometry;

					if ( geometry.hasAttribute( 'position' ) === true ) {

						cb( mesh, geometry );

					}

				}

			} );

		}

		// Default options
		const defaultOptions = {
			binary: false,
			excludeAttributes: [], // normal, uv, color, index
			littleEndian: false
		};

		options = Object.assign( defaultOptions, options );

		const excludeAttributes = options.excludeAttributes;
		let includeIndices = true;
		let includeNormals = false;
		let includeColors = false;
		let includeUVs = false;

		// count the vertices, check which properties are used,
		// and cache the BufferGeometry
		let vertexCount = 0;
		let faceCount = 0;

		object.traverse( function ( child ) {

			if ( child.isMesh === true ) {

				const mesh = child;
				const geometry = mesh.geometry;

				const vertices = geometry.getAttribute( 'position' );
				const normals = geometry.getAttribute( 'normal' );
				const uvs = geometry.getAttribute( 'uv' );
				const colors = geometry.getAttribute( 'color' );
				const indices = geometry.getIndex();

				if ( vertices === undefined ) {

					return;

				}

				vertexCount += vertices.count;
				faceCount += indices ? indices.count / 3 : vertices.count / 3;

				if ( normals !== undefined ) includeNormals = true;

				if ( uvs !== undefined ) includeUVs = true;

				if ( colors !== undefined ) includeColors = true;

			} else if ( child.isPoints ) {

				const mesh = child;
				const geometry = mesh.geometry;

				const vertices = geometry.getAttribute( 'position' );
				const normals = geometry.getAttribute( 'normal' );
				const colors = geometry.getAttribute( 'color' );

				vertexCount += vertices.count;

				if ( normals !== undefined ) includeNormals = true;

				if ( colors !== undefined ) includeColors = true;

				includeIndices = false;

			}

		} );

		const tempColor = new Color();
		includeIndices = includeIndices && excludeAttributes.indexOf( 'index' ) === -1;
		includeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === -1;
		includeColors = includeColors && excludeAttributes.indexOf( 'color' ) === -1;
		includeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === -1;


		if ( includeIndices && faceCount !== Math.floor( faceCount ) ) {

			// point cloud meshes will not have an index array and may not have a
			// number of vertices that is divisible by 3 (and therefore representable
			// as triangles)
			console.error(

				'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +
				'number of indices is not divisible by 3.'

			);

			return null;

		}

		const indexByteCount = 4;

		let header =
			'ply\n' +
			`format ${ options.binary ? ( options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' ) : 'ascii' } 1.0\n` +
			`element vertex ${vertexCount}\n` +

			// position
			'property float x\n' +
			'property float y\n' +
			'property float z\n';

		if ( includeNormals === true ) {

			// normal
			header +=
				'property float nx\n' +
				'property float ny\n' +
				'property float nz\n';

		}

		if ( includeUVs === true ) {

			// uvs
			header +=
				'property float s\n' +
				'property float t\n';

		}

		if ( includeColors === true ) {

			// colors
			header +=
				'property uchar red\n' +
				'property uchar green\n' +
				'property uchar blue\n';

		}

		if ( includeIndices === true ) {

			// faces
			header +=
				`element face ${faceCount}\n` +
				'property list uchar int vertex_index\n';

		}

		header += 'end_header\n';


		// Generate attribute data
		const vertex = new Vector3();
		const normalMatrixWorld = new Matrix3();
		let result = null;

		if ( options.binary === true ) {

			// Binary File Generation
			const headerBin = new TextEncoder().encode( header );

			// 3 position values at 4 bytes
			// 3 normal values at 4 bytes
			// 3 color channels with 1 byte
			// 2 uv values at 4 bytes
			const vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );

			// 1 byte shape descriptor
			// 3 vertex indices at ${indexByteCount} bytes
			const faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;
			const output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );
			new Uint8Array( output.buffer ).set( headerBin, 0 );


			let vOffset = headerBin.length;
			let fOffset = headerBin.length + vertexListLength;
			let writtenVertices = 0;
			traverseMeshes( function ( mesh, geometry ) {

				const vertices = geometry.getAttribute( 'position' );
				const normals = geometry.getAttribute( 'normal' );
				const uvs = geometry.getAttribute( 'uv' );
				const colors = geometry.getAttribute( 'color' );
				const indices = geometry.getIndex();

				normalMatrixWorld.getNormalMatrix( mesh.matrixWorld );

				for ( let i = 0, l = vertices.count; i < l; i ++ ) {

					vertex.fromBufferAttribute( vertices, i );

					vertex.applyMatrix4( mesh.matrixWorld );


					// Position information
					output.setFloat32( vOffset, vertex.x, options.littleEndian );
					vOffset += 4;

					output.setFloat32( vOffset, vertex.y, options.littleEndian );
					vOffset += 4;

					output.setFloat32( vOffset, vertex.z, options.littleEndian );
					vOffset += 4;

					// Normal information
					if ( includeNormals === true ) {

						if ( normals != null ) {

							vertex.fromBufferAttribute( normals, i );

							vertex.applyMatrix3( normalMatrixWorld ).normalize();

							output.setFloat32( vOffset, vertex.x, options.littleEndian );
							vOffset += 4;

							output.setFloat32( vOffset, vertex.y, options.littleEndian );
							vOffset += 4;

							output.setFloat32( vOffset, vertex.z, options.littleEndian );
							vOffset += 4;

						} else {

							output.setFloat32( vOffset, 0, options.littleEndian );
							vOffset += 4;

							output.setFloat32( vOffset, 0, options.littleEndian );
							vOffset += 4;

							output.setFloat32( vOffset, 0, options.littleEndian );
							vOffset += 4;

						}

					}

					// UV information
					if ( includeUVs === true ) {

						if ( uvs != null ) {

							output.setFloat32( vOffset, uvs.getX( i ), options.littleEndian );
							vOffset += 4;

							output.setFloat32( vOffset, uvs.getY( i ), options.littleEndian );
							vOffset += 4;

						} else {

							output.setFloat32( vOffset, 0, options.littleEndian );
							vOffset += 4;

							output.setFloat32( vOffset, 0, options.littleEndian );
							vOffset += 4;

						}

					}

					// Color information
					if ( includeColors === true ) {

						if ( colors != null ) {

							tempColor.fromBufferAttribute( colors, i );

							ColorManagement.fromWorkingColorSpace( tempColor, SRGBColorSpace );

							output.setUint8( vOffset, Math.floor( tempColor.r * 255 ) );
							vOffset += 1;

							output.setUint8( vOffset, Math.floor( tempColor.g * 255 ) );
							vOffset += 1;

							output.setUint8( vOffset, Math.floor( tempColor.b * 255 ) );
							vOffset += 1;

						} else {

							output.setUint8( vOffset, 255 );
							vOffset += 1;

							output.setUint8( vOffset, 255 );
							vOffset += 1;

							output.setUint8( vOffset, 255 );
							vOffset += 1;

						}

					}

				}

				if ( includeIndices === true ) {

					// Create the face list

					if ( indices !== null ) {

						for ( let i = 0, l = indices.count; i < l; i += 3 ) {

							output.setUint8( fOffset, 3 );
							fOffset += 1;

							output.setUint32( fOffset, indices.getX( i + 0 ) + writtenVertices, options.littleEndian );
							fOffset += indexByteCount;

							output.setUint32( fOffset, indices.getX( i + 1 ) + writtenVertices, options.littleEndian );
							fOffset += indexByteCount;

							output.setUint32( fOffset, indices.getX( i + 2 ) + writtenVertices, options.littleEndian );
							fOffset += indexByteCount;

						}

					} else {

						for ( let i = 0, l = vertices.count; i < l; i += 3 ) {

							output.setUint8( fOffset, 3 );
							fOffset += 1;

							output.setUint32( fOffset, writtenVertices + i, options.littleEndian );
							fOffset += indexByteCount;

							output.setUint32( fOffset, writtenVertices + i + 1, options.littleEndian );
							fOffset += indexByteCount;

							output.setUint32( fOffset, writtenVertices + i + 2, options.littleEndian );
							fOffset += indexByteCount;

						}

					}

				}


				// Save the amount of verts we've already written so we can offset
				// the face index on the next mesh
				writtenVertices += vertices.count;

			} );

			result = output.buffer;

		} else {

			// Ascii File Generation
			// count the number of vertices
			let writtenVertices = 0;
			let vertexList = '';
			let faceList = '';

			traverseMeshes( function ( mesh, geometry ) {

				const vertices = geometry.getAttribute( 'position' );
				const normals = geometry.getAttribute( 'normal' );
				const uvs = geometry.getAttribute( 'uv' );
				const colors = geometry.getAttribute( 'color' );
				const indices = geometry.getIndex();

				normalMatrixWorld.getNormalMatrix( mesh.matrixWorld );

				// form each line
				for ( let i = 0, l = vertices.count; i < l; i ++ ) {

					vertex.fromBufferAttribute( vertices, i );

					vertex.applyMatrix4( mesh.matrixWorld );


					// Position information
					let line =
						vertex.x + ' ' +
						vertex.y + ' ' +
						vertex.z;

					// Normal information
					if ( includeNormals === true ) {

						if ( normals != null ) {

							vertex.fromBufferAttribute( normals, i );

							vertex.applyMatrix3( normalMatrixWorld ).normalize();

							line += ' ' +
								vertex.x + ' ' +
								vertex.y + ' ' +
								vertex.z;

						} else {

							line += ' 0 0 0';

						}

					}

					// UV information
					if ( includeUVs === true ) {

						if ( uvs != null ) {

							line += ' ' +
								uvs.getX( i ) + ' ' +
								uvs.getY( i );

						} else {

							line += ' 0 0';

						}

					}

					// Color information
					if ( includeColors === true ) {

						if ( colors != null ) {

							tempColor.fromBufferAttribute( colors, i );

							ColorManagement.fromWorkingColorSpace( tempColor, SRGBColorSpace );

							line += ' ' +
								Math.floor( tempColor.r * 255 ) + ' ' +
								Math.floor( tempColor.g * 255 ) + ' ' +
								Math.floor( tempColor.b * 255 );

						} else {

							line += ' 255 255 255';

						}

					}

					vertexList += line + '\n';

				}

				// Create the face list
				if ( includeIndices === true ) {

					if ( indices !== null ) {

						for ( let i = 0, l = indices.count; i < l; i += 3 ) {

							faceList += `3 ${ indices.getX( i + 0 ) + writtenVertices }`;
							faceList += ` ${ indices.getX( i + 1 ) + writtenVertices }`;
							faceList += ` ${ indices.getX( i + 2 ) + writtenVertices }\n`;

						}

					} else {

						for ( let i = 0, l = vertices.count; i < l; i += 3 ) {

							faceList += `3 ${ writtenVertices + i } ${ writtenVertices + i + 1 } ${ writtenVertices + i + 2 }\n`;

						}

					}

					faceCount += indices ? indices.count / 3 : vertices.count / 3;

				}

				writtenVertices += vertices.count;

			} );

			result = `${ header }${vertexList}${ includeIndices ? `${faceList}\n` : '\n' }`;

		}

		if ( typeof onDone === 'function' ) requestAnimationFrame( () => onDone( result ) );

		return result;

	}

}

class OBJExporter {

	parse( object ) {

		let output = '';

		let indexVertex = 0;
		let indexVertexUvs = 0;
		let indexNormals = 0;

		const vertex = new Vector3();
		const color = new Color();
		const normal = new Vector3();
		const uv = new Vector2();

		const face = [];

		function parseMesh( mesh ) {

			let nbVertex = 0;
			let nbNormals = 0;
			let nbVertexUvs = 0;

			const geometry = mesh.geometry;

			const normalMatrixWorld = new Matrix3();

			// shortcuts
			const vertices = geometry.getAttribute( 'position' );
			const normals = geometry.getAttribute( 'normal' );
			const uvs = geometry.getAttribute( 'uv' );
			const indices = geometry.getIndex();

			// name of the mesh object
			output += 'o ' + mesh.name + '\n';

			// name of the mesh material
			if ( mesh.material && mesh.material.name ) {

				output += 'usemtl ' + mesh.material.name + '\n';

			}

			// vertices

			if ( vertices !== undefined ) {

				for ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {

					vertex.fromBufferAttribute( vertices, i );

					// transform the vertex to world space
					vertex.applyMatrix4( mesh.matrixWorld );

					// transform the vertex to export format
					output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';

				}

			}

			// uvs

			if ( uvs !== undefined ) {

				for ( let i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {

					uv.fromBufferAttribute( uvs, i );

					// transform the uv to export format
					output += 'vt ' + uv.x + ' ' + uv.y + '\n';

				}

			}

			// normals

			if ( normals !== undefined ) {

				normalMatrixWorld.getNormalMatrix( mesh.matrixWorld );

				for ( let i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {

					normal.fromBufferAttribute( normals, i );

					// transform the normal to world space
					normal.applyMatrix3( normalMatrixWorld ).normalize();

					// transform the normal to export format
					output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\n';

				}

			}

			// faces

			if ( indices !== null ) {

				for ( let i = 0, l = indices.count; i < l; i += 3 ) {

					for ( let m = 0; m < 3; m ++ ) {

						const j = indices.getX( i + m ) + 1;

						face[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );

					}

					// transform the face to export format
					output += 'f ' + face.join( ' ' ) + '\n';

				}

			} else {

				for ( let i = 0, l = vertices.count; i < l; i += 3 ) {

					for ( let m = 0; m < 3; m ++ ) {

						const j = i + m + 1;

						face[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );

					}

					// transform the face to export format
					output += 'f ' + face.join( ' ' ) + '\n';

				}

			}

			// update index
			indexVertex += nbVertex;
			indexVertexUvs += nbVertexUvs;
			indexNormals += nbNormals;

		}

		function parseLine( line ) {

			let nbVertex = 0;

			const geometry = line.geometry;
			const type = line.type;

			// shortcuts
			const vertices = geometry.getAttribute( 'position' );

			// name of the line object
			output += 'o ' + line.name + '\n';

			if ( vertices !== undefined ) {

				for ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {

					vertex.fromBufferAttribute( vertices, i );

					// transform the vertex to world space
					vertex.applyMatrix4( line.matrixWorld );

					// transform the vertex to export format
					output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';

				}

			}

			if ( type === 'Line' ) {

				output += 'l ';

				for ( let j = 1, l = vertices.count; j <= l; j ++ ) {

					output += ( indexVertex + j ) + ' ';

				}

				output += '\n';

			}

			if ( type === 'LineSegments' ) {

				for ( let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {

					output += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '\n';

				}

			}

			// update index
			indexVertex += nbVertex;

		}

		function parsePoints( points ) {

			let nbVertex = 0;

			const geometry = points.geometry;

			const vertices = geometry.getAttribute( 'position' );
			const colors = geometry.getAttribute( 'color' );

			output += 'o ' + points.name + '\n';

			if ( vertices !== undefined ) {

				for ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {

					vertex.fromBufferAttribute( vertices, i );
					vertex.applyMatrix4( points.matrixWorld );

					output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;

					if ( colors !== undefined ) {

						color.fromBufferAttribute( colors, i );

						ColorManagement.fromWorkingColorSpace( color, SRGBColorSpace );

						output += ' ' + color.r + ' ' + color.g + ' ' + color.b;

					}

					output += '\n';

				}

				output += 'p ';

				for ( let j = 1, l = vertices.count; j <= l; j ++ ) {

					output += ( indexVertex + j ) + ' ';

				}

				output += '\n';

			}

			// update index
			indexVertex += nbVertex;

		}

		object.traverse( function ( child ) {

			if ( child.isMesh === true ) {

				parseMesh( child );

			}

			if ( child.isLine === true ) {

				parseLine( child );

			}

			if ( child.isPoints === true ) {

				parsePoints( child );

			}

		} );

		return output;

	}

}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$f = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$d = objectProto$f.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$f.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$d.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$e = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$e.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$1 = Array.isArray;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
}

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -Infinity) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity$1(value) {
  return value;
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$1(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$d = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$d.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root, 'WeakMap');

/** Used to store function metadata. */
var metaMap = WeakMap$1 && new WeakMap$1;

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */
function baseLodash() {
  // No operation performed.
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$1 = 4294967295;

/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH$1;
  this.__views__ = [];
}

// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = baseCreate(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop$1() {
  // No operation performed.
}

/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !metaMap ? noop$1 : function(func) {
  return metaMap.get(func);
};

/** Used to lookup unminified function names. */
var realNames = {};

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$c.hasOwnProperty;

/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */
function getFuncName(func) {
  var result = (func.name + ''),
      array = realNames[result],
      length = hasOwnProperty$b.call(realNames, result) ? array.length : 0;

  while (length--) {
    var data = array[length],
        otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}

/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = undefined;
}

LodashWrapper.prototype = baseCreate(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper) {
    return wrapper.clone();
  }
  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray(wrapper.__actions__);
  result.__index__  = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$b.hasOwnProperty;

/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array and iteratees accept only
 * one argument. The heuristic for whether a section qualifies for shortcut
 * fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */
function lodash(value) {
  if (isObjectLike(value) && !isArray$1(value) && !(value instanceof LazyWrapper)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty$a.call(value, '__wrapped__')) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}

// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = baseLodash.prototype;
lodash.prototype.constructor = lodash;

/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */
function isLaziable(func) {
  var funcName = getFuncName(func),
      other = lodash[funcName];

  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData(other);
  return !!data && func === data[0];
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (-1);

  while ((++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$2 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$2(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$2(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity$1), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike$1(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$9;

  return value === proto;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$1;
}

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$8.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$8.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Built-in value references. */
var Buffer$1 = moduleExports$1 ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    weakMapTag$1 = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] =
typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] =
typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] =
typedArrayTags[weakMapTag$1] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$6.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$2(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString$2(value));
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Built-in value references. */
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray$1(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (predicate(value)) {
      {
        arrayPush(result, value);
      }
    } else {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array) : [];
}

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */
var objectTag$1 = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$2.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (true && end >= length) ? array : baseSlice(array, start, end);
}

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff',
    rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
    rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ$1 = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ$1 + rsAstralRange$1  + rsComboRange$1 + rsVarRange$1 + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsFinite = root.isFinite,
    nativeMin = Math.min;

/**
 * Creates a function like `_.round`.
 *
 * @private
 * @param {string} methodName The name of the `Math` method to use when rounding.
 * @returns {Function} Returns the new round function.
 */
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber(number);
    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
    if (precision && nativeIsFinite(number)) {
      // Shift with exponential notation to avoid floating-point issues.
      // See [MDN](https://mdn.io/round#Examples) for more details.
      var pair = (toString$2(number) + 'e').split('e'),
          value = func(pair[0] + 'e' + (+pair[1] + precision));

      pair = (toString$2(value) + 'e').split('e');
      return +(pair[0] + 'e' + (+pair[1] - precision));
    }
    return func(number);
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax$1 = Math.max;

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if ((size === undefined)) {
    size = 1;
  } else {
    size = nativeMax$1(toInteger(size), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice(array, index, (index += size));
  }
  return result;
}

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

/* Built-in method references that are verified to be native. */
var DataView$1 = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root, 'Set');

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$1 = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap$1);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag) ||
    (Map$1 && getTag(new Map$1) != mapTag$1) ||
    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag(new Set$1) != setTag$1) ||
    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag$1;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$1;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto$1[key]) && !hasOwnProperty$1.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

/**
 * Checks if `string` ends with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=string.length] The position to search up to.
 * @returns {boolean} Returns `true` if `string` ends with `target`,
 *  else `false`.
 * @example
 *
 * _.endsWith('abc', 'c');
 * // => true
 *
 * _.endsWith('abc', 'b');
 * // => false
 *
 * _.endsWith('abc', 'b', 2);
 * // => true
 */
function endsWith(string, target, position) {
  string = toString$2(string);
  target = baseToString(target);

  var length = string.length;
  position = position === undefined
    ? length
    : baseClamp(toInteger(position), 0, length);

  var end = position;
  position -= target.length;
  return position >= 0 && string.slice(position, end) == target;
}

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_FLAG = 8,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256;

/**
 * Creates a `_.flow` or `_.flowRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new flow function.
 */
function createFlow(fromRight) {
  return flatRest(function(funcs) {
    var length = funcs.length,
        index = length,
        prereq = LodashWrapper.prototype.thru;
    while (index--) {
      var func = funcs[index];
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
        var wrapper = new LodashWrapper([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func = funcs[index];

      var funcName = getFuncName(func),
          data = funcName == 'wrapper' ? getData(func) : undefined;

      if (data && isLaziable(data[0]) &&
            data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
            !data[4].length && data[9] == 1
          ) {
        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = (func.length == 1 && isLaziable(func))
          ? wrapper[funcName]()
          : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments,
          value = args[0];

      if (wrapper && args.length == 1 && isArray$1(value)) {
        return wrapper.plant(value).value();
      }
      var index = 0,
          result = length ? funcs[index].apply(this, args) : value;

      while (++index < length) {
        result = funcs[index].call(this, result);
      }
      return result;
    };
  });
}

/**
 * Creates a function that returns the result of invoking the given functions
 * with the `this` binding of the created function, where each successive
 * invocation is supplied the return value of the previous.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {...(Function|Function[])} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flowRight
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flow([_.add, square]);
 * addSquare(1, 2);
 * // => 9
 */
var flow = createFlow();

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray$1(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike$1(collection) ? collection : values(collection);
  fromIndex = (fromIndex && true) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

/**
 * The base implementation of `_.invoke` without support for individual
 * method arguments.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {Array} args The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 */
function baseInvoke(object, path, args) {
  path = castPath(path, object);
  object = parent(object, path);
  var func = object == null ? object : object[toKey(last$1(path))];
  return func == null ? undefined : apply(func, object, args);
}

/**
 * Invokes the method at `path` of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
 *
 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
 * // => [2, 3]
 */
var invoke = baseRest(baseInvoke);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike$1(value) &&
      (isArray$1(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil(value) {
  return value == null;
}

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

/* Node.js helper references. */
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * Computes `number` rounded to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round.
 * @param {number} [precision=0] The precision to round to.
 * @returns {number} Returns the rounded number.
 * @example
 *
 * _.round(4.006);
 * // => 4
 *
 * _.round(4.006, 2);
 * // => 4.01
 *
 * _.round(4060, -2);
 * // => 4100
 */
var round = createRound('round');

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/**
 * Splits `string` by `separator`.
 *
 * **Note:** This method is based on
 * [`String#split`](https://mdn.io/String/split).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to split.
 * @param {RegExp|string} separator The separator pattern to split by.
 * @param {number} [limit] The length to truncate results to.
 * @returns {Array} Returns the string segments.
 * @example
 *
 * _.split('a-b-c', '-', 2);
 * // => ['a', 'b']
 */
function split(string, separator, limit) {
  if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
    separator = limit = undefined;
  }
  limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString$2(string);
  if (string && (
        typeof separator == 'string' ||
        (separator != null && !isRegExp(separator))
      )) {
    separator = baseToString(separator);
    if (!separator && hasUnicode(string)) {
      return castSlice(stringToArray(string), 0, limit);
    }
  }
  return string.split(separator, limit);
}

/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */
function startsWith(string, target, position) {
  string = toString$2(string);
  position = position == null
    ? 0
    : baseClamp(toInteger(position), 0, string.length);

  target = baseToString(target);
  return string.slice(position, position + target.length) == target;
}

/**
 * Converts `value` to a property path array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {*} value The value to convert.
 * @returns {Array} Returns the new property path array.
 * @example
 *
 * _.toPath('a.b.c');
 * // => ['a', 'b', 'c']
 *
 * _.toPath('a[0].b.c');
 * // => ['a', '0', 'b', 'c']
 */
function toPath(value) {
  if (isArray$1(value)) {
    return arrayMap(value, toKey);
  }
  return isSymbol(value) ? [value] : copyArray(stringToPath(toString$2(value)));
}

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString$2(prefix) + id;
}

var __defProp$W = Object.defineProperty;
var __defNormalProp$W = (obj, key, value) => key in obj ? __defProp$W(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$W = (obj, key, value) => __defNormalProp$W(obj, typeof key !== "symbol" ? key + "" : key, value);
const _ExporterTool = class _ExporterTool {
  constructor() {
    __publicField$W(this, "dRACOExporter");
    __publicField$W(this, "gLTFExporter");
    __publicField$W(this, "uSDZExporter");
    __publicField$W(this, "sTLExporter");
    __publicField$W(this, "pLYExporter");
    __publicField$W(this, "oBJExporter");
    this.dRACOExporter = new DRACOExporter();
    this.gLTFExporter = new GLTFExporter();
    this.uSDZExporter = new USDZExporter();
    this.sTLExporter = new STLExporter();
    this.pLYExporter = new PLYExporter();
    this.oBJExporter = new OBJExporter();
  }
  static getInstance() {
    if (!_ExporterTool.instance) {
      _ExporterTool.instance = new _ExporterTool();
    }
    return _ExporterTool.instance;
  }
  // 必须导出 场景
  // todo
  exportDRC(object, InOptions) {
    const options = {
      decodeSpeed: 5,
      encodeSpeed: 5,
      encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,
      quantization: [16, 8, 8, 8, 8],
      exportUvs: true,
      exportNormals: true,
      exportColor: object.geometry.hasAttribute("color")
    };
    const result = this.dRACOExporter.parse(object, options);
    DownloadTool.saveArrayBuffer(result, "model.drc");
  }
  exportGLB(input, options) {
    const animations = this.getAnimations(input);
    const optimizedAnimations = [];
    for (const animation of animations) {
      optimizedAnimations.push(animation.clone().optimize());
    }
    this.gLTFExporter.parseAsync(input, {
      binary: true,
      animations: optimizedAnimations,
      ...options
    }).then((result) => {
      DownloadTool.saveArrayBuffer(result, "scene.glb");
    });
  }
  exportOBJ(object) {
    DownloadTool.saveString(this.oBJExporter.parse(object), "model.obj");
  }
  exportPLY(object, options) {
    this.pLYExporter.parse(object, (result) => {
      DownloadTool.saveArrayBuffer(result, "model.ply");
    }, options);
  }
  exportSTL(scene, options) {
    let result = this.sTLExporter.parse(scene, options);
    if (isString(result)) {
      DownloadTool.saveString(result, "model.stl");
    } else {
      DownloadTool.saveArrayBuffer(result, "model.stl");
    }
  }
  exportUSDZ(scene) {
    this.uSDZExporter.parse(scene).then((res) => {
      DownloadTool.saveArrayBuffer(res, "model.usdz");
    });
  }
  getAnimations(scene) {
    const animations = [];
    scene.traverse((object) => {
      animations.push(...object.animations);
    });
    return animations;
  }
  objectExport(object) {
    let output = object.toJSON();
    let outputString = "";
    try {
      outputString = JSON.stringify(output, null, "	");
      outputString = outputString.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, "$1");
    } catch (e) {
      outputString = JSON.stringify(output);
    }
    let name = object.name === "" ? "object" : object.name;
    DownloadTool.save(new Blob([outputString]), `${name}.json`);
  }
  materialExport(object, currentMaterialSlot = 0) {
    const material = Array.isArray(object.material) ? object.material[currentMaterialSlot] : object.material;
    let outputString = "";
    let output = material.toJSON();
    try {
      outputString = JSON.stringify(outputString, null, "	");
      outputString = outputString.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, "$1");
    } catch (e) {
      outputString = JSON.stringify(output);
    }
    material.name === "" ? "object" : material.name;
    DownloadTool.save(new Blob([outputString]), `${material}.json`);
  }
  geometryExport(object) {
    const geometry = object.geometry;
    let output = geometry.toJSON();
    let outputString = "";
    try {
      outputString = JSON.stringify(outputString, null, "	");
      outputString = outputString.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, "$1");
    } catch (e) {
      outputString = JSON.stringify(output);
    }
    let name = geometry.name === "" ? "geometry" : geometry.name;
    DownloadTool.save(new Blob([outputString]), `${name}.json`);
  }
};
__publicField$W(_ExporterTool, "instance");
let ExporterTool = _ExporterTool;

function extractFileNameAndExtension(file) {
  const filename = file.name;
  const splitArray = filename.split(".");
  const nameWithoutExtension = splitArray.slice(0, -1).join(".");
  const extension = splitArray.pop()?.toLowerCase();
  return [nameWithoutExtension, extension];
}

const isCamera = (value) => {
  return get(value, "isCamera") === true;
};

const isPerspectiveCamera$1 = (value) => {
  return get(value, "isPerspectiveCamera") === true;
};

const isDirectionalLight = (value) => {
  return get(value, "isDirectionalLight") === true;
};

const isHemisphereLight = (value) => {
  return get(value, "isHemisphereLight") === true;
};

const isPointLight = (value) => {
  return get(value, "isPointLight") === true;
};

const isSpotLight = (value) => {
  return get(value, "isSpotLight") === true;
};

const isColor = (value) => {
  return get(value, "isColor") === true;
};

const isVector3 = (value) => {
  return !isNil(value) && get(value, "isVector3") === true;
};

const isGroup = (value) => {
  return get(value, "isGroup") === true;
};

const isMesh = (value) => {
  return get(value, "isMesh") === true;
};

const isPoints = (value) => {
  return get(value, "isPoints") === true;
};

const isSkinnedMesh = (value) => {
  return get(value, "isSkinnedMesh") === true;
};

const isDataTexture = (value) => {
  return get(value, "isDataTexture") === true;
};

function getStatistics(scene) {
  let objects = 0, vertices = 0, triangles = 0;
  for (let i = 0, l = scene.children.length; i < l; i++) {
    const object = scene.children[i];
    object.traverseVisible((object2) => {
      objects++;
      if (isMesh(object2) || isPoints(object2)) {
        const geometry = object2.geometry;
        vertices += geometry.attributes.position.count;
        if (isMesh(object2)) {
          if (geometry.index !== null) {
            triangles += geometry.index.count / 3;
          } else {
            triangles += geometry.attributes.position.count / 3;
          }
        }
      }
    });
  }
  return {
    objects,
    vertices,
    triangles
  };
}

const v = new THREE$2.Vector3();
class LineTool {
  static getQuadraticBezierCurve3Points(options) {
    const { start, end, mid, quadraticBezierCurve3 } = options;
    if (isVector3(start)) {
      quadraticBezierCurve3.v0.copy(start);
    } else {
      quadraticBezierCurve3.v0.set(...start);
    }
    if (isVector3(end)) {
      quadraticBezierCurve3.v2.copy(end);
    } else {
      quadraticBezierCurve3.v2.set(...end);
    }
    if (isVector3(mid)) {
      quadraticBezierCurve3.v1.copy(mid);
    } else if (Array.isArray(mid)) {
      quadraticBezierCurve3.v1.set(...mid);
    } else {
      quadraticBezierCurve3.v1.copy(
        quadraticBezierCurve3.v0.clone().add(quadraticBezierCurve3.v2.clone().sub(quadraticBezierCurve3.v0)).add(v.set(0, quadraticBezierCurve3.v0.y - quadraticBezierCurve3.v2.y, 0))
      );
    }
    return quadraticBezierCurve3;
  }
  static getCubicBezierCurve3Points(options) {
    const { start, end, midA, midB, cubicBezierCurve3 } = options;
    if (isVector3(start)) {
      cubicBezierCurve3.v0.copy(start);
    } else {
      cubicBezierCurve3.v0.set(...start);
    }
    if (isVector3(end)) {
      cubicBezierCurve3.v3.copy(end);
    } else {
      cubicBezierCurve3.v3.set(...end);
    }
    if (isVector3(midA)) {
      cubicBezierCurve3.v1.copy(midA);
    } else {
      cubicBezierCurve3.v1.set(...midA);
    }
    if (isVector3(midB)) {
      cubicBezierCurve3.v2.copy(midB);
    } else {
      cubicBezierCurve3.v2.set(...midB);
    }
    return cubicBezierCurve3;
  }
}

var __defProp$V = Object.defineProperty;
var __defNormalProp$V = (obj, key, value) => key in obj ? __defProp$V(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$V = (obj, key, value) => __defNormalProp$V(obj, key + "" , value);
function shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {
  const material = class extends THREE$2.ShaderMaterial {
    constructor(parameters = {}) {
      const entries = Object.entries(uniforms);
      super({
        uniforms: entries.reduce((acc, [name, value]) => {
          const uniform = THREE$2.UniformsUtils.clone({ [name]: { value } });
          return {
            ...acc,
            ...uniform
          };
        }, {}),
        vertexShader,
        fragmentShader
      });
      __publicField$V(this, "key", "");
      entries.forEach(
        ([name]) => Object.defineProperty(this, name, {
          get: () => this.uniforms[name].value,
          set: (v) => this.uniforms[name].value = v
        })
      );
      Object.assign(this, parameters);
      if (onInit) onInit(this);
    }
    // } as unknown as typeof THREE.ShaderMaterial & { key: string }
  };
  return material;
}

function compareObjects(objA, objB, keys) {
  for (const key of keys) {
    if (Reflect.get(objA, "key") !== Reflect.get(objA, "key")) {
      return true;
    }
  }
  return false;
}

function deepMergeRetain$1(target, source) {
  if (isNil(source)) {
    return target;
  }
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      if (isPlainObject(get(target, key))) {
        if (!target.hasOwnProperty(key)) {
          Reflect.set(target, key, {});
        }
        deepMergeRetain$1(Reflect.get(target, key), Reflect.get(source, key));
      } else {
        Reflect.set(target, key, get(source, key));
      }
    }
  }
  return target;
}

function isUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (err) {
    return false;
  }
}

function normalize(value, min, max, a = 0, b = 1) {
  return a + (value - min) * (b - a) / (max - min);
}

function reflectGet(object, name) {
  return Reflect.get(object, name);
}

function reflectSet(object, name, value) {
  return Reflect.set(object, name, value);
}

var __defProp$U = Object.defineProperty;
var __defNormalProp$U = (obj, key, value) => key in obj ? __defProp$U(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$U = (obj, key, value) => __defNormalProp$U(obj, typeof key !== "symbol" ? key + "" : key, value);
var ESearchMode = /* @__PURE__ */ ((ESearchMode2) => {
  ESearchMode2["MatchAll"] = "all";
  ESearchMode2["MatchAny"] = "any";
  ESearchMode2["MatchNone"] = "none";
  return ESearchMode2;
})(ESearchMode || {});
var SearchOperator = /* @__PURE__ */ ((SearchOperator2) => {
  SearchOperator2[SearchOperator2["Has"] = 0] = "Has";
  SearchOperator2[SearchOperator2["NotHas"] = 1] = "NotHas";
  SearchOperator2[SearchOperator2["In"] = 2] = "In";
  SearchOperator2[SearchOperator2["NotIn"] = 3] = "NotIn";
  SearchOperator2[SearchOperator2["NotEqual"] = 4] = "NotEqual";
  SearchOperator2[SearchOperator2["Equal"] = 5] = "Equal";
  SearchOperator2[SearchOperator2["GreaterThan"] = 6] = "GreaterThan";
  SearchOperator2[SearchOperator2["GreaterThanOrEqual"] = 7] = "GreaterThanOrEqual";
  SearchOperator2[SearchOperator2["LessThan"] = 8] = "LessThan";
  SearchOperator2[SearchOperator2["LessThanOrEqual"] = 9] = "LessThanOrEqual";
  SearchOperator2[SearchOperator2["StartWith"] = 10] = "StartWith";
  SearchOperator2[SearchOperator2["EndWith"] = 11] = "EndWith";
  return SearchOperator2;
})(SearchOperator || {});
class Search {
  constructor(conditions, searchMode = "all" /* MatchAll */) {
    __publicField$U(this, "conditions", []);
    __publicField$U(this, "searchMode", "all" /* MatchAll */);
    this.conditions = conditions;
    this.searchMode = searchMode;
  }
  // 根据表达式计算结果
  isCondition(obj, condition) {
    if (isNil(obj) || isEmpty(obj)) {
      return false;
    }
    const { propertyPath, operator, value } = condition;
    const property = get(obj, propertyPath);
    switch (operator) {
      case 0 /* Has */:
        return !isNil(property);
      // 检查属性是否存在
      case 1 /* NotHas */:
        return isNil(property);
      // 检查属性是否不存在
      case 2 /* In */:
        return includes(property, value);
      // 检查值是否在数组中, 字符串是否包含子字符串
      case 3 /* NotIn */:
        return !includes(property, value);
      // 检查值是否不在数组中
      case 4 /* NotEqual */:
        return property !== value;
      // 检查不等于
      case 5 /* Equal */:
        return property === value;
      // 检查等于
      case 6 /* GreaterThan */:
        return property > value;
      // 检查大于
      case 7 /* GreaterThanOrEqual */:
        return property >= value;
      // 检查大于等于
      case 8 /* LessThan */:
        return property < value;
      // 检查小于
      case 9 /* LessThanOrEqual */:
        return property <= value;
      // 检查小于等于
      case 10 /* StartWith */:
        return startsWith(property, value);
      // 以...开头
      case 11 /* EndWith */:
        return endsWith(property, value);
    }
  }
  // 验证对象是否符合搜索条件
  matching(obj) {
    const conditions = this.conditions || [];
    const results = [];
    conditions.forEach((condition) => {
      let isCondition = this.isCondition(obj, condition);
      if (isCondition) {
        results.push(isCondition);
      }
    });
    switch (this.searchMode) {
      case "all" /* MatchAll */:
        return results.length === conditions.length;
      // 所有条件都需满足
      case "any" /* MatchAny */:
        return results.length >= 1;
      // 任一条件满足
      case "none" /* MatchNone */:
        return results.length === 0;
    }
  }
}

function setByPath(object, name, value) {
  return set(object, name, value);
}

let Tool$1 = class Tool {
  static getObjectMaterial(object, slot) {
    let material = object.material;
    if (Array.isArray(material) && slot !== void 0) {
      material = material[slot];
    }
    return material;
  }
  static setObjectMaterial(object, slot, newMaterial) {
    if (Array.isArray(object.material) && slot !== void 0) {
      object.material[slot] = newMaterial;
    } else {
      object.material = newMaterial;
    }
  }
  static search(obj, array, searchMode = ESearchMode.MatchAll) {
    const search = new Search(array, searchMode);
    let result = [];
    obj.traverse((target) => {
      const isMatch = search.matching(target);
      if (isMatch) {
        result.push(target);
      }
    });
    return result;
  }
  static calculateCenter(pointA, pointB) {
    return new THREE$2.Vector3().addVectors(pointA, pointB).multiplyScalar(0.5);
  }
  static calculateTotalLength(points) {
    let totalLength = 0;
    for (let i = 0; i < points.length - 1; i++) {
      const pointA = points[i];
      const pointB = points[i + 1];
      totalLength += pointA.distanceTo(pointB);
    }
    return totalLength;
  }
  static v3ArrayToVector3Array(array) {
    if (array.length === 0) {
      return array;
    }
    if (isVector3(array[0])) {
      return array;
    } else {
      return array.map((v) => {
        return new THREE$2.Vector3(v[0], v[1], v[2]);
      });
    }
  }
  static v3ArrayToNum3Array(array) {
    if (array.length === 0) {
      return array;
    }
    if (!isVector3(array[0])) {
      return array;
    } else {
      return array.map((v) => {
        return v.toArray();
      });
    }
  }
  /**
   * 从V3Array创建QuadraticBezierCurve3Points
   * @param array
   */
  static getQuadraticBezierCurve3Points(array) {
    return {
      vector3Array: Tool.v3ArrayToVector3Array(array),
      num3Array: Tool.v3ArrayToNum3Array(array)
    };
  }
  /**
   * 从V3Array创建Box3
   * @param array
   */
  static getBox3ByV3Array(array) {
    const v3Array = Tool.v3ArrayToVector3Array(array);
    return new THREE$2.Box3().setFromPoints(v3Array);
  }
  /**
   * 从Texture创建base64字符串
   * @param texture
   */
  static getBase64FromTexture(texture) {
    if (isDataTexture(texture)) {
      return void 0;
    } else {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const img = texture.image;
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      return canvas.toDataURL("image/jpeg");
    }
  }
  /**
   * 从base64字符串创建Texture
   * @param base64
   */
  static getTextureFromBase64(base64) {
    const texture = new THREE$2.Texture();
    const image = new Image();
    image.src = base64;
    image.onload = () => {
      texture.image = image;
      texture.needsUpdate = true;
    };
    return texture;
  }
  static getObjectByUuid(object, uuid) {
    return object.getObjectByProperty("uuid", uuid);
  }
  // 获取鼠标在容器中的 位置的 比值 0-1
  static getMousePosition(event, dom) {
    const rect = dom.getBoundingClientRect();
    const x = event.clientX;
    const y = event.clientY;
    return [(x - rect.left) / rect.width, (y - rect.top) / rect.height];
  }
  // 归一化设备坐标
  static getNFC(event, dom) {
    let [x, y] = Tool.getMousePosition(event, dom);
    x = normalize(x, 0, 1, -1, 1);
    y = normalize(y, 0, 1, -1, 1);
    return [x, -y];
  }
  /**
   * 获取多个物体的包围盒
   * @param objects
   */
  static getBox3ByObject3ds(objects) {
    const box3 = new THREE$2.Box3();
    for (let i = 0; i < objects.length; i++) {
      const object = objects[i];
      if (isMesh(object)) {
        if (object.geometry.boundingBox === null) {
          object.geometry.computeBoundingBox();
        }
        box3.union(object.geometry.boundingBox.clone().applyMatrix4(object.matrixWorld));
      } else if (isGroup(object)) {
        const box = new THREE$2.Box3();
        box.setFromObject(object);
        box3.union(box);
      }
    }
    return box3;
  }
  /**
   * 获取多个物体的包围球
   * @param objects
   */
  static getSphereByObject3ds(objects) {
    const sphere = new THREE$2.Sphere();
    for (let i = 0; i < objects.length; i++) {
      const object = objects[i];
      if (isMesh(object)) {
        if (object.geometry.boundingSphere === null) {
          object.geometry.computeBoundingSphere();
        }
        sphere.union(object.geometry.boundingSphere.clone().applyMatrix4(object.matrixWorld));
      } else if (isGroup(object)) {
        const box = new THREE$2.Box3();
        box.setFromObject(object);
        sphere.union(box.getBoundingSphere(new Sphere()));
      }
    }
    return sphere;
  }
  /**
   * 获取场景的包围盒
   * @param scene
   */
  static getSceneBox(scene) {
    const box3 = new THREE$2.Box3();
    scene.traverse((mesh) => {
      if (isMesh(mesh)) {
        mesh.geometry.computeBoundingBox();
        if (mesh.geometry.boundingBox) {
          box3.union(mesh.geometry.boundingBox.clone().applyMatrix4(mesh.matrixWorld));
        }
      }
    });
    return box3;
  }
  /**
   * 获取场景的包围球
   * @param scene
   */
  static getSceneSphere(scene) {
    const sphere = new THREE$2.Sphere();
    scene.traverse((mesh) => {
      if (isMesh(mesh)) {
        mesh.geometry.computeBoundingSphere();
        if (mesh.geometry.boundingSphere) {
          sphere.union(mesh.geometry.boundingSphere.clone().applyMatrix4(mesh.matrixWorld));
        }
      }
    });
    return sphere;
  }
};

function logStack(name = uniqueId()) {
  console.log(new Error(name).stack);
}

function throwDebug() {
  throw new Error("");
}

let debugNum = 0;
function throwNum(num) {
  if (debugNum === num) {
    debugNum = 0;
    throw new Error("");
  }
  debugNum += 1;
}

var __defProp$T = Object.defineProperty;
var __defNormalProp$T = (obj, key, value) => key in obj ? __defProp$T(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$T = (obj, key, value) => __defNormalProp$T(obj, typeof key !== "symbol" ? key + "" : key, value);
class Component {
  constructor(options) {
    __publicField$T(this, "options");
    __publicField$T(this, "viewer");
    this.options = deepMergeRetain$1(options, {});
    this.viewer = this.options.viewer;
  }
  get scene() {
    return this.viewer.scene;
  }
  get sceneHelpers() {
    return this.viewer.sceneHelpers;
  }
  get eventManager() {
    return this.viewer.eventManager;
  }
  get cameraManager() {
    return this.viewer.cameraManager;
  }
  get cameraControls() {
    return this.viewer.cameraManager.cameraControls;
  }
  get renderer() {
    return this.viewer.renderManager.defaultWebGLRenderer;
  }
  get renderManager() {
    return this.viewer.renderManager;
  }
  get postProcessingComponent() {
    return this.viewer.postProcessingComponent;
  }
  get assetManager() {
    return this.viewer.assetManager;
  }
  get camera() {
    return this.viewer.cameraManager.camera;
  }
  get container() {
    return this.viewer.container;
  }
  get canvas() {
    return this.renderManager.defaultWebGLRenderer.domElement;
  }
  get editor() {
    return this.viewer.editor;
  }
  get loop() {
    return this.viewer.loop;
  }
  get cssRenderer() {
    return this.viewer.cssRenderer;
  }
}

/**
 * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
 */

const _position = new Vector3();
const _quaternion = new Quaternion();
const _scale = new Vector3();

//

const _matrix = new Matrix4();
const _matrix2 = new Matrix4();

class CSS3DRenderer {

	constructor( parameters = {} ) {

		const _this = this;

		let _width, _height;
		let _widthHalf, _heightHalf;

		const cache = {
			camera: { style: '' },
			objects: new WeakMap()
		};

		const domElement = parameters.element !== undefined ? parameters.element : document.createElement( 'div' );

		domElement.style.overflow = 'hidden';

		this.domElement = domElement;

		const viewElement = document.createElement( 'div' );
		viewElement.style.transformOrigin = '0 0';
		viewElement.style.pointerEvents = 'none';
		domElement.appendChild( viewElement );

		const cameraElement = document.createElement( 'div' );

		cameraElement.style.transformStyle = 'preserve-3d';

		viewElement.appendChild( cameraElement );

		this.getSize = function () {

			return {
				width: _width,
				height: _height
			};

		};

		this.render = function ( scene, camera ) {

			const fov = camera.projectionMatrix.elements[ 5 ] * _heightHalf;

			if ( camera.view && camera.view.enabled ) {

				// view offset
				viewElement.style.transform = `translate( ${ - camera.view.offsetX * ( _width / camera.view.width ) }px, ${ - camera.view.offsetY * ( _height / camera.view.height ) }px )`;

				// view fullWidth and fullHeight, view width and height
				viewElement.style.transform += `scale( ${ camera.view.fullWidth / camera.view.width }, ${ camera.view.fullHeight / camera.view.height } )`;

			} else {

				viewElement.style.transform = '';

			}

			if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();
			if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

			let tx, ty;

			if ( camera.isOrthographicCamera ) {

				tx = - ( camera.right + camera.left ) / 2;
				ty = ( camera.top + camera.bottom ) / 2;

			}

			const scaleByViewOffset = camera.view && camera.view.enabled ? camera.view.height / camera.view.fullHeight : 1;
			const cameraCSSMatrix = camera.isOrthographicCamera ?
				`scale( ${ scaleByViewOffset } )` + 'scale(' + fov + ')' + 'translate(' + epsilon( tx ) + 'px,' + epsilon( ty ) + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse ) :
				`scale( ${ scaleByViewOffset } )` + 'translateZ(' + fov + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse );
			const perspective = camera.isPerspectiveCamera ? 'perspective(' + fov + 'px) ' : '';

			const style = perspective + cameraCSSMatrix +
				'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';

			if ( cache.camera.style !== style ) {

				cameraElement.style.transform = style;

				cache.camera.style = style;

			}

			renderObject( scene, scene, camera);

		};

		this.setSize = function ( width, height ) {

			_width = width;
			_height = height;
			_widthHalf = _width / 2;
			_heightHalf = _height / 2;

			domElement.style.width = width + 'px';
			domElement.style.height = height + 'px';

			viewElement.style.width = width + 'px';
			viewElement.style.height = height + 'px';

			cameraElement.style.width = width + 'px';
			cameraElement.style.height = height + 'px';

		};

		function epsilon( value ) {

			return Math.abs( value ) < 1e-10 ? 0 : value;

		}

		function getCameraCSSMatrix( matrix ) {

			const elements = matrix.elements;

			return 'matrix3d(' +
				epsilon( elements[ 0 ] ) + ',' +
				epsilon( - elements[ 1 ] ) + ',' +
				epsilon( elements[ 2 ] ) + ',' +
				epsilon( elements[ 3 ] ) + ',' +
				epsilon( elements[ 4 ] ) + ',' +
				epsilon( - elements[ 5 ] ) + ',' +
				epsilon( elements[ 6 ] ) + ',' +
				epsilon( elements[ 7 ] ) + ',' +
				epsilon( elements[ 8 ] ) + ',' +
				epsilon( - elements[ 9 ] ) + ',' +
				epsilon( elements[ 10 ] ) + ',' +
				epsilon( elements[ 11 ] ) + ',' +
				epsilon( elements[ 12 ] ) + ',' +
				epsilon( - elements[ 13 ] ) + ',' +
				epsilon( elements[ 14 ] ) + ',' +
				epsilon( elements[ 15 ] ) +
			')';

		}

		function getObjectCSSMatrix( matrix ) {

			const elements = matrix.elements;
			const matrix3d = 'matrix3d(' +
				epsilon( elements[ 0 ] ) + ',' +
				epsilon( elements[ 1 ] ) + ',' +
				epsilon( elements[ 2 ] ) + ',' +
				epsilon( elements[ 3 ] ) + ',' +
				epsilon( - elements[ 4 ] ) + ',' +
				epsilon( - elements[ 5 ] ) + ',' +
				epsilon( - elements[ 6 ] ) + ',' +
				epsilon( - elements[ 7 ] ) + ',' +
				epsilon( elements[ 8 ] ) + ',' +
				epsilon( elements[ 9 ] ) + ',' +
				epsilon( elements[ 10 ] ) + ',' +
				epsilon( elements[ 11 ] ) + ',' +
				epsilon( elements[ 12 ] ) + ',' +
				epsilon( elements[ 13 ] ) + ',' +
				epsilon( elements[ 14 ] ) + ',' +
				epsilon( elements[ 15 ] ) +
			')';

			return 'translate(-50%,-50%)' + matrix3d;

		}

		function hideObject( object ) {

			if ( object.isCSS3DObject ) object.element.style.display = 'none';

			for ( let i = 0, l = object.children.length; i < l; i ++ ) {

				hideObject( object.children[ i ] );

			}

		}

		function renderObject( object, scene, camera, cameraCSSMatrix ) {

			if ( object.visible === false ) {

				hideObject( object );

				return;

			}

			if ( object.isCSS3DObject ) {

				const visible = ( object.layers.test( camera.layers ) === true );

				const element = object.element;
				element.style.display = visible === true ? '' : 'none';

				if ( visible === true ) {

					object.onBeforeRender( _this, scene, camera );

					let style;

					if ( object.isCSS3DSprite ) {

						// http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/

						_matrix.copy( camera.matrixWorldInverse );
						_matrix.transpose();

						if ( object.rotation2D !== 0 ) _matrix.multiply( _matrix2.makeRotationZ( object.rotation2D ) );

						object.matrixWorld.decompose( _position, _quaternion, _scale );
						_matrix.setPosition( _position );
						_matrix.scale( _scale );

						_matrix.elements[ 3 ] = 0;
						_matrix.elements[ 7 ] = 0;
						_matrix.elements[ 11 ] = 0;
						_matrix.elements[ 15 ] = 1;

						style = getObjectCSSMatrix( _matrix );

					} else {

						style = getObjectCSSMatrix( object.matrixWorld );

					}

					const cachedObject = cache.objects.get( object );

					if ( cachedObject === undefined || cachedObject.style !== style ) {

						element.style.transform = style;

						const objectData = { style: style };
						cache.objects.set( object, objectData );

					}

					if ( element.parentNode !== cameraElement ) {

						cameraElement.appendChild( element );

					}

					object.onAfterRender( _this, scene, camera );

				}

			}

			for ( let i = 0, l = object.children.length; i < l; i ++ ) {

				renderObject( object.children[ i ], scene, camera);

			}

		}

	}

}

var __defProp$S = Object.defineProperty;
var __defNormalProp$S = (obj, key, value) => key in obj ? __defProp$S(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$S = (obj, key, value) => __defNormalProp$S(obj, typeof key !== "symbol" ? key + "" : key, value);
class CssRenderer extends Component {
  constructor(options) {
    super(options);
    __publicField$S(this, "css2DRenderer");
    __publicField$S(this, "css3DRenderer");
    __publicField$S(this, "enableCss2D", false);
    __publicField$S(this, "enableCss3D", false);
    this.css2DRenderer = new CSS2DRenderer();
    this.css3DRenderer = new CSS3DRenderer();
  }
  setSize(width, height) {
    this.renderManager.setSize(width, height);
    this.cameraManager.setSize(width, height);
  }
  render() {
    if (this.enableCss3D) {
      this.css3DRenderer.render(this.scene, this.camera);
    }
    if (this.enableCss2D) {
      this.css2DRenderer.render(this.scene, this.camera);
    }
  }
}

var __defProp$R = Object.defineProperty;
var __defNormalProp$R = (obj, key, value) => key in obj ? __defProp$R(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$R = (obj, key, value) => __defNormalProp$R(obj, typeof key !== "symbol" ? key + "" : key, value);
class Pick extends Component {
  constructor(options) {
    super(options);
    __publicField$R(this, "raycaster");
    __publicField$R(this, "pointer", new THREE$2.Vector2());
    this.raycaster = new THREE$2.Raycaster();
    this.eventManager.leftClickSubject.subscribe((event) => {
      this.pointer.fromArray(Tool$1.getNFC(event, this.container));
      const pickObj = this.pick(this.scene, this.camera, event);
      this.eventManager.leftClickPickSubject.next(pickObj);
    });
    this.eventManager.rightClickSubject.subscribe((event) => {
      this.pointer.fromArray(Tool$1.getNFC(event, this.container));
      const pickObj = this.pick(this.scene, this.camera, event);
      this.eventManager.rightClickPickSubject.next(pickObj);
    });
    this.eventManager.dblClickSubject.subscribe((event) => {
      this.pointer.fromArray(Tool$1.getNFC(event, this.container));
      const pickObj = this.pick(this.scene, this.camera, event);
      this.eventManager.dblClickPickSubject.next(pickObj);
    });
  }
  pick(scene, camera, event) {
    this.raycaster.setFromCamera(this.pointer, camera);
    const intersects = this.raycaster.intersectObject(scene);
    let obj = {
      position: intersects.length > 0 ? intersects[0].point : this.ScreenToWorld(),
      intersects
    };
    return obj;
  }
  ScreenToWorld(height) {
    let [x, y] = [this.pointer.x, this.pointer.y];
    const camera = this.camera;
    let screenPosition = new THREE$2.Vector3(x, y, 0);
    const cameraPosition = new THREE$2.Vector3();
    camera.updateProjectionMatrix();
    if (isPerspectiveCamera$1(camera)) {
      cameraPosition.setFromMatrixPosition(camera.matrixWorld);
      screenPosition.unproject(camera);
      screenPosition.sub(cameraPosition).normalize();
    }
    const min = 1e-4;
    const normalY = new THREE$2.Vector3(0, 1, 0);
    const dotNormalY = normalY.dot(screenPosition);
    const center = this.cameraManager.cameraControls.getTarget(new THREE$2.Vector3());
    if (!(Math.abs(dotNormalY) < min)) {
      const distance = (-cameraPosition.y + (height || 0) + center.y) / screenPosition.y;
      let position = new THREE$2.Vector3().copy(cameraPosition).add(new THREE$2.Vector3().copy(screenPosition).multiplyScalar(distance));
      if (!isNil(height)) {
        position.y = height;
      }
      return position;
    }
  }
}

/**
 * @param {BufferGeometry} geometry
 * @param {number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	if ( drawMode === TrianglesDrawMode ) {

		console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );
		return geometry;

	}

	if ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {

		let index = geometry.getIndex();

		// generate index if not present

		if ( index === null ) {

			const indices = [];

			const position = geometry.getAttribute( 'position' );

			if ( position !== undefined ) {

				for ( let i = 0; i < position.count; i ++ ) {

					indices.push( i );

				}

				geometry.setIndex( indices );
				index = geometry.getIndex();

			} else {

				console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
				return geometry;

			}

		}

		//

		const numberOfTriangles = index.count - 2;
		const newIndices = [];

		if ( drawMode === TriangleFanDrawMode ) {

			// gl.TRIANGLE_FAN

			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

				newIndices.push( index.getX( 0 ) );
				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );

			}

		} else {

			// gl.TRIANGLE_STRIP

			for ( let i = 0; i < numberOfTriangles; i ++ ) {

				if ( i % 2 === 0 ) {

					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i + 2 ) );

				} else {

					newIndices.push( index.getX( i + 2 ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i ) );

				}

			}

		}

		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

			console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

		}

		// build final geometry

		const newGeometry = geometry.clone();
		newGeometry.setIndex( newIndices );
		newGeometry.clearGroups();

		return newGeometry;

	} else {

		console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );
		return geometry;

	}

}


/**
 * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,
 * non-indexed geometry. Returns the geometry with smooth normals everywhere except
 * faces that meet at an angle greater than the crease angle.
 *
 * @param {BufferGeometry} geometry
 * @param {number} [creaseAngle]
 * @return {BufferGeometry}
 */
function toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {

	const creaseDot = Math.cos( creaseAngle );
	const hashMultiplier = ( 1 + 1e-10 ) * 1e2;

	// reusable vectors
	const verts = [ new Vector3(), new Vector3(), new Vector3() ];
	const tempVec1 = new Vector3();
	const tempVec2 = new Vector3();
	const tempNorm = new Vector3();
	const tempNorm2 = new Vector3();

	// hashes a vector
	function hashVertex( v ) {

		const x = ~ ~ ( v.x * hashMultiplier );
		const y = ~ ~ ( v.y * hashMultiplier );
		const z = ~ ~ ( v.z * hashMultiplier );
		return `${x},${y},${z}`;

	}

	// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed
	// and returns the original geometry
	const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;
	const posAttr = resultGeometry.attributes.position;
	const vertexMap = {};

	// find all the normals shared by commonly located vertices
	for ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {

		const i3 = 3 * i;
		const a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );
		const b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );
		const c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );

		tempVec1.subVectors( c, b );
		tempVec2.subVectors( a, b );

		// add the normal to the map for all vertices
		const normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();
		for ( let n = 0; n < 3; n ++ ) {

			const vert = verts[ n ];
			const hash = hashVertex( vert );
			if ( ! ( hash in vertexMap ) ) {

				vertexMap[ hash ] = [];

			}

			vertexMap[ hash ].push( normal );

		}

	}

	// average normals from all vertices that share a common location if they are within the
	// provided crease threshold
	const normalArray = new Float32Array( posAttr.count * 3 );
	const normAttr = new BufferAttribute( normalArray, 3, false );
	for ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {

		// get the face normal for this vertex
		const i3 = 3 * i;
		const a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );
		const b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );
		const c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );

		tempVec1.subVectors( c, b );
		tempVec2.subVectors( a, b );

		tempNorm.crossVectors( tempVec1, tempVec2 ).normalize();

		// average all normals that meet the threshold and set the normal value
		for ( let n = 0; n < 3; n ++ ) {

			const vert = verts[ n ];
			const hash = hashVertex( vert );
			const otherNormals = vertexMap[ hash ];
			tempNorm2.set( 0, 0, 0 );

			for ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {

				const otherNorm = otherNormals[ k ];
				if ( tempNorm.dot( otherNorm ) > creaseDot ) {

					tempNorm2.add( otherNorm );

				}

			}

			tempNorm2.normalize();
			normAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );

		}

	}

	resultGeometry.setAttribute( 'normal', normAttr );
	return resultGeometry;

}

class GLTFLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsDispersionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureAVIFExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsEmissiveStrengthExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIridescenceExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsAnisotropyExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsBumpExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshGpuInstancing( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file
			// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'
			// resourcePath = 'https://my-cnd-server.com/assets/models/'
			// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'
			// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'
			const relativeUrl = LoaderUtils.extractUrlBase( url );
			resourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );

		} else {

			resourcePath = LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === -1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== -1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let json;
		const extensions = {};
		const plugins = {};
		const textDecoder = new TextDecoder();

		if ( typeof data === 'string' ) {

			json = JSON.parse( data );

		} else if ( data instanceof ArrayBuffer ) {

			const magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				json = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );

			} else {

				json = JSON.parse( textDecoder.decode( data ) );

			}

		} else {

			json = data;

		}

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );

			if ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );

			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
	KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
	EXT_MATERIALS_BUMP: 'EXT_materials_bump',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_TEXTURE_AVIF: 'EXT_texture_avif',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
	EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new Color( 0xffffff );

		if ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new DirectionalLight( color );
				lightNode.target.position.set( 0, 0, -1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, -1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		assignExtrasToUserData( lightNode, lightDef );

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	getDependency( type, index ) {

		if ( type !== 'light' ) return;

		return this._loadLight( index );

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Emissive Strength Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
 */
class GLTFMaterialsEmissiveStrengthExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;

		if ( emissiveStrength !== undefined ) {

			materialParams.emissiveIntensity = emissiveStrength;

		}

		return Promise.resolve();

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Materials dispersion Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion
 */
class GLTFMaterialsDispersionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;

		return Promise.resolve();

	}

}

/**
 * Iridescence Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
 */
class GLTFMaterialsIridescenceExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.iridescenceFactor !== undefined ) {

			materialParams.iridescence = extension.iridescenceFactor;

		}

		if ( extension.iridescenceTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );

		}

		if ( extension.iridescenceIor !== undefined ) {

			materialParams.iridescenceIOR = extension.iridescenceIor;

		}

		if ( materialParams.iridescenceThicknessRange === undefined ) {

			materialParams.iridescenceThicknessRange = [ 100, 400 ];

		}

		if ( extension.iridescenceThicknessMinimum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;

		}

		if ( extension.iridescenceThicknessMaximum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;

		}

		if ( extension.iridescenceThicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new Color( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			const colorFactor = extension.sheenColorFactor;
			materialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || Infinity;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );

		}

		return Promise.all( pending );

	}

}


/**
 * Materials bump Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump
 */
class GLTFMaterialsBumpExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_MATERIALS_BUMP;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;

		if ( extension.bumpTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials anisotropy Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy
 */
class GLTFMaterialsAnisotropyExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.anisotropyStrength !== undefined ) {

			materialParams.anisotropy = extension.anisotropyStrength;

		}

		if ( extension.anisotropyRotation !== undefined ) {

			materialParams.anisotropyRotation = extension.anisotropyRotation;

		}

		if ( extension.anisotropyTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * AVIF Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif
 */
class GLTFTextureAVIFExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image.
				image.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';
				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return buffer.then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const source = new Uint8Array( res, byteOffset, byteLength );

				if ( decoder.decodeGltfBufferAsync ) {

					return decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {

						return res.buffer;

					} );

				} else {

					// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync
					return decoder.ready.then( function () {

						const result = new ArrayBuffer( count * stride );
						decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
						return result;

					} );

				}

			} );

		} else {

			return null;

		}

	}

}

/**
 * GPU Instancing Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
 *
 */
class GLTFMeshGpuInstancing {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
		this.parser = parser;

	}

	createNodeMesh( nodeIndex ) {

		const json = this.parser.json;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||
			nodeDef.mesh === undefined ) {

			return null;

		}

		const meshDef = json.meshes[ nodeDef.mesh ];

		// No Points or Lines + Instancing support yet

		for ( const primitive of meshDef.primitives ) {

			if ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&
				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
				 primitive.mode !== undefined ) {

				return null;

			}

		}

		const extensionDef = nodeDef.extensions[ this.name ];
		const attributesDef = extensionDef.attributes;

		// @TODO: Can we support InstancedMesh + SkinnedMesh?

		const pending = [];
		const attributes = {};

		for ( const key in attributesDef ) {

			pending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {

				attributes[ key ] = accessor;
				return attributes[ key ];

			} ) );

		}

		if ( pending.length < 1 ) {

			return null;

		}

		pending.push( this.parser.createNodeMesh( nodeIndex ) );

		return Promise.all( pending ).then( results => {

			const nodeObject = results.pop();
			const meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];
			const count = results[ 0 ].count; // All attribute counts should be same
			const instancedMeshes = [];

			for ( const mesh of meshes ) {

				// Temporal variables
				const m = new Matrix4();
				const p = new Vector3();
				const q = new Quaternion();
				const s = new Vector3( 1, 1, 1 );

				const instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );

				for ( let i = 0; i < count; i ++ ) {

					if ( attributes.TRANSLATION ) {

						p.fromBufferAttribute( attributes.TRANSLATION, i );

					}

					if ( attributes.ROTATION ) {

						q.fromBufferAttribute( attributes.ROTATION, i );

					}

					if ( attributes.SCALE ) {

						s.fromBufferAttribute( attributes.SCALE, i );

					}

					instancedMesh.setMatrixAt( i, m.compose( p, q, s ) );

				}

				// Add instance attributes to the geometry, excluding TRS.
				for ( const attributeName in attributes ) {

					if ( attributeName === '_COLOR_0' ) {

						const attr = attributes[ attributeName ];
						instancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );

					} else if ( attributeName !== 'TRANSLATION' &&
						 attributeName !== 'ROTATION' &&
						 attributeName !== 'SCALE' ) {

						mesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );

					}

				}

				// Just in case
				Object3D.prototype.copy.call( instancedMesh, mesh );

				this.parser.assignFinalMaterial( instancedMesh );

				instancedMeshes.push( instancedMesh );

			}

			if ( nodeObject.isGroup ) {

				nodeObject.clear();

				nodeObject.add( ... instancedMeshes );

				return nodeObject;

			}

			return instancedMeshes[ 0 ];

		} );

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );
		const textDecoder = new TextDecoder();

		this.header = {
			magic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = textDecoder.decode( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType.name;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve, reject ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )
			&& transform.offset === undefined
			&& transform.rotation === undefined
			&& transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.texCoord !== undefined ) {

			texture.channel = transform.texCoord;

		}

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer;
		const values = this.sampleValues;
		const stride = this.valueSize;

		const stride2 = stride * 2;
		const stride3 = stride * 3;

		const td = t1 - t0;

		const p = ( t - t0 ) / td;
		const pp = p * p;
		const ppp = pp * p;

		const offset1 = i1 * stride3;
		const offset0 = offset1 - stride3;

		const s2 = -2 * ppp + 3 * pp;
		const s3 = ppp - pp;
		const s0 = 1 - s2;
		const s1 = s3 - pp + p;

		// Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
		for ( let i = 0; i !== stride; i ++ ) {

			const p0 = values[ offset0 + i + stride ]; // splineVertex_k
			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

		}

		return result;

	}

}

const _q = new Quaternion();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS = {
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: NearestFilter,
	9729: LinearFilter,
	9984: NearestMipmapNearestFilter,
	9985: LinearMipmapNearestFilter,
	9986: NearestMipmapLinearFilter,
	9987: LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: ClampToEdgeWrapping,
	33648: MirroredRepeatWrapping,
	10497: RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv1',
	TEXCOORD_2: 'uv2',
	TEXCOORD_3: 'uv3',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: InterpolateLinear,
	STEP: InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 *
 * @param {Object<string, Material>} cache
 * @return {Material}
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	let geometryKey;

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	if ( primitiveDef.targets !== undefined ) {

		for ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {

			geometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );

		}

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';
	if ( uri.search( /\.ktx2($|\?)/i ) > 0 || uri.search( /^data\:image\/ktx2/ ) === 0 ) return 'image/ktx2';

	return 'image/png';

}

const _identityMatrix = new Matrix4();

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Node cache
		this.nodeCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.

		let isSafari = false;
		let safariVersion = -1;
		let isFirefox = false;
		let firefoxVersion = -1;

		if ( typeof navigator !== 'undefined' ) {

			const userAgent = navigator.userAgent;

			isSafari = /^((?!chrome|android).)*safari/i.test( userAgent ) === true;
			const safariMatch = userAgent.match( /Version\/(\d+)/ );
			safariVersion = isSafari && safariMatch ? parseInt( safariMatch[ 1 ], 10 ) : -1;

			isFirefox = userAgent.indexOf( 'Firefox' ) > -1;
			firefoxVersion = isFirefox ? userAgent.match( /Firefox\/([0-9]+)\./ )[ 1 ] : -1;

		}

		if ( typeof createImageBitmap === 'undefined' || ( isSafari && safariVersion < 17 ) || ( isFirefox && firefoxVersion < 98 ) ) {

			this.textureLoader = new TextureLoader( this.options.manager );

		} else {

			this.textureLoader = new ImageBitmapLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();
		this.nodeCache = {};

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			return Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				for ( const scene of result.scenes ) {

					scene.updateMatrixWorld();

				}

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 *
	 * @param {Object} cache
	 * @param {Object3D} index
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/**
	 * Returns a reference to a shared resource, cloning it if necessary.
	 *
	 * @param {Object} cache
	 * @param {number} index
	 * @param {Object} object
	 * @return {Object}
	 */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadNode && ext.loadNode( index );

					} );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadAnimation && ext.loadAnimation( index );

					} );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					dependency = this._invokeOne( function ( ext ) {

						return ext != this && ext.getDependency && ext.getDependency( type, index );

					} );

					if ( ! dependency ) {

						throw new Error( 'Unknown type: ' + type );

					}

					break;

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];
			const normalized = accessorDef.normalized === true;

			const array = new TypedArray( accessorDef.count * itemSize );
			return Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				// Ignore normalized since we copy from sparse
				bufferAttribute.normalized = false;

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

				bufferAttribute.normalized = normalized;

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture|null>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			texture.name = textureDef.name || sourceDef.name || '';

			if ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {

				texture.name = sourceDef.uri;

			}

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;
			texture.generateMipmaps = ! texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			assignExtrasToUserData( texture, sourceDef );

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 *
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @param {string} colorSpace
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef, colorSpace ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			if ( ! texture ) return null;

			if ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {

				texture = texture.clone();
				texture.channel = mapDef.texCoord;

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			if ( colorSpace !== undefined ) {

				texture.colorSpace = colorSpace;

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new PointsMaterial();
				Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new LineBasicMaterial();
				Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );
				lineMaterial.map = material.map;

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= -1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= -1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

			const emissiveFactor = materialDef.emissiveFactor;
			materialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );

		}

		return Promise.all( pending ).then( function () {

			const material = new materialType( materialParams );

			if ( materialDef.name ) material.name = materialDef.name;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/**
	 * When Object3D instances are targeted by animation, they need unique names.
	 *
	 * @param {string} originalName
	 * @return {string}
	 */
	createUniqueName( originalName ) {

		const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

		if ( sanitizedName in this.nodeNamesUsed ) {

			return sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );

		} else {

			this.nodeNamesUsed[ sanitizedName ] = 0;

			return sanitizedName;

		}

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new SkinnedMesh( geometry, material )
						: new Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true ) {

						// normalize skin weights to fix malformed assets (see #15319)
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new Line$1( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );

				return meshes[ 0 ];

			}

			const group = new Group();

			if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Skeleton>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const pending = [];

		for ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {

			pending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );

		}

		if ( skinDef.inverseBindMatrices !== undefined ) {

			pending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );

		} else {

			pending.push( null );

		}

		return Promise.all( pending ).then( function ( results ) {

			const inverseBindMatrices = results.pop();
			const jointNodes = results;

			// Note that bones (joint nodes) may or may not be in the
			// scene graph at this time.

			const bones = [];
			const boneInverses = [];

			for ( let i = 0, il = jointNodes.length; i < il; i ++ ) {

				const jointNode = jointNodes[ i ];

				if ( jointNode ) {

					bones.push( jointNode );

					const mat = new Matrix4();

					if ( inverseBindMatrices !== null ) {

						mat.fromArray( inverseBindMatrices.array, i * 16 );

					}

					boneInverses.push( mat );

				} else {

					console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[ i ] );

				}

			}

			return new Skeleton( bones, boneInverses );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;
		const parser = this;

		const animationDef = json.animations[ animationIndex ];
		const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node;
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			if ( target.node === undefined ) continue;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				if ( node.updateMatrix ) {

					node.updateMatrix();

				}

				const createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );

				if ( createdTracks ) {

					for ( let k = 0; k < createdTracks.length; k ++ ) {

						tracks.push( createdTracks[ k ] );

					}

				}

			}

			return new AnimationClip( animationName, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		const nodePending = parser._loadNodeShallow( nodeIndex );

		const childPending = [];
		const childrenDef = nodeDef.children || [];

		for ( let i = 0, il = childrenDef.length; i < il; i ++ ) {

			childPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );

		}

		const skeletonPending = nodeDef.skin === undefined
			? Promise.resolve( null )
			: parser.getDependency( 'skin', nodeDef.skin );

		return Promise.all( [
			nodePending,
			Promise.all( childPending ),
			skeletonPending
		] ).then( function ( results ) {

			const node = results[ 0 ];
			const children = results[ 1 ];
			const skeleton = results[ 2 ];

			if ( skeleton !== null ) {

				// This full traverse should be fine because
				// child glTF nodes have not been added to this node yet.
				node.traverse( function ( mesh ) {

					if ( ! mesh.isSkinnedMesh ) return;

					mesh.bind( skeleton, _identityMatrix );

				} );

			}

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				node.add( children[ i ] );

			}

			return node;

		} );

	}

	// ._loadNodeShallow() parses a single node.
	// skin and child nodes are created and added in .loadNode() (no '_' prefix).
	_loadNodeShallow( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		// This method is called from .loadNode() and .loadSkin().
		// Cache a node to avoid duplication.

		if ( this.nodeCache[ nodeIndex ] !== undefined ) {

			return this.nodeCache[ nodeIndex ];

		}

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		const pending = [];

		const meshPromise = parser._invokeOne( function ( ext ) {

			return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

		} );

		if ( meshPromise ) {

			pending.push( meshPromise );

		}

		if ( nodeDef.camera !== undefined ) {

			pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

				return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

			} ) );

		}

		parser._invokeAll( function ( ext ) {

			return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

		} ).forEach( function ( promise ) {

			pending.push( promise );

		} );

		this.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new Bone();

			} else if ( objects.length > 1 ) {

				node = new Group();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

		return this.nodeCache[ nodeIndex ];

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new Group();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( parser.getDependency( 'node', nodeIds[ i ] ) );

		}

		return Promise.all( pending ).then( function ( nodes ) {

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				scene.add( nodes[ i ] );

			}

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof Material || key instanceof Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

	_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {

		const tracks = [];

		const targetName = node.name ? node.name : node.uuid;
		const targetNames = [];

		if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

			node.traverse( function ( object ) {

				if ( object.morphTargetInfluences ) {

					targetNames.push( object.name ? object.name : object.uuid );

				}

			} );

		} else {

			targetNames.push( targetName );

		}

		let TypedKeyframeTrack;

		switch ( PATH_PROPERTIES[ target.path ] ) {

			case PATH_PROPERTIES.weights:

				TypedKeyframeTrack = NumberKeyframeTrack;
				break;

			case PATH_PROPERTIES.rotation:

				TypedKeyframeTrack = QuaternionKeyframeTrack;
				break;

			case PATH_PROPERTIES.position:
			case PATH_PROPERTIES.scale:

				TypedKeyframeTrack = VectorKeyframeTrack;
				break;

			default:

				switch ( outputAccessor.itemSize ) {

					case 1:
						TypedKeyframeTrack = NumberKeyframeTrack;
						break;
					case 2:
					case 3:
					default:
						TypedKeyframeTrack = VectorKeyframeTrack;
						break;

				}

				break;

		}

		const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;


		const outputArray = this._getArrayFromAccessor( outputAccessor );

		for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

			const track = new TypedKeyframeTrack(
				targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
				inputAccessor.array,
				outputArray,
				interpolation
			);

			// Override interpolation with custom factory method.
			if ( sampler.interpolation === 'CUBICSPLINE' ) {

				this._createCubicSplineTrackInterpolant( track );

			}

			tracks.push( track );

		}

		return tracks;

	}

	_getArrayFromAccessor( accessor ) {

		let outputArray = accessor.array;

		if ( accessor.normalized ) {

			const scale = getNormalizedComponentScale( outputArray.constructor );
			const scaled = new Float32Array( outputArray.length );

			for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

				scaled[ j ] = outputArray[ j ] * scale;

			}

			outputArray = scaled;

		}

		return outputArray;

	}

	_createCubicSplineTrackInterpolant( track ) {

		track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

			// A CUBICSPLINE keyframe in glTF has three output values for each input value,
			// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
			// must be divided by three to get the interpolant's sampleSize argument.

			const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

			return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

		};

		// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
		track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

	}

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new Vector3();
		const vector = new Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	if ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {

		console.warn( `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.` );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

const _taskCache$2 = new WeakMap();

class DRACOLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.decoderPath = '';
		this.decoderConfig = {};
		this.decoderBinary = null;
		this.decoderPending = null;

		this.workerLimit = 4;
		this.workerPool = [];
		this.workerNextTaskID = 1;
		this.workerSourceURL = '';

		this.defaultAttributeIDs = {
			position: 'POSITION',
			normal: 'NORMAL',
			color: 'COLOR',
			uv: 'TEX_COORD'
		};
		this.defaultAttributeTypes = {
			position: 'Float32Array',
			normal: 'Float32Array',
			color: 'Float32Array',
			uv: 'Float32Array'
		};

	}

	setDecoderPath( path ) {

		this.decoderPath = path;

		return this;

	}

	setDecoderConfig( config ) {

		this.decoderConfig = config;

		return this;

	}

	setWorkerLimit( workerLimit ) {

		this.workerLimit = workerLimit;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, ( buffer ) => {

			this.parse( buffer, onLoad, onError );

		}, onProgress, onError );

	}


	parse( buffer, onLoad, onError = ()=>{} ) {

		this.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace, onError ).catch( onError );

	}

	decodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace, onError = () => {} ) {

		const taskConfig = {
			attributeIDs: attributeIDs || this.defaultAttributeIDs,
			attributeTypes: attributeTypes || this.defaultAttributeTypes,
			useUniqueIDs: !! attributeIDs,
			vertexColorSpace: vertexColorSpace,
		};

		return this.decodeGeometry( buffer, taskConfig ).then( callback ).catch( onError );

	}

	decodeGeometry( buffer, taskConfig ) {

		const taskKey = JSON.stringify( taskConfig );

		// Check for an existing task using this buffer. A transferred buffer cannot be transferred
		// again from this thread.
		if ( _taskCache$2.has( buffer ) ) {

			const cachedTask = _taskCache$2.get( buffer );

			if ( cachedTask.key === taskKey ) {

				return cachedTask.promise;

			} else if ( buffer.byteLength === 0 ) {

				// Technically, it would be possible to wait for the previous task to complete,
				// transfer the buffer back, and decode again with the second configuration. That
				// is complex, and I don't know of any reason to decode a Draco buffer twice in
				// different ways, so this is left unimplemented.
				throw new Error(

					'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +
					'settings. Buffer has already been transferred.'

				);

			}

		}

		//

		let worker;
		const taskID = this.workerNextTaskID ++;
		const taskCost = buffer.byteLength;

		// Obtain a worker and assign a task, and construct a geometry instance
		// when the task completes.
		const geometryPending = this._getWorker( taskID, taskCost )
			.then( ( _worker ) => {

				worker = _worker;

				return new Promise( ( resolve, reject ) => {

					worker._callbacks[ taskID ] = { resolve, reject };

					worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );

					// this.debug();

				} );

			} )
			.then( ( message ) => this._createGeometry( message.geometry ) );

		// Remove task from the task list.
		// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
		geometryPending
			.catch( () => true )
			.then( () => {

				if ( worker && taskID ) {

					this._releaseTask( worker, taskID );

					// this.debug();

				}

			} );

		// Cache the task result.
		_taskCache$2.set( buffer, {

			key: taskKey,
			promise: geometryPending

		} );

		return geometryPending;

	}

	_createGeometry( geometryData ) {

		const geometry = new BufferGeometry();

		if ( geometryData.index ) {

			geometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );

		}

		for ( let i = 0; i < geometryData.attributes.length; i ++ ) {

			const result = geometryData.attributes[ i ];
			const name = result.name;
			const array = result.array;
			const itemSize = result.itemSize;

			const attribute = new BufferAttribute( array, itemSize );

			if ( name === 'color' ) {

				this._assignVertexColorSpace( attribute, result.vertexColorSpace );

				attribute.normalized = ( array instanceof Float32Array ) === false;

			}

			geometry.setAttribute( name, attribute );

		}

		return geometry;

	}

	_assignVertexColorSpace( attribute, inputColorSpace ) {

		// While .drc files do not specify colorspace, the only 'official' tooling
		// is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc
		// file is passed into .load() or .parse(). GLTFLoader uses internal APIs
		// to decode geometry, and vertex colors are already Linear-sRGB in there.

		if ( inputColorSpace !== SRGBColorSpace ) return;

		const _color = new Color();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			_color.fromBufferAttribute( attribute, i );
			ColorManagement.toWorkingColorSpace( _color, SRGBColorSpace );
			attribute.setXYZ( i, _color.r, _color.g, _color.b );

		}

	}

	_loadLibrary( url, responseType ) {

		const loader = new FileLoader( this.manager );
		loader.setPath( this.decoderPath );
		loader.setResponseType( responseType );
		loader.setWithCredentials( this.withCredentials );

		return new Promise( ( resolve, reject ) => {

			loader.load( url, resolve, undefined, reject );

		} );

	}

	preload() {

		this._initDecoder();

		return this;

	}

	_initDecoder() {

		if ( this.decoderPending ) return this.decoderPending;

		const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
		const librariesPending = [];

		if ( useJS ) {

			librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );

		} else {

			librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );
			librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );

		}

		this.decoderPending = Promise.all( librariesPending )
			.then( ( libraries ) => {

				const jsContent = libraries[ 0 ];

				if ( ! useJS ) {

					this.decoderConfig.wasmBinary = libraries[ 1 ];

				}

				const fn = DRACOWorker.toString();

				const body = [
					'/* draco decoder */',
					jsContent,
					'',
					'/* worker */',
					fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
				].join( '\n' );

				this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );

			} );

		return this.decoderPending;

	}

	_getWorker( taskID, taskCost ) {

		return this._initDecoder().then( () => {

			if ( this.workerPool.length < this.workerLimit ) {

				const worker = new Worker( this.workerSourceURL );

				worker._callbacks = {};
				worker._taskCosts = {};
				worker._taskLoad = 0;

				worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );

				worker.onmessage = function ( e ) {

					const message = e.data;

					switch ( message.type ) {

						case 'decode':
							worker._callbacks[ message.id ].resolve( message );
							break;

						case 'error':
							worker._callbacks[ message.id ].reject( message );
							break;

						default:
							console.error( 'THREE.DRACOLoader: Unexpected message, "' + message.type + '"' );

					}

				};

				this.workerPool.push( worker );

			} else {

				this.workerPool.sort( function ( a, b ) {

					return a._taskLoad > b._taskLoad ? -1 : 1;

				} );

			}

			const worker = this.workerPool[ this.workerPool.length - 1 ];
			worker._taskCosts[ taskID ] = taskCost;
			worker._taskLoad += taskCost;
			return worker;

		} );

	}

	_releaseTask( worker, taskID ) {

		worker._taskLoad -= worker._taskCosts[ taskID ];
		delete worker._callbacks[ taskID ];
		delete worker._taskCosts[ taskID ];

	}

	debug() {

		console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );

	}

	dispose() {

		for ( let i = 0; i < this.workerPool.length; ++ i ) {

			this.workerPool[ i ].terminate();

		}

		this.workerPool.length = 0;

		if ( this.workerSourceURL !== '' ) {

			URL.revokeObjectURL( this.workerSourceURL );

		}

		return this;

	}

}

/* WEB WORKER */

function DRACOWorker() {

	let decoderConfig;
	let decoderPending;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				decoderConfig = message.decoderConfig;
				decoderPending = new Promise( function ( resolve/*, reject*/ ) {

					decoderConfig.onModuleLoaded = function ( draco ) {

						// Module is Promise-like. Wrap before resolving to avoid loop.
						resolve( { draco: draco } );

					};

					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

				} );
				break;

			case 'decode':
				const buffer = message.buffer;
				const taskConfig = message.taskConfig;
				decoderPending.then( ( module ) => {

					const draco = module.draco;
					const decoder = new draco.Decoder();

					try {

						const geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );

						const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

						if ( geometry.index ) buffers.push( geometry.index.array.buffer );

						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					} finally {

						draco.destroy( decoder );

					}

				} );
				break;

		}

	};

	function decodeGeometry( draco, decoder, array, taskConfig ) {

		const attributeIDs = taskConfig.attributeIDs;
		const attributeTypes = taskConfig.attributeTypes;

		let dracoGeometry;
		let decodingStatus;

		const geometryType = decoder.GetEncodedGeometryType( array );

		if ( geometryType === draco.TRIANGULAR_MESH ) {

			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );

		} else if ( geometryType === draco.POINT_CLOUD ) {

			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );

		} else {

			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

		}

		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

		}

		const geometry = { index: null, attributes: [] };

		// Gather all vertex attributes.
		for ( const attributeName in attributeIDs ) {

			const attributeType = self[ attributeTypes[ attributeName ] ];

			let attribute;
			let attributeID;

			// A Draco file may be created with default vertex attributes, whose attribute IDs
			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
			// a Draco file may contain a custom set of attributes, identified by known unique
			// IDs. glTF files always do the latter, and `.drc` files typically do the former.
			if ( taskConfig.useUniqueIDs ) {

				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

			} else {

				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

				if ( attributeID === -1 ) continue;

				attribute = decoder.GetAttribute( dracoGeometry, attributeID );

			}

			const attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );

			if ( attributeName === 'color' ) {

				attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;

			}

			geometry.attributes.push( attributeResult );

		}

		// Add index.
		if ( geometryType === draco.TRIANGULAR_MESH ) {

			geometry.index = decodeIndex( draco, decoder, dracoGeometry );

		}

		draco.destroy( dracoGeometry );

		return geometry;

	}

	function decodeIndex( draco, decoder, dracoGeometry ) {

		const numFaces = dracoGeometry.num_faces();
		const numIndices = numFaces * 3;
		const byteLength = numIndices * 4;

		const ptr = draco._malloc( byteLength );
		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
		const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
		draco._free( ptr );

		return { array: index, itemSize: 1 };

	}

	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

		const numComponents = attribute.num_components();
		const numPoints = dracoGeometry.num_points();
		const numValues = numPoints * numComponents;
		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		const dataType = getDracoDataType( draco, attributeType );

		const ptr = draco._malloc( byteLength );
		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
		const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
		draco._free( ptr );

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};

	}

	function getDracoDataType( draco, attributeType ) {

		switch ( attributeType ) {

			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;

		}

	}

}

/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/


// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
// fixed length extra bits
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
// fixed distance extra bits
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
// code length index map
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
// get base, reverse index map from extra bits
var freb = function (eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
        b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new i32(b[30]);
    for (var i = 1; i < 30; ++i) {
        for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = ((j - b[i]) << 5) | i;
        }
    }
    return { b: b, r: r };
};
var _a$1 = freb(fleb, 2), fl = _a$1.b, revfl = _a$1.r;
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b;
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
    // reverse table algorithm from SO
    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);
    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);
    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);
    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = (function (cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for (; i < s; ++i) {
        if (cd[i])
            ++l[cd[i] - 1];
    }
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for (i = 1; i < mb; ++i) {
        le[i] = (le[i - 1] + l[i - 1]) << 1;
    }
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for (i = 0; i < s; ++i) {
            // ignore 0 lengths
            if (cd[i]) {
                // num encoding both symbol and bits read
                var sv = (i << 4) | cd[i];
                // free bits
                var r_1 = mb - cd[i];
                // start value
                var v = le[cd[i] - 1]++ << r_1;
                // m is end value
                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                    // every 16 bit value starting with the code yields the same result
                    co[rev[v] >> rvb] = sv;
                }
            }
        }
    }
    else {
        co = new u16(s);
        for (i = 0; i < s; ++i) {
            if (cd[i]) {
                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);
            }
        }
    }
    return co;
});
// fixed length tree
var flt = new u8(288);
for (var i = 0; i < 144; ++i)
    flt[i] = 8;
for (var i = 144; i < 256; ++i)
    flt[i] = 9;
for (var i = 256; i < 280; ++i)
    flt[i] = 7;
for (var i = 280; i < 288; ++i)
    flt[i] = 8;
// fixed distance tree
var fdt = new u8(32);
for (var i = 0; i < 32; ++i)
    fdt[i] = 5;
// fixed length map
var flrm = /*#__PURE__*/ hMap(flt, 9, 1);
// fixed distance map
var fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
// find max of array
var max = function (a) {
    var m = a[0];
    for (var i = 1; i < a.length; ++i) {
        if (a[i] > m)
            m = a[i];
    }
    return m;
};
// read d, starting at bit p and mask with m
var bits = function (d, p, m) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
};
// read d, starting at bit p continuing for at least 16 bits
var bits16 = function (d, p) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
};
// get end of byte
var shft = function (p) { return ((p + 7) / 8) | 0; };
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function (v, s, e) {
    if (e == null || e > v.length)
        e = v.length;
    // can't use .constructor in case user-supplied
    return new u8(v.subarray(s, e));
};
// error codes
var ec = [
    'unexpected EOF',
    'invalid block type',
    'invalid length/literal',
    'invalid distance',
    'stream finished',
    'no stream handler',
    ,
    'no callback',
    'invalid UTF-8 data',
    'extra field too long',
    'date not in range 1980-2099',
    'filename too long',
    'stream finishing',
    'invalid zip data'
    // determined by unknown compression method
];
var err$1 = function (ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
        Error.captureStackTrace(e, err$1);
    if (!nt)
        throw e;
    return e;
};
// expands raw DEFLATE data
var inflt = function (dat, st, buf, dict) {
    // source length       dict length
    var sl = dat.length, dl = 0;
    if (!sl || st.f && !st.l)
        return buf || new u8(0);
    var noBuf = !buf;
    // have to estimate size
    var resize = noBuf || st.i != 2;
    // no state
    var noSt = st.i;
    // Assumes roughly 33% compression ratio average
    if (noBuf)
        buf = new u8(sl * 3);
    // ensure buffer can fit at least l elements
    var cbuf = function (l) {
        var bl = buf.length;
        // need to increase size to fit
        if (l > bl) {
            // Double or set to necessary, whichever is greater
            var nbuf = new u8(Math.max(bl * 2, l));
            nbuf.set(buf);
            buf = nbuf;
        }
    };
    //  last chunk         bitpos           bytes
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    // total bits
    var tbts = sl * 8;
    do {
        if (!lm) {
            // BFINAL - this is only 1 when last chunk is next
            final = bits(dat, pos, 1);
            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
                // go to end of byte boundary
                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                if (t > sl) {
                    if (noSt)
                        err$1(0);
                    break;
                }
                // ensure size
                if (resize)
                    cbuf(bt + l);
                // Copy over uncompressed data
                buf.set(dat.subarray(s, t), bt);
                // Get new bitpos, update byte count
                st.b = bt += l, st.p = pos = t * 8, st.f = final;
                continue;
            }
            else if (type == 1)
                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
                //  literal                            lengths
                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                var tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14;
                // length+distance tree
                var ldt = new u8(tl);
                // code length tree
                var clt = new u8(19);
                for (var i = 0; i < hcLen; ++i) {
                    // use index map to get real code
                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
                }
                pos += hcLen * 3;
                // code lengths bits
                var clb = max(clt), clbmsk = (1 << clb) - 1;
                // code lengths map
                var clm = hMap(clt, clb, 1);
                for (var i = 0; i < tl;) {
                    var r = clm[bits(dat, pos, clbmsk)];
                    // bits read
                    pos += r & 15;
                    // symbol
                    var s = r >> 4;
                    // code length to copy
                    if (s < 16) {
                        ldt[i++] = s;
                    }
                    else {
                        //  copy   count
                        var c = 0, n = 0;
                        if (s == 16)
                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                        else if (s == 17)
                            n = 3 + bits(dat, pos, 7), pos += 3;
                        else if (s == 18)
                            n = 11 + bits(dat, pos, 127), pos += 7;
                        while (n--)
                            ldt[i++] = c;
                    }
                }
                //    length tree                 distance tree
                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                // max length bits
                lbt = max(lt);
                // max dist bits
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
            }
            else
                err$1(1);
            if (pos > tbts) {
                if (noSt)
                    err$1(0);
                break;
            }
        }
        // Make sure the buffer can hold this + the largest possible addition
        // Maximum chunk size (practically, theoretically infinite) is 2^17
        if (resize)
            cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (;; lpos = pos) {
            // bits read, code
            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
            pos += c & 15;
            if (pos > tbts) {
                if (noSt)
                    err$1(0);
                break;
            }
            if (!c)
                err$1(2);
            if (sym < 256)
                buf[bt++] = sym;
            else if (sym == 256) {
                lpos = pos, lm = null;
                break;
            }
            else {
                var add = sym - 254;
                // no extra bits needed if less
                if (sym > 264) {
                    // index
                    var i = sym - 257, b = fleb[i];
                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
                    pos += b;
                }
                // dist
                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
                if (!d)
                    err$1(3);
                pos += d & 15;
                var dt = fd[dsym];
                if (dsym > 3) {
                    var b = fdeb[dsym];
                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
                }
                if (pos > tbts) {
                    if (noSt)
                        err$1(0);
                    break;
                }
                if (resize)
                    cbuf(bt + 131072);
                var end = bt + add;
                if (bt < dt) {
                    var shift = dl - dt, dend = Math.min(dt, end);
                    if (shift + bt < 0)
                        err$1(3);
                    for (; bt < dend; ++bt)
                        buf[bt] = dict[shift + bt];
                }
                for (; bt < end; ++bt)
                    buf[bt] = buf[bt - dt];
            }
        }
        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
        if (lm)
            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    // don't reallocate for streams or user buffers
    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
// empty
var et$1 = /*#__PURE__*/ new u8(0);
// zlib start
var zls = function (d, dict) {
    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
        err$1(6, 'invalid zlib data');
    if ((d[1] >> 5 & 1) == 1)
        err$1(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');
    return (d[1] >> 3 & 4) + 2;
};
/**
 * Expands Zlib data
 * @param data The data to decompress
 * @param opts The decompression options
 * @returns The decompressed version of the data
 */
function unzlibSync(data, opts) {
    return inflt(data.subarray(zls(data), -4), { i: 2 }, opts, opts);
}
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et$1, { stream: true });
    tds = 1;
}
catch (e) { }

/**
 * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.
 * Supports reading as UnsignedByte, HalfFloat and Float type data texture.
 *
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation, so I have preserved their copyright notices.
 */

// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */

// // TinyEXR contains some OpenEXR code, which is licensed under ------------

// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////

// // End of OpenEXR license -------------------------------------------------

class EXRLoader extends DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = HalfFloatType;

	}

	parse( buffer ) {

		const USHORT_RANGE = ( 1 << 16 );
		const BITMAP_SIZE = ( USHORT_RANGE >> 3 );

		const HUF_ENCBITS = 16; // literal (value) bit length
		const HUF_DECBITS = 14; // decoding bit size (>= 8)

		const HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size
		const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size
		const HUF_DECMASK = HUF_DECSIZE - 1;

		const NBITS = 16;
		const A_OFFSET = 1 << ( NBITS - 1 );
		const MOD_MASK = ( 1 << NBITS ) - 1;

		const SHORT_ZEROCODE_RUN = 59;
		const LONG_ZEROCODE_RUN = 63;
		const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;

		const ULONG_SIZE = 8;
		const FLOAT32_SIZE = 4;
		const INT32_SIZE = 4;
		const INT16_SIZE = 2;
		const INT8_SIZE = 1;

		const STATIC_HUFFMAN = 0;
		const DEFLATE = 1;

		const UNKNOWN = 0;
		const LOSSY_DCT = 1;
		const RLE = 2;

		const logBase = Math.pow( 2.7182818, 2.2 );

		function reverseLutFromBitmap( bitmap, lut ) {

			let k = 0;

			for ( let i = 0; i < USHORT_RANGE; ++ i ) {

				if ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {

					lut[ k ++ ] = i;

				}

			}

			const n = k - 1;

			while ( k < USHORT_RANGE ) lut[ k ++ ] = 0;

			return n;

		}

		function hufClearDecTable( hdec ) {

			for ( let i = 0; i < HUF_DECSIZE; i ++ ) {

				hdec[ i ] = {};
				hdec[ i ].len = 0;
				hdec[ i ].lit = 0;
				hdec[ i ].p = null;

			}

		}

		const getBitsReturn = { l: 0, c: 0, lc: 0 };

		function getBits( nBits, c, lc, uInt8Array, inOffset ) {

			while ( lc < nBits ) {

				c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );
				lc += 8;

			}

			lc -= nBits;

			getBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );
			getBitsReturn.c = c;
			getBitsReturn.lc = lc;

		}

		const hufTableBuffer = new Array( 59 );

		function hufCanonicalCodeTable( hcode ) {

			for ( let i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;
			for ( let i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;

			let c = 0;

			for ( let i = 58; i > 0; -- i ) {

				const nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );
				hufTableBuffer[ i ] = c;
				c = nc;

			}

			for ( let i = 0; i < HUF_ENCSIZE; ++ i ) {

				const l = hcode[ i ];
				if ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );

			}

		}

		function hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {

			const p = inOffset;
			let c = 0;
			let lc = 0;

			for ( ; im <= iM; im ++ ) {

				if ( p.value - inOffset.value > ni ) return false;

				getBits( 6, c, lc, uInt8Array, p );

				const l = getBitsReturn.l;
				c = getBitsReturn.c;
				lc = getBitsReturn.lc;

				hcode[ im ] = l;

				if ( l == LONG_ZEROCODE_RUN ) {

					if ( p.value - inOffset.value > ni ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					getBits( 8, c, lc, uInt8Array, p );

					let zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
					c = getBitsReturn.c;
					lc = getBitsReturn.lc;

					if ( im + zerun > iM + 1 ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					while ( zerun -- ) hcode[ im ++ ] = 0;

					im --;

				} else if ( l >= SHORT_ZEROCODE_RUN ) {

					let zerun = l - SHORT_ZEROCODE_RUN + 2;

					if ( im + zerun > iM + 1 ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					while ( zerun -- ) hcode[ im ++ ] = 0;

					im --;

				}

			}

			hufCanonicalCodeTable( hcode );

		}

		function hufLength( code ) {

			return code & 63;

		}

		function hufCode( code ) {

			return code >> 6;

		}

		function hufBuildDecTable( hcode, im, iM, hdecod ) {

			for ( ; im <= iM; im ++ ) {

				const c = hufCode( hcode[ im ] );
				const l = hufLength( hcode[ im ] );

				if ( c >> l ) {

					throw new Error( 'Invalid table entry' );

				}

				if ( l > HUF_DECBITS ) {

					const pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];

					if ( pl.len ) {

						throw new Error( 'Invalid table entry' );

					}

					pl.lit ++;

					if ( pl.p ) {

						const p = pl.p;
						pl.p = new Array( pl.lit );

						for ( let i = 0; i < pl.lit - 1; ++ i ) {

							pl.p[ i ] = p[ i ];

						}

					} else {

						pl.p = new Array( 1 );

					}

					pl.p[ pl.lit - 1 ] = im;

				} else if ( l ) {

					let plOffset = 0;

					for ( let i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {

						const pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];

						if ( pl.len || pl.p ) {

							throw new Error( 'Invalid table entry' );

						}

						pl.len = l;
						pl.lit = im;

						plOffset ++;

					}

				}

			}

			return true;

		}

		const getCharReturn = { c: 0, lc: 0 };

		function getChar( c, lc, uInt8Array, inOffset ) {

			c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );
			lc += 8;

			getCharReturn.c = c;
			getCharReturn.lc = lc;

		}

		const getCodeReturn = { c: 0, lc: 0 };

		function getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {

			if ( po == rlc ) {

				if ( lc < 8 ) {

					getChar( c, lc, uInt8Array, inOffset );
					c = getCharReturn.c;
					lc = getCharReturn.lc;

				}

				lc -= 8;

				let cs = ( c >> lc );
				cs = new Uint8Array( [ cs ] )[ 0 ];

				if ( outBufferOffset.value + cs > outBufferEndOffset ) {

					return false;

				}

				const s = outBuffer[ outBufferOffset.value - 1 ];

				while ( cs -- > 0 ) {

					outBuffer[ outBufferOffset.value ++ ] = s;

				}

			} else if ( outBufferOffset.value < outBufferEndOffset ) {

				outBuffer[ outBufferOffset.value ++ ] = po;

			} else {

				return false;

			}

			getCodeReturn.c = c;
			getCodeReturn.lc = lc;

		}

		function UInt16( value ) {

			return ( value & 0xFFFF );

		}

		function Int16( value ) {

			const ref = UInt16( value );
			return ( ref > 0x7FFF ) ? ref - 0x10000 : ref;

		}

		const wdec14Return = { a: 0, b: 0 };

		function wdec14( l, h ) {

			const ls = Int16( l );
			const hs = Int16( h );

			const hi = hs;
			const ai = ls + ( hi & 1 ) + ( hi >> 1 );

			const as = ai;
			const bs = ai - hi;

			wdec14Return.a = as;
			wdec14Return.b = bs;

		}

		function wdec16( l, h ) {

			const m = UInt16( l );
			const d = UInt16( h );

			const bb = ( m - ( d >> 1 ) ) & MOD_MASK;
			const aa = ( d + bb - A_OFFSET ) & MOD_MASK;

			wdec14Return.a = aa;
			wdec14Return.b = bb;

		}

		function wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {

			const w14 = mx < ( 1 << 14 );
			const n = ( nx > ny ) ? ny : nx;
			let p = 1;
			let p2;
			let py;

			while ( p <= n ) p <<= 1;

			p >>= 1;
			p2 = p;
			p >>= 1;

			while ( p >= 1 ) {

				py = 0;
				const ey = py + oy * ( ny - p2 );
				const oy1 = oy * p;
				const oy2 = oy * p2;
				const ox1 = ox * p;
				const ox2 = ox * p2;
				let i00, i01, i10, i11;

				for ( ; py <= ey; py += oy2 ) {

					let px = py;
					const ex = py + ox * ( nx - p2 );

					for ( ; px <= ex; px += ox2 ) {

						const p01 = px + ox1;
						const p10 = px + oy1;
						const p11 = p10 + ox1;

						if ( w14 ) {

							wdec14( buffer[ px + j ], buffer[ p10 + j ] );

							i00 = wdec14Return.a;
							i10 = wdec14Return.b;

							wdec14( buffer[ p01 + j ], buffer[ p11 + j ] );

							i01 = wdec14Return.a;
							i11 = wdec14Return.b;

							wdec14( i00, i01 );

							buffer[ px + j ] = wdec14Return.a;
							buffer[ p01 + j ] = wdec14Return.b;

							wdec14( i10, i11 );

							buffer[ p10 + j ] = wdec14Return.a;
							buffer[ p11 + j ] = wdec14Return.b;

						} else {

							wdec16( buffer[ px + j ], buffer[ p10 + j ] );

							i00 = wdec14Return.a;
							i10 = wdec14Return.b;

							wdec16( buffer[ p01 + j ], buffer[ p11 + j ] );

							i01 = wdec14Return.a;
							i11 = wdec14Return.b;

							wdec16( i00, i01 );

							buffer[ px + j ] = wdec14Return.a;
							buffer[ p01 + j ] = wdec14Return.b;

							wdec16( i10, i11 );

							buffer[ p10 + j ] = wdec14Return.a;
							buffer[ p11 + j ] = wdec14Return.b;


						}

					}

					if ( nx & p ) {

						const p10 = px + oy1;

						if ( w14 )
							wdec14( buffer[ px + j ], buffer[ p10 + j ] );
						else
							wdec16( buffer[ px + j ], buffer[ p10 + j ] );

						i00 = wdec14Return.a;
						buffer[ p10 + j ] = wdec14Return.b;

						buffer[ px + j ] = i00;

					}

				}

				if ( ny & p ) {

					let px = py;
					const ex = py + ox * ( nx - p2 );

					for ( ; px <= ex; px += ox2 ) {

						const p01 = px + ox1;

						if ( w14 )
							wdec14( buffer[ px + j ], buffer[ p01 + j ] );
						else
							wdec16( buffer[ px + j ], buffer[ p01 + j ] );

						i00 = wdec14Return.a;
						buffer[ p01 + j ] = wdec14Return.b;

						buffer[ px + j ] = i00;

					}

				}

				p2 = p;
				p >>= 1;

			}

			return py;

		}

		function hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {

			let c = 0;
			let lc = 0;
			const outBufferEndOffset = no;
			const inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );

			while ( inOffset.value < inOffsetEnd ) {

				getChar( c, lc, uInt8Array, inOffset );

				c = getCharReturn.c;
				lc = getCharReturn.lc;

				while ( lc >= HUF_DECBITS ) {

					const index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;
					const pl = decodingTable[ index ];

					if ( pl.len ) {

						lc -= pl.len;

						getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

						c = getCodeReturn.c;
						lc = getCodeReturn.lc;

					} else {

						if ( ! pl.p ) {

							throw new Error( 'hufDecode issues' );

						}

						let j;

						for ( j = 0; j < pl.lit; j ++ ) {

							const l = hufLength( encodingTable[ pl.p[ j ] ] );

							while ( lc < l && inOffset.value < inOffsetEnd ) {

								getChar( c, lc, uInt8Array, inOffset );

								c = getCharReturn.c;
								lc = getCharReturn.lc;

							}

							if ( lc >= l ) {

								if ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {

									lc -= l;

									getCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

									c = getCodeReturn.c;
									lc = getCodeReturn.lc;

									break;

								}

							}

						}

						if ( j == pl.lit ) {

							throw new Error( 'hufDecode issues' );

						}

					}

				}

			}

			const i = ( 8 - ni ) & 7;

			c >>= i;
			lc -= i;

			while ( lc > 0 ) {

				const pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];

				if ( pl.len ) {

					lc -= pl.len;

					getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

					c = getCodeReturn.c;
					lc = getCodeReturn.lc;

				} else {

					throw new Error( 'hufDecode issues' );

				}

			}

			return true;

		}

		function hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {

			const outOffset = { value: 0 };
			const initialInOffset = inOffset.value;

			const im = parseUint32( inDataView, inOffset );
			const iM = parseUint32( inDataView, inOffset );

			inOffset.value += 4;

			const nBits = parseUint32( inDataView, inOffset );

			inOffset.value += 4;

			if ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {

				throw new Error( 'Something wrong with HUF_ENCSIZE' );

			}

			const freq = new Array( HUF_ENCSIZE );
			const hdec = new Array( HUF_DECSIZE );

			hufClearDecTable( hdec );

			const ni = nCompressed - ( inOffset.value - initialInOffset );

			hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );

			if ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {

				throw new Error( 'Something wrong with hufUncompress' );

			}

			hufBuildDecTable( freq, im, iM, hdec );

			hufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );

		}

		function applyLut( lut, data, nData ) {

			for ( let i = 0; i < nData; ++ i ) {

				data[ i ] = lut[ data[ i ] ];

			}

		}

		function predictor( source ) {

			for ( let t = 1; t < source.length; t ++ ) {

				const d = source[ t - 1 ] + source[ t ] - 128;
				source[ t ] = d;

			}

		}

		function interleaveScalar( source, out ) {

			let t1 = 0;
			let t2 = Math.floor( ( source.length + 1 ) / 2 );
			let s = 0;
			const stop = source.length - 1;

			while ( true ) {

				if ( s > stop ) break;
				out[ s ++ ] = source[ t1 ++ ];

				if ( s > stop ) break;
				out[ s ++ ] = source[ t2 ++ ];

			}

		}

		function decodeRunLength( source ) {

			let size = source.byteLength;
			const out = new Array();
			let p = 0;

			const reader = new DataView( source );

			while ( size > 0 ) {

				const l = reader.getInt8( p ++ );

				if ( l < 0 ) {

					const count = - l;
					size -= count + 1;

					for ( let i = 0; i < count; i ++ ) {

						out.push( reader.getUint8( p ++ ) );

					}


				} else {

					const count = l;
					size -= 2;

					const value = reader.getUint8( p ++ );

					for ( let i = 0; i < count + 1; i ++ ) {

						out.push( value );

					}

				}

			}

			return out;

		}

		function lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {

			let dataView = new DataView( outBuffer.buffer );

			const width = channelData[ cscSet.idx[ 0 ] ].width;
			const height = channelData[ cscSet.idx[ 0 ] ].height;

			const numComp = 3;

			const numFullBlocksX = Math.floor( width / 8.0 );
			const numBlocksX = Math.ceil( width / 8.0 );
			const numBlocksY = Math.ceil( height / 8.0 );
			const leftoverX = width - ( numBlocksX - 1 ) * 8;
			const leftoverY = height - ( numBlocksY - 1 ) * 8;

			const currAcComp = { value: 0 };
			const currDcComp = new Array( numComp );
			const dctData = new Array( numComp );
			const halfZigBlock = new Array( numComp );
			const rowBlock = new Array( numComp );
			const rowOffsets = new Array( numComp );

			for ( let comp = 0; comp < numComp; ++ comp ) {

				rowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];
				currDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;
				dctData[ comp ] = new Float32Array( 64 );
				halfZigBlock[ comp ] = new Uint16Array( 64 );
				rowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );

			}

			for ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {

				let maxY = 8;

				if ( blocky == numBlocksY - 1 )
					maxY = leftoverY;

				let maxX = 8;

				for ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {

					if ( blockx == numBlocksX - 1 )
						maxX = leftoverX;

					for ( let comp = 0; comp < numComp; ++ comp ) {

						halfZigBlock[ comp ].fill( 0 );

						// set block DC component
						halfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];
						// set block AC components
						unRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );

						// UnZigZag block to float
						unZigZag( halfZigBlock[ comp ], dctData[ comp ] );
						// decode float dct
						dctInverse( dctData[ comp ] );

					}

					{

						csc709Inverse( dctData );

					}

					for ( let comp = 0; comp < numComp; ++ comp ) {

						convertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );

					}

				} // blockx

				let offset = 0;

				for ( let comp = 0; comp < numComp; ++ comp ) {

					const type = channelData[ cscSet.idx[ comp ] ].type;

					for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {

						offset = rowOffsets[ comp ][ y ];

						for ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {

							const src = blockx * 64 + ( ( y & 0x7 ) * 8 );

							dataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );
							dataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );
							dataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );
							dataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );

							dataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );
							dataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );
							dataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );
							dataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );

							offset += 8 * INT16_SIZE * type;

						}

					}

					// handle partial X blocks
					if ( numFullBlocksX != numBlocksX ) {

						for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {

							const offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;
							const src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );

							for ( let x = 0; x < maxX; ++ x ) {

								dataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );

							}

						}

					}

				} // comp

			} // blocky

			const halfRow = new Uint16Array( width );
			dataView = new DataView( outBuffer.buffer );

			// convert channels back to float, if needed
			for ( let comp = 0; comp < numComp; ++ comp ) {

				channelData[ cscSet.idx[ comp ] ].decoded = true;
				const type = channelData[ cscSet.idx[ comp ] ].type;

				if ( channelData[ comp ].type != 2 ) continue;

				for ( let y = 0; y < height; ++ y ) {

					const offset = rowOffsets[ comp ][ y ];

					for ( let x = 0; x < width; ++ x ) {

						halfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );

					}

					for ( let x = 0; x < width; ++ x ) {

						dataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );

					}

				}

			}

		}

		function unRleAC( currAcComp, acBuffer, halfZigBlock ) {

			let acValue;
			let dctComp = 1;

			while ( dctComp < 64 ) {

				acValue = acBuffer[ currAcComp.value ];

				if ( acValue == 0xff00 ) {

					dctComp = 64;

				} else if ( acValue >> 8 == 0xff ) {

					dctComp += acValue & 0xff;

				} else {

					halfZigBlock[ dctComp ] = acValue;
					dctComp ++;

				}

				currAcComp.value ++;

			}

		}

		function unZigZag( src, dst ) {

			dst[ 0 ] = decodeFloat16( src[ 0 ] );
			dst[ 1 ] = decodeFloat16( src[ 1 ] );
			dst[ 2 ] = decodeFloat16( src[ 5 ] );
			dst[ 3 ] = decodeFloat16( src[ 6 ] );
			dst[ 4 ] = decodeFloat16( src[ 14 ] );
			dst[ 5 ] = decodeFloat16( src[ 15 ] );
			dst[ 6 ] = decodeFloat16( src[ 27 ] );
			dst[ 7 ] = decodeFloat16( src[ 28 ] );
			dst[ 8 ] = decodeFloat16( src[ 2 ] );
			dst[ 9 ] = decodeFloat16( src[ 4 ] );

			dst[ 10 ] = decodeFloat16( src[ 7 ] );
			dst[ 11 ] = decodeFloat16( src[ 13 ] );
			dst[ 12 ] = decodeFloat16( src[ 16 ] );
			dst[ 13 ] = decodeFloat16( src[ 26 ] );
			dst[ 14 ] = decodeFloat16( src[ 29 ] );
			dst[ 15 ] = decodeFloat16( src[ 42 ] );
			dst[ 16 ] = decodeFloat16( src[ 3 ] );
			dst[ 17 ] = decodeFloat16( src[ 8 ] );
			dst[ 18 ] = decodeFloat16( src[ 12 ] );
			dst[ 19 ] = decodeFloat16( src[ 17 ] );

			dst[ 20 ] = decodeFloat16( src[ 25 ] );
			dst[ 21 ] = decodeFloat16( src[ 30 ] );
			dst[ 22 ] = decodeFloat16( src[ 41 ] );
			dst[ 23 ] = decodeFloat16( src[ 43 ] );
			dst[ 24 ] = decodeFloat16( src[ 9 ] );
			dst[ 25 ] = decodeFloat16( src[ 11 ] );
			dst[ 26 ] = decodeFloat16( src[ 18 ] );
			dst[ 27 ] = decodeFloat16( src[ 24 ] );
			dst[ 28 ] = decodeFloat16( src[ 31 ] );
			dst[ 29 ] = decodeFloat16( src[ 40 ] );

			dst[ 30 ] = decodeFloat16( src[ 44 ] );
			dst[ 31 ] = decodeFloat16( src[ 53 ] );
			dst[ 32 ] = decodeFloat16( src[ 10 ] );
			dst[ 33 ] = decodeFloat16( src[ 19 ] );
			dst[ 34 ] = decodeFloat16( src[ 23 ] );
			dst[ 35 ] = decodeFloat16( src[ 32 ] );
			dst[ 36 ] = decodeFloat16( src[ 39 ] );
			dst[ 37 ] = decodeFloat16( src[ 45 ] );
			dst[ 38 ] = decodeFloat16( src[ 52 ] );
			dst[ 39 ] = decodeFloat16( src[ 54 ] );

			dst[ 40 ] = decodeFloat16( src[ 20 ] );
			dst[ 41 ] = decodeFloat16( src[ 22 ] );
			dst[ 42 ] = decodeFloat16( src[ 33 ] );
			dst[ 43 ] = decodeFloat16( src[ 38 ] );
			dst[ 44 ] = decodeFloat16( src[ 46 ] );
			dst[ 45 ] = decodeFloat16( src[ 51 ] );
			dst[ 46 ] = decodeFloat16( src[ 55 ] );
			dst[ 47 ] = decodeFloat16( src[ 60 ] );
			dst[ 48 ] = decodeFloat16( src[ 21 ] );
			dst[ 49 ] = decodeFloat16( src[ 34 ] );

			dst[ 50 ] = decodeFloat16( src[ 37 ] );
			dst[ 51 ] = decodeFloat16( src[ 47 ] );
			dst[ 52 ] = decodeFloat16( src[ 50 ] );
			dst[ 53 ] = decodeFloat16( src[ 56 ] );
			dst[ 54 ] = decodeFloat16( src[ 59 ] );
			dst[ 55 ] = decodeFloat16( src[ 61 ] );
			dst[ 56 ] = decodeFloat16( src[ 35 ] );
			dst[ 57 ] = decodeFloat16( src[ 36 ] );
			dst[ 58 ] = decodeFloat16( src[ 48 ] );
			dst[ 59 ] = decodeFloat16( src[ 49 ] );

			dst[ 60 ] = decodeFloat16( src[ 57 ] );
			dst[ 61 ] = decodeFloat16( src[ 58 ] );
			dst[ 62 ] = decodeFloat16( src[ 62 ] );
			dst[ 63 ] = decodeFloat16( src[ 63 ] );

		}

		function dctInverse( data ) {

			const a = 0.5 * Math.cos( 3.14159 / 4.0 );
			const b = 0.5 * Math.cos( 3.14159 / 16.0 );
			const c = 0.5 * Math.cos( 3.14159 / 8.0 );
			const d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );
			const e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );
			const f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );
			const g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );

			const alpha = new Array( 4 );
			const beta = new Array( 4 );
			const theta = new Array( 4 );
			const gamma = new Array( 4 );

			for ( let row = 0; row < 8; ++ row ) {

				const rowPtr = row * 8;

				alpha[ 0 ] = c * data[ rowPtr + 2 ];
				alpha[ 1 ] = f * data[ rowPtr + 2 ];
				alpha[ 2 ] = c * data[ rowPtr + 6 ];
				alpha[ 3 ] = f * data[ rowPtr + 6 ];

				beta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];
				beta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];
				beta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];
				beta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];

				theta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );
				theta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );
				theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
				theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];

				gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
				gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
				gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
				gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];

				data[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];
				data[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];
				data[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];
				data[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];

				data[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];
				data[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];
				data[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];
				data[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];

			}

			for ( let column = 0; column < 8; ++ column ) {

				alpha[ 0 ] = c * data[ 16 + column ];
				alpha[ 1 ] = f * data[ 16 + column ];
				alpha[ 2 ] = c * data[ 48 + column ];
				alpha[ 3 ] = f * data[ 48 + column ];

				beta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];
				beta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];
				beta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];
				beta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];

				theta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );
				theta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );

				theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
				theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];

				gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
				gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
				gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
				gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];

				data[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];
				data[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];
				data[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];
				data[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];

				data[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];
				data[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];
				data[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];
				data[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];

			}

		}

		function csc709Inverse( data ) {

			for ( let i = 0; i < 64; ++ i ) {

				const y = data[ 0 ][ i ];
				const cb = data[ 1 ][ i ];
				const cr = data[ 2 ][ i ];

				data[ 0 ][ i ] = y + 1.5747 * cr;
				data[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;
				data[ 2 ][ i ] = y + 1.8556 * cb;

			}

		}

		function convertToHalf( src, dst, idx ) {

			for ( let i = 0; i < 64; ++ i ) {

				dst[ idx + i ] = DataUtils.toHalfFloat( toLinear( src[ i ] ) );

			}

		}

		function toLinear( float ) {

			if ( float <= 1 ) {

				return Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );

			} else {

				return Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );

			}

		}

		function uncompressRAW( info ) {

			return new DataView( info.array.buffer, info.offset.value, info.size );

		}

		function uncompressRLE( info ) {

			const compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = new Uint8Array( decodeRunLength( compressed ) );
			const tmpBuffer = new Uint8Array( rawBuffer.length );

			predictor( rawBuffer ); // revert predictor

			interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressZIP( info ) {

			const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = unzlibSync( compressed );
			const tmpBuffer = new Uint8Array( rawBuffer.length );

			predictor( rawBuffer ); // revert predictor

			interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressPIZ( info ) {

			const inDataView = info.viewer;
			const inOffset = { value: info.offset.value };

			const outBuffer = new Uint16Array( info.columns * info.lines * ( info.inputChannels.length * info.type ) );
			const bitmap = new Uint8Array( BITMAP_SIZE );

			// Setup channel info
			let outBufferEnd = 0;
			const pizChannelData = new Array( info.inputChannels.length );
			for ( let i = 0, il = info.inputChannels.length; i < il; i ++ ) {

				pizChannelData[ i ] = {};
				pizChannelData[ i ][ 'start' ] = outBufferEnd;
				pizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];
				pizChannelData[ i ][ 'nx' ] = info.columns;
				pizChannelData[ i ][ 'ny' ] = info.lines;
				pizChannelData[ i ][ 'size' ] = info.type;

				outBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;

			}

			// Read range compression data

			const minNonZero = parseUint16( inDataView, inOffset );
			const maxNonZero = parseUint16( inDataView, inOffset );

			if ( maxNonZero >= BITMAP_SIZE ) {

				throw new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );

			}

			if ( minNonZero <= maxNonZero ) {

				for ( let i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {

					bitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );

				}

			}

			// Reverse LUT
			const lut = new Uint16Array( USHORT_RANGE );
			const maxValue = reverseLutFromBitmap( bitmap, lut );

			const length = parseUint32( inDataView, inOffset );

			// Huffman decoding
			hufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );

			// Wavelet decoding
			for ( let i = 0; i < info.inputChannels.length; ++ i ) {

				const cd = pizChannelData[ i ];

				for ( let j = 0; j < pizChannelData[ i ].size; ++ j ) {

					wav2Decode(
						outBuffer,
						cd.start + j,
						cd.nx,
						cd.size,
						cd.ny,
						cd.nx * cd.size,
						maxValue
					);

				}

			}

			// Expand the pixel data to their original range
			applyLut( lut, outBuffer, outBufferEnd );

			// Rearrange the pixel data into the format expected by the caller.
			let tmpOffset = 0;
			const tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );
			for ( let y = 0; y < info.lines; y ++ ) {

				for ( let c = 0; c < info.inputChannels.length; c ++ ) {

					const cd = pizChannelData[ c ];

					const n = cd.nx * cd.size;
					const cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );

					tmpBuffer.set( cp, tmpOffset );
					tmpOffset += n * INT16_SIZE;
					cd.end += n;

				}

			}

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressPXR( info ) {

			const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = unzlibSync( compressed );

			const byteSize = info.inputChannels.length * info.lines * info.columns * info.totalBytes;
			const tmpBuffer = new ArrayBuffer( byteSize );
			const viewer = new DataView( tmpBuffer );

			let tmpBufferEnd = 0;
			let writePtr = 0;
			const ptr = new Array( 4 );

			for ( let y = 0; y < info.lines; y ++ ) {

				for ( let c = 0; c < info.inputChannels.length; c ++ ) {

					let pixel = 0;

					const type = info.inputChannels[ c ].pixelType;
					switch ( type ) {

						case 1:

							ptr[ 0 ] = tmpBufferEnd;
							ptr[ 1 ] = ptr[ 0 ] + info.columns;
							tmpBufferEnd = ptr[ 1 ] + info.columns;

							for ( let j = 0; j < info.columns; ++ j ) {

								const diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 8 ) | rawBuffer[ ptr[ 1 ] ++ ];

								pixel += diff;

								viewer.setUint16( writePtr, pixel, true );
								writePtr += 2;

							}

							break;

						case 2:

							ptr[ 0 ] = tmpBufferEnd;
							ptr[ 1 ] = ptr[ 0 ] + info.columns;
							ptr[ 2 ] = ptr[ 1 ] + info.columns;
							tmpBufferEnd = ptr[ 2 ] + info.columns;

							for ( let j = 0; j < info.columns; ++ j ) {

								const diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 24 ) | ( rawBuffer[ ptr[ 1 ] ++ ] << 16 ) | ( rawBuffer[ ptr[ 2 ] ++ ] << 8 );

								pixel += diff;

								viewer.setUint32( writePtr, pixel, true );
								writePtr += 4;

							}

							break;

					}

				}

			}

			return viewer;

		}

		function uncompressDWA( info ) {

			const inDataView = info.viewer;
			const inOffset = { value: info.offset.value };
			const outBuffer = new Uint8Array( info.columns * info.lines * ( info.inputChannels.length * info.type * INT16_SIZE ) );

			// Read compression header information
			const dwaHeader = {

				version: parseInt64( inDataView, inOffset ),
				unknownUncompressedSize: parseInt64( inDataView, inOffset ),
				unknownCompressedSize: parseInt64( inDataView, inOffset ),
				acCompressedSize: parseInt64( inDataView, inOffset ),
				dcCompressedSize: parseInt64( inDataView, inOffset ),
				rleCompressedSize: parseInt64( inDataView, inOffset ),
				rleUncompressedSize: parseInt64( inDataView, inOffset ),
				rleRawSize: parseInt64( inDataView, inOffset ),
				totalAcUncompressedCount: parseInt64( inDataView, inOffset ),
				totalDcUncompressedCount: parseInt64( inDataView, inOffset ),
				acCompression: parseInt64( inDataView, inOffset )

			};

			if ( dwaHeader.version < 2 )
				throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' );

			// Read channel ruleset information
			const channelRules = new Array();
			let ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;

			while ( ruleSize > 0 ) {

				const name = parseNullTerminatedString( inDataView.buffer, inOffset );
				const value = parseUint8( inDataView, inOffset );
				const compression = ( value >> 2 ) & 3;
				const csc = ( value >> 4 ) - 1;
				const index = new Int8Array( [ csc ] )[ 0 ];
				const type = parseUint8( inDataView, inOffset );

				channelRules.push( {
					name: name,
					index: index,
					type: type,
					compression: compression,
				} );

				ruleSize -= name.length + 3;

			}

			// Classify channels
			const channels = EXRHeader.channels;
			const channelData = new Array( info.inputChannels.length );

			for ( let i = 0; i < info.inputChannels.length; ++ i ) {

				const cd = channelData[ i ] = {};
				const channel = channels[ i ];

				cd.name = channel.name;
				cd.compression = UNKNOWN;
				cd.decoded = false;
				cd.type = channel.pixelType;
				cd.pLinear = channel.pLinear;
				cd.width = info.columns;
				cd.height = info.lines;

			}

			const cscSet = {
				idx: new Array( 3 )
			};

			for ( let offset = 0; offset < info.inputChannels.length; ++ offset ) {

				const cd = channelData[ offset ];

				for ( let i = 0; i < channelRules.length; ++ i ) {

					const rule = channelRules[ i ];

					if ( cd.name == rule.name ) {

						cd.compression = rule.compression;

						if ( rule.index >= 0 ) {

							cscSet.idx[ rule.index ] = offset;

						}

						cd.offset = offset;

					}

				}

			}

			let acBuffer, dcBuffer, rleBuffer;

			// Read DCT - AC component data
			if ( dwaHeader.acCompressedSize > 0 ) {

				switch ( dwaHeader.acCompression ) {

					case STATIC_HUFFMAN:

						acBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );
						hufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );
						break;

					case DEFLATE:

						const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );
						const data = unzlibSync( compressed );
						acBuffer = new Uint16Array( data.buffer );
						inOffset.value += dwaHeader.totalAcUncompressedCount;
						break;

				}


			}

			// Read DCT - DC component data
			if ( dwaHeader.dcCompressedSize > 0 ) {

				const zlibInfo = {
					array: info.array,
					offset: inOffset,
					size: dwaHeader.dcCompressedSize
				};
				dcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );
				inOffset.value += dwaHeader.dcCompressedSize;

			}

			// Read RLE compressed data
			if ( dwaHeader.rleRawSize > 0 ) {

				const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );
				const data = unzlibSync( compressed );
				rleBuffer = decodeRunLength( data.buffer );

				inOffset.value += dwaHeader.rleCompressedSize;

			}

			// Prepare outbuffer data offset
			let outBufferEnd = 0;
			const rowOffsets = new Array( channelData.length );
			for ( let i = 0; i < rowOffsets.length; ++ i ) {

				rowOffsets[ i ] = new Array();

			}

			for ( let y = 0; y < info.lines; ++ y ) {

				for ( let chan = 0; chan < channelData.length; ++ chan ) {

					rowOffsets[ chan ].push( outBufferEnd );
					outBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;

				}

			}

			// Lossy DCT decode RGB channels
			lossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );

			// Decode other channels
			for ( let i = 0; i < channelData.length; ++ i ) {

				const cd = channelData[ i ];

				if ( cd.decoded ) continue;

				switch ( cd.compression ) {

					case RLE:

						let row = 0;
						let rleOffset = 0;

						for ( let y = 0; y < info.lines; ++ y ) {

							let rowOffsetBytes = rowOffsets[ i ][ row ];

							for ( let x = 0; x < cd.width; ++ x ) {

								for ( let byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {

									outBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];

								}

								rleOffset ++;

							}

							row ++;

						}

						break;

					case LOSSY_DCT: // skip

					default:
						throw new Error( 'EXRLoader.parse: unsupported channel compression' );

				}

			}

			return new DataView( outBuffer.buffer );

		}

		function parseNullTerminatedString( buffer, offset ) {

			const uintBuffer = new Uint8Array( buffer );
			let endOffset = 0;

			while ( uintBuffer[ offset.value + endOffset ] != 0 ) {

				endOffset += 1;

			}

			const stringValue = new TextDecoder().decode(
				uintBuffer.slice( offset.value, offset.value + endOffset )
			);

			offset.value = offset.value + endOffset + 1;

			return stringValue;

		}

		function parseFixedLengthString( buffer, offset, size ) {

			const stringValue = new TextDecoder().decode(
				new Uint8Array( buffer ).slice( offset.value, offset.value + size )
			);

			offset.value = offset.value + size;

			return stringValue;

		}

		function parseRational( dataView, offset ) {

			const x = parseInt32( dataView, offset );
			const y = parseUint32( dataView, offset );

			return [ x, y ];

		}

		function parseTimecode( dataView, offset ) {

			const x = parseUint32( dataView, offset );
			const y = parseUint32( dataView, offset );

			return [ x, y ];

		}

		function parseInt32( dataView, offset ) {

			const Int32 = dataView.getInt32( offset.value, true );

			offset.value = offset.value + INT32_SIZE;

			return Int32;

		}

		function parseUint32( dataView, offset ) {

			const Uint32 = dataView.getUint32( offset.value, true );

			offset.value = offset.value + INT32_SIZE;

			return Uint32;

		}

		function parseUint8Array( uInt8Array, offset ) {

			const Uint8 = uInt8Array[ offset.value ];

			offset.value = offset.value + INT8_SIZE;

			return Uint8;

		}

		function parseUint8( dataView, offset ) {

			const Uint8 = dataView.getUint8( offset.value );

			offset.value = offset.value + INT8_SIZE;

			return Uint8;

		}

		const parseInt64 = function ( dataView, offset ) {

			let int;

			if ( 'getBigInt64' in DataView.prototype ) {

				int = Number( dataView.getBigInt64( offset.value, true ) );

			} else {

				int = dataView.getUint32( offset.value + 4, true ) + Number( dataView.getUint32( offset.value, true ) << 32 );

			}

			offset.value += ULONG_SIZE;

			return int;

		};

		function parseFloat32( dataView, offset ) {

			const float = dataView.getFloat32( offset.value, true );

			offset.value += FLOAT32_SIZE;

			return float;

		}

		function decodeFloat32( dataView, offset ) {

			return DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );

		}

		// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript
		function decodeFloat16( binary ) {

			const exponent = ( binary & 0x7C00 ) >> 10,
				fraction = binary & 0x03FF;

			return ( binary >> 15 ? -1 : 1 ) * (
				exponent ?
					(
						exponent === 0x1F ?
							fraction ? NaN : Infinity :
							Math.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )
					) :
					6.103515625e-5 * ( fraction / 0x400 )
			);

		}

		function parseUint16( dataView, offset ) {

			const Uint16 = dataView.getUint16( offset.value, true );

			offset.value += INT16_SIZE;

			return Uint16;

		}

		function parseFloat16( buffer, offset ) {

			return decodeFloat16( parseUint16( buffer, offset ) );

		}

		function parseChlist( dataView, buffer, offset, size ) {

			const startOffset = offset.value;
			const channels = [];

			while ( offset.value < ( startOffset + size - 1 ) ) {

				const name = parseNullTerminatedString( buffer, offset );
				const pixelType = parseInt32( dataView, offset );
				const pLinear = parseUint8( dataView, offset );
				offset.value += 3; // reserved, three chars
				const xSampling = parseInt32( dataView, offset );
				const ySampling = parseInt32( dataView, offset );

				channels.push( {
					name: name,
					pixelType: pixelType,
					pLinear: pLinear,
					xSampling: xSampling,
					ySampling: ySampling
				} );

			}

			offset.value += 1;

			return channels;

		}

		function parseChromaticities( dataView, offset ) {

			const redX = parseFloat32( dataView, offset );
			const redY = parseFloat32( dataView, offset );
			const greenX = parseFloat32( dataView, offset );
			const greenY = parseFloat32( dataView, offset );
			const blueX = parseFloat32( dataView, offset );
			const blueY = parseFloat32( dataView, offset );
			const whiteX = parseFloat32( dataView, offset );
			const whiteY = parseFloat32( dataView, offset );

			return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };

		}

		function parseCompression( dataView, offset ) {

			const compressionCodes = [
				'NO_COMPRESSION',
				'RLE_COMPRESSION',
				'ZIPS_COMPRESSION',
				'ZIP_COMPRESSION',
				'PIZ_COMPRESSION',
				'PXR24_COMPRESSION',
				'B44_COMPRESSION',
				'B44A_COMPRESSION',
				'DWAA_COMPRESSION',
				'DWAB_COMPRESSION'
			];

			const compression = parseUint8( dataView, offset );

			return compressionCodes[ compression ];

		}

		function parseBox2i( dataView, offset ) {

			const xMin = parseInt32( dataView, offset );
			const yMin = parseInt32( dataView, offset );
			const xMax = parseInt32( dataView, offset );
			const yMax = parseInt32( dataView, offset );

			return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };

		}

		function parseLineOrder( dataView, offset ) {

			const lineOrders = [
				'INCREASING_Y',
				'DECREASING_Y',
				'RANDOM_Y',
			];

			const lineOrder = parseUint8( dataView, offset );

			return lineOrders[ lineOrder ];

		}

		function parseEnvmap( dataView, offset ) {

			const envmaps = [
				'ENVMAP_LATLONG',
				'ENVMAP_CUBE'
			];

			const envmap = parseUint8( dataView, offset );

			return envmaps[ envmap ];

		}

		function parseTiledesc( dataView, offset ) {

			const levelModes = [
				'ONE_LEVEL',
				'MIPMAP_LEVELS',
				'RIPMAP_LEVELS',
			];

			const roundingModes = [
				'ROUND_DOWN',
				'ROUND_UP',
			];

			const xSize = parseUint32( dataView, offset );
			const ySize = parseUint32( dataView, offset );
			const modes = parseUint8( dataView, offset );

			return {
				xSize: xSize,
				ySize: ySize,
				levelMode: levelModes[ modes & 0xf ],
				roundingMode: roundingModes[ modes >> 4 ]
			};

		}

		function parseV2f( dataView, offset ) {

			const x = parseFloat32( dataView, offset );
			const y = parseFloat32( dataView, offset );

			return [ x, y ];

		}

		function parseV3f( dataView, offset ) {

			const x = parseFloat32( dataView, offset );
			const y = parseFloat32( dataView, offset );
			const z = parseFloat32( dataView, offset );

			return [ x, y, z ];

		}

		function parseValue( dataView, buffer, offset, type, size ) {

			if ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {

				return parseFixedLengthString( buffer, offset, size );

			} else if ( type === 'chlist' ) {

				return parseChlist( dataView, buffer, offset, size );

			} else if ( type === 'chromaticities' ) {

				return parseChromaticities( dataView, offset );

			} else if ( type === 'compression' ) {

				return parseCompression( dataView, offset );

			} else if ( type === 'box2i' ) {

				return parseBox2i( dataView, offset );

			} else if ( type === 'envmap' ) {

				return parseEnvmap( dataView, offset );

			} else if ( type === 'tiledesc' ) {

				return parseTiledesc( dataView, offset );

			} else if ( type === 'lineOrder' ) {

				return parseLineOrder( dataView, offset );

			} else if ( type === 'float' ) {

				return parseFloat32( dataView, offset );

			} else if ( type === 'v2f' ) {

				return parseV2f( dataView, offset );

			} else if ( type === 'v3f' ) {

				return parseV3f( dataView, offset );

			} else if ( type === 'int' ) {

				return parseInt32( dataView, offset );

			} else if ( type === 'rational' ) {

				return parseRational( dataView, offset );

			} else if ( type === 'timecode' ) {

				return parseTimecode( dataView, offset );

			} else if ( type === 'preview' ) {

				offset.value += size;
				return 'skipped';

			} else {

				offset.value += size;
				return undefined;

			}

		}

		function roundLog2( x, mode ) {

			const log2 = Math.log2( x );
			return mode == 'ROUND_DOWN' ? Math.floor( log2 ) : Math.ceil( log2 );

		}

		function calculateTileLevels( tiledesc, w, h ) {

			let num = 0;

			switch ( tiledesc.levelMode ) {

				case 'ONE_LEVEL':
					num = 1;
					break;

				case 'MIPMAP_LEVELS':
					num = roundLog2( Math.max( w, h ), tiledesc.roundingMode ) + 1;
					break;

				case 'RIPMAP_LEVELS':
					throw new Error( 'THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.' );

			}

			return num;

		}

		function calculateTiles( count, dataSize, size, roundingMode ) {

			const tiles = new Array( count );

			for ( let i = 0; i < count; i ++ ) {

				const b = ( 1 << i );
				let s = ( dataSize / b ) | 0;

				if ( roundingMode == 'ROUND_UP' && s * b < dataSize ) s += 1;

				const l = Math.max( s, 1 );

				tiles[ i ] = ( ( l + size - 1 ) / size ) | 0;

			}

			return tiles;

		}

		function parseTiles() {

			const EXRDecoder = this;
			const offset = EXRDecoder.offset;
			const tmpOffset = { value: 0 };

			for ( let tile = 0; tile < EXRDecoder.tileCount; tile ++ ) {

				const tileX = parseInt32( EXRDecoder.viewer, offset );
				const tileY = parseInt32( EXRDecoder.viewer, offset );
				offset.value += 8; // skip levels - only parsing top-level
				EXRDecoder.size = parseUint32( EXRDecoder.viewer, offset );

				const startX = tileX * EXRDecoder.blockWidth;
				const startY = tileY * EXRDecoder.blockHeight;
				EXRDecoder.columns = ( startX + EXRDecoder.blockWidth > EXRDecoder.width ) ? EXRDecoder.width - startX : EXRDecoder.blockWidth;
				EXRDecoder.lines = ( startY + EXRDecoder.blockHeight > EXRDecoder.height ) ? EXRDecoder.height - startY : EXRDecoder.blockHeight;

				const bytesBlockLine = EXRDecoder.columns * EXRDecoder.totalBytes;
				const isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesBlockLine;
				const viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );

				offset.value += EXRDecoder.size;

				for ( let line = 0; line < EXRDecoder.lines; line ++ ) {

					const lineOffset = line * EXRDecoder.columns * EXRDecoder.totalBytes;

					for ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {

						const name = EXRHeader.channels[ channelID ].name;
						const lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;
						const cOff = EXRDecoder.decodeChannels[ name ];

						if ( cOff === undefined ) continue;

						tmpOffset.value = lineOffset + lOff;
						const outLineOffset = ( EXRDecoder.height - ( 1 + startY + line ) ) * EXRDecoder.outLineWidth;

						for ( let x = 0; x < EXRDecoder.columns; x ++ ) {

							const outIndex = outLineOffset + ( x + startX ) * EXRDecoder.outputChannels + cOff;
							EXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );

						}

					}

				}

			}

		}

		function parseScanline() {

			const EXRDecoder = this;
			const offset = EXRDecoder.offset;
			const tmpOffset = { value: 0 };

			for ( let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.blockHeight; scanlineBlockIdx ++ ) {

				const line = parseInt32( EXRDecoder.viewer, offset ) - EXRHeader.dataWindow.yMin; // line_no
				EXRDecoder.size = parseUint32( EXRDecoder.viewer, offset ); // data_len
				EXRDecoder.lines = ( ( line + EXRDecoder.blockHeight > EXRDecoder.height ) ? ( EXRDecoder.height - line ) : EXRDecoder.blockHeight );

				const bytesPerLine = EXRDecoder.columns * EXRDecoder.totalBytes;
				const isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesPerLine;
				const viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );

				offset.value += EXRDecoder.size;

				for ( let line_y = 0; line_y < EXRDecoder.blockHeight; line_y ++ ) {

					const scan_y = scanlineBlockIdx * EXRDecoder.blockHeight;
					const true_y = line_y + EXRDecoder.scanOrder( scan_y );
					if ( true_y >= EXRDecoder.height ) continue;

					const lineOffset = line_y * bytesPerLine;
					const outLineOffset = ( EXRDecoder.height - 1 - true_y ) * EXRDecoder.outLineWidth;

					for ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {

						const name = EXRHeader.channels[ channelID ].name;
						const lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;
						const cOff = EXRDecoder.decodeChannels[ name ];

						if ( cOff === undefined ) continue;

						tmpOffset.value = lineOffset + lOff;

						for ( let x = 0; x < EXRDecoder.columns; x ++ ) {

							const outIndex = outLineOffset + x * EXRDecoder.outputChannels + cOff;
							EXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );

						}

					}

				}

			}

		}

		function parseHeader( dataView, buffer, offset ) {

			const EXRHeader = {};

			if ( dataView.getUint32( 0, true ) != 20000630 ) { // magic

				throw new Error( 'THREE.EXRLoader: Provided file doesn\'t appear to be in OpenEXR format.' );

			}

			EXRHeader.version = dataView.getUint8( 4 );

			const spec = dataView.getUint8( 5 ); // fullMask

			EXRHeader.spec = {
				singleTile: !! ( spec & 2 ),
				longName: !! ( spec & 4 ),
				deepFormat: !! ( spec & 8 ),
				multiPart: !! ( spec & 16 ),
			};

			// start of header

			offset.value = 8; // start at 8 - after pre-amble

			let keepReading = true;

			while ( keepReading ) {

				const attributeName = parseNullTerminatedString( buffer, offset );

				if ( attributeName == 0 ) {

					keepReading = false;

				} else {

					const attributeType = parseNullTerminatedString( buffer, offset );
					const attributeSize = parseUint32( dataView, offset );
					const attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );

					if ( attributeValue === undefined ) {

						console.warn( `THREE.EXRLoader: Skipped unknown header attribute type \'${attributeType}\'.` );

					} else {

						EXRHeader[ attributeName ] = attributeValue;

					}

				}

			}

			if ( ( spec & -7 ) != 0 ) { // unsupported deep-image, multi-part

				console.error( 'THREE.EXRHeader:', EXRHeader );
				throw new Error( 'THREE.EXRLoader: Provided file is currently unsupported.' );

			}

			return EXRHeader;

		}

		function setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType ) {

			const EXRDecoder = {
				size: 0,
				viewer: dataView,
				array: uInt8Array,
				offset: offset,
				width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,
				height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,
				inputChannels: EXRHeader.channels,
				channelByteOffsets: {},
				scanOrder: null,
				totalBytes: null,
				columns: null,
				lines: null,
				type: null,
				uncompress: null,
				getter: null,
				format: null,
				colorSpace: LinearSRGBColorSpace,
			};

			switch ( EXRHeader.compression ) {

				case 'NO_COMPRESSION':
					EXRDecoder.blockHeight = 1;
					EXRDecoder.uncompress = uncompressRAW;
					break;

				case 'RLE_COMPRESSION':
					EXRDecoder.blockHeight = 1;
					EXRDecoder.uncompress = uncompressRLE;
					break;

				case 'ZIPS_COMPRESSION':
					EXRDecoder.blockHeight = 1;
					EXRDecoder.uncompress = uncompressZIP;
					break;

				case 'ZIP_COMPRESSION':
					EXRDecoder.blockHeight = 16;
					EXRDecoder.uncompress = uncompressZIP;
					break;

				case 'PIZ_COMPRESSION':
					EXRDecoder.blockHeight = 32;
					EXRDecoder.uncompress = uncompressPIZ;
					break;

				case 'PXR24_COMPRESSION':
					EXRDecoder.blockHeight = 16;
					EXRDecoder.uncompress = uncompressPXR;
					break;

				case 'DWAA_COMPRESSION':
					EXRDecoder.blockHeight = 32;
					EXRDecoder.uncompress = uncompressDWA;
					break;

				case 'DWAB_COMPRESSION':
					EXRDecoder.blockHeight = 256;
					EXRDecoder.uncompress = uncompressDWA;
					break;

				default:
					throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );

			}

			const channels = {};
			for ( const channel of EXRHeader.channels ) {

				switch ( channel.name ) {

					case 'Y':
					case 'R':
					case 'G':
					case 'B':
					case 'A':
						channels[ channel.name ] = true;
						EXRDecoder.type = channel.pixelType;

				}

			}

			// RGB images will be converted to RGBA format, preventing software emulation in select devices.
			let fillAlpha = false;

			if ( channels.R && channels.G && channels.B ) {

				fillAlpha = ! channels.A;
				EXRDecoder.outputChannels = 4;
				EXRDecoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };

			} else if ( channels.Y ) {

				EXRDecoder.outputChannels = 1;
				EXRDecoder.decodeChannels = { Y: 0 };

			} else {

				throw new Error( 'EXRLoader.parse: file contains unsupported data channels.' );

			}

			if ( EXRDecoder.type == 1 ) {

				// half
				switch ( outputType ) {

					case FloatType:
						EXRDecoder.getter = parseFloat16;
						break;

					case HalfFloatType:
						EXRDecoder.getter = parseUint16;
						break;

				}

			} else if ( EXRDecoder.type == 2 ) {

				// float
				switch ( outputType ) {

					case FloatType:
						EXRDecoder.getter = parseFloat32;
						break;

					case HalfFloatType:
						EXRDecoder.getter = decodeFloat32;

				}

			} else {

				throw new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );

			}

			EXRDecoder.columns = EXRDecoder.width;
			const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;

			switch ( outputType ) {

				case FloatType:
					EXRDecoder.byteArray = new Float32Array( size );

					// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten
					if ( fillAlpha )
						EXRDecoder.byteArray.fill( 1, 0, size );

					break;

				case HalfFloatType:
					EXRDecoder.byteArray = new Uint16Array( size );

					if ( fillAlpha )
						EXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1

					break;

				default:
					console.error( 'THREE.EXRLoader: unsupported type: ', outputType );
					break;

			}

			let byteOffset = 0;
			for ( const channel of EXRHeader.channels ) {

				if ( EXRDecoder.decodeChannels[ channel.name ] !== undefined ) {

					EXRDecoder.channelByteOffsets[ channel.name ] = byteOffset;

				}

				byteOffset += channel.pixelType * 2;

			}

			EXRDecoder.totalBytes = byteOffset;
			EXRDecoder.outLineWidth = EXRDecoder.width * EXRDecoder.outputChannels;

			if ( EXRHeader.lineOrder === 'INCREASING_Y' ) {

				EXRDecoder.scanOrder = ( y ) => y;

			} else {

				EXRDecoder.scanOrder = ( y ) => EXRDecoder.height - 1 - y;

			}

			if ( EXRDecoder.outputChannels == 4 ) {

				EXRDecoder.format = RGBAFormat;
				EXRDecoder.colorSpace = LinearSRGBColorSpace;

			} else {

				EXRDecoder.format = RedFormat;
				EXRDecoder.colorSpace = NoColorSpace;

			}

			if ( EXRHeader.spec.singleTile ) {

				EXRDecoder.blockHeight = EXRHeader.tiles.ySize;
				EXRDecoder.blockWidth = EXRHeader.tiles.xSize;

				const numXLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );
				// const numYLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );

				const numXTiles = calculateTiles( numXLevels, EXRDecoder.width, EXRHeader.tiles.xSize, EXRHeader.tiles.roundingMode );
				const numYTiles = calculateTiles( numXLevels, EXRDecoder.height, EXRHeader.tiles.ySize, EXRHeader.tiles.roundingMode );

				EXRDecoder.tileCount = numXTiles[ 0 ] * numYTiles[ 0 ];

				for ( let l = 0; l < numXLevels; l ++ )
					for ( let y = 0; y < numYTiles[ l ]; y ++ )
						for ( let x = 0; x < numXTiles[ l ]; x ++ )
							parseInt64( dataView, offset ); // tileOffset

				EXRDecoder.decode = parseTiles.bind( EXRDecoder );

			} else {

				EXRDecoder.blockWidth = EXRDecoder.width;
				const blockCount = Math.ceil( EXRDecoder.height / EXRDecoder.blockHeight );

				for ( let i = 0; i < blockCount; i ++ )
					parseInt64( dataView, offset ); // scanlineOffset

				EXRDecoder.decode = parseScanline.bind( EXRDecoder );

			}

			return EXRDecoder;

		}

		// start parsing file [START]
		const offset = { value: 0 };
		const bufferDataView = new DataView( buffer );
		const uInt8Array = new Uint8Array( buffer );

		// get header information and validate format.
		const EXRHeader = parseHeader( bufferDataView, buffer, offset );

		// get input compression information and prepare decoding.
		const EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type );

		// parse input data
		EXRDecoder.decode();

		return {
			header: EXRHeader,
			width: EXRDecoder.width,
			height: EXRDecoder.height,
			data: EXRDecoder.byteArray,
			format: EXRDecoder.format,
			colorSpace: EXRDecoder.colorSpace,
			type: this.type,
		};

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			texture.colorSpace = texData.colorSpace;
			texture.minFilter = LinearFilter;
			texture.magFilter = LinearFilter;
			texture.generateMipmaps = false;
			texture.flipY = false;

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}

/**
 * @monogrid/gainmap-js v3.1.0
 * With ❤️, by MONOGRID <rnd@monogrid.com>
 */


const getBufferForType = (type, width, height) => {
    let out;
    switch (type) {
        case UnsignedByteType:
            out = new Uint8ClampedArray(width * height * 4);
            break;
        case HalfFloatType:
            out = new Uint16Array(width * height * 4);
            break;
        case UnsignedIntType:
            out = new Uint32Array(width * height * 4);
            break;
        case ByteType:
            out = new Int8Array(width * height * 4);
            break;
        case ShortType:
            out = new Int16Array(width * height * 4);
            break;
        case IntType:
            out = new Int32Array(width * height * 4);
            break;
        case FloatType:
            out = new Float32Array(width * height * 4);
            break;
        default:
            throw new Error('Unsupported data type');
    }
    return out;
};
let _canReadPixelsResult;
/**
 * Test if this browser implementation can correctly read pixels from the specified
 * Render target type.
 *
 * Runs only once
 *
 * @param type
 * @param renderer
 * @param camera
 * @param renderTargetOptions
 * @returns
 */
const canReadPixels = (type, renderer, camera, renderTargetOptions) => {
    if (_canReadPixelsResult !== undefined)
        return _canReadPixelsResult;
    const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);
    renderer.setRenderTarget(testRT);
    const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({ color: 0xffffff }));
    renderer.render(mesh, camera);
    renderer.setRenderTarget(null);
    const out = getBufferForType(type, testRT.width, testRT.height);
    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);
    testRT.dispose();
    mesh.geometry.dispose();
    mesh.material.dispose();
    _canReadPixelsResult = out[0] !== 0;
    return _canReadPixelsResult;
};
/**
 * Utility class used for rendering a texture with a material
 *
 * @category Core
 * @group Core
 */
class QuadRenderer {
    /**
     * Constructs a new QuadRenderer
     *
     * @param options Parameters for this QuadRenderer
     */
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        this._rendererIsDisposable = false;
        this._supportsReadPixels = true;
        /**
         * Renders the input texture using the specified material
         */
        this.render = () => {
            this._renderer.setRenderTarget(this._renderTarget);
            try {
                this._renderer.render(this._scene, this._camera);
            }
            catch (e) {
                this._renderer.setRenderTarget(null);
                throw e;
            }
            this._renderer.setRenderTarget(null);
        };
        this._width = options.width;
        this._height = options.height;
        this._type = options.type;
        this._colorSpace = options.colorSpace;
        const rtOptions = {
            // fixed options
            format: RGBAFormat,
            depthBuffer: false,
            stencilBuffer: false,
            // user options
            type: this._type, // set in class property
            colorSpace: this._colorSpace, // set in class property
            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,
            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,
            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : LinearFilter,
            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : LinearFilter,
            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,
            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : ClampToEdgeWrapping,
            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : ClampToEdgeWrapping
        };
        this._material = options.material;
        if (options.renderer) {
            this._renderer = options.renderer;
        }
        else {
            this._renderer = QuadRenderer.instantiateRenderer();
            this._rendererIsDisposable = true;
        }
        this._scene = new Scene();
        this._camera = new OrthographicCamera();
        this._camera.position.set(0, 0, 10);
        this._camera.left = -0.5;
        this._camera.right = 0.5;
        this._camera.top = 0.5;
        this._camera.bottom = -0.5;
        this._camera.updateProjectionMatrix();
        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {
            let alternativeType;
            switch (this._type) {
                case HalfFloatType:
                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? FloatType : undefined;
                    break;
            }
            if (alternativeType !== undefined) {
                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);
                this._type = alternativeType;
            }
            else {
                this._supportsReadPixels = false;
                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');
            }
        }
        this._quad = new Mesh(new PlaneGeometry(), this._material);
        this._quad.geometry.computeBoundingBox();
        this._scene.add(this._quad);
        this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);
        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : UVMapping;
    }
    /**
     * Instantiates a temporary renderer
     *
     * @returns
     */
    static instantiateRenderer() {
        const renderer = new WebGLRenderer();
        renderer.setSize(128, 128);
        // renderer.outputColorSpace = SRGBColorSpace
        // renderer.toneMapping = LinearToneMapping
        // renderer.debug.checkShaderErrors = false
        // this._rendererIsDisposable = true
        return renderer;
    }
    /**
     * Obtains a Buffer containing the rendered texture.
     *
     * @throws Error if the browser cannot read pixels from this RenderTarget type.
     * @returns a TypedArray containing RGBA values from this renderer
     */
    toArray() {
        if (!this._supportsReadPixels)
            throw new Error('Can\'t read pixels in this browser');
        const out = getBufferForType(this._type, this._width, this._height);
        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);
        return out;
    }
    /**
     * Performs a readPixel operation in the renderTarget
     * and returns a DataTexture containing the read data
     *
     * @param options options
     * @returns
     */
    toDataTexture(options) {
        const returnValue = new DataTexture(
        // fixed values
        this.toArray(), this.width, this.height, RGBAFormat, this._type, 
        // user values
        (options === null || options === void 0 ? void 0 : options.mapping) || UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, 
        // fixed value
        LinearSRGBColorSpace);
        // set this afterwards, we can't set it in constructor
        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;
        return returnValue;
    }
    /**
     * If using a disposable renderer, it will dispose it.
     */
    disposeOnDemandRenderer() {
        this._renderer.setRenderTarget(null);
        if (this._rendererIsDisposable) {
            this._renderer.dispose();
            this._renderer.forceContextLoss();
        }
    }
    /**
     * Will dispose of **all** assets used by this renderer.
     *
     *
     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later
     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`
     * or are otherwise done with it.
     *
     * @example
     * ```js
     * const loader = new HDRJPGLoader(renderer)
     * const result = await loader.loadAsync('gainmap.jpeg')
     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )
     * // DO NOT dispose the renderTarget here,
     * // it is used directly in the material
     * result.dispose()
     * ```
     *
     * @example
     * ```js
     * const loader = new HDRJPGLoader(renderer)
     * const pmremGenerator = new PMREMGenerator( renderer );
     * const result = await loader.loadAsync('gainmap.jpeg')
     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)
     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )
     * // renderTarget can be disposed here
     * // because it was used to generate a PMREM texture
     * result.dispose(true)
     * ```
     */
    dispose(disposeRenderTarget) {
        this.disposeOnDemandRenderer();
        if (disposeRenderTarget) {
            this.renderTarget.dispose();
        }
        // dispose shader material texture uniforms
        if (this.material instanceof ShaderMaterial) {
            Object.values(this.material.uniforms).forEach(v => {
                if (v.value instanceof Texture)
                    v.value.dispose();
            });
        }
        // dispose other material properties
        Object.values(this.material).forEach(value => {
            if (value instanceof Texture)
                value.dispose();
        });
        this.material.dispose();
        this._quad.geometry.dispose();
    }
    /**
     * Width of the texture
     */
    get width() { return this._width; }
    set width(value) {
        this._width = value;
        this._renderTarget.setSize(this._width, this._height);
    }
    /**
     * Height of the texture
     */
    get height() { return this._height; }
    set height(value) {
        this._height = value;
        this._renderTarget.setSize(this._width, this._height);
    }
    /**
     * The renderer used
     */
    get renderer() { return this._renderer; }
    /**
     * The `WebGLRenderTarget` used.
     */
    get renderTarget() { return this._renderTarget; }
    set renderTarget(value) {
        this._renderTarget = value;
        this._width = value.width;
        this._height = value.height;
        // this._type = value.texture.type
    }
    /**
     * The `Material` used.
     */
    get material() { return this._material; }
    /**
     *
     */
    get type() { return this._type; }
    get colorSpace() { return this._colorSpace; }
}

/**
 * @monogrid/gainmap-js v3.1.0
 * With ❤️, by MONOGRID <rnd@monogrid.com>
 */


const vertexShader = /* glsl */ `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
const fragmentShader = /* glsl */ `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;
/**
 * A Material which is able to decode the Gainmap into a full HDR Representation
 *
 * @category Materials
 * @group Materials
 */
class GainMapDecoderMaterial extends ShaderMaterial {
    /**
     *
     * @param params
     */
    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {
        super({
            name: 'GainMapDecoderMaterial',
            vertexShader,
            fragmentShader,
            uniforms: {
                sdr: { value: sdr },
                gainMap: { value: gainMap },
                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },
                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },
                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },
                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },
                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },
                weightFactor: {
                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)
                }
            },
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
        this._maxDisplayBoost = maxDisplayBoost;
        this._hdrCapacityMin = hdrCapacityMin;
        this._hdrCapacityMax = hdrCapacityMax;
        this.needsUpdate = true;
        this.uniformsNeedUpdate = true;
    }
    get sdr() { return this.uniforms.sdr.value; }
    set sdr(value) { this.uniforms.sdr.value = value; }
    get gainMap() { return this.uniforms.gainMap.value; }
    set gainMap(value) { this.uniforms.gainMap.value = value; }
    /**
     * @see {@link GainMapMetadata.offsetHdr}
     */
    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }
    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }
    /**
     * @see {@link GainMapMetadata.offsetSdr}
     */
    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }
    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }
    /**
     * @see {@link GainMapMetadata.gainMapMin}
     */
    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }
    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }
    /**
     * @see {@link GainMapMetadata.gainMapMax}
     */
    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }
    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }
    /**
     * @see {@link GainMapMetadata.gamma}
     */
    get gamma() {
        const g = this.uniforms.gamma.value;
        return [1 / g.x, 1 / g.y, 1 / g.z];
    }
    set gamma(value) {
        const g = this.uniforms.gamma.value;
        g.x = 1.0 / value[0];
        g.y = 1.0 / value[1];
        g.z = 1.0 / value[2];
    }
    /**
     * @see {@link GainMapMetadata.hdrCapacityMin}
     * @remarks Logarithmic space
     */
    get hdrCapacityMin() { return this._hdrCapacityMin; }
    set hdrCapacityMin(value) {
        this._hdrCapacityMin = value;
        this.calculateWeight();
    }
    /**
     * @see {@link GainMapMetadata.hdrCapacityMin}
     * @remarks Logarithmic space
     */
    get hdrCapacityMax() { return this._hdrCapacityMax; }
    set hdrCapacityMax(value) {
        this._hdrCapacityMax = value;
        this.calculateWeight();
    }
    /**
     * @see {@link GainmapDecodingParameters.maxDisplayBoost}
     * @remarks Non Logarithmic space
     */
    get maxDisplayBoost() { return this._maxDisplayBoost; }
    set maxDisplayBoost(value) {
        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));
        this.calculateWeight();
    }
    calculateWeight() {
        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);
        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));
    }
}

class GainMapNotFoundError extends Error {
}

class XMPMetadataNotFoundError extends Error {
}

const getXMLValue = (xml, tag, defaultValue) => {
    // Check for attribute format first: tag="value"
    const attributeMatch = new RegExp(`${tag}="([^"]*)"`, 'i').exec(xml);
    if (attributeMatch)
        return attributeMatch[1];
    // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>
    const tagMatch = new RegExp(`<${tag}[^>]*>([\\s\\S]*?)</${tag}>`, 'i').exec(xml);
    if (tagMatch) {
        // Check if it contains rdf:li elements
        const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
        if (liValues && liValues.length === 3) {
            return liValues.map(v => v.replace(/<\/?rdf:li>/g, ''));
        }
        return tagMatch[1].trim();
    }
    if (defaultValue !== undefined)
        return defaultValue;
    throw new Error(`Can't find ${tag} in gainmap metadata`);
};
const extractXMP = (input) => {
    let str;
    // support node test environment
    if (typeof TextDecoder !== 'undefined')
        str = new TextDecoder().decode(input);
    else
        str = input.toString();
    let start = str.indexOf('<x:xmpmeta');
    while (start !== -1) {
        const end = str.indexOf('x:xmpmeta>', start);
        const xmpBlock = str.slice(start, end + 10);
        try {
            const gainMapMin = getXMLValue(xmpBlock, 'hdrgm:GainMapMin', '0');
            const gainMapMax = getXMLValue(xmpBlock, 'hdrgm:GainMapMax');
            const gamma = getXMLValue(xmpBlock, 'hdrgm:Gamma', '1');
            const offsetSDR = getXMLValue(xmpBlock, 'hdrgm:OffsetSDR', '0.015625');
            const offsetHDR = getXMLValue(xmpBlock, 'hdrgm:OffsetHDR', '0.015625');
            // These are always attributes, so we can use a simpler regex
            const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(xmpBlock);
            const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : '0';
            const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(xmpBlock);
            if (!hdrCapacityMaxMatch)
                throw new Error('Incomplete gainmap metadata');
            const hdrCapacityMax = hdrCapacityMaxMatch[1];
            return {
                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],
                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],
                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],
                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],
                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],
                hdrCapacityMin: parseFloat(hdrCapacityMin),
                hdrCapacityMax: parseFloat(hdrCapacityMax)
            };
        }
        catch (e) {
            // Continue searching for another xmpmeta block if this one fails
        }
        start = str.indexOf('<x:xmpmeta', end);
    }
};

/**
 * MPF Extractor (Multi Picture Format Extractor)
 * By Henrik S Nilsson 2019
 *
 * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html
 * under "CIPA DC-007-Translation-2021 Multi-Picture Format"
 *
 * Overly commented, and without intention of being complete or production ready.
 * Created to extract depth maps from iPhone images, and to learn about image metadata.
 * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)
 */
class MPFExtractor {
    constructor(options) {
        this.options = {
            debug: options && options.debug !== undefined ? options.debug : false,
            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,
            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true
        };
    }
    extract(imageArrayBuffer) {
        return new Promise((resolve, reject) => {
            const debug = this.options.debug;
            const dataView = new DataView(imageArrayBuffer.buffer);
            // If you're executing this line on a big endian machine, it'll be reversed.
            // bigEnd further down though, refers to the endianness of the image itself.
            if (dataView.getUint16(0) !== 0xffd8) {
                reject(new Error('Not a valid jpeg'));
                return;
            }
            const length = dataView.byteLength;
            let offset = 2;
            let loops = 0;
            let marker; // APP# marker
            while (offset < length) {
                if (++loops > 250) {
                    reject(new Error(`Found no marker after ${loops} loops 😵`));
                    return;
                }
                if (dataView.getUint8(offset) !== 0xff) {
                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));
                    return;
                }
                marker = dataView.getUint8(offset + 1);
                if (debug)
                    console.log(`Marker: ${marker.toString(16)}`);
                if (marker === 0xe2) {
                    if (debug)
                        console.log('Found APP2 marker (0xffe2)');
                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.
                    // Great way to visualize image information in html is using Exiftool. E.g.:
                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html
                    const formatPt = offset + 4;
                    /*
                     *  Structure of the MP Format Identifier
                     *
                     *  Offset Addr.  | Code (Hex)  | Description
                     *  +00             ff            Marker Prefix      <-- offset
                     *  +01             e2            APP2
                     *  +02             #n            APP2 Field Length
                     *  +03             #n            APP2 Field Length
                     *  +04             4d            'M'                <-- formatPt
                     *  +05             50            'P'
                     *  +06             46            'F'
                     *  +07             00            NULL
                     *                                                   <-- tiffOffset
                     */
                    if (dataView.getUint32(formatPt) === 0x4d504600) {
                        // Found MPF tag, so we start dig out sub images
                        const tiffOffset = formatPt + 4;
                        let bigEnd; // Endianness from TIFF header
                        // Test for TIFF validity and endianness
                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian
                        if (dataView.getUint16(tiffOffset) === 0x4949) {
                            bigEnd = false;
                        }
                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {
                            bigEnd = true;
                        }
                        else {
                            reject(new Error('No valid endianness marker found in TIFF header'));
                            return;
                        }
                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {
                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));
                            return;
                        }
                        // 32 bit number stating the offset from the start of the 8 Byte MP Header
                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)
                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);
                        if (firstIFDOffset < 0x00000008) {
                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));
                            return;
                        }
                        // Move ahead to MP Index IFD
                        // Assume we're at the first IFD, so firstIFDOffset points to
                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,
                        // we fail silently here due to this assumption)
                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)
                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)
                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)
                        // Extract info from MPEntries (starting after Count)
                        const entriesStart = dirStart + 2;
                        let numberOfImages = 0;
                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {
                            // Each entry is 12 Bytes long
                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images
                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {
                                // stored in Last 4 bytes of its 12 Byte entry.
                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);
                            }
                        }
                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags
                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;
                        const images = [];
                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {
                            const image = {
                                MPType: dataView.getUint32(i, !bigEnd),
                                size: dataView.getUint32(i + 4, !bigEnd),
                                // This offset is specified relative to the address of the MP Endian
                                // field in the MP Header, unless the image is a First Individual Image,
                                // in which case the value of the offset shall be NULL (0x00000000).
                                dataOffset: dataView.getUint32(i + 8, !bigEnd),
                                dependantImages: dataView.getUint32(i + 12, !bigEnd),
                                start: -1,
                                end: -1,
                                isFII: false
                            };
                            if (!image.dataOffset) {
                                // dataOffset is 0x00000000 for First Individual Image
                                image.start = 0;
                                image.isFII = true;
                            }
                            else {
                                image.start = tiffOffset + image.dataOffset;
                                image.isFII = false;
                            }
                            image.end = image.start + image.size;
                            images.push(image);
                        }
                        if (this.options.extractNonFII && images.length) {
                            const bufferBlob = new Blob([dataView]);
                            const imgs = [];
                            for (const image of images) {
                                if (image.isFII && !this.options.extractFII) {
                                    continue; // Skip FII
                                }
                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');
                                // we don't need this
                                // const imageUrl = URL.createObjectURL(imageBlob)
                                // image.img = document.createElement('img')
                                // image.img.src = imageUrl
                                imgs.push(imageBlob);
                            }
                            resolve(imgs);
                        }
                    }
                }
                offset += 2 + dataView.getUint16(offset + 2);
            }
        });
    }
}

/**
 * Extracts XMP Metadata and the gain map recovery image
 * from a single JPEG file.
 *
 * @category Decoding Functions
 * @group Decoding Functions
 * @param jpegFile an `Uint8Array` containing and encoded JPEG file
 * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata
 * @throws Error if XMP Metadata is not found
 * @throws Error if Gain map image is not found
 * @example
 * import { FileLoader } from 'three'
 * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'
 *
 * const jpegFile = await new FileLoader()
 *  .setResponseType('arraybuffer')
 *  .loadAsync('image.jpg')
 *
 * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)
 */
const extractGainmapFromJPEG = async (jpegFile) => {
    const metadata = extractXMP(jpegFile);
    if (!metadata)
        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');
    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });
    const images = await mpfExtractor.extract(jpegFile);
    if (images.length !== 2)
        throw new GainMapNotFoundError('Gain map recovery image not found');
    return {
        sdr: new Uint8Array(await images[0].arrayBuffer()),
        gainMap: new Uint8Array(await images[1].arrayBuffer()),
        metadata
    };
};

/**
 * private function, async get image from blob
 *
 * @param blob
 * @returns
 */
const getHTMLImageFromBlob = (blob) => {
    return new Promise((resolve, reject) => {
        const img = document.createElement('img');
        img.onload = () => { resolve(img); };
        img.onerror = (e) => { reject(e); };
        img.src = URL.createObjectURL(blob);
    });
};

class LoaderBase extends Loader {
    /**
     *
     * @param renderer
     * @param manager
     */
    constructor(renderer, manager) {
        super(manager);
        if (renderer)
            this._renderer = renderer;
        this._internalLoadingManager = new LoadingManager();
    }
    /**
     * Specify the renderer to use when rendering the gain map
     *
     * @param renderer
     * @returns
     */
    setRenderer(renderer) {
        this._renderer = renderer;
        return this;
    }
    /**
     * Specify the renderTarget options to use when rendering the gain map
     *
     * @param options
     * @returns
     */
    setRenderTargetOptions(options) {
        this._renderTargetOptions = options;
        return this;
    }
    /**
     * @private
     * @returns
     */
    prepareQuadRenderer() {
        if (!this._renderer)
            console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');
        // temporary values
        const material = new GainMapDecoderMaterial({
            gainMapMax: [1, 1, 1],
            gainMapMin: [0, 0, 0],
            gamma: [1, 1, 1],
            offsetHdr: [1, 1, 1],
            offsetSdr: [1, 1, 1],
            hdrCapacityMax: 1,
            hdrCapacityMin: 0,
            maxDisplayBoost: 1,
            gainMap: new Texture(),
            sdr: new Texture()
        });
        return new QuadRenderer({
            width: 16,
            height: 16,
            type: HalfFloatType,
            colorSpace: LinearSRGBColorSpace,
            material,
            renderer: this._renderer,
            renderTargetOptions: this._renderTargetOptions
        });
    }
    /**
   * @private
   * @param quadRenderer
   * @param metadata
   * @param sdrBuffer
   * @param gainMapBuffer
   */
    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {
        // this is optional, will render a black gain-map if not present
        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;
        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });
        let sdrImage;
        let gainMapImage;
        let needsFlip = false;
        if (typeof createImageBitmap === 'undefined') {
            const res = await Promise.all([
                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),
                getHTMLImageFromBlob(sdrBlob)
            ]);
            gainMapImage = res[0];
            sdrImage = res[1];
            needsFlip = true;
        }
        else {
            const res = await Promise.all([
                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),
                createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })
            ]);
            gainMapImage = res[0];
            sdrImage = res[1];
        }
        const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);
        gainMap.flipY = needsFlip;
        gainMap.needsUpdate = true;
        const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);
        sdr.flipY = needsFlip;
        sdr.needsUpdate = true;
        quadRenderer.width = sdrImage.width;
        quadRenderer.height = sdrImage.height;
        quadRenderer.material.gainMap = gainMap;
        quadRenderer.material.sdr = sdr;
        quadRenderer.material.gainMapMin = metadata.gainMapMin;
        quadRenderer.material.gainMapMax = metadata.gainMapMax;
        quadRenderer.material.offsetHdr = metadata.offsetHdr;
        quadRenderer.material.offsetSdr = metadata.offsetSdr;
        quadRenderer.material.gamma = metadata.gamma;
        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;
        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;
        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);
        quadRenderer.material.needsUpdate = true;
        quadRenderer.render();
    }
}

/**
 * A Three.js Loader for the gain map format.
 *
 * @category Loaders
 * @group Loaders
 *
 * @example
 * import { GainMapLoader } from '@monogrid/gainmap-js'
 * import {
 *   EquirectangularReflectionMapping,
 *   LinearFilter,
 *   Mesh,
 *   MeshBasicMaterial,
 *   PerspectiveCamera,
 *   PlaneGeometry,
 *   Scene,
 *   WebGLRenderer
 * } from 'three'
 *
 * const renderer = new WebGLRenderer()
 *
 * const loader = new GainMapLoader(renderer)
 *
 * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])
 * // `result` can be used to populate a Texture
 *
 * const scene = new Scene()
 * const mesh = new Mesh(
 *   new PlaneGeometry(),
 *   new MeshBasicMaterial({ map: result.renderTarget.texture })
 * )
 * scene.add(mesh)
 * renderer.render(scene, new PerspectiveCamera())
 *
 * // Starting from three.js r159
 * // `result.renderTarget.texture` can
 * // also be used as Equirectangular scene background
 * //
 * // it was previously needed to convert it
 * // to a DataTexture with `result.toDataTexture()`
 * scene.background = result.renderTarget.texture
 * scene.background.mapping = EquirectangularReflectionMapping
 *
 * // result must be manually disposed
 * // when you are done using it
 * result.dispose()
 *
 */
class GainMapLoader extends LoaderBase {
    /**
     * Loads a gainmap using separate data
     * * sdr image
     * * gain map image
     * * metadata json
     *
     * useful for webp gain maps
     *
     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]
     * @param onLoad Load complete callback, will receive the result
     * @param onProgress Progress callback, will receive a {@link ProgressEvent}
     * @param onError Error callback
     * @returns
     */
    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {
        const quadRenderer = this.prepareQuadRenderer();
        let sdr;
        let gainMap;
        let metadata;
        const loadCheck = async () => {
            if (sdr && gainMap && metadata) {
                // solves #16
                try {
                    await this.render(quadRenderer, metadata, sdr, gainMap);
                }
                catch (error) {
                    this.manager.itemError(sdrUrl);
                    this.manager.itemError(gainMapUrl);
                    this.manager.itemError(metadataUrl);
                    if (typeof onError === 'function')
                        onError(error);
                    quadRenderer.disposeOnDemandRenderer();
                    return;
                }
                if (typeof onLoad === 'function')
                    onLoad(quadRenderer);
                this.manager.itemEnd(sdrUrl);
                this.manager.itemEnd(gainMapUrl);
                this.manager.itemEnd(metadataUrl);
                quadRenderer.disposeOnDemandRenderer();
            }
        };
        let sdrLengthComputable = true;
        let sdrTotal = 0;
        let sdrLoaded = 0;
        let gainMapLengthComputable = true;
        let gainMapTotal = 0;
        let gainMapLoaded = 0;
        let metadataLengthComputable = true;
        let metadataTotal = 0;
        let metadataLoaded = 0;
        const progressHandler = () => {
            if (typeof onProgress === 'function') {
                const total = sdrTotal + gainMapTotal + metadataTotal;
                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;
                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;
                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));
            }
        };
        this.manager.itemStart(sdrUrl);
        this.manager.itemStart(gainMapUrl);
        this.manager.itemStart(metadataUrl);
        const sdrLoader = new FileLoader(this._internalLoadingManager);
        sdrLoader.setResponseType('arraybuffer');
        sdrLoader.setRequestHeader(this.requestHeader);
        sdrLoader.setPath(this.path);
        sdrLoader.setWithCredentials(this.withCredentials);
        sdrLoader.load(sdrUrl, async (buffer) => {
            /* istanbul ignore if
             this condition exists only because of three.js types + strict mode
            */
            if (typeof buffer === 'string')
                throw new Error('Invalid sdr buffer');
            sdr = buffer;
            await loadCheck();
        }, (e) => {
            sdrLengthComputable = e.lengthComputable;
            sdrLoaded = e.loaded;
            sdrTotal = e.total;
            progressHandler();
        }, (error) => {
            this.manager.itemError(sdrUrl);
            if (typeof onError === 'function')
                onError(error);
        });
        const gainMapLoader = new FileLoader(this._internalLoadingManager);
        gainMapLoader.setResponseType('arraybuffer');
        gainMapLoader.setRequestHeader(this.requestHeader);
        gainMapLoader.setPath(this.path);
        gainMapLoader.setWithCredentials(this.withCredentials);
        gainMapLoader.load(gainMapUrl, async (buffer) => {
            /* istanbul ignore if
             this condition exists only because of three.js types + strict mode
            */
            if (typeof buffer === 'string')
                throw new Error('Invalid gainmap buffer');
            gainMap = buffer;
            await loadCheck();
        }, (e) => {
            gainMapLengthComputable = e.lengthComputable;
            gainMapLoaded = e.loaded;
            gainMapTotal = e.total;
            progressHandler();
        }, (error) => {
            this.manager.itemError(gainMapUrl);
            if (typeof onError === 'function')
                onError(error);
        });
        const metadataLoader = new FileLoader(this._internalLoadingManager);
        // metadataLoader.setResponseType('json')
        metadataLoader.setRequestHeader(this.requestHeader);
        metadataLoader.setPath(this.path);
        metadataLoader.setWithCredentials(this.withCredentials);
        metadataLoader.load(metadataUrl, async (json) => {
            /* istanbul ignore if
             this condition exists only because of three.js types + strict mode
            */
            if (typeof json !== 'string')
                throw new Error('Invalid metadata string');
            // TODO: implement check on JSON file and remove this eslint disable
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            metadata = JSON.parse(json);
            await loadCheck();
        }, (e) => {
            metadataLengthComputable = e.lengthComputable;
            metadataLoaded = e.loaded;
            metadataTotal = e.total;
            progressHandler();
        }, (error) => {
            this.manager.itemError(metadataUrl);
            if (typeof onError === 'function')
                onError(error);
        });
        return quadRenderer;
    }
}

/**
 * A Three.js Loader for a JPEG with embedded gainmap metadata.
 *
 * @category Loaders
 * @group Loaders
 *
 * @example
 * import { HDRJPGLoader } from '@monogrid/gainmap-js'
 * import {
 *   EquirectangularReflectionMapping,
 *   LinearFilter,
 *   Mesh,
 *   MeshBasicMaterial,
 *   PerspectiveCamera,
 *   PlaneGeometry,
 *   Scene,
 *   WebGLRenderer
 * } from 'three'
 *
 * const renderer = new WebGLRenderer()
 *
 * const loader = new HDRJPGLoader(renderer)
 *
 * const result = await loader.loadAsync('gainmap.jpeg')
 * // `result` can be used to populate a Texture
 *
 * const scene = new Scene()
 * const mesh = new Mesh(
 *   new PlaneGeometry(),
 *   new MeshBasicMaterial({ map: result.renderTarget.texture })
 * )
 * scene.add(mesh)
 * renderer.render(scene, new PerspectiveCamera())
 *
 * // Starting from three.js r159
 * // `result.renderTarget.texture` can
 * // also be used as Equirectangular scene background
 * //
 * // it was previously needed to convert it
 * // to a DataTexture with `result.toDataTexture()`
 * scene.background = result.renderTarget.texture
 * scene.background.mapping = EquirectangularReflectionMapping
 *
 * // result must be manually disposed
 * // when you are done using it
 * result.dispose()
 *
 */
class HDRJPGLoader extends LoaderBase {
    /**
     * Loads a JPEG containing gain map metadata
     * Renders a normal SDR image if gainmap data is not found
     *
     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]
     * @param onLoad Load complete callback, will receive the result
     * @param onProgress Progress callback, will receive a {@link ProgressEvent}
     * @param onError Error callback
     * @returns
     */
    load(url, onLoad, onProgress, onError) {
        const quadRenderer = this.prepareQuadRenderer();
        const loader = new FileLoader(this._internalLoadingManager);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.setWithCredentials(this.withCredentials);
        this.manager.itemStart(url);
        loader.load(url, async (jpeg) => {
            /* istanbul ignore if
             this condition exists only because of three.js types + strict mode
            */
            if (typeof jpeg === 'string')
                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');
            const jpegBuffer = new Uint8Array(jpeg);
            let sdrJPEG;
            let gainMapJPEG;
            let metadata;
            try {
                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);
                // gain map is successfully reconstructed
                sdrJPEG = extractionResult.sdr;
                gainMapJPEG = extractionResult.gainMap;
                metadata = extractionResult.metadata;
            }
            catch (e) {
                // render the SDR version if this is not a gainmap
                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {
                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);
                    metadata = {
                        gainMapMin: [0, 0, 0],
                        gainMapMax: [1, 1, 1],
                        gamma: [1, 1, 1],
                        hdrCapacityMin: 0,
                        hdrCapacityMax: 1,
                        offsetHdr: [0, 0, 0],
                        offsetSdr: [0, 0, 0]
                    };
                    sdrJPEG = jpegBuffer;
                }
                else {
                    throw e;
                }
            }
            // solves #16
            try {
                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);
            }
            catch (error) {
                this.manager.itemError(url);
                if (typeof onError === 'function')
                    onError(error);
                quadRenderer.disposeOnDemandRenderer();
                return;
            }
            if (typeof onLoad === 'function')
                onLoad(quadRenderer);
            this.manager.itemEnd(url);
            quadRenderer.disposeOnDemandRenderer();
        }, onProgress, (error) => {
            this.manager.itemError(url);
            if (typeof onError === 'function')
                onError(error);
        });
        return quadRenderer;
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function isFunction(value) {
    return typeof value === 'function';
}

function createErrorClass(createImpl) {
    var _super = function (instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
}

var UnsubscriptionError = createErrorClass(function (_super) {
    return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors
            ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
            : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
    };
});

function arrRemove(arr, item) {
    if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
    }
}

var Subscription = (function () {
    function Subscription(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
    }
    Subscription.prototype.unsubscribe = function () {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
                this._parentage = null;
                if (Array.isArray(_parentage)) {
                    try {
                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                            var parent_1 = _parentage_1_1.value;
                            parent_1.remove(this);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                else {
                    _parentage.remove(this);
                }
            }
            var initialFinalizer = this.initialTeardown;
            if (isFunction(initialFinalizer)) {
                try {
                    initialFinalizer();
                }
                catch (e) {
                    errors = e instanceof UnsubscriptionError ? e.errors : [e];
                }
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
                this._finalizers = null;
                try {
                    for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                        var finalizer = _finalizers_1_1.value;
                        try {
                            execFinalizer(finalizer);
                        }
                        catch (err) {
                            errors = errors !== null && errors !== void 0 ? errors : [];
                            if (err instanceof UnsubscriptionError) {
                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                            }
                            else {
                                errors.push(err);
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            if (errors) {
                throw new UnsubscriptionError(errors);
            }
        }
    };
    Subscription.prototype.add = function (teardown) {
        var _a;
        if (teardown && teardown !== this) {
            if (this.closed) {
                execFinalizer(teardown);
            }
            else {
                if (teardown instanceof Subscription) {
                    if (teardown.closed || teardown._hasParent(this)) {
                        return;
                    }
                    teardown._addParent(this);
                }
                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
        }
    };
    Subscription.prototype._hasParent = function (parent) {
        var _parentage = this._parentage;
        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
    };
    Subscription.prototype._addParent = function (parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription.prototype._removeParent = function (parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
            this._parentage = null;
        }
        else if (Array.isArray(_parentage)) {
            arrRemove(_parentage, parent);
        }
    };
    Subscription.prototype.remove = function (teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription) {
            teardown._removeParent(this);
        }
    };
    Subscription.EMPTY = (function () {
        var empty = new Subscription();
        empty.closed = true;
        return empty;
    })();
    return Subscription;
}());
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
    return (value instanceof Subscription ||
        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));
}
function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
        finalizer();
    }
    else {
        finalizer.unsubscribe();
    }
}

var config$1 = {
    Promise: undefined};

var timeoutProvider = {
    setTimeout: function (handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function (handle) {
        return (clearTimeout)(handle);
    },
    delegate: undefined,
};

function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function () {
        {
            throw err;
        }
    });
}

function noop() { }

function errorContext(cb) {
    {
        cb();
    }
}

var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
            _this.destination = destination;
            if (isSubscription(destination)) {
                destination.add(_this);
            }
        }
        else {
            _this.destination = EMPTY_OBSERVER;
        }
        return _this;
    }
    Subscriber.create = function (next, error, complete) {
        return new SafeSubscriber(next, error, complete);
    };
    Subscriber.prototype.next = function (value) {
        if (this.isStopped) ;
        else {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (this.isStopped) ;
        else {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (this.isStopped) ;
        else {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
        }
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        try {
            this.destination.error(err);
        }
        finally {
            this.unsubscribe();
        }
    };
    Subscriber.prototype._complete = function () {
        try {
            this.destination.complete();
        }
        finally {
            this.unsubscribe();
        }
    };
    return Subscriber;
}(Subscription));
var ConsumerObserver = (function () {
    function ConsumerObserver(partialObserver) {
        this.partialObserver = partialObserver;
    }
    ConsumerObserver.prototype.next = function (value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
            try {
                partialObserver.next(value);
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
    };
    ConsumerObserver.prototype.error = function (err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
            try {
                partialObserver.error(err);
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
        else {
            handleUnhandledError(err);
        }
    };
    ConsumerObserver.prototype.complete = function () {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
            try {
                partialObserver.complete();
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
    };
    return ConsumerObserver;
}());
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction(observerOrNext) || !observerOrNext) {
            partialObserver = {
                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),
                error: error !== null && error !== void 0 ? error : undefined,
                complete: complete !== null && complete !== void 0 ? complete : undefined,
            };
        }
        else {
            {
                partialObserver = observerOrNext;
            }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
    }
    return SafeSubscriber;
}(Subscriber));
function handleUnhandledError(error) {
    {
        reportUnhandledError(error);
    }
}
function defaultErrorHandler(err) {
    throw err;
}
var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop,
};

var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

function identity(x) {
    return x;
}

function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}

var Observable = (function () {
    function Observable(subscribe) {
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
        errorContext(function () {
            var _a = _this, operator = _a.operator, source = _a.source;
            subscriber.add(operator
                ?
                    operator.call(subscriber, source)
                : source
                    ?
                        _this._subscribe(subscriber)
                    :
                        _this._trySubscribe(subscriber));
        });
        return subscriber;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.error(err);
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscriber = new SafeSubscriber({
                next: function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscriber.unsubscribe();
                    }
                },
                error: reject,
                complete: resolve,
            });
            _this.subscribe(subscriber);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable.prototype[observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$1.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
}

function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
    return function (source) {
        if (hasLift(source)) {
            return source.lift(function (liftedSource) {
                try {
                    return init(liftedSource, this);
                }
                catch (err) {
                    this.error(err);
                }
            });
        }
        throw new TypeError('Unable to lift unknown Observable type');
    };
}

function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = (function (_super) {
    __extends(OperatorSubscriber, _super);
    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext
            ? function (value) {
                try {
                    onNext(value);
                }
                catch (err) {
                    destination.error(err);
                }
            }
            : _super.prototype._next;
        _this._error = onError
            ? function (err) {
                try {
                    onError(err);
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._error;
        _this._complete = onComplete
            ? function () {
                try {
                    onComplete();
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._complete;
        return _this;
    }
    OperatorSubscriber.prototype.unsubscribe = function () {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
    };
    return OperatorSubscriber;
}(Subscriber));

var ObjectUnsubscribedError = createErrorClass(function (_super) {
    return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = 'ObjectUnsubscribedError';
        this.message = 'object unsubscribed';
    };
});

var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype._throwIfClosed = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
    };
    Subject.prototype.next = function (value) {
        var _this = this;
        errorContext(function () {
            var e_1, _a;
            _this._throwIfClosed();
            if (!_this.isStopped) {
                if (!_this.currentObservers) {
                    _this.currentObservers = Array.from(_this.observers);
                }
                try {
                    for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var observer = _c.value;
                        observer.next(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
    };
    Subject.prototype.error = function (err) {
        var _this = this;
        errorContext(function () {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.hasError = _this.isStopped = true;
                _this.thrownError = err;
                var observers = _this.observers;
                while (observers.length) {
                    observers.shift().error(err);
                }
            }
        });
    };
    Subject.prototype.complete = function () {
        var _this = this;
        errorContext(function () {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.isStopped = true;
                var observers = _this.observers;
                while (observers.length) {
                    observers.shift().complete();
                }
            }
        });
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject.prototype, "observed", {
        get: function () {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
    });
    Subject.prototype._trySubscribe = function (subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject.prototype._subscribe = function (subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
    };
    Subject.prototype._innerSubscribe = function (subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
            return EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription(function () {
            _this.currentObservers = null;
            arrRemove(observers, subscriber);
        });
    };
    Subject.prototype._checkFinalizedStatuses = function (subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
            subscriber.error(thrownError);
        }
        else if (isStopped) {
            subscriber.complete();
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable));
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject.prototype.error = function (err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject.prototype.complete = function () {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject;
}(Subject));

var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: false,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
            throw thrownError;
        }
        this._throwIfClosed();
        return _value;
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, (this._value = value));
    };
    return BehaviorSubject;
}(Subject));

var EMPTY = new Observable(function (subscriber) { return subscriber.complete(); });

function isScheduler(value) {
    return value && isFunction(value.schedule);
}

function last(arr) {
    return arr[arr.length - 1];
}
function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : undefined;
}
function popNumber(args, defaultValue) {
    return typeof last(args) === 'number' ? args.pop() : defaultValue;
}

var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

function isInteropObservable(input) {
    return isFunction(input[observable]);
}

function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = getSymbolIterator();

function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    reader = readableStream.getReader();
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, , 9, 10]);
                    _b.label = 2;
                case 2:
                    return [4, __await(reader.read())];
                case 3:
                    _a = _b.sent(), value = _a.value, done = _a.done;
                    if (!done) return [3, 5];
                    return [4, __await(void 0)];
                case 4: return [2, _b.sent()];
                case 5: return [4, __await(value)];
                case 6: return [4, _b.sent()];
                case 7:
                    _b.sent();
                    return [3, 2];
                case 8: return [3, 10];
                case 9:
                    reader.releaseLock();
                    return [7];
                case 10: return [2];
            }
        });
    });
}
function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

function innerFrom(input) {
    if (input instanceof Observable) {
        return input;
    }
    if (input != null) {
        if (isInteropObservable(input)) {
            return fromInteropObservable(input);
        }
        if (isArrayLike(input)) {
            return fromArrayLike(input);
        }
        if (isPromise(input)) {
            return fromPromise(input);
        }
        if (isAsyncIterable(input)) {
            return fromAsyncIterable(input);
        }
        if (isIterable(input)) {
            return fromIterable(input);
        }
        if (isReadableStreamLike(input)) {
            return fromReadableStreamLike(input);
        }
    }
    throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
    return new Observable(function (subscriber) {
        var obs = obj[observable]();
        if (isFunction(obs.subscribe)) {
            return obs.subscribe(subscriber);
        }
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    });
}
function fromArrayLike(array) {
    return new Observable(function (subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    });
}
function fromPromise(promise) {
    return new Observable(function (subscriber) {
        promise
            .then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, reportUnhandledError);
    });
}
function fromIterable(iterable) {
    return new Observable(function (subscriber) {
        var e_1, _a;
        try {
            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                var value = iterable_1_1.value;
                subscriber.next(value);
                if (subscriber.closed) {
                    return;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        subscriber.complete();
    });
}
function fromAsyncIterable(asyncIterable) {
    return new Observable(function (subscriber) {
        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
    });
}
function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function () {
        var value, e_2_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 5, 6, 11]);
                    asyncIterable_1 = __asyncValues(asyncIterable);
                    _b.label = 1;
                case 1: return [4, asyncIterable_1.next()];
                case 2:
                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                    value = asyncIterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return [2];
                    }
                    _b.label = 3;
                case 3: return [3, 1];
                case 4: return [3, 11];
                case 5:
                    e_2_1 = _b.sent();
                    e_2 = { error: e_2_1 };
                    return [3, 11];
                case 6:
                    _b.trys.push([6, , 9, 10]);
                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                    return [4, _a.call(asyncIterable_1)];
                case 7:
                    _b.sent();
                    _b.label = 8;
                case 8: return [3, 10];
                case 9:
                    if (e_2) throw e_2.error;
                    return [7];
                case 10: return [7];
                case 11:
                    subscriber.complete();
                    return [2];
            }
        });
    });
}

function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) { delay = 0; }
    if (repeat === void 0) { repeat = false; }
    var scheduleSubscription = scheduler.schedule(function () {
        work();
        if (repeat) {
            parentSubscription.add(this.schedule(null, delay));
        }
        else {
            this.unsubscribe();
        }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
        return scheduleSubscription;
    }
}

function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return operate(function (source, subscriber) {
        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));
    });
}

function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return operate(function (source, subscriber) {
        subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));
    });
}

function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

function scheduleArray(input, scheduler) {
    return new Observable(function (subscriber) {
        var i = 0;
        return scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
            }
            else {
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    this.schedule();
                }
            }
        });
    });
}

function scheduleIterable(input, scheduler) {
    return new Observable(function (subscriber) {
        var iterator$1;
        executeSchedule(subscriber, scheduler, function () {
            iterator$1 = input[iterator]();
            executeSchedule(subscriber, scheduler, function () {
                var _a;
                var value;
                var done;
                try {
                    (_a = iterator$1.next(), value = _a.value, done = _a.done);
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                }
            }, 0, true);
        });
        return function () { return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return(); };
    });
}

function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable(function (subscriber) {
        executeSchedule(subscriber, scheduler, function () {
            var iterator = input[Symbol.asyncIterator]();
            executeSchedule(subscriber, scheduler, function () {
                iterator.next().then(function (result) {
                    if (result.done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(result.value);
                    }
                });
            }, 0, true);
        });
    });
}

function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable(input)) {
            return scheduleObservable(input, scheduler);
        }
        if (isArrayLike(input)) {
            return scheduleArray(input, scheduler);
        }
        if (isPromise(input)) {
            return schedulePromise(input, scheduler);
        }
        if (isAsyncIterable(input)) {
            return scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable(input)) {
            return scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike(input)) {
            return scheduleReadableStreamLike(input, scheduler);
        }
    }
    throw createInvalidObservableTypeError(input);
}

function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

function map(project, thisArg) {
    return operate(function (source, subscriber) {
        var index = 0;
        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
            subscriber.next(project.call(thisArg, value, index++));
        }));
    });
}

var isArray = Array.isArray;
function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
    return map(function (args) { return callOrApply(fn, args); });
}

function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function () {
        if (isComplete && !buffer.length && !active) {
            subscriber.complete();
        }
    };
    var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };
    var doInnerSub = function (value) {
        active++;
        var innerComplete = false;
        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {
            {
                subscriber.next(innerValue);
            }
        }, function () {
            innerComplete = true;
        }, undefined, function () {
            if (innerComplete) {
                try {
                    active--;
                    var _loop_1 = function () {
                        var bufferedValue = buffer.shift();
                        if (innerSubScheduler) ;
                        else {
                            doInnerSub(bufferedValue);
                        }
                    };
                    while (buffer.length && active < concurrent) {
                        _loop_1();
                    }
                    checkComplete();
                }
                catch (err) {
                    subscriber.error(err);
                }
            }
        }));
    };
    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {
        isComplete = true;
        checkComplete();
    }));
    return function () {
    };
}

function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Infinity; }
    if (isFunction(resultSelector)) {
        return mergeMap(function (a, i) { return map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom(project(a, i))); }, concurrent);
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return operate(function (source, subscriber) { return mergeInternals(source, subscriber, project, concurrent); });
}

function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Infinity; }
    return mergeMap(identity, concurrent);
}

var nodeEventEmitterMethods = ['addListener', 'removeListener'];
var eventTargetMethods = ['addEventListener', 'removeEventListener'];
var jqueryMethods = ['on', 'off'];
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
    }
    var _a = __read(isEventTarget(target)
        ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })
        :
            isNodeStyleEventEmitter(target)
                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
                : isJQueryStyleEventEmitter(target)
                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
                    : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
        if (isArrayLike(target)) {
            return mergeMap(function (subTarget) { return fromEvent(subTarget, eventName, options); })(innerFrom(target));
        }
    }
    if (!add) {
        throw new TypeError('Invalid event target');
    }
    return new Observable(function (subscriber) {
        var handler = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return subscriber.next(1 < args.length ? args : args[0]);
        };
        add(handler);
        return function () { return remove(handler); };
    });
}
function toCommonHandlerRegistry(target, eventName) {
    return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };
}
function isNodeStyleEventEmitter(target) {
    return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
    return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

function merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    var sources = args;
    return !sources.length
        ?
            EMPTY
        : sources.length === 1
            ?
                innerFrom(sources[0])
            :
                mergeAll(concurrent)(from(sources, scheduler));
}

/**
 * @author Deepkolos / https://github.com/deepkolos
 */

class WorkerPool {

	constructor( pool = 4 ) {

		this.pool = pool;
		this.queue = [];
		this.workers = [];
		this.workersResolve = [];
		this.workerStatus = 0;

	}

	_initWorker( workerId ) {

		if ( ! this.workers[ workerId ] ) {

			const worker = this.workerCreator();
			worker.addEventListener( 'message', this._onMessage.bind( this, workerId ) );
			this.workers[ workerId ] = worker;

		}

	}

	_getIdleWorker() {

		for ( let i = 0; i < this.pool; i ++ )
			if ( ! ( this.workerStatus & ( 1 << i ) ) ) return i;

		return -1;

	}

	_onMessage( workerId, msg ) {

		const resolve = this.workersResolve[ workerId ];
		resolve && resolve( msg );

		if ( this.queue.length ) {

			const { resolve, msg, transfer } = this.queue.shift();
			this.workersResolve[ workerId ] = resolve;
			this.workers[ workerId ].postMessage( msg, transfer );

		} else {

			this.workerStatus ^= 1 << workerId;

		}

	}

	setWorkerCreator( workerCreator ) {

		this.workerCreator = workerCreator;

	}

	setWorkerLimit( pool ) {

		this.pool = pool;

	}

	postMessage( msg, transfer ) {

		return new Promise( ( resolve ) => {

			const workerId = this._getIdleWorker();

			if ( workerId !== -1 ) {

				this._initWorker( workerId );
				this.workerStatus |= 1 << workerId;
				this.workersResolve[ workerId ] = resolve;
				this.workers[ workerId ].postMessage( msg, transfer );

			} else {

				this.queue.push( { resolve, msg, transfer } );

			}

		} );

	}

	dispose() {

		this.workers.forEach( ( worker ) => worker.terminate() );
		this.workersResolve.length = 0;
		this.workers.length = 0;
		this.queue.length = 0;
		this.workerStatus = 0;

	}

}

const t=0,n=2,g$1=1,u=2,T$1=0,C$1=1,R=10,it=0,ct=9,yt$1=15,xt=16,wt$1=22,Ft$1=37,Ct$1=43,te$1=76,ae=83,ge=97,ue=100,we=103,Ae$1=109,In=165,Sn=166,pi=1000066e3;class Ii{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=0,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:0,descriptorBlockSize:0,versionNumber:2,colorModel:0,colorPrimaries:1,transferFunction:2,flags:0,texelBlockDimension:[0,0,0,0],bytesPlane:[0,0,0,0,0,0,0,0],samples:[]}],this.keyValue={},this.globalData=null;}}class Si{constructor(t,e,n,i){this._dataView=void 0,this._littleEndian=void 0,this._offset=void 0,this._dataView=new DataView(t.buffer,t.byteOffset+e,n),this._littleEndian=i,this._offset=0;}_nextUint8(){const t=this._dataView.getUint8(this._offset);return this._offset+=1,t}_nextUint16(){const t=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,t}_nextUint32(){const t=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,t}_nextUint64(){const t=this._dataView.getUint32(this._offset,this._littleEndian)+2**32*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,t}_nextInt32(){const t=this._dataView.getInt32(this._offset,this._littleEndian);return this._offset+=4,t}_nextUint8Array(t){const e=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._offset,t);return this._offset+=t,e}_skip(t){return this._offset+=t,this}_scan(t,e){ void 0===e&&(e=0);const n=this._offset;let i=0;for(;this._dataView.getUint8(this._offset)!==e&&i<t;)i++,this._offset++;return i<t&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+n,i)}}const Oi=[171,75,84,88,32,50,48,187,13,10,26,10];function Ti(t){return (new TextDecoder).decode(t)}function Pi(t){const e=new Uint8Array(t.buffer,t.byteOffset,Oi.length);if(e[0]!==Oi[0]||e[1]!==Oi[1]||e[2]!==Oi[2]||e[3]!==Oi[3]||e[4]!==Oi[4]||e[5]!==Oi[5]||e[6]!==Oi[6]||e[7]!==Oi[7]||e[8]!==Oi[8]||e[9]!==Oi[9]||e[10]!==Oi[10]||e[11]!==Oi[11])throw new Error("Missing KTX 2.0 identifier.");const n=new Ii,i=17*Uint32Array.BYTES_PER_ELEMENT,s=new Si(t,Oi.length,i,true);n.vkFormat=s._nextUint32(),n.typeSize=s._nextUint32(),n.pixelWidth=s._nextUint32(),n.pixelHeight=s._nextUint32(),n.pixelDepth=s._nextUint32(),n.layerCount=s._nextUint32(),n.faceCount=s._nextUint32();const a=s._nextUint32();n.supercompressionScheme=s._nextUint32();const r=s._nextUint32(),o=s._nextUint32(),l=s._nextUint32(),f=s._nextUint32(),h=s._nextUint64(),U=s._nextUint64(),c=new Si(t,Oi.length+i,3*a*8,true);for(let e=0;e<a;e++)n.levels.push({levelData:new Uint8Array(t.buffer,t.byteOffset+c._nextUint64(),c._nextUint64()),uncompressedByteLength:c._nextUint64()});const _=new Si(t,r,o,true),p={vendorId:_._skip(4)._nextUint16(),descriptorType:_._nextUint16(),versionNumber:_._nextUint16(),descriptorBlockSize:_._nextUint16(),colorModel:_._nextUint8(),colorPrimaries:_._nextUint8(),transferFunction:_._nextUint8(),flags:_._nextUint8(),texelBlockDimension:[_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8()],bytesPlane:[_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8()],samples:[]},g=(p.descriptorBlockSize/4-6)/4;for(let t=0;t<g;t++){const e={bitOffset:_._nextUint16(),bitLength:_._nextUint8(),channelType:_._nextUint8(),samplePosition:[_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8()],sampleLower:-Infinity,sampleUpper:Infinity};64&e.channelType?(e.sampleLower=_._nextInt32(),e.sampleUpper=_._nextInt32()):(e.sampleLower=_._nextUint32(),e.sampleUpper=_._nextUint32()),p.samples[t]=e;}n.dataFormatDescriptor.length=0,n.dataFormatDescriptor.push(p);const y=new Si(t,l,f,true);for(;y._offset<f;){const t=y._nextUint32(),e=y._scan(t),i=Ti(e);if(n.keyValue[i]=y._nextUint8Array(t-e.byteLength-1),i.match(/^ktx/i)){const t=Ti(n.keyValue[i]);n.keyValue[i]=t.substring(0,t.lastIndexOf("\0"));}y._skip(t%4?4-t%4:0);}if(U<=0)return n;const x=new Si(t,h,U,true),u=x._nextUint16(),b=x._nextUint16(),d=x._nextUint32(),w=x._nextUint32(),m=x._nextUint32(),D=x._nextUint32(),B=[];for(let t=0;t<a;t++)B.push({imageFlags:x._nextUint32(),rgbSliceByteOffset:x._nextUint32(),rgbSliceByteLength:x._nextUint32(),alphaSliceByteOffset:x._nextUint32(),alphaSliceByteLength:x._nextUint32()});const L=h+x._offset,v=L+d,A=v+w,k=A+m,V=new Uint8Array(t.buffer,t.byteOffset+L,d),I=new Uint8Array(t.buffer,t.byteOffset+v,w),S=new Uint8Array(t.buffer,t.byteOffset+A,m),F=new Uint8Array(t.buffer,t.byteOffset+k,D);return n.globalData={endpointCount:u,selectorCount:b,imageDescs:B,endpointsData:V,selectorsData:I,tablesData:S,extendedData:F},n}

let A$1,I,B;const g={env:{emscripten_notify_memory_growth:function(A){B=new Uint8Array(I.exports.memory.buffer);}}};class Q{init(){return A$1||(A$1="undefined"!=typeof fetch?fetch("data:application/wasm;base64,"+C).then(A=>A.arrayBuffer()).then(A=>WebAssembly.instantiate(A,g)).then(this._init):WebAssembly.instantiate(Buffer.from(C,"base64"),g).then(this._init),A$1)}_init(A){I=A.instance,g.env.emscripten_notify_memory_growth(0);}decode(A,g=0){if(!I)throw new Error("ZSTDDecoder: Await .init() before decoding.");const Q=A.byteLength,C=I.exports.malloc(Q);B.set(A,C),g=g||Number(I.exports.ZSTD_findDecompressedSize(C,Q));const E=I.exports.malloc(g),i=I.exports.ZSTD_decompress(E,g,C,Q),D=B.slice(E,E+i);return I.exports.free(C),I.exports.free(E),D}}const C="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";

const DisplayP3ColorSpace = 'display-p3';
const LinearDisplayP3ColorSpace = 'display-p3-linear';

/**
 * Loader for KTX 2.0 GPU Texture containers.
 *
 * KTX 2.0 is a container format for various GPU texture formats. The loader
 * supports Basis Universal GPU textures, which can be quickly transcoded to
 * a wide variety of GPU texture compression formats, as well as some
 * uncompressed DataTexture and Data3DTexture formats.
 *
 * References:
 * - KTX: http://github.khronos.org/KTX-Specification/
 * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor
 * - BasisU HDR: https://github.com/BinomialLLC/basis_universal/wiki/UASTC-HDR-Texture-Specification-v1.0
 */


const _taskCache$1 = new WeakMap();

let _activeLoaders = 0;

let _zstd;

class KTX2Loader extends Loader {

	constructor( manager ) {

		super( manager );

		this.transcoderPath = '';
		this.transcoderBinary = null;
		this.transcoderPending = null;

		this.workerPool = new WorkerPool();
		this.workerSourceURL = '';
		this.workerConfig = null;

		if ( typeof MSC_TRANSCODER !== 'undefined' ) {

			console.warn(

				'THREE.KTX2Loader: Please update to latest "basis_transcoder".'
				+ ' "msc_basis_transcoder" is no longer supported in three.js r125+.'

			);

		}

	}

	setTranscoderPath( path ) {

		this.transcoderPath = path;

		return this;

	}

	setWorkerLimit( num ) {

		this.workerPool.setWorkerLimit( num );

		return this;

	}

	async detectSupportAsync( renderer ) {

		this.workerConfig = {
			astcSupported: await renderer.hasFeatureAsync( 'texture-compression-astc' ),
			astcHDRSupported: false, // https://github.com/gpuweb/gpuweb/issues/3856
			etc1Supported: await renderer.hasFeatureAsync( 'texture-compression-etc1' ),
			etc2Supported: await renderer.hasFeatureAsync( 'texture-compression-etc2' ),
			dxtSupported: await renderer.hasFeatureAsync( 'texture-compression-bc' ),
			bptcSupported: await renderer.hasFeatureAsync( 'texture-compression-bptc' ),
			pvrtcSupported: await renderer.hasFeatureAsync( 'texture-compression-pvrtc' )
		};

		return this;

	}

	detectSupport( renderer ) {

		if ( renderer.isWebGPURenderer === true ) {

			this.workerConfig = {
				astcSupported: renderer.hasFeature( 'texture-compression-astc' ),
				astcHDRSupported: false, // https://github.com/gpuweb/gpuweb/issues/3856
				etc1Supported: renderer.hasFeature( 'texture-compression-etc1' ),
				etc2Supported: renderer.hasFeature( 'texture-compression-etc2' ),
				dxtSupported: renderer.hasFeature( 'texture-compression-bc' ),
				bptcSupported: renderer.hasFeature( 'texture-compression-bptc' ),
				pvrtcSupported: renderer.hasFeature( 'texture-compression-pvrtc' )
			};

		} else {

			this.workerConfig = {
				astcSupported: renderer.extensions.has( 'WEBGL_compressed_texture_astc' ),
				astcHDRSupported: renderer.extensions.has( 'WEBGL_compressed_texture_astc' )
					&& renderer.extensions.get( 'WEBGL_compressed_texture_astc' ).getSupportedProfiles().includes( 'hdr' ),
				etc1Supported: renderer.extensions.has( 'WEBGL_compressed_texture_etc1' ),
				etc2Supported: renderer.extensions.has( 'WEBGL_compressed_texture_etc' ),
				dxtSupported: renderer.extensions.has( 'WEBGL_compressed_texture_s3tc' ),
				bptcSupported: renderer.extensions.has( 'EXT_texture_compression_bptc' ),
				pvrtcSupported: renderer.extensions.has( 'WEBGL_compressed_texture_pvrtc' )
					|| renderer.extensions.has( 'WEBKIT_WEBGL_compressed_texture_pvrtc' )
			};

		}

		return this;

	}

	init() {

		if ( ! this.transcoderPending ) {

			// Load transcoder wrapper.
			const jsLoader = new FileLoader( this.manager );
			jsLoader.setPath( this.transcoderPath );
			jsLoader.setWithCredentials( this.withCredentials );
			const jsContent = jsLoader.loadAsync( 'basis_transcoder.js' );

			// Load transcoder WASM binary.
			const binaryLoader = new FileLoader( this.manager );
			binaryLoader.setPath( this.transcoderPath );
			binaryLoader.setResponseType( 'arraybuffer' );
			binaryLoader.setWithCredentials( this.withCredentials );
			const binaryContent = binaryLoader.loadAsync( 'basis_transcoder.wasm' );

			this.transcoderPending = Promise.all( [ jsContent, binaryContent ] )
				.then( ( [ jsContent, binaryContent ] ) => {

					const fn = KTX2Loader.BasisWorker.toString();

					const body = [
						'/* constants */',
						'let _EngineFormat = ' + JSON.stringify( KTX2Loader.EngineFormat ),
						'let _EngineType = ' + JSON.stringify( KTX2Loader.EngineType ),
						'let _TranscoderFormat = ' + JSON.stringify( KTX2Loader.TranscoderFormat ),
						'let _BasisFormat = ' + JSON.stringify( KTX2Loader.BasisFormat ),
						'/* basis_transcoder.js */',
						jsContent,
						'/* worker */',
						fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
					].join( '\n' );

					this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );
					this.transcoderBinary = binaryContent;

					this.workerPool.setWorkerCreator( () => {

						const worker = new Worker( this.workerSourceURL );
						const transcoderBinary = this.transcoderBinary.slice( 0 );

						worker.postMessage( { type: 'init', config: this.workerConfig, transcoderBinary }, [ transcoderBinary ] );

						return worker;

					} );

				} );

			if ( _activeLoaders > 0 ) {

				// Each instance loads a transcoder and allocates workers, increasing network and memory cost.

				console.warn(

					'THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.'
					+ ' Use a single KTX2Loader instance, or call .dispose() on old instances.'

				);

			}

			_activeLoaders ++;

		}

		return this.transcoderPending;

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.workerConfig === null ) {

			throw new Error( 'THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.' );

		}

		const loader = new FileLoader( this.manager );

		loader.setResponseType( 'arraybuffer' );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, ( buffer ) => {

			this.parse( buffer, onLoad, onError );

		}, onProgress, onError );

	}

	parse( buffer, onLoad, onError ) {

		if ( this.workerConfig === null ) {

			throw new Error( 'THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.' );

		}

		// Check for an existing task using this buffer. A transferred buffer cannot be transferred
		// again from this thread.
		if ( _taskCache$1.has( buffer ) ) {

			const cachedTask = _taskCache$1.get( buffer );

			return cachedTask.promise.then( onLoad ).catch( onError );

		}

		this._createTexture( buffer )
			.then( ( texture ) => onLoad ? onLoad( texture ) : null )
			.catch( onError );

	}

	_createTextureFrom( transcodeResult, container ) {

		const { type: messageType, error, data: { faces, width, height, format, type, dfdFlags } } = transcodeResult;

		if ( messageType === 'error' ) return Promise.reject( error );

		let texture;

		if ( container.faceCount === 6 ) {

			texture = new CompressedCubeTexture( faces, format, type );

		} else {

			const mipmaps = faces[ 0 ].mipmaps;

			texture = container.layerCount > 1
				? new CompressedArrayTexture( mipmaps, width, height, container.layerCount, format, type )
				: new CompressedTexture( mipmaps, width, height, format, type );

		}

		texture.minFilter = faces[ 0 ].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
		texture.magFilter = LinearFilter;
		texture.generateMipmaps = false;

		texture.needsUpdate = true;
		texture.colorSpace = parseColorSpace( container );
		texture.premultiplyAlpha = !! ( dfdFlags & g$1 );

		return texture;

	}

	/**
	 * @param {ArrayBuffer} buffer
	 * @param {?Object} config
	 * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
	 */
	async _createTexture( buffer, config = {} ) {

		const container = Pi( new Uint8Array( buffer ) );

		// Basis UASTC HDR is a subset of ASTC, which can be transcoded efficiently
		// to BC6H. To detect whether a KTX2 file uses Basis UASTC HDR, or default
		// ASTC, inspect the DFD color model.
		//
		// Source: https://github.com/BinomialLLC/basis_universal/issues/381
		const isBasisHDR = container.vkFormat === pi
			&& container.dataFormatDescriptor[ 0 ].colorModel === 0xA7;

		// If the device supports ASTC, Basis UASTC HDR requires no transcoder.
		const needsTranscoder = container.vkFormat === it
			|| isBasisHDR && ! this.workerConfig.astcHDRSupported;

		if ( ! needsTranscoder ) {

			return createRawTexture( container );

		}

		//
		const taskConfig = config;
		const texturePending = this.init().then( () => {

			return this.workerPool.postMessage( { type: 'transcode', buffer, taskConfig: taskConfig }, [ buffer ] );

		} ).then( ( e ) => this._createTextureFrom( e.data, container ) );

		// Cache the task result.
		_taskCache$1.set( buffer, { promise: texturePending } );

		return texturePending;

	}

	dispose() {

		this.workerPool.dispose();
		if ( this.workerSourceURL ) URL.revokeObjectURL( this.workerSourceURL );

		_activeLoaders --;

		return this;

	}

}


/* CONSTANTS */

KTX2Loader.BasisFormat = {
	ETC1S: 0,
	UASTC: 1,
	UASTC_HDR: 2,
};

// Source: https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture_test/index.html
KTX2Loader.TranscoderFormat = {
	ETC1: 0,
	ETC2: 1,
	BC1: 2,
	BC3: 3,
	BC4: 4,
	BC5: 5,
	BC7_M6_OPAQUE_ONLY: 6,
	BC7_M5: 7,
	PVRTC1_4_RGB: 8,
	PVRTC1_4_RGBA: 9,
	ASTC_4x4: 10,
	ATC_RGB: 11,
	ATC_RGBA_INTERPOLATED_ALPHA: 12,
	RGBA32: 13,
	RGB565: 14,
	BGR565: 15,
	RGBA4444: 16,
	BC6H: 22,
	RGB_HALF: 24,
	RGBA_HALF: 25,
};

KTX2Loader.EngineFormat = {
	RGBAFormat: RGBAFormat,
	RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
	RGB_BPTC_UNSIGNED_Format: RGB_BPTC_UNSIGNED_Format,
	RGBA_BPTC_Format: RGBA_BPTC_Format,
	RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,
	RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
	RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
	RGB_ETC1_Format: RGB_ETC1_Format,
	RGB_ETC2_Format: RGB_ETC2_Format,
	RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
	RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format,
};

KTX2Loader.EngineType = {
	UnsignedByteType: UnsignedByteType,
	HalfFloatType: HalfFloatType,
	FloatType: FloatType,
};

/* WEB WORKER */

KTX2Loader.BasisWorker = function () {

	let config;
	let transcoderPending;
	let BasisModule;

	const EngineFormat = _EngineFormat; // eslint-disable-line no-undef
	const EngineType = _EngineType; // eslint-disable-line no-undef
	const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef
	const BasisFormat = _BasisFormat; // eslint-disable-line no-undef

	self.addEventListener( 'message', function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				config = message.config;
				init( message.transcoderBinary );
				break;

			case 'transcode':
				transcoderPending.then( () => {

					try {

						const { faces, buffers, width, height, hasAlpha, format, type, dfdFlags } = transcode( message.buffer );

						self.postMessage( { type: 'transcode', id: message.id, data: { faces, width, height, hasAlpha, format, type, dfdFlags } }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					}

				} );
				break;

		}

	} );

	function init( wasmBinary ) {

		transcoderPending = new Promise( ( resolve ) => {

			BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
			BASIS( BasisModule ); // eslint-disable-line no-undef

		} ).then( () => {

			BasisModule.initializeBasis();

			if ( BasisModule.KTX2File === undefined ) {

				console.warn( 'THREE.KTX2Loader: Please update Basis Universal transcoder.' );

			}

		} );

	}

	function transcode( buffer ) {

		const ktx2File = new BasisModule.KTX2File( new Uint8Array( buffer ) );

		function cleanup() {

			ktx2File.close();
			ktx2File.delete();

		}

		if ( ! ktx2File.isValid() ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader:	Invalid or unsupported .ktx2 file' );

		}

		let basisFormat;

		if ( ktx2File.isUASTC() ) {

			basisFormat = BasisFormat.UASTC;

		} else if ( ktx2File.isETC1S() ) {

			basisFormat = BasisFormat.ETC1S;

		} else if ( ktx2File.isHDR() ) {

			basisFormat = BasisFormat.UASTC_HDR;

		} else {

			throw new Error( 'THREE.KTX2Loader: Unknown Basis encoding' );

		}

		const width = ktx2File.getWidth();
		const height = ktx2File.getHeight();
		const layerCount = ktx2File.getLayers() || 1;
		const levelCount = ktx2File.getLevels();
		const faceCount = ktx2File.getFaces();
		const hasAlpha = ktx2File.getHasAlpha();
		const dfdFlags = ktx2File.getDFDFlags();

		const { transcoderFormat, engineFormat, engineType } = getTranscoderFormat( basisFormat, width, height, hasAlpha );

		if ( ! width || ! height || ! levelCount ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader:	Invalid texture' );

		}

		if ( ! ktx2File.startTranscoding() ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader: .startTranscoding failed' );

		}

		const faces = [];
		const buffers = [];

		for ( let face = 0; face < faceCount; face ++ ) {

			const mipmaps = [];

			for ( let mip = 0; mip < levelCount; mip ++ ) {

				const layerMips = [];

				let mipWidth, mipHeight;

				for ( let layer = 0; layer < layerCount; layer ++ ) {

					const levelInfo = ktx2File.getImageLevelInfo( mip, layer, face );

					if ( face === 0 && mip === 0 && layer === 0 && ( levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0 ) ) {

						console.warn( 'THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.' );

					}

					if ( levelCount > 1 ) {

						mipWidth = levelInfo.origWidth;
						mipHeight = levelInfo.origHeight;

					} else {

						// Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with
						// mipmaps must use multiple-of-four dimensions, for some texture formats and APIs.
						// See mrdoob/three.js#25908.
						mipWidth = levelInfo.width;
						mipHeight = levelInfo.height;

					}

					let dst = new Uint8Array( ktx2File.getImageTranscodedSizeInBytes( mip, layer, 0, transcoderFormat ) );
					const status = ktx2File.transcodeImage( dst, mip, layer, face, transcoderFormat, 0, -1, -1 );

					if ( engineType === EngineType.HalfFloatType ) {

						dst = new Uint16Array( dst.buffer, dst.byteOffset, dst.byteLength / Uint16Array.BYTES_PER_ELEMENT );

					}

					if ( ! status ) {

						cleanup();
						throw new Error( 'THREE.KTX2Loader: .transcodeImage failed.' );

					}

					layerMips.push( dst );

				}

				const mipData = concat( layerMips );

				mipmaps.push( { data: mipData, width: mipWidth, height: mipHeight } );
				buffers.push( mipData.buffer );

			}

			faces.push( { mipmaps, width, height, format: engineFormat, type: engineType } );

		}

		cleanup();

		return { faces, buffers, width, height, hasAlpha, dfdFlags, format: engineFormat, type: engineType };

	}

	//

	// Optimal choice of a transcoder target format depends on the Basis format (ETC1S, UASTC, or
	// UASTC HDR), device capabilities, and texture dimensions. The list below ranks the formats
	// separately for each format. Currently, priority is assigned based on:
	//
	//   high quality > low quality > uncompressed
	//
	// Prioritization may be revisited, or exposed for configuration, in the future.
	//
	// Reference: https://github.com/KhronosGroup/3D-Formats-Guidelines/blob/main/KTXDeveloperGuide.md
	const FORMAT_OPTIONS = [
		{
			if: 'astcSupported',
			basisFormat: [ BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4 ],
			engineFormat: [ EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: Infinity,
			priorityUASTC: 1,
			needsPowerOfTwo: false,
		},
		{
			if: 'bptcSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5 ],
			engineFormat: [ EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: 3,
			priorityUASTC: 2,
			needsPowerOfTwo: false,
		},
		{
			if: 'dxtSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.BC1, TranscoderFormat.BC3 ],
			engineFormat: [ EngineFormat.RGBA_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: 4,
			priorityUASTC: 5,
			needsPowerOfTwo: false,
		},
		{
			if: 'etc2Supported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.ETC1, TranscoderFormat.ETC2 ],
			engineFormat: [ EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: 1,
			priorityUASTC: 3,
			needsPowerOfTwo: false,
		},
		{
			if: 'etc1Supported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.ETC1 ],
			engineFormat: [ EngineFormat.RGB_ETC1_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: 2,
			priorityUASTC: 4,
			needsPowerOfTwo: false,
		},
		{
			if: 'pvrtcSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA ],
			engineFormat: [ EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: 5,
			priorityUASTC: 6,
			needsPowerOfTwo: true,
		},
		{
			if: 'bptcSupported',
			basisFormat: [ BasisFormat.UASTC_HDR ],
			transcoderFormat: [ TranscoderFormat.BC6H ],
			engineFormat: [ EngineFormat.RGB_BPTC_UNSIGNED_Format ],
			engineType: [ EngineType.HalfFloatType ],
			priorityHDR: 1,
			needsPowerOfTwo: false,
		},

		// Uncompressed fallbacks.

		{
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.RGBA32, TranscoderFormat.RGBA32 ],
			engineFormat: [ EngineFormat.RGBAFormat, EngineFormat.RGBAFormat ],
			engineType: [ EngineType.UnsignedByteType, EngineType.UnsignedByteType ],
			priorityETC1S: 100,
			priorityUASTC: 100,
			needsPowerOfTwo: false,
		},
		{
			basisFormat: [ BasisFormat.UASTC_HDR ],
			transcoderFormat: [ TranscoderFormat.RGBA_HALF ],
			engineFormat: [ EngineFormat.RGBAFormat ],
			engineType: [ EngineType.HalfFloatType ],
			priorityHDR: 100,
			needsPowerOfTwo: false,
		}
	];

	const OPTIONS = {
		// TODO: For ETC1S we intentionally sort by _UASTC_ priority, preserving
		// a historical accident shown to avoid performance pitfalls for Linux with
		// Firefox & AMD GPU (RadeonSI). Further work needed.
		// See https://github.com/mrdoob/three.js/pull/29730.
		[ BasisFormat.ETC1S ]: FORMAT_OPTIONS
			.filter( ( opt ) => opt.basisFormat.includes( BasisFormat.ETC1S ) )
			.sort( ( a, b ) => a.priorityUASTC - b.priorityUASTC ),

		[ BasisFormat.UASTC ]: FORMAT_OPTIONS
			.filter( ( opt ) => opt.basisFormat.includes( BasisFormat.UASTC ) )
			.sort( ( a, b ) => a.priorityUASTC - b.priorityUASTC ),

		[ BasisFormat.UASTC_HDR ]: FORMAT_OPTIONS
			.filter( ( opt ) => opt.basisFormat.includes( BasisFormat.UASTC_HDR ) )
			.sort( ( a, b ) => a.priorityHDR - b.priorityHDR ),
	};

	function getTranscoderFormat( basisFormat, width, height, hasAlpha ) {

		const options = OPTIONS[ basisFormat ];

		for ( let i = 0; i < options.length; i ++ ) {

			const opt = options[ i ];

			if ( opt.if && ! config[ opt.if ] ) continue;
			if ( ! opt.basisFormat.includes( basisFormat ) ) continue;
			if ( hasAlpha && opt.transcoderFormat.length < 2 ) continue;
			if ( opt.needsPowerOfTwo && ! ( isPowerOfTwo( width ) && isPowerOfTwo( height ) ) ) continue;

			const transcoderFormat = opt.transcoderFormat[ hasAlpha ? 1 : 0 ];
			const engineFormat = opt.engineFormat[ hasAlpha ? 1 : 0 ];
			const engineType = opt.engineType[ 0 ];

			return { transcoderFormat, engineFormat, engineType };

		}

		throw new Error( 'THREE.KTX2Loader: Failed to identify transcoding target.' );

	}

	function isPowerOfTwo( value ) {

		if ( value <= 2 ) return true;

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

	/**
	 * Concatenates N byte arrays.
	 *
	 * @param {Uint8Array[]} arrays
	 * @return {Uint8Array}
	 */
	function concat( arrays ) {

		if ( arrays.length === 1 ) return arrays[ 0 ];

		let totalByteLength = 0;

		for ( let i = 0; i < arrays.length; i ++ ) {

			const array = arrays[ i ];
			totalByteLength += array.byteLength;

		}

		const result = new Uint8Array( totalByteLength );

		let byteOffset = 0;

		for ( let i = 0; i < arrays.length; i ++ ) {

			const array = arrays[ i ];
			result.set( array, byteOffset );

			byteOffset += array.byteLength;

		}

		return result;

	}

};

// Parsing for non-Basis textures. These textures may have supercompression
// like Zstd, but they do not require transcoding.

const UNCOMPRESSED_FORMATS = new Set( [ RGBAFormat, RGFormat, RedFormat ] );

const FORMAT_MAP = {

	[ Ae$1 ]: RGBAFormat,
	[ ge ]: RGBAFormat,
	[ Ft$1 ]: RGBAFormat,
	[ Ct$1 ]: RGBAFormat,

	[ we ]: RGFormat,
	[ ae ]: RGFormat,
	[ xt ]: RGFormat,
	[ wt$1 ]: RGFormat,

	[ ue ]: RedFormat,
	[ te$1 ]: RedFormat,
	[ yt$1 ]: RedFormat,
	[ ct ]: RedFormat,

	[ pi ]: RGBA_ASTC_4x4_Format,
	[ Sn ]: RGBA_ASTC_6x6_Format,
	[ In ]: RGBA_ASTC_6x6_Format,

};

const TYPE_MAP = {

	[ Ae$1 ]: FloatType,
	[ ge ]: HalfFloatType,
	[ Ft$1 ]: UnsignedByteType,
	[ Ct$1 ]: UnsignedByteType,

	[ we ]: FloatType,
	[ ae ]: HalfFloatType,
	[ xt ]: UnsignedByteType,
	[ wt$1 ]: UnsignedByteType,

	[ ue ]: FloatType,
	[ te$1 ]: HalfFloatType,
	[ yt$1 ]: UnsignedByteType,
	[ ct ]: UnsignedByteType,

	[ pi ]: HalfFloatType,
	[ Sn ]: UnsignedByteType,
	[ In ]: UnsignedByteType,

};

async function createRawTexture( container ) {

	const { vkFormat } = container;

	if ( FORMAT_MAP[ vkFormat ] === undefined ) {

		throw new Error( 'THREE.KTX2Loader: Unsupported vkFormat.' );

	}

	//

	let zstd;

	if ( container.supercompressionScheme === n ) {

		if ( ! _zstd ) {

			_zstd = new Promise( async ( resolve ) => {

				const zstd = new Q();
				await zstd.init();
				resolve( zstd );

			} );

		}

		zstd = await _zstd;

	}

	//

	const mipmaps = [];


	for ( let levelIndex = 0; levelIndex < container.levels.length; levelIndex ++ ) {

		const levelWidth = Math.max( 1, container.pixelWidth >> levelIndex );
		const levelHeight = Math.max( 1, container.pixelHeight >> levelIndex );
		const levelDepth = container.pixelDepth ? Math.max( 1, container.pixelDepth >> levelIndex ) : 0;

		const level = container.levels[ levelIndex ];

		let levelData;

		if ( container.supercompressionScheme === t ) {

			levelData = level.levelData;

		} else if ( container.supercompressionScheme === n ) {

			levelData = zstd.decode( level.levelData, level.uncompressedByteLength );

		} else {

			throw new Error( 'THREE.KTX2Loader: Unsupported supercompressionScheme.' );

		}

		let data;

		if ( TYPE_MAP[ vkFormat ] === FloatType ) {

			data = new Float32Array(

				levelData.buffer,
				levelData.byteOffset,
				levelData.byteLength / Float32Array.BYTES_PER_ELEMENT

			);

		} else if ( TYPE_MAP[ vkFormat ] === HalfFloatType ) {

			data = new Uint16Array(

				levelData.buffer,
				levelData.byteOffset,
				levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT

			);

		} else {

			data = levelData;

		}

		mipmaps.push( {

			data: data,
			width: levelWidth,
			height: levelHeight,
			depth: levelDepth,

		} );

	}

	let texture;

	if ( UNCOMPRESSED_FORMATS.has( FORMAT_MAP[ vkFormat ] ) ) {

		texture = container.pixelDepth === 0
			? new DataTexture( mipmaps[ 0 ].data, container.pixelWidth, container.pixelHeight )
			: new Data3DTexture( mipmaps[ 0 ].data, container.pixelWidth, container.pixelHeight, container.pixelDepth );

	} else {

		if ( container.pixelDepth > 0 ) throw new Error( 'THREE.KTX2Loader: Unsupported pixelDepth.' );

		texture = new CompressedTexture( mipmaps, container.pixelWidth, container.pixelHeight );

		texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
		texture.magFilter = LinearFilter;

	}

	texture.mipmaps = mipmaps;

	texture.type = TYPE_MAP[ vkFormat ];
	texture.format = FORMAT_MAP[ vkFormat ];
	texture.colorSpace = parseColorSpace( container );
	texture.needsUpdate = true;

	//

	return Promise.resolve( texture );

}

function parseColorSpace( container ) {

	const dfd = container.dataFormatDescriptor[ 0 ];

	if ( dfd.colorPrimaries === C$1 ) {

		return dfd.transferFunction === u ? SRGBColorSpace : LinearSRGBColorSpace;

	} else if ( dfd.colorPrimaries === R ) {

		return dfd.transferFunction === u ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;

	} else if ( dfd.colorPrimaries === T$1 ) {

		return NoColorSpace;

	} else {

		console.warn( `THREE.KTX2Loader: Unsupported color primaries, "${ dfd.colorPrimaries }"` );
		return NoColorSpace;

	}

}

class PDBLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	// Based on CanvasMol PDB parser

	parse( text ) {

		function trim( text ) {

			return text.replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' );

		}

		function capitalize( text ) {

			return text.charAt( 0 ).toUpperCase() + text.slice( 1 ).toLowerCase();

		}

		function hash( s, e ) {

			return 's' + Math.min( s, e ) + 'e' + Math.max( s, e );

		}

		function parseBond( start, length, satom, i ) {

			const eatom = parseInt( lines[ i ].slice( start, start + length ) );

			if ( eatom ) {

				const h = hash( satom, eatom );

				if ( _bhash[ h ] === undefined ) {

					_bonds.push( [ satom - 1, eatom - 1, 1 ] );
					_bhash[ h ] = _bonds.length - 1;

				}

			}

		}

		function buildGeometry() {

			const build = {
				geometryAtoms: new BufferGeometry(),
				geometryBonds: new BufferGeometry(),
				json: {
					atoms: atoms
				}
			};

			const geometryAtoms = build.geometryAtoms;
			const geometryBonds = build.geometryBonds;

			const verticesAtoms = [];
			const colorsAtoms = [];
			const verticesBonds = [];

			// atoms

			const c = new Color();

			for ( let i = 0, l = atoms.length; i < l; i ++ ) {

				const atom = atoms[ i ];

				const x = atom[ 0 ];
				const y = atom[ 1 ];
				const z = atom[ 2 ];

				verticesAtoms.push( x, y, z );

				const r = atom[ 3 ][ 0 ] / 255;
				const g = atom[ 3 ][ 1 ] / 255;
				const b = atom[ 3 ][ 2 ] / 255;

				c.setRGB( r, g, b, SRGBColorSpace );

				colorsAtoms.push( c.r, c.g, c.b );

			}

			// bonds

			for ( let i = 0, l = _bonds.length; i < l; i ++ ) {

				const bond = _bonds[ i ];

				const start = bond[ 0 ];
				const end = bond[ 1 ];

				const startAtom = _atomMap[ start ];
				const endAtom = _atomMap[ end ];

				let x = startAtom[ 0 ];
				let y = startAtom[ 1 ];
				let z = startAtom[ 2 ];

				verticesBonds.push( x, y, z );

				x = endAtom[ 0 ];
				y = endAtom[ 1 ];
				z = endAtom[ 2 ];

				verticesBonds.push( x, y, z );

			}

			// build geometry

			geometryAtoms.setAttribute( 'position', new Float32BufferAttribute( verticesAtoms, 3 ) );
			geometryAtoms.setAttribute( 'color', new Float32BufferAttribute( colorsAtoms, 3 ) );

			geometryBonds.setAttribute( 'position', new Float32BufferAttribute( verticesBonds, 3 ) );

			return build;

		}

		const CPK = { h: [ 255, 255, 255 ], he: [ 217, 255, 255 ], li: [ 204, 128, 255 ], be: [ 194, 255, 0 ], b: [ 255, 181, 181 ], c: [ 144, 144, 144 ], n: [ 48, 80, 248 ], o: [ 255, 13, 13 ], f: [ 144, 224, 80 ], ne: [ 179, 227, 245 ], na: [ 171, 92, 242 ], mg: [ 138, 255, 0 ], al: [ 191, 166, 166 ], si: [ 240, 200, 160 ], p: [ 255, 128, 0 ], s: [ 255, 255, 48 ], cl: [ 31, 240, 31 ], ar: [ 128, 209, 227 ], k: [ 143, 64, 212 ], ca: [ 61, 255, 0 ], sc: [ 230, 230, 230 ], ti: [ 191, 194, 199 ], v: [ 166, 166, 171 ], cr: [ 138, 153, 199 ], mn: [ 156, 122, 199 ], fe: [ 224, 102, 51 ], co: [ 240, 144, 160 ], ni: [ 80, 208, 80 ], cu: [ 200, 128, 51 ], zn: [ 125, 128, 176 ], ga: [ 194, 143, 143 ], ge: [ 102, 143, 143 ], as: [ 189, 128, 227 ], se: [ 255, 161, 0 ], br: [ 166, 41, 41 ], kr: [ 92, 184, 209 ], rb: [ 112, 46, 176 ], sr: [ 0, 255, 0 ], y: [ 148, 255, 255 ], zr: [ 148, 224, 224 ], nb: [ 115, 194, 201 ], mo: [ 84, 181, 181 ], tc: [ 59, 158, 158 ], ru: [ 36, 143, 143 ], rh: [ 10, 125, 140 ], pd: [ 0, 105, 133 ], ag: [ 192, 192, 192 ], cd: [ 255, 217, 143 ], in: [ 166, 117, 115 ], sn: [ 102, 128, 128 ], sb: [ 158, 99, 181 ], te: [ 212, 122, 0 ], i: [ 148, 0, 148 ], xe: [ 66, 158, 176 ], cs: [ 87, 23, 143 ], ba: [ 0, 201, 0 ], la: [ 112, 212, 255 ], ce: [ 255, 255, 199 ], pr: [ 217, 255, 199 ], nd: [ 199, 255, 199 ], pm: [ 163, 255, 199 ], sm: [ 143, 255, 199 ], eu: [ 97, 255, 199 ], gd: [ 69, 255, 199 ], tb: [ 48, 255, 199 ], dy: [ 31, 255, 199 ], ho: [ 0, 255, 156 ], er: [ 0, 230, 117 ], tm: [ 0, 212, 82 ], yb: [ 0, 191, 56 ], lu: [ 0, 171, 36 ], hf: [ 77, 194, 255 ], ta: [ 77, 166, 255 ], w: [ 33, 148, 214 ], re: [ 38, 125, 171 ], os: [ 38, 102, 150 ], ir: [ 23, 84, 135 ], pt: [ 208, 208, 224 ], au: [ 255, 209, 35 ], hg: [ 184, 184, 208 ], tl: [ 166, 84, 77 ], pb: [ 87, 89, 97 ], bi: [ 158, 79, 181 ], po: [ 171, 92, 0 ], at: [ 117, 79, 69 ], rn: [ 66, 130, 150 ], fr: [ 66, 0, 102 ], ra: [ 0, 125, 0 ], ac: [ 112, 171, 250 ], th: [ 0, 186, 255 ], pa: [ 0, 161, 255 ], u: [ 0, 143, 255 ], np: [ 0, 128, 255 ], pu: [ 0, 107, 255 ], am: [ 84, 92, 242 ], cm: [ 120, 92, 227 ], bk: [ 138, 79, 227 ], cf: [ 161, 54, 212 ], es: [ 179, 31, 212 ], fm: [ 179, 31, 186 ], md: [ 179, 13, 166 ], no: [ 189, 13, 135 ], lr: [ 199, 0, 102 ], rf: [ 204, 0, 89 ], db: [ 209, 0, 79 ], sg: [ 217, 0, 69 ], bh: [ 224, 0, 56 ], hs: [ 230, 0, 46 ], mt: [ 235, 0, 38 ], ds: [ 235, 0, 38 ], rg: [ 235, 0, 38 ], cn: [ 235, 0, 38 ], uut: [ 235, 0, 38 ], uuq: [ 235, 0, 38 ], uup: [ 235, 0, 38 ], uuh: [ 235, 0, 38 ], uus: [ 235, 0, 38 ], uuo: [ 235, 0, 38 ] };

		const atoms = [];

		const _bonds = [];
		const _bhash = {};
		const _atomMap = {};

		// parse

		const lines = text.split( '\n' );

		for ( let i = 0, l = lines.length; i < l; i ++ ) {

			if ( lines[ i ].slice( 0, 4 ) === 'ATOM' || lines[ i ].slice( 0, 6 ) === 'HETATM' ) {

				const x = parseFloat( lines[ i ].slice( 30, 37 ) );
				const y = parseFloat( lines[ i ].slice( 38, 45 ) );
				const z = parseFloat( lines[ i ].slice( 46, 53 ) );
				const index = parseInt( lines[ i ].slice( 6, 11 ) ) - 1;

				let e = trim( lines[ i ].slice( 76, 78 ) ).toLowerCase();

				if ( e === '' ) {

					e = trim( lines[ i ].slice( 12, 14 ) ).toLowerCase();

				}

				const atomData = [ x, y, z, CPK[ e ], capitalize( e ) ];

				atoms.push( atomData );
				_atomMap[ index ] = atomData;

			} else if ( lines[ i ].slice( 0, 6 ) === 'CONECT' ) {

				const satom = parseInt( lines[ i ].slice( 6, 11 ) );

				parseBond( 11, 5, satom, i );
				parseBond( 16, 5, satom, i );
				parseBond( 21, 5, satom, i );
				parseBond( 26, 5, satom, i );

			}

		}

		// build and return geometry

		return buildGeometry();

	}

}

class PCDLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.littleEndian = true;

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( data ) {

			try {

				onLoad( scope.parse( data ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( data ) {

		// from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js

		function decompressLZF( inData, outLength ) {

			const inLength = inData.length;
			const outData = new Uint8Array( outLength );
			let inPtr = 0;
			let outPtr = 0;
			let ctrl;
			let len;
			let ref;
			do {

				ctrl = inData[ inPtr ++ ];
				if ( ctrl < ( 1 << 5 ) ) {

					ctrl ++;
					if ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );
					if ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );
					do {

						outData[ outPtr ++ ] = inData[ inPtr ++ ];

					} while ( -- ctrl );

				} else {

					len = ctrl >> 5;
					ref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;
					if ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );
					if ( len === 7 ) {

						len += inData[ inPtr ++ ];
						if ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );

					}

					ref -= inData[ inPtr ++ ];
					if ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );
					if ( ref < 0 ) throw new Error( 'Invalid compressed data' );
					if ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );
					do {

						outData[ outPtr ++ ] = outData[ ref ++ ];

					} while ( -- len + 2 );

				}

			} while ( inPtr < inLength );

			return outData;

		}

		function parseHeader( data ) {

			const PCDheader = {};
			const result1 = data.search( /[\r\n]DATA\s(\S*)\s/i );
			const result2 = /[\r\n]DATA\s(\S*)\s/i.exec( data.slice( result1 - 1 ) );

			PCDheader.data = result2[ 1 ];
			PCDheader.headerLen = result2[ 0 ].length + result1;
			PCDheader.str = data.slice( 0, PCDheader.headerLen );

			// remove comments

			PCDheader.str = PCDheader.str.replace( /#.*/gi, '' );

			// parse

			PCDheader.version = /^VERSION (.*)/im.exec( PCDheader.str );
			PCDheader.fields = /^FIELDS (.*)/im.exec( PCDheader.str );
			PCDheader.size = /^SIZE (.*)/im.exec( PCDheader.str );
			PCDheader.type = /^TYPE (.*)/im.exec( PCDheader.str );
			PCDheader.count = /^COUNT (.*)/im.exec( PCDheader.str );
			PCDheader.width = /^WIDTH (.*)/im.exec( PCDheader.str );
			PCDheader.height = /^HEIGHT (.*)/im.exec( PCDheader.str );
			PCDheader.viewpoint = /^VIEWPOINT (.*)/im.exec( PCDheader.str );
			PCDheader.points = /^POINTS (.*)/im.exec( PCDheader.str );

			// evaluate

			if ( PCDheader.version !== null )
				PCDheader.version = parseFloat( PCDheader.version[ 1 ] );

			PCDheader.fields = ( PCDheader.fields !== null ) ? PCDheader.fields[ 1 ].split( ' ' ) : [];

			if ( PCDheader.type !== null )
				PCDheader.type = PCDheader.type[ 1 ].split( ' ' );

			if ( PCDheader.width !== null )
				PCDheader.width = parseInt( PCDheader.width[ 1 ] );

			if ( PCDheader.height !== null )
				PCDheader.height = parseInt( PCDheader.height[ 1 ] );

			if ( PCDheader.viewpoint !== null )
				PCDheader.viewpoint = PCDheader.viewpoint[ 1 ];

			if ( PCDheader.points !== null )
				PCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );

			if ( PCDheader.points === null )
				PCDheader.points = PCDheader.width * PCDheader.height;

			if ( PCDheader.size !== null ) {

				PCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {

					return parseInt( x, 10 );

				} );

			}

			if ( PCDheader.count !== null ) {

				PCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {

					return parseInt( x, 10 );

				} );

			} else {

				PCDheader.count = [];

				for ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) {

					PCDheader.count.push( 1 );

				}

			}

			PCDheader.offset = {};

			let sizeSum = 0;

			for ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) {

				if ( PCDheader.data === 'ascii' ) {

					PCDheader.offset[ PCDheader.fields[ i ] ] = i;

				} else {

					PCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;
					sizeSum += PCDheader.size[ i ] * PCDheader.count[ i ];

				}

			}

			// for binary only

			PCDheader.rowSize = sizeSum;

			return PCDheader;

		}

		const textData = new TextDecoder().decode( data );

		// parse header (always ascii format)

		const PCDheader = parseHeader( textData );

		// parse data

		const position = [];
		const normal = [];
		const color = [];
		const intensity = [];
		const label = [];

		const c = new Color();

		// ascii

		if ( PCDheader.data === 'ascii' ) {

			const offset = PCDheader.offset;
			const pcdData = textData.slice( PCDheader.headerLen );
			const lines = pcdData.split( '\n' );

			for ( let i = 0, l = lines.length; i < l; i ++ ) {

				if ( lines[ i ] === '' ) continue;

				const line = lines[ i ].split( ' ' );

				if ( offset.x !== undefined ) {

					position.push( parseFloat( line[ offset.x ] ) );
					position.push( parseFloat( line[ offset.y ] ) );
					position.push( parseFloat( line[ offset.z ] ) );

				}

				if ( offset.rgb !== undefined ) {

					const rgb_field_index = PCDheader.fields.findIndex( ( field ) => field === 'rgb' );
					const rgb_type = PCDheader.type[ rgb_field_index ];

					const float = parseFloat( line[ offset.rgb ] );
					let rgb = float;

					if ( rgb_type === 'F' ) {

						// treat float values as int
						// https://github.com/daavoo/pyntcloud/pull/204/commits/7b4205e64d5ed09abe708b2e91b615690c24d518
						const farr = new Float32Array( 1 );
						farr[ 0 ] = float;
						rgb = new Int32Array( farr.buffer )[ 0 ];

					}

					const r = ( ( rgb >> 16 ) & 0x0000ff ) / 255;
					const g = ( ( rgb >> 8 ) & 0x0000ff ) / 255;
					const b = ( ( rgb >> 0 ) & 0x0000ff ) / 255;

					c.setRGB( r, g, b, SRGBColorSpace );

					color.push( c.r, c.g, c.b );

				}

				if ( offset.normal_x !== undefined ) {

					normal.push( parseFloat( line[ offset.normal_x ] ) );
					normal.push( parseFloat( line[ offset.normal_y ] ) );
					normal.push( parseFloat( line[ offset.normal_z ] ) );

				}

				if ( offset.intensity !== undefined ) {

					intensity.push( parseFloat( line[ offset.intensity ] ) );

				}

				if ( offset.label !== undefined ) {

					label.push( parseInt( line[ offset.label ] ) );

				}

			}

		}

		// binary-compressed

		// normally data in PCD files are organized as array of structures: XYZRGBXYZRGB
		// binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB
		// that requires a totally different parsing approach compared to non-compressed data

		if ( PCDheader.data === 'binary_compressed' ) {

			const sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );
			const compressedSize = sizes[ 0 ];
			const decompressedSize = sizes[ 1 ];
			const decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );
			const dataview = new DataView( decompressed.buffer );

			const offset = PCDheader.offset;

			for ( let i = 0; i < PCDheader.points; i ++ ) {

				if ( offset.x !== undefined ) {

					const xIndex = PCDheader.fields.indexOf( 'x' );
					const yIndex = PCDheader.fields.indexOf( 'y' );
					const zIndex = PCDheader.fields.indexOf( 'z' );
					position.push( dataview.getFloat32( ( PCDheader.points * offset.x ) + PCDheader.size[ xIndex ] * i, this.littleEndian ) );
					position.push( dataview.getFloat32( ( PCDheader.points * offset.y ) + PCDheader.size[ yIndex ] * i, this.littleEndian ) );
					position.push( dataview.getFloat32( ( PCDheader.points * offset.z ) + PCDheader.size[ zIndex ] * i, this.littleEndian ) );

				}

				if ( offset.rgb !== undefined ) {

					const rgbIndex = PCDheader.fields.indexOf( 'rgb' );

					const r = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 2 ) / 255.0;
					const g = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 1 ) / 255.0;
					const b = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 0 ) / 255.0;

					c.setRGB( r, g, b, SRGBColorSpace );

					color.push( c.r, c.g, c.b );

				}

				if ( offset.normal_x !== undefined ) {

					const xIndex = PCDheader.fields.indexOf( 'normal_x' );
					const yIndex = PCDheader.fields.indexOf( 'normal_y' );
					const zIndex = PCDheader.fields.indexOf( 'normal_z' );
					normal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_x ) + PCDheader.size[ xIndex ] * i, this.littleEndian ) );
					normal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_y ) + PCDheader.size[ yIndex ] * i, this.littleEndian ) );
					normal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_z ) + PCDheader.size[ zIndex ] * i, this.littleEndian ) );

				}

				if ( offset.intensity !== undefined ) {

					const intensityIndex = PCDheader.fields.indexOf( 'intensity' );
					intensity.push( dataview.getFloat32( ( PCDheader.points * offset.intensity ) + PCDheader.size[ intensityIndex ] * i, this.littleEndian ) );

				}

				if ( offset.label !== undefined ) {

					const labelIndex = PCDheader.fields.indexOf( 'label' );
					label.push( dataview.getInt32( ( PCDheader.points * offset.label ) + PCDheader.size[ labelIndex ] * i, this.littleEndian ) );

				}

			}

		}

		// binary

		if ( PCDheader.data === 'binary' ) {

			const dataview = new DataView( data, PCDheader.headerLen );
			const offset = PCDheader.offset;

			for ( let i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {

				if ( offset.x !== undefined ) {

					position.push( dataview.getFloat32( row + offset.x, this.littleEndian ) );
					position.push( dataview.getFloat32( row + offset.y, this.littleEndian ) );
					position.push( dataview.getFloat32( row + offset.z, this.littleEndian ) );

				}

				if ( offset.rgb !== undefined ) {

					const r = dataview.getUint8( row + offset.rgb + 2 ) / 255.0;
					const g = dataview.getUint8( row + offset.rgb + 1 ) / 255.0;
					const b = dataview.getUint8( row + offset.rgb + 0 ) / 255.0;

					c.setRGB( r, g, b, SRGBColorSpace );

					color.push( c.r, c.g, c.b );

				}

				if ( offset.normal_x !== undefined ) {

					normal.push( dataview.getFloat32( row + offset.normal_x, this.littleEndian ) );
					normal.push( dataview.getFloat32( row + offset.normal_y, this.littleEndian ) );
					normal.push( dataview.getFloat32( row + offset.normal_z, this.littleEndian ) );

				}

				if ( offset.intensity !== undefined ) {

					intensity.push( dataview.getFloat32( row + offset.intensity, this.littleEndian ) );

				}

				if ( offset.label !== undefined ) {

					label.push( dataview.getInt32( row + offset.label, this.littleEndian ) );

				}

			}

		}

		// build geometry

		const geometry = new BufferGeometry();

		if ( position.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );
		if ( normal.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) );
		if ( color.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) );
		if ( intensity.length > 0 ) geometry.setAttribute( 'intensity', new Float32BufferAttribute( intensity, 1 ) );
		if ( label.length > 0 ) geometry.setAttribute( 'label', new Int32BufferAttribute( label, 1 ) );

		geometry.computeBoundingSphere();

		// build material

		const material = new PointsMaterial( { size: 0.005 } );

		if ( color.length > 0 ) {

			material.vertexColors = true;

		}

		// build point cloud

		return new Points( geometry, material );

	}

}

// https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf


class LUTCubeLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.type = UnsignedByteType;

	}

	setType( type ) {

		if ( type !== UnsignedByteType && type !== FloatType ) {

			throw new Error( 'LUTCubeLoader: Unsupported type' );

		}

		this.type = type;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'text' );
		loader.load( url, text => {

			try {

				onLoad( this.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				this.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( input ) {

		const regExpTitle = /TITLE +"([^"]*)"/;
		const regExpSize = /LUT_3D_SIZE +(\d+)/;
		const regExpDomainMin = /DOMAIN_MIN +([\d.]+) +([\d.]+) +([\d.]+)/;
		const regExpDomainMax = /DOMAIN_MAX +([\d.]+) +([\d.]+) +([\d.]+)/;
		const regExpDataPoints = /^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm;

		let result = regExpTitle.exec( input );
		const title = ( result !== null ) ? result[ 1 ] : null;

		result = regExpSize.exec( input );

		if ( result === null ) {

			throw new Error( 'LUTCubeLoader: Missing LUT_3D_SIZE information' );

		}

		const size = Number( result[ 1 ] );
		const length = size ** 3 * 4;
		const data = this.type === UnsignedByteType ? new Uint8Array( length ) : new Float32Array( length );

		const domainMin = new Vector3( 0, 0, 0 );
		const domainMax = new Vector3( 1, 1, 1 );

		result = regExpDomainMin.exec( input );

		if ( result !== null ) {

			domainMin.set( Number( result[ 1 ] ), Number( result[ 2 ] ), Number( result[ 3 ] ) );

		}

		result = regExpDomainMax.exec( input );

		if ( result !== null ) {

			domainMax.set( Number( result[ 1 ] ), Number( result[ 2 ] ), Number( result[ 3 ] ) );

		}

		if ( domainMin.x > domainMax.x || domainMin.y > domainMax.y || domainMin.z > domainMax.z ) {

			throw new Error( 'LUTCubeLoader: Invalid input domain' );

		}

		const scale = this.type === UnsignedByteType ? 255 : 1;
		let i = 0;

		while ( ( result = regExpDataPoints.exec( input ) ) !== null ) {

			data[ i ++ ] = Number( result[ 1 ] ) * scale;
			data[ i ++ ] = Number( result[ 2 ] ) * scale;
			data[ i ++ ] = Number( result[ 3 ] ) * scale;
			data[ i ++ ] = scale;

		}

		const texture3D = new Data3DTexture();
		texture3D.image.data = data;
		texture3D.image.width = size;
		texture3D.image.height = size;
		texture3D.image.depth = size;
		texture3D.type = this.type;
		texture3D.magFilter = LinearFilter;
		texture3D.minFilter = LinearFilter;
		texture3D.wrapS = ClampToEdgeWrapping;
		texture3D.wrapT = ClampToEdgeWrapping;
		texture3D.wrapR = ClampToEdgeWrapping;
		texture3D.generateMipmaps = false;
		texture3D.needsUpdate = true;

		return {
			title,
			size,
			domainMin,
			domainMax,
			texture3D,
		};

	}

}

// http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492
// https://community.foundry.com/discuss/topic/103636/format-spec-for-3dl?mode=Post&postID=895258


class LUT3dlLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.type = UnsignedByteType;

	}

	setType( type ) {

		if ( type !== UnsignedByteType && type !== FloatType ) {

			throw new Error( 'LUT3dlLoader: Unsupported type' );

		}

		this.type = type;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'text' );
		loader.load( url, text => {

			try {

				onLoad( this.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				this.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( input ) {

		const regExpGridInfo = /^[\d ]+$/m;
		const regExpDataPoints = /^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm;

		// The first line describes the positions of values on the LUT grid.
		let result = regExpGridInfo.exec( input );

		if ( result === null ) {

			throw new Error( 'LUT3dlLoader: Missing grid information' );

		}

		const gridLines = result[ 0 ].trim().split( /\s+/g ).map( Number );
		const gridStep = gridLines[ 1 ] - gridLines[ 0 ];
		const size = gridLines.length;
		const sizeSq = size ** 2;

		for ( let i = 1, l = gridLines.length; i < l; ++ i ) {

			if ( gridStep !== ( gridLines[ i ] - gridLines[ i - 1 ] ) ) {

				throw new Error( 'LUT3dlLoader: Inconsistent grid size' );

			}

		}

		const dataFloat = new Float32Array( size ** 3 * 4 );
		let maxValue = 0.0;
		let index = 0;

		while ( ( result = regExpDataPoints.exec( input ) ) !== null ) {

			const r = Number( result[ 1 ] );
			const g = Number( result[ 2 ] );
			const b = Number( result[ 3 ] );

			maxValue = Math.max( maxValue, r, g, b );

			const bLayer = index % size;
			const gLayer = Math.floor( index / size ) % size;
			const rLayer = Math.floor( index / ( sizeSq ) ) % size;

			// b grows first, then g, then r.
			const d4 = ( bLayer * sizeSq + gLayer * size + rLayer ) * 4;
			dataFloat[ d4 + 0 ] = r;
			dataFloat[ d4 + 1 ] = g;
			dataFloat[ d4 + 2 ] = b;

			++ index;

		}

		// Determine the bit depth to scale the values to [0.0, 1.0].
		const bits = Math.ceil( Math.log2( maxValue ) );
		const maxBitValue = Math.pow( 2, bits );

		const data = this.type === UnsignedByteType ? new Uint8Array( dataFloat.length ) : dataFloat;
		const scale = this.type === UnsignedByteType ? 255 : 1;

		for ( let i = 0, l = data.length; i < l; i += 4 ) {

			const i1 = i + 1;
			const i2 = i + 2;
			const i3 = i + 3;

			// Note: data is dataFloat when type is FloatType.
			data[ i ] = dataFloat[ i ] / maxBitValue * scale;
			data[ i1 ] = dataFloat[ i1 ] / maxBitValue * scale;
			data[ i2 ] = dataFloat[ i2 ] / maxBitValue * scale;
			data[ i3 ] = scale;

		}

		const texture3D = new Data3DTexture();
		texture3D.image.data = data;
		texture3D.image.width = size;
		texture3D.image.height = size;
		texture3D.image.depth = size;
		texture3D.format = RGBAFormat;
		texture3D.type = this.type;
		texture3D.magFilter = LinearFilter;
		texture3D.minFilter = LinearFilter;
		texture3D.wrapS = ClampToEdgeWrapping;
		texture3D.wrapT = ClampToEdgeWrapping;
		texture3D.wrapR = ClampToEdgeWrapping;
		texture3D.generateMipmaps = false;
		texture3D.needsUpdate = true;

		return {
			size,
			texture3D,
		};

	}

}

// Special surface finish tag types.
// Note: "MATERIAL" tag (e.g. GLITTER, SPECKLE) is not implemented
const FINISH_TYPE_DEFAULT = 0;
const FINISH_TYPE_CHROME = 1;
const FINISH_TYPE_PEARLESCENT = 2;
const FINISH_TYPE_RUBBER = 3;
const FINISH_TYPE_MATTE_METALLIC = 4;
const FINISH_TYPE_METAL = 5;

// State machine to search a subobject path.
// The LDraw standard establishes these various possible subfolders.
const FILE_LOCATION_TRY_PARTS = 0;
const FILE_LOCATION_TRY_P = 1;
const FILE_LOCATION_TRY_MODELS = 2;
const FILE_LOCATION_AS_IS = 3;
const FILE_LOCATION_TRY_RELATIVE = 4;
const FILE_LOCATION_TRY_ABSOLUTE = 5;
const FILE_LOCATION_NOT_FOUND = 6;

const MAIN_COLOUR_CODE = '16';
const MAIN_EDGE_COLOUR_CODE = '24';

const COLOR_SPACE_LDRAW = SRGBColorSpace;

const _tempVec0 = new Vector3();
const _tempVec1 = new Vector3();


class ConditionalLineSegments extends LineSegments {

	constructor( geometry, material ) {

		super( geometry, material );
		this.isConditionalLine = true;

	}

}

function generateFaceNormals( faces ) {

	for ( let i = 0, l = faces.length; i < l; i ++ ) {

		const face = faces[ i ];
		const vertices = face.vertices;
		const v0 = vertices[ 0 ];
		const v1 = vertices[ 1 ];
		const v2 = vertices[ 2 ];

		_tempVec0.subVectors( v1, v0 );
		_tempVec1.subVectors( v2, v1 );
		face.faceNormal = new Vector3()
			.crossVectors( _tempVec0, _tempVec1 )
			.normalize();

	}

}

const _ray$1 = new Ray();
function smoothNormals( faces, lineSegments, checkSubSegments = false ) {

	// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because
	// it allows edges to be smoothed as expected (see minifig arms).
	// --
	// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating
	// point errors on vertices along quantization boundaries. Ie after matrix multiplication
	// vertices that should be merged might be set to "1.7" and "1.6999..." meaning they won't
	// get merged. This added epsilon attempts to push these error values to the same quantized
	// value for the sake of hashing. See "AT-ST mini" dishes. See mrdoob/three#23169.

	const hashMultiplier = ( 1 + 1e-10 ) * 1e2;
	function hashVertex( v ) {

		const x = ~ ~ ( v.x * hashMultiplier );
		const y = ~ ~ ( v.y * hashMultiplier );
		const z = ~ ~ ( v.z * hashMultiplier );

		return `${ x },${ y },${ z }`;

	}

	function hashEdge( v0, v1 ) {

		return `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;

	}

	// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected
	// onto the original line.
	function toNormalizedRay( v0, v1, targetRay ) {

		targetRay.direction.subVectors( v1, v0 ).normalize();

		const scalar = v0.dot( targetRay.direction );
		targetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );

		return targetRay;

	}

	function hashRay( ray ) {

		return hashEdge( ray.origin, ray.direction );

	}

	const hardEdges = new Set();
	const hardEdgeRays = new Map();
	const halfEdgeList = {};
	const normals = [];

	// Save the list of hard edges by hash
	for ( let i = 0, l = lineSegments.length; i < l; i ++ ) {

		const ls = lineSegments[ i ];
		const vertices = ls.vertices;
		const v0 = vertices[ 0 ];
		const v1 = vertices[ 1 ];
		hardEdges.add( hashEdge( v0, v1 ) );
		hardEdges.add( hashEdge( v1, v0 ) );

		// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check
		// and requires more memory.
		if ( checkSubSegments ) {

			// add both ray directions to the map
			const ray = toNormalizedRay( v0, v1, new Ray() );
			const rh1 = hashRay( ray );
			if ( ! hardEdgeRays.has( rh1 ) ) {

				toNormalizedRay( v1, v0, ray );
				const rh2 = hashRay( ray );

				const info = {
					ray,
					distances: [],
				};

				hardEdgeRays.set( rh1, info );
				hardEdgeRays.set( rh2, info );

			}

			// store both segments ends in min, max order in the distances array to check if a face edge is a
			// subsegment later.
			const info = hardEdgeRays.get( rh1 );
			let d0 = info.ray.direction.dot( v0 );
			let d1 = info.ray.direction.dot( v1 );
			if ( d0 > d1 ) {

				[ d0, d1 ] = [ d1, d0 ];

			}

			info.distances.push( d0, d1 );

		}

	}

	// track the half edges associated with each triangle
	for ( let i = 0, l = faces.length; i < l; i ++ ) {

		const tri = faces[ i ];
		const vertices = tri.vertices;
		const vertCount = vertices.length;
		for ( let i2 = 0; i2 < vertCount; i2 ++ ) {

			const index = i2;
			const next = ( i2 + 1 ) % vertCount;
			const v0 = vertices[ index ];
			const v1 = vertices[ next ];
			const hash = hashEdge( v0, v1 );

			// don't add the triangle if the edge is supposed to be hard
			if ( hardEdges.has( hash ) ) {

				continue;

			}

			// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds
			if ( checkSubSegments ) {

				toNormalizedRay( v0, v1, _ray$1 );

				const rayHash = hashRay( _ray$1 );
				if ( hardEdgeRays.has( rayHash ) ) {

					const info = hardEdgeRays.get( rayHash );
					const { ray, distances } = info;
					let d0 = ray.direction.dot( v0 );
					let d1 = ray.direction.dot( v1 );

					if ( d0 > d1 ) {

						[ d0, d1 ] = [ d1, d0 ];

					}

					// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have "hard" normals
					let found = false;
					for ( let i = 0, l = distances.length; i < l; i += 2 ) {

						if ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {

							found = true;
							break;

						}

					}

					if ( found ) {

						continue;

					}

				}

			}

			const info = {
				index: index,
				tri: tri
			};
			halfEdgeList[ hash ] = info;

		}

	}

	// Iterate until we've tried to connect all faces to share normals
	while ( true ) {

		// Stop if there are no more faces left
		let halfEdge = null;
		for ( const key in halfEdgeList ) {

			halfEdge = halfEdgeList[ key ];
			break;

		}

		if ( halfEdge === null ) {

			break;

		}

		// Exhaustively find all connected faces
		const queue = [ halfEdge ];
		while ( queue.length > 0 ) {

			// initialize all vertex normals in this triangle
			const tri = queue.pop().tri;
			const vertices = tri.vertices;
			const vertNormals = tri.normals;
			const faceNormal = tri.faceNormal;

			// Check if any edge is connected to another triangle edge
			const vertCount = vertices.length;
			for ( let i2 = 0; i2 < vertCount; i2 ++ ) {

				const index = i2;
				const next = ( i2 + 1 ) % vertCount;
				const v0 = vertices[ index ];
				const v1 = vertices[ next ];

				// delete this triangle from the list so it won't be found again
				const hash = hashEdge( v0, v1 );
				delete halfEdgeList[ hash ];

				const reverseHash = hashEdge( v1, v0 );
				const otherInfo = halfEdgeList[ reverseHash ];
				if ( otherInfo ) {

					const otherTri = otherInfo.tri;
					const otherIndex = otherInfo.index;
					const otherNormals = otherTri.normals;
					const otherVertCount = otherNormals.length;
					const otherFaceNormal = otherTri.faceNormal;

					// NOTE: If the angle between faces is > 67.5 degrees then assume it's
					// hard edge. There are some cases where the line segments do not line up exactly
					// with or span multiple triangle edges (see Lunar Vehicle wheels).
					if ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {

						continue;

					}

					// if this triangle has already been traversed then it won't be in
					// the halfEdgeList. If it has not then add it to the queue and delete
					// it so it won't be found again.
					if ( reverseHash in halfEdgeList ) {

						queue.push( otherInfo );
						delete halfEdgeList[ reverseHash ];

					}

					// share the first normal
					const otherNext = ( otherIndex + 1 ) % otherVertCount;
					if (
						vertNormals[ index ] && otherNormals[ otherNext ] &&
						vertNormals[ index ] !== otherNormals[ otherNext ]
					) {

						otherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );
						vertNormals[ index ].norm = otherNormals[ otherNext ].norm;

					}

					let sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];
					if ( sharedNormal1 === null ) {

						// it's possible to encounter an edge of a triangle that has already been traversed meaning
						// both edges already have different normals defined and shared. To work around this we create
						// a wrapper object so when those edges are merged the normals can be updated everywhere.
						sharedNormal1 = { norm: new Vector3() };
						normals.push( sharedNormal1.norm );

					}

					if ( vertNormals[ index ] === null ) {

						vertNormals[ index ] = sharedNormal1;
						sharedNormal1.norm.add( faceNormal );

					}

					if ( otherNormals[ otherNext ] === null ) {

						otherNormals[ otherNext ] = sharedNormal1;
						sharedNormal1.norm.add( otherFaceNormal );

					}

					// share the second normal
					if (
						vertNormals[ next ] && otherNormals[ otherIndex ] &&
						vertNormals[ next ] !== otherNormals[ otherIndex ]
					) {

						otherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );
						vertNormals[ next ].norm = otherNormals[ otherIndex ].norm;

					}

					let sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];
					if ( sharedNormal2 === null ) {

						sharedNormal2 = { norm: new Vector3() };
						normals.push( sharedNormal2.norm );

					}

					if ( vertNormals[ next ] === null ) {

						vertNormals[ next ] = sharedNormal2;
						sharedNormal2.norm.add( faceNormal );

					}

					if ( otherNormals[ otherIndex ] === null ) {

						otherNormals[ otherIndex ] = sharedNormal2;
						sharedNormal2.norm.add( otherFaceNormal );

					}

				}

			}

		}

	}

	// The normals of each face have been added up so now we average them by normalizing the vector.
	for ( let i = 0, l = normals.length; i < l; i ++ ) {

		normals[ i ].normalize();

	}

}

function isPartType( type ) {

	return type === 'Part' || type === 'Unofficial_Part';

}

function isPrimitiveType( type ) {

	return /primitive/i.test( type ) || type === 'Subpart';

}

class LineParser {

	constructor( line, lineNumber ) {

		this.line = line;
		this.lineLength = line.length;
		this.currentCharIndex = 0;
		this.currentChar = ' ';
		this.lineNumber = lineNumber;

	}

	seekNonSpace() {

		while ( this.currentCharIndex < this.lineLength ) {

			this.currentChar = this.line.charAt( this.currentCharIndex );

			if ( this.currentChar !== ' ' && this.currentChar !== '\t' ) {

				return;

			}

			this.currentCharIndex ++;

		}

	}

	getToken() {

		const pos0 = this.currentCharIndex ++;

		// Seek space
		while ( this.currentCharIndex < this.lineLength ) {

			this.currentChar = this.line.charAt( this.currentCharIndex );

			if ( this.currentChar === ' ' || this.currentChar === '\t' ) {

				break;

			}

			this.currentCharIndex ++;

		}

		const pos1 = this.currentCharIndex;

		this.seekNonSpace();

		return this.line.substring( pos0, pos1 );

	}

	getVector() {

		return new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );

	}

	getRemainingString() {

		return this.line.substring( this.currentCharIndex, this.lineLength );

	}

	isAtTheEnd() {

		return this.currentCharIndex >= this.lineLength;

	}

	setToEnd() {

		this.currentCharIndex = this.lineLength;

	}

	getLineNumberString() {

		return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';

	}

}

// Fetches and parses an intermediate representation of LDraw parts files.
class LDrawParsedCache {

	constructor( loader ) {

		this.loader = loader;
		this._cache = {};

	}

	cloneResult( original ) {

		const result = {};

		// vertices are transformed and normals computed before being converted to geometry
		// so these pieces must be cloned.
		result.faces = original.faces.map( face => {

			return {
				colorCode: face.colorCode,
				material: face.material,
				vertices: face.vertices.map( v => v.clone() ),
				normals: face.normals.map( () => null ),
				faceNormal: null
			};

		} );

		result.conditionalSegments = original.conditionalSegments.map( face => {

			return {
				colorCode: face.colorCode,
				material: face.material,
				vertices: face.vertices.map( v => v.clone() ),
				controlPoints: face.controlPoints.map( v => v.clone() )
			};

		} );

		result.lineSegments = original.lineSegments.map( face => {

			return {
				colorCode: face.colorCode,
				material: face.material,
				vertices: face.vertices.map( v => v.clone() )
			};

		} );

		// none if this is subsequently modified
		result.type = original.type;
		result.category = original.category;
		result.keywords = original.keywords;
		result.author = original.author;
		result.subobjects = original.subobjects;
		result.fileName = original.fileName;
		result.totalFaces = original.totalFaces;
		result.startingBuildingStep = original.startingBuildingStep;
		result.materials = original.materials;
		result.group = null;
		return result;

	}

	async fetchData( fileName ) {

		let triedLowerCase = false;
		let locationState = FILE_LOCATION_TRY_PARTS;
		while ( locationState !== FILE_LOCATION_NOT_FOUND ) {

			let subobjectURL = fileName;
			switch ( locationState ) {

				case FILE_LOCATION_AS_IS:
					locationState = locationState + 1;
					break;

				case FILE_LOCATION_TRY_PARTS:
					subobjectURL = 'parts/' + subobjectURL;
					locationState = locationState + 1;
					break;

				case FILE_LOCATION_TRY_P:
					subobjectURL = 'p/' + subobjectURL;
					locationState = locationState + 1;
					break;

				case FILE_LOCATION_TRY_MODELS:
					subobjectURL = 'models/' + subobjectURL;
					locationState = locationState + 1;
					break;

				case FILE_LOCATION_TRY_RELATIVE:
					subobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;
					locationState = locationState + 1;
					break;

				case FILE_LOCATION_TRY_ABSOLUTE:

					if ( triedLowerCase ) {

						// Try absolute path
						locationState = FILE_LOCATION_NOT_FOUND;

					} else {

						// Next attempt is lower case
						fileName = fileName.toLowerCase();
						subobjectURL = fileName;
						triedLowerCase = true;
						locationState = FILE_LOCATION_TRY_PARTS;

					}

					break;

			}

			const loader = this.loader;
			const fileLoader = new FileLoader( loader.manager );
			fileLoader.setPath( loader.partsLibraryPath );
			fileLoader.setRequestHeader( loader.requestHeader );
			fileLoader.setWithCredentials( loader.withCredentials );

			try {

				const text = await fileLoader.loadAsync( subobjectURL );
				return text;

			} catch ( _ ) {

				continue;

			}

		}

		throw new Error( 'LDrawLoader: Subobject "' + fileName + '" could not be loaded.' );

	}

	parse( text, fileName = null ) {

		const loader = this.loader;

		// final results
		const faces = [];
		const lineSegments = [];
		const conditionalSegments = [];
		const subobjects = [];
		const materials = {};

		const getLocalMaterial = colorCode => {

			return materials[ colorCode ] || null;

		};

		let type = 'Model';
		let category = null;
		let keywords = null;
		let author = null;
		let totalFaces = 0;

		// split into lines
		if ( text.indexOf( '\r\n' ) !== -1 ) {

			// This is faster than String.split with regex that splits on both
			text = text.replace( /\r\n/g, '\n' );

		}

		const lines = text.split( '\n' );
		const numLines = lines.length;

		let parsingEmbeddedFiles = false;
		let currentEmbeddedFileName = null;
		let currentEmbeddedText = null;

		let bfcCertified = false;
		let bfcCCW = true;
		let bfcInverted = false;
		let bfcCull = true;

		let startingBuildingStep = false;

		// Parse all line commands
		for ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {

			const line = lines[ lineIndex ];

			if ( line.length === 0 ) continue;

			if ( parsingEmbeddedFiles ) {

				if ( line.startsWith( '0 FILE ' ) ) {

					// Save previous embedded file in the cache
					this.setData( currentEmbeddedFileName, currentEmbeddedText );

					// New embedded text file
					currentEmbeddedFileName = line.substring( 7 );
					currentEmbeddedText = '';

				} else {

					currentEmbeddedText += line + '\n';

				}

				continue;

			}

			const lp = new LineParser( line, lineIndex + 1 );
			lp.seekNonSpace();

			if ( lp.isAtTheEnd() ) {

				// Empty line
				continue;

			}

			// Parse the line type
			const lineType = lp.getToken();

			let material;
			let colorCode;
			let segment;
			let ccw;
			let doubleSided;
			let v0, v1, v2, v3, c0, c1;

			switch ( lineType ) {

				// Line type 0: Comment or META
				case '0':

					// Parse meta directive
					const meta = lp.getToken();

					if ( meta ) {

						switch ( meta ) {

							case '!LDRAW_ORG':

								type = lp.getToken();
								break;

							case '!COLOUR':

								material = loader.parseColorMetaDirective( lp );
								if ( material ) {

									materials[ material.userData.code ] = material;

								}	else {

									console.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );

								}

								break;

							case '!CATEGORY':

								category = lp.getToken();
								break;

							case '!KEYWORDS':

								const newKeywords = lp.getRemainingString().split( ',' );
								if ( newKeywords.length > 0 ) {

									if ( ! keywords ) {

										keywords = [];

									}

									newKeywords.forEach( function ( keyword ) {

										keywords.push( keyword.trim() );

									} );

								}

								break;

							case 'FILE':

								if ( lineIndex > 0 ) {

									// Start embedded text files parsing
									parsingEmbeddedFiles = true;
									currentEmbeddedFileName = lp.getRemainingString();
									currentEmbeddedText = '';

									bfcCertified = false;
									bfcCCW = true;

								}

								break;

							case 'BFC':

								// Changes to the backface culling state
								while ( ! lp.isAtTheEnd() ) {

									const token = lp.getToken();

									switch ( token ) {

										case 'CERTIFY':
										case 'NOCERTIFY':

											bfcCertified = token === 'CERTIFY';
											bfcCCW = true;

											break;

										case 'CW':
										case 'CCW':

											bfcCCW = token === 'CCW';

											break;

										case 'INVERTNEXT':

											bfcInverted = true;

											break;

										case 'CLIP':
										case 'NOCLIP':

											bfcCull = token === 'CLIP';

											break;

										default:

											console.warn( 'THREE.LDrawLoader: BFC directive "' + token + '" is unknown.' );

											break;

									}

								}

								break;

							case 'STEP':

								startingBuildingStep = true;

								break;

							case 'Author:':

								author = lp.getToken();

								break;

						}

					}

					break;

					// Line type 1: Sub-object file
				case '1':

					colorCode = lp.getToken();
					material = getLocalMaterial( colorCode );

					const posX = parseFloat( lp.getToken() );
					const posY = parseFloat( lp.getToken() );
					const posZ = parseFloat( lp.getToken() );
					const m0 = parseFloat( lp.getToken() );
					const m1 = parseFloat( lp.getToken() );
					const m2 = parseFloat( lp.getToken() );
					const m3 = parseFloat( lp.getToken() );
					const m4 = parseFloat( lp.getToken() );
					const m5 = parseFloat( lp.getToken() );
					const m6 = parseFloat( lp.getToken() );
					const m7 = parseFloat( lp.getToken() );
					const m8 = parseFloat( lp.getToken() );

					const matrix = new Matrix4().set(
						m0, m1, m2, posX,
						m3, m4, m5, posY,
						m6, m7, m8, posZ,
						0, 0, 0, 1
					);

					let fileName = lp.getRemainingString().trim().replace( /\\/g, '/' );

					if ( loader.fileMap[ fileName ] ) {

						// Found the subobject path in the preloaded file path map
						fileName = loader.fileMap[ fileName ];

					} else {

						// Standardized subfolders
						if ( fileName.startsWith( 's/' ) ) {

							fileName = 'parts/' + fileName;

						} else if ( fileName.startsWith( '48/' ) ) {

							fileName = 'p/' + fileName;

						}

					}

					subobjects.push( {
						material: material,
						colorCode: colorCode,
						matrix: matrix,
						fileName: fileName,
						inverted: bfcInverted,
						startingBuildingStep: startingBuildingStep
					} );

					startingBuildingStep = false;
					bfcInverted = false;

					break;

					// Line type 2: Line segment
				case '2':

					colorCode = lp.getToken();
					material = getLocalMaterial( colorCode );
					v0 = lp.getVector();
					v1 = lp.getVector();

					segment = {
						material: material,
						colorCode: colorCode,
						vertices: [ v0, v1 ],
					};

					lineSegments.push( segment );

					break;

					// Line type 5: Conditional Line segment
				case '5':

					colorCode = lp.getToken();
					material = getLocalMaterial( colorCode );
					v0 = lp.getVector();
					v1 = lp.getVector();
					c0 = lp.getVector();
					c1 = lp.getVector();

					segment = {
						material: material,
						colorCode: colorCode,
						vertices: [ v0, v1 ],
						controlPoints: [ c0, c1 ],
					};

					conditionalSegments.push( segment );

					break;

					// Line type 3: Triangle
				case '3':

					colorCode = lp.getToken();
					material = getLocalMaterial( colorCode );
					ccw = bfcCCW;
					doubleSided = ! bfcCertified || ! bfcCull;

					if ( ccw === true ) {

						v0 = lp.getVector();
						v1 = lp.getVector();
						v2 = lp.getVector();

					} else {

						v2 = lp.getVector();
						v1 = lp.getVector();
						v0 = lp.getVector();

					}

					faces.push( {
						material: material,
						colorCode: colorCode,
						faceNormal: null,
						vertices: [ v0, v1, v2 ],
						normals: [ null, null, null ],
					} );
					totalFaces ++;

					if ( doubleSided === true ) {

						faces.push( {
							material: material,
							colorCode: colorCode,
							faceNormal: null,
							vertices: [ v2, v1, v0 ],
							normals: [ null, null, null ],
						} );
						totalFaces ++;

					}

					break;

					// Line type 4: Quadrilateral
				case '4':

					colorCode = lp.getToken();
					material = getLocalMaterial( colorCode );
					ccw = bfcCCW;
					doubleSided = ! bfcCertified || ! bfcCull;

					if ( ccw === true ) {

						v0 = lp.getVector();
						v1 = lp.getVector();
						v2 = lp.getVector();
						v3 = lp.getVector();

					} else {

						v3 = lp.getVector();
						v2 = lp.getVector();
						v1 = lp.getVector();
						v0 = lp.getVector();

					}

					// specifically place the triangle diagonal in the v0 and v1 slots so we can
					// account for the doubling of vertices later when smoothing normals.
					faces.push( {
						material: material,
						colorCode: colorCode,
						faceNormal: null,
						vertices: [ v0, v1, v2, v3 ],
						normals: [ null, null, null, null ],
					} );
					totalFaces += 2;

					if ( doubleSided === true ) {

						faces.push( {
							material: material,
							colorCode: colorCode,
							faceNormal: null,
							vertices: [ v3, v2, v1, v0 ],
							normals: [ null, null, null, null ],
						} );
						totalFaces += 2;

					}

					break;

				default:
					throw new Error( 'LDrawLoader: Unknown line type "' + lineType + '"' + lp.getLineNumberString() + '.' );

			}

		}

		if ( parsingEmbeddedFiles ) {

			this.setData( currentEmbeddedFileName, currentEmbeddedText );

		}

		return {
			faces,
			conditionalSegments,
			lineSegments,
			type,
			category,
			keywords,
			author,
			subobjects,
			totalFaces,
			startingBuildingStep,
			materials,
			fileName,
			group: null
		};

	}

	// returns an (optionally cloned) instance of the data
	getData( fileName, clone = true ) {

		const key = fileName.toLowerCase();
		const result = this._cache[ key ];
		if ( result === null || result instanceof Promise ) {

			return null;

		}

		if ( clone ) {

			return this.cloneResult( result );

		} else {

			return result;

		}

	}

	// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when
	// the data is ready to use and can be retrieved synchronously with "getData".
	async ensureDataLoaded( fileName ) {

		const key = fileName.toLowerCase();
		if ( ! ( key in this._cache ) ) {

			// replace the promise with a copy of the parsed data for immediate processing
			this._cache[ key ] = this.fetchData( fileName ).then( text => {

				const info = this.parse( text, fileName );
				this._cache[ key ] = info;
				return info;

			} );

		}

		await this._cache[ key ];

	}

	// sets the data in the cache from parsed data
	setData( fileName, text ) {

		const key = fileName.toLowerCase();
		this._cache[ key ] = this.parse( text, fileName );

	}

}

// returns the material for an associated color code. If the color code is 16 for a face or 24 for
// an edge then the passthroughColorCode is used.
function getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {

	const isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;
	if ( isPassthrough ) {

		colorCode = parentColorCode;

	}

	return materialHierarchy[ colorCode ] || null;

}

// Class used to parse and build LDraw parts as three.js objects and cache them if they're a "Part" type.
class LDrawPartsGeometryCache {

	constructor( loader ) {

		this.loader = loader;
		this.parseCache = new LDrawParsedCache( loader );
		this._cache = {};

	}

	// Convert the given file information into a mesh by processing subobjects.
	async processIntoMesh( info ) {

		const loader = this.loader;
		const parseCache = this.parseCache;
		const faceMaterials = new Set();

		// Processes the part subobject information to load child parts and merge geometry onto part
		// piece object.
		const processInfoSubobjects = async ( info, subobject = null ) => {

			const subobjects = info.subobjects;
			const promises = [];

			// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate
			// group which lets instruction steps apply correctly.
			for ( let i = 0, l = subobjects.length; i < l; i ++ ) {

				const subobject = subobjects[ i ];
				const promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {

					const subobjectInfo = parseCache.getData( subobject.fileName, false );
					if ( ! isPrimitiveType( subobjectInfo.type ) ) {

						return this.loadModel( subobject.fileName ).catch( error => {

							console.warn( error );
							return null;

						} );

					}

					return processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );

				} );

				promises.push( promise );

			}

			const group = new Group();
			group.userData.category = info.category;
			group.userData.keywords = info.keywords;
			group.userData.author = info.author;
			group.userData.type = info.type;
			group.userData.fileName = info.fileName;
			info.group = group;

			const subobjectInfos = await Promise.all( promises );
			for ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {

				const subobject = info.subobjects[ i ];
				const subobjectInfo = subobjectInfos[ i ];

				if ( subobjectInfo === null ) {

					// the subobject failed to load
					continue;

				}

				// if the subobject was loaded as a separate group then apply the parent scopes materials
				if ( subobjectInfo.isGroup ) {

					const subobjectGroup = subobjectInfo;
					subobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );
					subobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;
					subobjectGroup.name = subobject.fileName;

					loader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );
					subobjectGroup.userData.colorCode = subobject.colorCode;

					group.add( subobjectGroup );
					continue;

				}

				// add the subobject group if it has children in case it has both children and primitives
				if ( subobjectInfo.group.children.length ) {

					group.add( subobjectInfo.group );

				}

				// transform the primitives into the local space of the parent piece and append them to
				// to the parent primitives list.
				const parentLineSegments = info.lineSegments;
				const parentConditionalSegments = info.conditionalSegments;
				const parentFaces = info.faces;

				const lineSegments = subobjectInfo.lineSegments;
				const conditionalSegments = subobjectInfo.conditionalSegments;

				const faces = subobjectInfo.faces;
				const matrix = subobject.matrix;
				const inverted = subobject.inverted;
				const matrixScaleInverted = matrix.determinant() < 0;
				const colorCode = subobject.colorCode;

				const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;
				for ( let i = 0, l = lineSegments.length; i < l; i ++ ) {

					const ls = lineSegments[ i ];
					const vertices = ls.vertices;
					vertices[ 0 ].applyMatrix4( matrix );
					vertices[ 1 ].applyMatrix4( matrix );
					ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;
					ls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );

					parentLineSegments.push( ls );

				}

				for ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {

					const os = conditionalSegments[ i ];
					const vertices = os.vertices;
					const controlPoints = os.controlPoints;
					vertices[ 0 ].applyMatrix4( matrix );
					vertices[ 1 ].applyMatrix4( matrix );
					controlPoints[ 0 ].applyMatrix4( matrix );
					controlPoints[ 1 ].applyMatrix4( matrix );
					os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;
					os.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );

					parentConditionalSegments.push( os );

				}

				for ( let i = 0, l = faces.length; i < l; i ++ ) {

					const tri = faces[ i ];
					const vertices = tri.vertices;
					for ( let i = 0, l = vertices.length; i < l; i ++ ) {

						vertices[ i ].applyMatrix4( matrix );

					}

					tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;
					tri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );
					faceMaterials.add( tri.colorCode );

					// If the scale of the object is negated then the triangle winding order
					// needs to be flipped.
					if ( matrixScaleInverted !== inverted ) {

						vertices.reverse();

					}

					parentFaces.push( tri );

				}

				info.totalFaces += subobjectInfo.totalFaces;

			}

			// Apply the parent subobjects pass through material code to this object. This is done several times due
			// to material scoping.
			if ( subobject ) {

				loader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );
				group.userData.colorCode = subobject.colorCode;

			}

			return info;

		};

		// Track material use to see if we need to use the normal smooth slow path for hard edges.
		for ( let i = 0, l = info.faces; i < l; i ++ ) {

			faceMaterials.add( info.faces[ i ].colorCode );

		}

		await processInfoSubobjects( info );

		if ( loader.smoothNormals ) {

			const checkSubSegments = faceMaterials.size > 1;
			generateFaceNormals( info.faces );
			smoothNormals( info.faces, info.lineSegments, checkSubSegments );

		}

		// Add the primitive objects and metadata.
		const group = info.group;
		if ( info.faces.length > 0 ) {

			group.add( createObject( this.loader, info.faces, 3, false, info.totalFaces ) );

		}

		if ( info.lineSegments.length > 0 ) {

			group.add( createObject( this.loader, info.lineSegments, 2 ) );

		}

		if ( info.conditionalSegments.length > 0 ) {

			group.add( createObject( this.loader, info.conditionalSegments, 2, true ) );

		}

		return group;

	}

	hasCachedModel( fileName ) {

		return fileName !== null && fileName.toLowerCase() in this._cache;

	}

	async getCachedModel( fileName ) {

		if ( fileName !== null && this.hasCachedModel( fileName ) ) {

			const key = fileName.toLowerCase();
			const group = await this._cache[ key ];
			return group.clone();

		} else {

			return null;

		}

	}

	// Loads and parses the model with the given file name. Returns a cached copy if available.
	async loadModel( fileName ) {

		const parseCache = this.parseCache;
		const key = fileName.toLowerCase();
		if ( this.hasCachedModel( fileName ) ) {

			// Return cached model if available.
			return this.getCachedModel( fileName );

		} else {

			// Otherwise parse a new model.
			// Ensure the file data is loaded and pre parsed.
			await parseCache.ensureDataLoaded( fileName );

			const info = parseCache.getData( fileName );
			const promise = this.processIntoMesh( info );

			// Now that the file has loaded it's possible that another part parse has been waiting in parallel
			// so check the cache again to see if it's been added since the last async operation so we don't
			// do unnecessary work.
			if ( this.hasCachedModel( fileName ) ) {

				return this.getCachedModel( fileName );

			}

			// Cache object if it's a part so it can be reused later.
			if ( isPartType( info.type ) ) {

				this._cache[ key ] = promise;

			}

			// return a copy
			const group = await promise;
			return group.clone();

		}

	}

	// parses the given model text into a renderable object. Returns cached copy if available.
	async parseModel( text ) {

		const parseCache = this.parseCache;
		const info = parseCache.parse( text );
		if ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {

			return this.getCachedModel( info.fileName );

		}

		return this.processIntoMesh( info );

	}

}

function sortByMaterial( a, b ) {

	if ( a.colorCode === b.colorCode ) {

		return 0;

	}

	if ( a.colorCode < b.colorCode ) {

		return -1;

	}

	return 1;

}

function createObject( loader, elements, elementSize, isConditionalSegments = false, totalElements = null ) {

	// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )
	// With per face / segment material, implemented with mesh groups and materials array

	// Sort the faces or line segments by color code to make later the mesh groups
	elements.sort( sortByMaterial );

	if ( totalElements === null ) {

		totalElements = elements.length;

	}

	const positions = new Float32Array( elementSize * totalElements * 3 );
	const normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;
	const materials = [];

	const quadArray = new Array( 6 );
	const bufferGeometry = new BufferGeometry();
	let prevMaterial = null;
	let index0 = 0;
	let numGroupVerts = 0;
	let offset = 0;

	for ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {

		const elem = elements[ iElem ];
		let vertices = elem.vertices;
		if ( vertices.length === 4 ) {

			quadArray[ 0 ] = vertices[ 0 ];
			quadArray[ 1 ] = vertices[ 1 ];
			quadArray[ 2 ] = vertices[ 2 ];
			quadArray[ 3 ] = vertices[ 0 ];
			quadArray[ 4 ] = vertices[ 2 ];
			quadArray[ 5 ] = vertices[ 3 ];
			vertices = quadArray;

		}

		for ( let j = 0, l = vertices.length; j < l; j ++ ) {

			const v = vertices[ j ];
			const index = offset + j * 3;
			positions[ index + 0 ] = v.x;
			positions[ index + 1 ] = v.y;
			positions[ index + 2 ] = v.z;

		}

		// create the normals array if this is a set of faces
		if ( elementSize === 3 ) {

			if ( ! elem.faceNormal ) {

				const v0 = vertices[ 0 ];
				const v1 = vertices[ 1 ];
				const v2 = vertices[ 2 ];
				_tempVec0.subVectors( v1, v0 );
				_tempVec1.subVectors( v2, v1 );
				elem.faceNormal = new Vector3()
					.crossVectors( _tempVec0, _tempVec1 )
					.normalize();

			}

			let elemNormals = elem.normals;
			if ( elemNormals.length === 4 ) {

				quadArray[ 0 ] = elemNormals[ 0 ];
				quadArray[ 1 ] = elemNormals[ 1 ];
				quadArray[ 2 ] = elemNormals[ 2 ];
				quadArray[ 3 ] = elemNormals[ 0 ];
				quadArray[ 4 ] = elemNormals[ 2 ];
				quadArray[ 5 ] = elemNormals[ 3 ];
				elemNormals = quadArray;

			}

			for ( let j = 0, l = elemNormals.length; j < l; j ++ ) {

				// use face normal if a vertex normal is not provided
				let n = elem.faceNormal;
				if ( elemNormals[ j ] ) {

					n = elemNormals[ j ].norm;

				}

				const index = offset + j * 3;
				normals[ index + 0 ] = n.x;
				normals[ index + 1 ] = n.y;
				normals[ index + 2 ] = n.z;

			}

		}

		if ( prevMaterial !== elem.colorCode ) {

			if ( prevMaterial !== null ) {

				bufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );

			}

			const material = elem.material;

			if ( material !== null ) {

				if ( elementSize === 3 ) {

					materials.push( material );

				} else if ( elementSize === 2 ) {

					if ( isConditionalSegments ) {

						const edgeMaterial = loader.edgeMaterialCache.get( material );

						materials.push( loader.conditionalEdgeMaterialCache.get( edgeMaterial ) );

					} else {

						materials.push( loader.edgeMaterialCache.get( material ) );

					}

				}

			} else {

				// If a material has not been made available yet then keep the color code string in the material array
				// to save the spot for the material once a parent scopes materials are being applied to the object.
				materials.push( elem.colorCode );

			}

			prevMaterial = elem.colorCode;
			index0 = offset / 3;
			numGroupVerts = vertices.length;

		} else {

			numGroupVerts += vertices.length;

		}

		offset += 3 * vertices.length;

	}

	if ( numGroupVerts > 0 ) {

		bufferGeometry.addGroup( index0, Infinity, materials.length - 1 );

	}

	bufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

	if ( normals !== null ) {

		bufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );

	}

	let object3d = null;

	if ( elementSize === 2 ) {

		if ( isConditionalSegments ) {

			object3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );

		} else {

			object3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );

		}

	} else if ( elementSize === 3 ) {

		object3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );

	}

	if ( isConditionalSegments ) {

		object3d.isConditionalLine = true;

		const controlArray0 = new Float32Array( elements.length * 3 * 2 );
		const controlArray1 = new Float32Array( elements.length * 3 * 2 );
		const directionArray = new Float32Array( elements.length * 3 * 2 );
		for ( let i = 0, l = elements.length; i < l; i ++ ) {

			const os = elements[ i ];
			const vertices = os.vertices;
			const controlPoints = os.controlPoints;
			const c0 = controlPoints[ 0 ];
			const c1 = controlPoints[ 1 ];
			const v0 = vertices[ 0 ];
			const v1 = vertices[ 1 ];
			const index = i * 3 * 2;
			controlArray0[ index + 0 ] = c0.x;
			controlArray0[ index + 1 ] = c0.y;
			controlArray0[ index + 2 ] = c0.z;
			controlArray0[ index + 3 ] = c0.x;
			controlArray0[ index + 4 ] = c0.y;
			controlArray0[ index + 5 ] = c0.z;

			controlArray1[ index + 0 ] = c1.x;
			controlArray1[ index + 1 ] = c1.y;
			controlArray1[ index + 2 ] = c1.z;
			controlArray1[ index + 3 ] = c1.x;
			controlArray1[ index + 4 ] = c1.y;
			controlArray1[ index + 5 ] = c1.z;

			directionArray[ index + 0 ] = v1.x - v0.x;
			directionArray[ index + 1 ] = v1.y - v0.y;
			directionArray[ index + 2 ] = v1.z - v0.z;
			directionArray[ index + 3 ] = v1.x - v0.x;
			directionArray[ index + 4 ] = v1.y - v0.y;
			directionArray[ index + 5 ] = v1.z - v0.z;

		}

		bufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );
		bufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );
		bufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );

	}

	return object3d;

}

//

class LDrawLoader extends Loader {

	constructor( manager ) {

		super( manager );

		// Array of THREE.Material
		this.materials = [];
		this.materialLibrary = {};
		this.edgeMaterialCache = new WeakMap();
		this.conditionalEdgeMaterialCache = new WeakMap();

		// This also allows to handle the embedded text files ("0 FILE" lines)
		this.partsCache = new LDrawPartsGeometryCache( this );

		// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.
		this.fileMap = {};

		// If this flag is set to true the vertex normals will be smoothed.
		this.smoothNormals = true;

		// The path to load parts from the LDraw parts library from.
		this.partsLibraryPath = '';

		// this material type must be injected via setConditionalLineMaterial()
		this.ConditionalLineMaterial = null;

		// Material assigned to not available colors for meshes and edges
		this.missingColorMaterial = new MeshStandardMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF, roughness: 0.3, metalness: 0 } );
		this.missingEdgeColorMaterial = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF } );
		this.missingConditionalEdgeColorMaterial = null;
		this.edgeMaterialCache.set( this.missingColorMaterial, this.missingEdgeColorMaterial );
		this.conditionalEdgeMaterialCache.set( this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial );

	}

	setPartsLibraryPath( path ) {

		this.partsLibraryPath = path;
		return this;

	}

	setConditionalLineMaterial( type ) {

		this.ConditionalLineMaterial = type;
		this.missingConditionalEdgeColorMaterial = new this.ConditionalLineMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, fog: true, color: 0xFF00FF } );
		return this;

	}

	async preloadMaterials( url ) {

		const fileLoader = new FileLoader( this.manager );
		fileLoader.setPath( this.path );
		fileLoader.setRequestHeader( this.requestHeader );
		fileLoader.setWithCredentials( this.withCredentials );

		const text = await fileLoader.loadAsync( url );
		const colorLineRegex = /^0 !COLOUR/;
		const lines = text.split( /[\n\r]/g );
		const materials = [];
		for ( let i = 0, l = lines.length; i < l; i ++ ) {

			const line = lines[ i ];
			if ( colorLineRegex.test( line ) ) {

				const directive = line.replace( colorLineRegex, '' );
				const material = this.parseColorMetaDirective( new LineParser( directive ) );
				materials.push( material );

			}

		}

		this.setMaterials( materials );

	}

	load( url, onLoad, onProgress, onError ) {

		const fileLoader = new FileLoader( this.manager );
		fileLoader.setPath( this.path );
		fileLoader.setRequestHeader( this.requestHeader );
		fileLoader.setWithCredentials( this.withCredentials );
		fileLoader.load( url, text => {

			// Initializes the materials library with default materials
			this.setMaterials( [] );

			this.partsCache
				.parseModel( text, this.materialLibrary )
				.then( group => {

					this.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );
					this.computeBuildingSteps( group );
					group.userData.fileName = url;
					onLoad( group );

				} )
				.catch( onError );

		}, onProgress, onError );

	}

	parse( text, onLoad, onError ) {

		this.partsCache
			.parseModel( text, this.materialLibrary )
			.then( group => {

				this.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );
				this.computeBuildingSteps( group );
				group.userData.fileName = '';
				onLoad( group );

			} )
			.catch( onError );

	}

	setMaterials( materials ) {

		this.materialLibrary = {};
		this.materials = [];
		for ( let i = 0, l = materials.length; i < l; i ++ ) {

			this.addMaterial( materials[ i ] );

		}

		// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)
		this.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );
		this.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );

		return this;

	}

	setFileMap( fileMap ) {

		this.fileMap = fileMap;

		return this;

	}

	addMaterial( material ) {

		// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array

		const matLib = this.materialLibrary;
		if ( ! matLib[ material.userData.code ] ) {

			this.materials.push( material );
			matLib[ material.userData.code ] = material;

		}

		return this;

	}

	getMaterial( colorCode ) {

		if ( colorCode.startsWith( '0x2' ) ) {

			// Special 'direct' material value (RGB color)
			const color = colorCode.substring( 3 );

			return this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );

		}

		return this.materialLibrary[ colorCode ] || null;

	}

	// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present
	// in the material array if they need to be filled in.
	applyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {

		// find any missing materials as indicated by a color code string and replace it with a material from the current material lib
		const loader = this;
		const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;
		group.traverse( c => {

			if ( c.isMesh || c.isLineSegments ) {

				if ( Array.isArray( c.material ) ) {

					for ( let i = 0, l = c.material.length; i < l; i ++ ) {

						if ( ! c.material[ i ].isMaterial ) {

							c.material[ i ] = getMaterial( c, c.material[ i ] );

						}

					}

				} else if ( ! c.material.isMaterial ) {

					c.material = getMaterial( c, c.material );

				}

			}

		} );


		// Returns the appropriate material for the object (line or face) given color code. If the code is "pass through"
		// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's
		// simply returned for the subsequent material application.
		function getMaterial( c, colorCode ) {

			// if our parent is a passthrough color code and we don't have the current material color available then
			// return early.
			if ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {

				return colorCode;

			}

			const forEdge = c.isLineSegments || c.isConditionalLine;
			const isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;
			if ( isPassthrough ) {

				colorCode = parentColorCode;

			}

			let material = null;
			if ( colorCode in materialHierarchy ) {

				material = materialHierarchy[ colorCode ];

			} else if ( finalMaterialPass ) {

				// see if we can get the final material from from the "getMaterial" function which will attempt to
				// parse the "direct" colors
				material = loader.getMaterial( colorCode );
				if ( material === null ) {

					// otherwise throw a warning if this is final opportunity to set the material
					console.warn( `LDrawLoader: Material properties for code ${ colorCode } not available.` );

					// And return the 'missing color' material
					material = loader.missingColorMaterial;

				}


			} else {

				return colorCode;

			}

			if ( c.isLineSegments ) {

				material = loader.edgeMaterialCache.get( material );

				if ( c.isConditionalLine ) {

					material = loader.conditionalEdgeMaterialCache.get( material );

				}

			}

			return material;

		}

	}

	getMainMaterial() {

		return this.getMaterial( MAIN_COLOUR_CODE );

	}

	getMainEdgeMaterial() {

		const mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE );
		return mat ? this.edgeMaterialCache.get( mat ) : null;

	}

	parseColorMetaDirective( lineParser ) {

		// Parses a color definition and returns a THREE.Material

		let code = null;

		// Triangle and line colors
		let fillColor = '#FF00FF';
		let edgeColor = '#FF00FF';

		// Transparency
		let alpha = 1;
		let isTransparent = false;
		// Self-illumination:
		let luminance = 0;

		let finishType = FINISH_TYPE_DEFAULT;

		let edgeMaterial = null;

		const name = lineParser.getToken();
		if ( ! name ) {

			throw new Error( 'LDrawLoader: Material name was expected after "!COLOUR tag' + lineParser.getLineNumberString() + '.' );

		}

		// Parse tag tokens and their parameters
		let token = null;
		while ( true ) {

			token = lineParser.getToken();

			if ( ! token ) {

				break;

			}

			if ( ! parseLuminance( token ) ) {

				switch ( token.toUpperCase() ) {

					case 'CODE':

						code = lineParser.getToken();
						break;

					case 'VALUE':

						fillColor = lineParser.getToken();
						if ( fillColor.startsWith( '0x' ) ) {

							fillColor = '#' + fillColor.substring( 2 );

						} else if ( ! fillColor.startsWith( '#' ) ) {

							throw new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );

						}

						break;

					case 'EDGE':

						edgeColor = lineParser.getToken();
						if ( edgeColor.startsWith( '0x' ) ) {

							edgeColor = '#' + edgeColor.substring( 2 );

						} else if ( ! edgeColor.startsWith( '#' ) ) {

							// Try to see if edge color is a color code
							edgeMaterial = this.getMaterial( edgeColor );
							if ( ! edgeMaterial ) {

								throw new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );

							}

							// Get the edge material for this triangle material
							edgeMaterial = this.edgeMaterialCache.get( edgeMaterial );

						}

						break;

					case 'ALPHA':

						alpha = parseInt( lineParser.getToken() );

						if ( isNaN( alpha ) ) {

							throw new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );

						}

						alpha = Math.max( 0, Math.min( 1, alpha / 255 ) );

						if ( alpha < 1 ) {

							isTransparent = true;

						}

						break;

					case 'LUMINANCE':

						if ( ! parseLuminance( lineParser.getToken() ) ) {

							throw new Error( 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.' );

						}

						break;

					case 'CHROME':
						finishType = FINISH_TYPE_CHROME;
						break;

					case 'PEARLESCENT':
						finishType = FINISH_TYPE_PEARLESCENT;
						break;

					case 'RUBBER':
						finishType = FINISH_TYPE_RUBBER;
						break;

					case 'MATTE_METALLIC':
						finishType = FINISH_TYPE_MATTE_METALLIC;
						break;

					case 'METAL':
						finishType = FINISH_TYPE_METAL;
						break;

					case 'MATERIAL':
						// Not implemented
						lineParser.setToEnd();
						break;

					default:
						throw new Error( 'LDrawLoader: Unknown token "' + token + '" while parsing material' + lineParser.getLineNumberString() + '.' );

				}

			}

		}

		let material = null;

		switch ( finishType ) {

			case FINISH_TYPE_DEFAULT:

				material = new MeshStandardMaterial( { roughness: 0.3, metalness: 0 } );
				break;

			case FINISH_TYPE_PEARLESCENT:

				// Try to imitate pearlescency by making the surface glossy
				material = new MeshStandardMaterial( { roughness: 0.3, metalness: 0.25 } );
				break;

			case FINISH_TYPE_CHROME:

				// Mirror finish surface
				material = new MeshStandardMaterial( { roughness: 0, metalness: 1 } );
				break;

			case FINISH_TYPE_RUBBER:

				// Rubber finish
				material = new MeshStandardMaterial( { roughness: 0.9, metalness: 0 } );
				break;

			case FINISH_TYPE_MATTE_METALLIC:

				// Brushed metal finish
				material = new MeshStandardMaterial( { roughness: 0.8, metalness: 0.4 } );
				break;

			case FINISH_TYPE_METAL:

				// Average metal finish
				material = new MeshStandardMaterial( { roughness: 0.2, metalness: 0.85 } );
				break;

		}

		material.color.setStyle( fillColor, COLOR_SPACE_LDRAW );
		material.transparent = isTransparent;
		material.premultipliedAlpha = true;
		material.opacity = alpha;
		material.depthWrite = ! isTransparent;

		material.polygonOffset = true;
		material.polygonOffsetFactor = 1;

		if ( luminance !== 0 ) {

			material.emissive.setStyle( fillColor, COLOR_SPACE_LDRAW ).multiplyScalar( luminance );

		}

		if ( ! edgeMaterial ) {

			// This is the material used for edges
			edgeMaterial = new LineBasicMaterial( {
				color: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),
				transparent: isTransparent,
				opacity: alpha,
				depthWrite: ! isTransparent
			} );
			edgeMaterial.color;
			edgeMaterial.userData.code = code;
			edgeMaterial.name = name + ' - Edge';

			if ( this.ConditionalLineMaterial === null ) {

				throw new Error( 'THREE.LDrawLoader: ConditionalLineMaterial type must be specified via .setConditionalLineMaterial().' );

			}

			// This is the material used for conditional edges
			const conditionalEdgeMaterial = new this.ConditionalLineMaterial( {

				fog: true,
				transparent: isTransparent,
				depthWrite: ! isTransparent,
				color: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),
				opacity: alpha,

			} );
			conditionalEdgeMaterial.userData.code = code;
			conditionalEdgeMaterial.name = name + ' - Conditional Edge';

			this.conditionalEdgeMaterialCache.set( edgeMaterial, conditionalEdgeMaterial );

		}

		material.userData.code = code;
		material.name = name;

		this.edgeMaterialCache.set( material, edgeMaterial );

		this.addMaterial( material );

		return material;

		function parseLuminance( token ) {

			// Returns success

			let lum;

			if ( token.startsWith( 'LUMINANCE' ) ) {

				lum = parseInt( token.substring( 9 ) );

			} else {

				lum = parseInt( token );

			}

			if ( isNaN( lum ) ) {

				return false;

			}

			luminance = Math.max( 0, Math.min( 1, lum / 255 ) );

			return true;

		}

	}

	computeBuildingSteps( model ) {

		// Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.

		let stepNumber = 0;

		model.traverse( c => {

			if ( c.isGroup ) {

				if ( c.userData.startingBuildingStep ) {

					stepNumber ++;

				}

				c.userData.buildingStep = stepNumber;

			}

		} );

		model.userData.numBuildingSteps = stepNumber + 1;

	}

}

const _taskCache = new WeakMap();

class Rhino3dmLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.libraryPath = '';
		this.libraryPending = null;
		this.libraryBinary = null;
		this.libraryConfig = {};

		this.url = '';

		this.workerLimit = 4;
		this.workerPool = [];
		this.workerNextTaskID = 1;
		this.workerSourceURL = '';
		this.workerConfig = {};

		this.materials = [];
		this.warnings = [];

	}

	setLibraryPath( path ) {

		this.libraryPath = path;

		return this;

	}

	setWorkerLimit( workerLimit ) {

		this.workerLimit = workerLimit;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );

		this.url = url;

		loader.load( url, ( buffer ) => {

			// Check for an existing task using this buffer. A transferred buffer cannot be transferred
			// again from this thread.
			if ( _taskCache.has( buffer ) ) {

				const cachedTask = _taskCache.get( buffer );

				return cachedTask.promise.then( onLoad ).catch( onError );

			}

			this.decodeObjects( buffer, url )
				.then( result => {

					result.userData.warnings = this.warnings;
					onLoad( result );

				 } )
				.catch( e => onError( e ) );

		}, onProgress, onError );

	}

	debug() {

		console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );

	}

	decodeObjects( buffer, url ) {

		let worker;
		let taskID;

		const taskCost = buffer.byteLength;

		const objectPending = this._getWorker( taskCost )
			.then( ( _worker ) => {

				worker = _worker;
				taskID = this.workerNextTaskID ++;

				return new Promise( ( resolve, reject ) => {

					worker._callbacks[ taskID ] = { resolve, reject };

					worker.postMessage( { type: 'decode', id: taskID, buffer }, [ buffer ] );

					// this.debug();

				} );

			} )
			.then( ( message ) => this._createGeometry( message.data ) )
			.catch( e => {

				throw e;

			} );

		// Remove task from the task list.
		// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
		objectPending
			.catch( () => true )
			.then( () => {

				if ( worker && taskID ) {

					this._releaseTask( worker, taskID );

					//this.debug();

				}

			} );

		// Cache the task result.
		_taskCache.set( buffer, {

			url: url,
			promise: objectPending

		} );

		return objectPending;

	}

	parse( data, onLoad, onError ) {

		this.decodeObjects( data, '' )
			.then( result => {

				result.userData.warnings = this.warnings;
				onLoad( result );

			} )
			.catch( e => onError( e ) );

	}

	_compareMaterials( material ) {

		const mat = {};
		mat.name = material.name;
		mat.color = {};
		mat.color.r = material.color.r;
		mat.color.g = material.color.g;
		mat.color.b = material.color.b;
		mat.type = material.type;
		mat.vertexColors = material.vertexColors;

		const json = JSON.stringify( mat );

		for ( let i = 0; i < this.materials.length; i ++ ) {

			const m = this.materials[ i ];
			const _mat = {};
			_mat.name = m.name;
			_mat.color = {};
			_mat.color.r = m.color.r;
			_mat.color.g = m.color.g;
			_mat.color.b = m.color.b;
			_mat.type = m.type;
			_mat.vertexColors = m.vertexColors;

			if ( JSON.stringify( _mat ) === json ) {

				return m;

			}

		}

		this.materials.push( material );

		return material;

	}

	_createMaterial( material, renderEnvironment ) {

		if ( material === undefined ) {

			return new MeshStandardMaterial( {
				color: new Color( 1, 1, 1 ),
				metalness: 0.8,
				name: Loader.DEFAULT_MATERIAL_NAME,
				side: DoubleSide
			} );

		}

		//console.log(material)

		const mat = new MeshPhysicalMaterial( {

			color: new Color( material.diffuseColor.r / 255.0, material.diffuseColor.g / 255.0, material.diffuseColor.b / 255.0 ),
			emissive: new Color( material.emissionColor.r, material.emissionColor.g, material.emissionColor.b ),
			flatShading: material.disableLighting,
			ior: material.indexOfRefraction,
			name: material.name,
			reflectivity: material.reflectivity,
			opacity: 1.0 - material.transparency,
			side: DoubleSide,
			specularColor: material.specularColor,
			transparent: material.transparency > 0 ? true : false

		} );

		mat.userData.id = material.id;

		if ( material.pbrSupported ) {

			const pbr = material.pbr;

			mat.anisotropy = pbr.anisotropic;
			mat.anisotropyRotation = pbr.anisotropicRotation;
			mat.color = new Color( pbr.baseColor.r, pbr.baseColor.g, pbr.baseColor.b );
			mat.clearcoat = pbr.clearcoat;
			mat.clearcoatRoughness = pbr.clearcoatRoughness;
			mat.metalness = pbr.metallic;
			mat.transmission = 1 - pbr.opacity;
			mat.roughness = pbr.roughness;
			mat.sheen = pbr.sheen;
			mat.specularIntensity = pbr.specular;
			mat.thickness = pbr.subsurface;

		}

		if ( material.pbrSupported && material.pbr.opacity === 0 && material.transparency === 1 ) {

			//some compromises

			mat.opacity = 0.2;
			mat.transmission = 1.00;

		}

		const textureLoader = new TextureLoader();

		for ( let i = 0; i < material.textures.length; i ++ ) {

			const texture = material.textures[ i ];

			if ( texture.image !== null ) {

				const map = textureLoader.load( texture.image );

				//console.log(texture.type )

				switch ( texture.type ) {

					case 'Bump':

						mat.bumpMap = map;

						break;

					case 'Diffuse':

						mat.map = map;

						break;

					case 'Emap':

						mat.envMap = map;

						break;

					case 'Opacity':

						mat.transmissionMap = map;

						break;

					case 'Transparency':

						mat.alphaMap = map;
						mat.transparent = true;

						break;

					case 'PBR_Alpha':

						mat.alphaMap = map;
						mat.transparent = true;

						break;

					case 'PBR_AmbientOcclusion':

						mat.aoMap = map;

						break;

					case 'PBR_Anisotropic':

						mat.anisotropyMap = map;

						break;

					case 'PBR_BaseColor':

						mat.map = map;

						break;

					case 'PBR_Clearcoat':

						mat.clearcoatMap = map;

						break;

					case 'PBR_ClearcoatBump':

						mat.clearcoatNormalMap = map;

						break;

					case 'PBR_ClearcoatRoughness':

						mat.clearcoatRoughnessMap = map;

						break;

					case 'PBR_Displacement':

						mat.displacementMap = map;

						break;

					case 'PBR_Emission':

						mat.emissiveMap = map;

						break;

					case 'PBR_Metallic':

						mat.metalnessMap = map;

						break;

					case 'PBR_Roughness':

						mat.roughnessMap = map;

						break;

					case 'PBR_Sheen':

						mat.sheenColorMap = map;

						break;

					case 'PBR_Specular':

						mat.specularColorMap = map;

						break;

					case 'PBR_Subsurface':

						mat.thicknessMap = map;

						break;

					default:

						this.warnings.push( {
							message: `THREE.3DMLoader: No conversion exists for 3dm ${texture.type}.`,
							type: 'no conversion'
						} );

						break;

				}

				map.wrapS = texture.wrapU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
				map.wrapT = texture.wrapV === 0 ? RepeatWrapping : ClampToEdgeWrapping;

				if ( texture.repeat ) {

					map.repeat.set( texture.repeat[ 0 ], texture.repeat[ 1 ] );

				}

			}

		}

		if ( renderEnvironment ) {

			new EXRLoader().load( renderEnvironment.image, function ( texture ) {

				texture.mapping = THREE.EquirectangularReflectionMapping;
				mat.envMap = texture;

			} );

		}

		return mat;

	}

	_createGeometry( data ) {

		const object = new Object3D();
		const instanceDefinitionObjects = [];
		const instanceDefinitions = [];
		const instanceReferences = [];

		object.userData[ 'layers' ] = data.layers;
		object.userData[ 'groups' ] = data.groups;
		object.userData[ 'settings' ] = data.settings;
		object.userData.settings[ 'renderSettings' ] = data.renderSettings;
		object.userData[ 'objectType' ] = 'File3dm';
		object.userData[ 'materials' ] = null;

		object.name = this.url;

		let objects = data.objects;
		const materials = data.materials;

		for ( let i = 0; i < objects.length; i ++ ) {

			const obj = objects[ i ];
			const attributes = obj.attributes;

			switch ( obj.objectType ) {

				case 'InstanceDefinition':

					instanceDefinitions.push( obj );

					break;

				case 'InstanceReference':

					instanceReferences.push( obj );

					break;

				default:

					let matId = null;

					switch ( attributes.materialSource.name ) {

						case 'ObjectMaterialSource_MaterialFromLayer':
							//check layer index
							if ( attributes.layerIndex >= 0 ) {

								matId = data.layers[ attributes.layerIndex ].renderMaterialIndex;

							}

							break;

						case 'ObjectMaterialSource_MaterialFromObject':

							if ( attributes.materialIndex >= 0 ) {

								matId = attributes.materialIndex;

							}

							break;

					}

					let material = null;

					if ( matId >= 0 ) {

						const rMaterial = materials[ matId ];
						material = this._createMaterial( rMaterial, data.renderEnvironment );


					}

					const _object = this._createObject( obj, material );

					if ( _object === undefined ) {

						continue;

					}

					const layer = data.layers[ attributes.layerIndex ];

					_object.visible = layer ? data.layers[ attributes.layerIndex ].visible : true;

					if ( attributes.isInstanceDefinitionObject ) {

						instanceDefinitionObjects.push( _object );

					} else {

						object.add( _object );

					}

					break;

			}

		}

		for ( let i = 0; i < instanceDefinitions.length; i ++ ) {

			const iDef = instanceDefinitions[ i ];

			objects = [];

			for ( let j = 0; j < iDef.attributes.objectIds.length; j ++ ) {

				const objId = iDef.attributes.objectIds[ j ];

				for ( let p = 0; p < instanceDefinitionObjects.length; p ++ ) {

					const idoId = instanceDefinitionObjects[ p ].userData.attributes.id;

					if ( objId === idoId ) {

						objects.push( instanceDefinitionObjects[ p ] );

					}

				}

			}

			// Currently clones geometry and does not take advantage of instancing

			for ( let j = 0; j < instanceReferences.length; j ++ ) {

				const iRef = instanceReferences[ j ];

				if ( iRef.geometry.parentIdefId === iDef.attributes.id ) {

					const iRefObject = new Object3D();
					const xf = iRef.geometry.xform.array;

					const matrix = new Matrix4();
					matrix.set( ...xf );

					iRefObject.applyMatrix4( matrix );

					for ( let p = 0; p < objects.length; p ++ ) {

						iRefObject.add( objects[ p ].clone( true ) );

					}

					object.add( iRefObject );

				}

			}

		}

		object.userData[ 'materials' ] = this.materials;
		object.name = '';
		return object;

	}

	_createObject( obj, mat ) {

		const loader = new BufferGeometryLoader();

		const attributes = obj.attributes;

		let geometry, material, _color, color;

		switch ( obj.objectType ) {

			case 'Point':
			case 'PointSet':

				geometry = loader.parse( obj.geometry );

				if ( geometry.attributes.hasOwnProperty( 'color' ) ) {

					material = new PointsMaterial( { vertexColors: true, sizeAttenuation: false, size: 2 } );

				} else {

					_color = attributes.drawColor;
					color = new Color( _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 );
					material = new PointsMaterial( { color: color, sizeAttenuation: false, size: 2 } );

				}

				material = this._compareMaterials( material );

				const points = new Points( geometry, material );
				points.userData[ 'attributes' ] = attributes;
				points.userData[ 'objectType' ] = obj.objectType;

				if ( attributes.name ) {

					points.name = attributes.name;

				}

				return points;

			case 'Mesh':
			case 'Extrusion':
			case 'SubD':
			case 'Brep':

				if ( obj.geometry === null ) return;

				geometry = loader.parse( obj.geometry );


				if ( mat === null ) {

					mat = this._createMaterial();

				}


				if ( geometry.attributes.hasOwnProperty( 'color' ) ) {

					mat.vertexColors = true;

				}

				mat = this._compareMaterials( mat );

				const mesh = new Mesh( geometry, mat );
				mesh.castShadow = attributes.castsShadows;
				mesh.receiveShadow = attributes.receivesShadows;
				mesh.userData[ 'attributes' ] = attributes;
				mesh.userData[ 'objectType' ] = obj.objectType;

				if ( attributes.name ) {

					mesh.name = attributes.name;

				}

				return mesh;

			case 'Curve':

				geometry = loader.parse( obj.geometry );

				_color = attributes.drawColor;
				color = new Color( _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 );

				material = new LineBasicMaterial( { color: color } );
				material = this._compareMaterials( material );

				const lines = new Line$1( geometry, material );
				lines.userData[ 'attributes' ] = attributes;
				lines.userData[ 'objectType' ] = obj.objectType;

				if ( attributes.name ) {

					lines.name = attributes.name;

				}

				return lines;

			case 'TextDot':

				geometry = obj.geometry;

				const ctx = document.createElement( 'canvas' ).getContext( '2d' );
				const font = `${geometry.fontHeight}px ${geometry.fontFace}`;
				ctx.font = font;
				const width = ctx.measureText( geometry.text ).width + 10;
				const height = geometry.fontHeight + 10;

				const r = window.devicePixelRatio;

				ctx.canvas.width = width * r;
				ctx.canvas.height = height * r;
				ctx.canvas.style.width = width + 'px';
				ctx.canvas.style.height = height + 'px';
				ctx.setTransform( r, 0, 0, r, 0, 0 );

				ctx.font = font;
				ctx.textBaseline = 'middle';
				ctx.textAlign = 'center';
				color = attributes.drawColor;
				ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a})`;
				ctx.fillRect( 0, 0, width, height );
				ctx.fillStyle = 'white';
				ctx.fillText( geometry.text, width / 2, height / 2 );

				const texture = new CanvasTexture( ctx.canvas );
				texture.minFilter = LinearFilter;
				texture.generateMipmaps = false;
				texture.wrapS = ClampToEdgeWrapping;
				texture.wrapT = ClampToEdgeWrapping;

				material = new SpriteMaterial( { map: texture, depthTest: false } );
				const sprite = new Sprite$1( material );
				sprite.position.set( geometry.point[ 0 ], geometry.point[ 1 ], geometry.point[ 2 ] );
				sprite.scale.set( width / 10, height / 10, 1.0 );

				sprite.userData[ 'attributes' ] = attributes;
				sprite.userData[ 'objectType' ] = obj.objectType;

				if ( attributes.name ) {

					sprite.name = attributes.name;

				}

				return sprite;

			case 'Light':

				geometry = obj.geometry;

				let light;

				switch ( geometry.lightStyle.name ) {

					case 'LightStyle_WorldPoint':

						light = new PointLight();
						light.castShadow = attributes.castsShadows;
						light.position.set( geometry.location[ 0 ], geometry.location[ 1 ], geometry.location[ 2 ] );
						light.shadow.normalBias = 0.1;

						break;

					case 'LightStyle_WorldSpot':

						light = new SpotLight();
						light.castShadow = attributes.castsShadows;
						light.position.set( geometry.location[ 0 ], geometry.location[ 1 ], geometry.location[ 2 ] );
						light.target.position.set( geometry.direction[ 0 ], geometry.direction[ 1 ], geometry.direction[ 2 ] );
						light.angle = geometry.spotAngleRadians;
						light.shadow.normalBias = 0.1;

						break;

					case 'LightStyle_WorldRectangular':

						light = new RectAreaLight();
						const width = Math.abs( geometry.width[ 2 ] );
						const height = Math.abs( geometry.length[ 0 ] );
						light.position.set( geometry.location[ 0 ] - ( height / 2 ), geometry.location[ 1 ], geometry.location[ 2 ] - ( width / 2 ) );
						light.height = height;
						light.width = width;
						light.lookAt( geometry.direction[ 0 ], geometry.direction[ 1 ], geometry.direction[ 2 ] );

						break;

					case 'LightStyle_WorldDirectional':

						light = new DirectionalLight();
						light.castShadow = attributes.castsShadows;
						light.position.set( geometry.location[ 0 ], geometry.location[ 1 ], geometry.location[ 2 ] );
						light.target.position.set( geometry.direction[ 0 ], geometry.direction[ 1 ], geometry.direction[ 2 ] );
						light.shadow.normalBias = 0.1;

						break;

				}

				if ( light ) {

					light.intensity = geometry.intensity;
					_color = geometry.diffuse;
					color = new Color( _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 );
					light.color = color;
					light.userData[ 'attributes' ] = attributes;
					light.userData[ 'objectType' ] = obj.objectType;

				}

				return light;

		}

	}

	_initLibrary() {

		if ( ! this.libraryPending ) {

			// Load rhino3dm wrapper.
			const jsLoader = new FileLoader( this.manager );
			jsLoader.setPath( this.libraryPath );
			const jsContent = new Promise( ( resolve, reject ) => {

				jsLoader.load( 'rhino3dm.js', resolve, undefined, reject );

			} );

			// Load rhino3dm WASM binary.
			const binaryLoader = new FileLoader( this.manager );
			binaryLoader.setPath( this.libraryPath );
			binaryLoader.setResponseType( 'arraybuffer' );
			const binaryContent = new Promise( ( resolve, reject ) => {

				binaryLoader.load( 'rhino3dm.wasm', resolve, undefined, reject );

			} );

			this.libraryPending = Promise.all( [ jsContent, binaryContent ] )
				.then( ( [ jsContent, binaryContent ] ) => {

					//this.libraryBinary = binaryContent;
					this.libraryConfig.wasmBinary = binaryContent;

					const fn = Rhino3dmWorker.toString();

					const body = [
						'/* rhino3dm.js */',
						jsContent,
						'/* worker */',
						fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
					].join( '\n' );

					this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );

				} );

		}

		return this.libraryPending;

	}

	_getWorker( taskCost ) {

		return this._initLibrary().then( () => {

			if ( this.workerPool.length < this.workerLimit ) {

				const worker = new Worker( this.workerSourceURL );

				worker._callbacks = {};
				worker._taskCosts = {};
				worker._taskLoad = 0;

				worker.postMessage( {
					type: 'init',
					libraryConfig: this.libraryConfig
				} );

				worker.onmessage = e => {

					const message = e.data;

					switch ( message.type ) {

						case 'warning':
							this.warnings.push( message.data );
							console.warn( message.data );
							break;

						case 'decode':
							worker._callbacks[ message.id ].resolve( message );
							break;

						case 'error':
							worker._callbacks[ message.id ].reject( message );
							break;

						default:
							console.error( 'THREE.Rhino3dmLoader: Unexpected message, "' + message.type + '"' );

					}

				};

				this.workerPool.push( worker );

			} else {

				this.workerPool.sort( function ( a, b ) {

					return a._taskLoad > b._taskLoad ? -1 : 1;

				} );

			}

			const worker = this.workerPool[ this.workerPool.length - 1 ];

			worker._taskLoad += taskCost;

			return worker;

		} );

	}

	_releaseTask( worker, taskID ) {

		worker._taskLoad -= worker._taskCosts[ taskID ];
		delete worker._callbacks[ taskID ];
		delete worker._taskCosts[ taskID ];

	}

	dispose() {

		for ( let i = 0; i < this.workerPool.length; ++ i ) {

			this.workerPool[ i ].terminate();

		}

		this.workerPool.length = 0;

		return this;

	}

}

/* WEB WORKER */

function Rhino3dmWorker() {

	let libraryPending;
	let libraryConfig;
	let rhino;
	let taskID;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':

				libraryConfig = message.libraryConfig;
				const wasmBinary = libraryConfig.wasmBinary;
				let RhinoModule;
				libraryPending = new Promise( function ( resolve ) {

					/* Like Basis Loader */
					RhinoModule = { wasmBinary, onRuntimeInitialized: resolve };

					rhino3dm( RhinoModule ); // eslint-disable-line no-undef

				 } ).then( () => {

					rhino = RhinoModule;

				 } );

				break;

			case 'decode':

				taskID = message.id;
				const buffer = message.buffer;
				libraryPending.then( () => {

					try {

						const data = decodeObjects( rhino, buffer );
						self.postMessage( { type: 'decode', id: message.id, data } );

					} catch ( error ) {

						self.postMessage( { type: 'error', id: message.id, error } );

					}

				} );

				break;

		}

	};

	function decodeObjects( rhino, buffer ) {

		const arr = new Uint8Array( buffer );
		const doc = rhino.File3dm.fromByteArray( arr );

		const objects = [];
		const materials = [];
		const layers = [];
		const views = [];
		const namedViews = [];
		const groups = [];
		const strings = [];

		//Handle objects

		const objs = doc.objects();
		const cnt = objs.count;

		for ( let i = 0; i < cnt; i ++ ) {

			const _object = objs.get( i );

			const object = extractObjectData( _object, doc );

			_object.delete();

			if ( object ) {

				objects.push( object );

			}

		}

		// Handle instance definitions
		// console.log( `Instance Definitions Count: ${doc.instanceDefinitions().count()}` );

		for ( let i = 0; i < doc.instanceDefinitions().count; i ++ ) {

			const idef = doc.instanceDefinitions().get( i );
			const idefAttributes = extractProperties( idef );
			idefAttributes.objectIds = idef.getObjectIds();

			objects.push( { geometry: null, attributes: idefAttributes, objectType: 'InstanceDefinition' } );

		}

		// Handle materials

		const textureTypes = [
			// rhino.TextureType.Bitmap,
			rhino.TextureType.Diffuse,
			rhino.TextureType.Bump,
			rhino.TextureType.Transparency,
			rhino.TextureType.Opacity,
			rhino.TextureType.Emap
		];

		const pbrTextureTypes = [
			rhino.TextureType.PBR_BaseColor,
			rhino.TextureType.PBR_Subsurface,
			rhino.TextureType.PBR_SubsurfaceScattering,
			rhino.TextureType.PBR_SubsurfaceScatteringRadius,
			rhino.TextureType.PBR_Metallic,
			rhino.TextureType.PBR_Specular,
			rhino.TextureType.PBR_SpecularTint,
			rhino.TextureType.PBR_Roughness,
			rhino.TextureType.PBR_Anisotropic,
			rhino.TextureType.PBR_Anisotropic_Rotation,
			rhino.TextureType.PBR_Sheen,
			rhino.TextureType.PBR_SheenTint,
			rhino.TextureType.PBR_Clearcoat,
			rhino.TextureType.PBR_ClearcoatBump,
			rhino.TextureType.PBR_ClearcoatRoughness,
			rhino.TextureType.PBR_OpacityIor,
			rhino.TextureType.PBR_OpacityRoughness,
			rhino.TextureType.PBR_Emission,
			rhino.TextureType.PBR_AmbientOcclusion,
			rhino.TextureType.PBR_Displacement
		];

		for ( let i = 0; i < doc.materials().count; i ++ ) {

			const _material = doc.materials().get( i );

			const material = extractProperties( _material );

			const textures = [];

			textures.push( ...extractTextures( _material, textureTypes, doc ) );

			material.pbrSupported = _material.physicallyBased().supported;

			if ( material.pbrSupported ) {

				textures.push( ...extractTextures( _material, pbrTextureTypes, doc ) );
				material.pbr = extractProperties( _material.physicallyBased() );

			}

			material.textures = textures;

			materials.push( material );

			_material.delete();

		}

		// Handle layers

		for ( let i = 0; i < doc.layers().count; i ++ ) {

			const _layer = doc.layers().get( i );
			const layer = extractProperties( _layer );

			layers.push( layer );

			_layer.delete();

		}

		// Handle views

		for ( let i = 0; i < doc.views().count; i ++ ) {

			const _view = doc.views().get( i );
			const view = extractProperties( _view );

			views.push( view );

			_view.delete();

		}

		// Handle named views

		for ( let i = 0; i < doc.namedViews().count; i ++ ) {

			const _namedView = doc.namedViews().get( i );
			const namedView = extractProperties( _namedView );

			namedViews.push( namedView );

			_namedView.delete();

		}

		// Handle groups

		for ( let i = 0; i < doc.groups().count; i ++ ) {

			const _group = doc.groups().get( i );
			const group = extractProperties( _group );

			groups.push( group );

			_group.delete();

		}

		// Handle settings

		const settings = extractProperties( doc.settings() );

		//TODO: Handle other document stuff like dimstyles, instance definitions, bitmaps etc.

		// Handle dimstyles
		// console.log( `Dimstyle Count: ${doc.dimstyles().count()}` );

		// Handle bitmaps
		// console.log( `Bitmap Count: ${doc.bitmaps().count()}` );

		// Handle strings
		// console.log( `Document Strings Count: ${doc.strings().count()}` );
		// Note: doc.strings().documentUserTextCount() counts any doc.strings defined in a section
		// console.log( `Document User Text Count: ${doc.strings().documentUserTextCount()}` );

		const strings_count = doc.strings().count;

		for ( let i = 0; i < strings_count; i ++ ) {

			strings.push( doc.strings().get( i ) );

		}

		// Handle Render Environments for Material Environment

		// get the id of the active render environment skylight, which we'll use for environment texture
		const reflectionId = doc.settings().renderSettings().renderEnvironments.reflectionId;

		const rc = doc.renderContent();

		let renderEnvironment = null;

		for ( let i = 0; i < rc.count; i ++ ) {

			const content = rc.get( i );

			switch ( content.kind ) {

				case 'environment':

					const id = content.id;

					// there could be multiple render environments in a 3dm file
					if ( id !== reflectionId ) break;

					const renderTexture = content.findChild( 'texture' );
					const fileName = renderTexture.fileName;

					for ( let j = 0; j < doc.embeddedFiles().count; j ++ ) {

						const _fileName = doc.embeddedFiles().get( j ).fileName;

						if ( fileName === _fileName ) {

							const background = doc.getEmbeddedFileAsBase64( fileName );
							const backgroundImage = 'data:image/png;base64,' + background;
							renderEnvironment = { type: 'renderEnvironment', image: backgroundImage, name: fileName };

						}

					}

					break;

			}

		}

		// Handle Render Settings

		const renderSettings = {
			ambientLight: doc.settings().renderSettings().ambientLight,
			backgroundColorTop: doc.settings().renderSettings().backgroundColorTop,
			backgroundColorBottom: doc.settings().renderSettings().backgroundColorBottom,
			useHiddenLights: doc.settings().renderSettings().useHiddenLights,
			depthCue: doc.settings().renderSettings().depthCue,
			flatShade: doc.settings().renderSettings().flatShade,
			renderBackFaces: doc.settings().renderSettings().renderBackFaces,
			renderPoints: doc.settings().renderSettings().renderPoints,
			renderCurves: doc.settings().renderSettings().renderCurves,
			renderIsoParams: doc.settings().renderSettings().renderIsoParams,
			renderMeshEdges: doc.settings().renderSettings().renderMeshEdges,
			renderAnnotations: doc.settings().renderSettings().renderAnnotations,
			useViewportSize: doc.settings().renderSettings().useViewportSize,
			scaleBackgroundToFit: doc.settings().renderSettings().scaleBackgroundToFit,
			transparentBackground: doc.settings().renderSettings().transparentBackground,
			imageDpi: doc.settings().renderSettings().imageDpi,
			shadowMapLevel: doc.settings().renderSettings().shadowMapLevel,
			namedView: doc.settings().renderSettings().namedView,
			snapShot: doc.settings().renderSettings().snapShot,
			specificViewport: doc.settings().renderSettings().specificViewport,
			groundPlane: extractProperties( doc.settings().renderSettings().groundPlane ),
			safeFrame: extractProperties( doc.settings().renderSettings().safeFrame ),
			dithering: extractProperties( doc.settings().renderSettings().dithering ),
			skylight: extractProperties( doc.settings().renderSettings().skylight ),
			linearWorkflow: extractProperties( doc.settings().renderSettings().linearWorkflow ),
			renderChannels: extractProperties( doc.settings().renderSettings().renderChannels ),
			sun: extractProperties( doc.settings().renderSettings().sun ),
			renderEnvironments: extractProperties( doc.settings().renderSettings().renderEnvironments ),
			postEffects: extractProperties( doc.settings().renderSettings().postEffects ),

		};

		doc.delete();

		return { objects, materials, layers, views, namedViews, groups, strings, settings, renderSettings, renderEnvironment };

	}

	function extractTextures( m, tTypes, d ) {

		const textures = [];

		for ( let i = 0; i < tTypes.length; i ++ ) {

			const _texture = m.getTexture( tTypes[ i ] );
			if ( _texture ) {

				let textureType = tTypes[ i ].constructor.name;
				textureType = textureType.substring( 12, textureType.length );
				const texture = extractTextureData( _texture, textureType, d );
				textures.push( texture );
				_texture.delete();

			}

		}

		return textures;

	}

	function extractTextureData( t, tType, d ) {

		const texture = { type: tType };

		const image = d.getEmbeddedFileAsBase64( t.fileName );

		texture.wrapU = t.wrapU;
		texture.wrapV = t.wrapV;
		texture.wrapW = t.wrapW;
		const uvw = t.uvwTransform.toFloatArray( true );

		texture.repeat = [ uvw[ 0 ], uvw[ 5 ] ];

		if ( image ) {

			texture.image = 'data:image/png;base64,' + image;

		} else {

			self.postMessage( { type: 'warning', id: taskID, data: {
				message: `THREE.3DMLoader: Image for ${tType} texture not embedded in file.`,
				type: 'missing resource'
			}

			} );

			texture.image = null;

		}

		return texture;

	}

	function extractObjectData( object, doc ) {

		const _geometry = object.geometry();
		const _attributes = object.attributes();
		let objectType = _geometry.objectType;
		let geometry, attributes, position, data, mesh;

		// skip instance definition objects
		//if( _attributes.isInstanceDefinitionObject ) { continue; }

		// TODO: handle other geometry types
		switch ( objectType ) {

			case rhino.ObjectType.Curve:

				const pts = curveToPoints( _geometry, 100 );

				position = {};
				attributes = {};
				data = {};

				position.itemSize = 3;
				position.type = 'Float32Array';
				position.array = [];

				for ( let j = 0; j < pts.length; j ++ ) {

					position.array.push( pts[ j ][ 0 ] );
					position.array.push( pts[ j ][ 1 ] );
					position.array.push( pts[ j ][ 2 ] );

				}

				attributes.position = position;
				data.attributes = attributes;

				geometry = { data };

				break;

			case rhino.ObjectType.Point:

				const pt = _geometry.location;

				position = {};
				const color = {};
				attributes = {};
				data = {};

				position.itemSize = 3;
				position.type = 'Float32Array';
				position.array = [ pt[ 0 ], pt[ 1 ], pt[ 2 ] ];

				const _color = _attributes.drawColor( doc );

				color.itemSize = 3;
				color.type = 'Float32Array';
				color.array = [ _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 ];

				attributes.position = position;
				attributes.color = color;
				data.attributes = attributes;

				geometry = { data };

				break;

			case rhino.ObjectType.PointSet:
			case rhino.ObjectType.Mesh:

				geometry = _geometry.toThreejsJSON();

				break;

			case rhino.ObjectType.Brep:

				const faces = _geometry.faces();
				mesh = new rhino.Mesh();

				for ( let faceIndex = 0; faceIndex < faces.count; faceIndex ++ ) {

					const face = faces.get( faceIndex );
					const _mesh = face.getMesh( rhino.MeshType.Any );

					if ( _mesh ) {

						mesh.append( _mesh );
						_mesh.delete();

					}

					face.delete();

				}

				if ( mesh.faces().count > 0 ) {

					mesh.compact();
					geometry = mesh.toThreejsJSON();
					faces.delete();

				}

				mesh.delete();

				break;

			case rhino.ObjectType.Extrusion:

				mesh = _geometry.getMesh( rhino.MeshType.Any );

				if ( mesh ) {

					geometry = mesh.toThreejsJSON();
					mesh.delete();

				}

				break;

			case rhino.ObjectType.TextDot:

				geometry = extractProperties( _geometry );

				break;

			case rhino.ObjectType.Light:

				geometry = extractProperties( _geometry );

				if ( geometry.lightStyle.name === 'LightStyle_WorldLinear' ) {

					self.postMessage( { type: 'warning', id: taskID, data: {
						message: `THREE.3DMLoader: No conversion exists for ${objectType.constructor.name} ${geometry.lightStyle.name}`,
						type: 'no conversion',
						guid: _attributes.id
					}

					} );

				}

				break;

			case rhino.ObjectType.InstanceReference:

				geometry = extractProperties( _geometry );
				geometry.xform = extractProperties( _geometry.xform );
				geometry.xform.array = _geometry.xform.toFloatArray( true );

				break;

			case rhino.ObjectType.SubD:

				// TODO: precalculate resulting vertices and faces and warn on excessive results
				_geometry.subdivide( 3 );
				mesh = rhino.Mesh.createFromSubDControlNet( _geometry, false );
				if ( mesh ) {

					geometry = mesh.toThreejsJSON();
					mesh.delete();

				}

				break;

				/*
				case rhino.ObjectType.Annotation:
				case rhino.ObjectType.Hatch:
				case rhino.ObjectType.ClipPlane:
				*/

			default:

				self.postMessage( { type: 'warning', id: taskID, data: {
					message: `THREE.3DMLoader: Conversion not implemented for ${objectType.constructor.name}`,
					type: 'not implemented',
					guid: _attributes.id
				}

				} );

				break;

		}

		if ( geometry ) {

			attributes = extractProperties( _attributes );
			attributes.geometry = extractProperties( _geometry );

			if ( _attributes.groupCount > 0 ) {

				attributes.groupIds = _attributes.getGroupList();

			}

			if ( _attributes.userStringCount > 0 ) {

				attributes.userStrings = _attributes.getUserStrings();

			}

			if ( _geometry.userStringCount > 0 ) {

				attributes.geometry.userStrings = _geometry.getUserStrings();

			}

			if ( _attributes.decals().count > 0 ) {

				self.postMessage( { type: 'warning', id: taskID, data: {
					message: 'THREE.3DMLoader: No conversion exists for the decals associated with this object.',
					type: 'no conversion',
					guid: _attributes.id
				}

				} );

			}

			attributes.drawColor = _attributes.drawColor( doc );

			objectType = objectType.constructor.name;
			objectType = objectType.substring( 11, objectType.length );

			return { geometry, attributes, objectType };

		} else {

			self.postMessage( { type: 'warning', id: taskID, data: {
				message: `THREE.3DMLoader: ${objectType.constructor.name} has no associated mesh geometry.`,
				type: 'missing mesh',
				guid: _attributes.id
			}

			} );

		}

	}

	function extractProperties( object ) {

		const result = {};

		for ( const property in object ) {

			const value = object[ property ];

			if ( typeof value !== 'function' ) {

				if ( typeof value === 'object' && value !== null && value.hasOwnProperty( 'constructor' ) ) {

					result[ property ] = { name: value.constructor.name, value: value.value };

				} else if ( typeof value === 'object' && value !== null ) {

					result[ property ] = extractProperties( value );

				} else {

					result[ property ] = value;

				}

			}

		}

		return result;

	}

	function curveToPoints( curve, pointLimit ) {

		let pointCount = pointLimit;
		let rc = [];
		const ts = [];

		if ( curve instanceof rhino.LineCurve ) {

			return [ curve.pointAtStart, curve.pointAtEnd ];

		}

		if ( curve instanceof rhino.PolylineCurve ) {

			pointCount = curve.pointCount;
			for ( let i = 0; i < pointCount; i ++ ) {

				rc.push( curve.point( i ) );

			}

			return rc;

		}

		if ( curve instanceof rhino.PolyCurve ) {

			const segmentCount = curve.segmentCount;

			for ( let i = 0; i < segmentCount; i ++ ) {

				const segment = curve.segmentCurve( i );
				const segmentArray = curveToPoints( segment, pointCount );
				rc = rc.concat( segmentArray );
				segment.delete();

			}

			return rc;

		}

		if ( curve instanceof rhino.ArcCurve ) {

			pointCount = Math.floor( curve.angleDegrees / 5 );
			pointCount = pointCount < 2 ? 2 : pointCount;
			// alternative to this hardcoded version: https://stackoverflow.com/a/18499923/2179399

		}

		if ( curve instanceof rhino.NurbsCurve && curve.degree === 1 ) {

			const pLine = curve.tryGetPolyline();

			for ( let i = 0; i < pLine.count; i ++ ) {

				rc.push( pLine.get( i ) );

			}

			pLine.delete();

			return rc;

		}

		const domain = curve.domain;
		const divisions = pointCount - 1.0;

		for ( let j = 0; j < pointCount; j ++ ) {

			const t = domain[ 0 ] + ( j / divisions ) * ( domain[ 1 ] - domain[ 0 ] );

			if ( t === domain[ 0 ] || t === domain[ 1 ] ) {

				ts.push( t );
				continue;

			}

			const tan = curve.tangentAt( t );
			const prevTan = curve.tangentAt( ts.slice( -1 )[ 0 ] );

			// Duplicated from THREE.Vector3
			// How to pass imports to worker?

			const tS = tan[ 0 ] * tan[ 0 ] + tan[ 1 ] * tan[ 1 ] + tan[ 2 ] * tan[ 2 ];
			const ptS = prevTan[ 0 ] * prevTan[ 0 ] + prevTan[ 1 ] * prevTan[ 1 ] + prevTan[ 2 ] * prevTan[ 2 ];

			const denominator = Math.sqrt( tS * ptS );

			let angle;

			if ( denominator === 0 ) {

				angle = Math.PI / 2;

			} else {

				const theta = ( tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z ) / denominator;
				angle = Math.acos( Math.max( -1, Math.min( 1, theta ) ) );

			}

			if ( angle < 0.1 ) continue;

			ts.push( t );

		}

		rc = ts.map( t => curve.pointAt( t ) );
		return rc;

	}

}

// o object_name | g group_name
const _object_pattern = /^[og]\s*(.+)?/;
// mtllib file_reference
const _material_library_pattern = /^mtllib /;
// usemtl material_name
const _material_use_pattern = /^usemtl /;
// usemap map_name
const _map_use_pattern = /^usemap /;
const _face_vertex_data_separator_pattern = /\s+/;

const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();

const _ab = new Vector3();
const _cb = new Vector3();

const _color = new Color();

function ParserState() {

	const state = {
		objects: [],
		object: {},

		vertices: [],
		normals: [],
		colors: [],
		uvs: [],

		materials: {},
		materialLibraries: [],

		startObject: function ( name, fromDeclaration ) {

			// If the current object (initial from reset) is not from a g/o declaration in the parsed
			// file. We need to use it for the first parsed g/o to keep things in sync.
			if ( this.object && this.object.fromDeclaration === false ) {

				this.object.name = name;
				this.object.fromDeclaration = ( fromDeclaration !== false );
				return;

			}

			const previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

			this.object = {
				name: name || '',
				fromDeclaration: ( fromDeclaration !== false ),

				geometry: {
					vertices: [],
					normals: [],
					colors: [],
					uvs: [],
					hasUVIndices: false
				},
				materials: [],
				smooth: true,

				startMaterial: function ( name, libraries ) {

					const previous = this._finalize( false );

					// New usemtl declaration overwrites an inherited material, except if faces were declared
					// after the material, then it must be preserved for proper MultiMaterial continuation.
					if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

						this.materials.splice( previous.index, 1 );

					}

					const material = {
						index: this.materials.length,
						name: name || '',
						mtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
						smooth: ( previous !== undefined ? previous.smooth : this.smooth ),
						groupStart: ( previous !== undefined ? previous.groupEnd : 0 ),
						groupEnd: -1,
						groupCount: -1,
						inherited: false,

						clone: function ( index ) {

							const cloned = {
								index: ( typeof index === 'number' ? index : this.index ),
								name: this.name,
								mtllib: this.mtllib,
								smooth: this.smooth,
								groupStart: 0,
								groupEnd: -1,
								groupCount: -1,
								inherited: false
							};
							cloned.clone = this.clone.bind( cloned );
							return cloned;

						}
					};

					this.materials.push( material );

					return material;

				},

				currentMaterial: function () {

					if ( this.materials.length > 0 ) {

						return this.materials[ this.materials.length - 1 ];

					}

					return undefined;

				},

				_finalize: function ( end ) {

					const lastMultiMaterial = this.currentMaterial();
					if ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {

						lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
						lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
						lastMultiMaterial.inherited = false;

					}

					// Ignore objects tail materials if no face declarations followed them before a new o/g started.
					if ( end && this.materials.length > 1 ) {

						for ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {

							if ( this.materials[ mi ].groupCount <= 0 ) {

								this.materials.splice( mi, 1 );

							}

						}

					}

					// Guarantee at least one empty material, this makes the creation later more straight forward.
					if ( end && this.materials.length === 0 ) {

						this.materials.push( {
							name: '',
							smooth: this.smooth
						} );

					}

					return lastMultiMaterial;

				}
			};

			// Inherit previous objects material.
			// Spec tells us that a declared material must be set to all objects until a new material is declared.
			// If a usemtl declaration is encountered while this new object is being parsed, it will
			// overwrite the inherited material. Exception being that there was already face declarations
			// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

			if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {

				const declared = previousMaterial.clone( 0 );
				declared.inherited = true;
				this.object.materials.push( declared );

			}

			this.objects.push( this.object );

		},

		finalize: function () {

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

		},

		parseVertexIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},

		parseNormalIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},

		parseUVIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

		},

		addVertex: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addVertexPoint: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},

		addVertexLine: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},

		addNormal: function ( a, b, c ) {

			const src = this.normals;
			const dst = this.object.geometry.normals;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addFaceNormal: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.normals;

			_vA.fromArray( src, a );
			_vB.fromArray( src, b );
			_vC.fromArray( src, c );

			_cb.subVectors( _vC, _vB );
			_ab.subVectors( _vA, _vB );
			_cb.cross( _ab );

			_cb.normalize();

			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );

		},

		addColor: function ( a, b, c ) {

			const src = this.colors;
			const dst = this.object.geometry.colors;

			if ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			if ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			if ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addUV: function ( a, b, c ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;

			dst.push( src[ a + 0 ], src[ a + 1 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ] );

		},

		addDefaultUV: function () {

			const dst = this.object.geometry.uvs;

			dst.push( 0, 0 );
			dst.push( 0, 0 );
			dst.push( 0, 0 );

		},

		addUVLine: function ( a ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;

			dst.push( src[ a + 0 ], src[ a + 1 ] );

		},

		addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {

			const vLen = this.vertices.length;

			let ia = this.parseVertexIndex( a, vLen );
			let ib = this.parseVertexIndex( b, vLen );
			let ic = this.parseVertexIndex( c, vLen );

			this.addVertex( ia, ib, ic );
			this.addColor( ia, ib, ic );

			// normals

			if ( na !== undefined && na !== '' ) {

				const nLen = this.normals.length;

				ia = this.parseNormalIndex( na, nLen );
				ib = this.parseNormalIndex( nb, nLen );
				ic = this.parseNormalIndex( nc, nLen );

				this.addNormal( ia, ib, ic );

			} else {

				this.addFaceNormal( ia, ib, ic );

			}

			// uvs

			if ( ua !== undefined && ua !== '' ) {

				const uvLen = this.uvs.length;

				ia = this.parseUVIndex( ua, uvLen );
				ib = this.parseUVIndex( ub, uvLen );
				ic = this.parseUVIndex( uc, uvLen );

				this.addUV( ia, ib, ic );

				this.object.geometry.hasUVIndices = true;

			} else {

				// add placeholder values (for inconsistent face definitions)

				this.addDefaultUV();

			}

		},

		addPointGeometry: function ( vertices ) {

			this.object.geometry.type = 'Points';

			const vLen = this.vertices.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				const index = this.parseVertexIndex( vertices[ vi ], vLen );

				this.addVertexPoint( index );
				this.addColor( index );

			}

		},

		addLineGeometry: function ( vertices, uvs ) {

			this.object.geometry.type = 'Line';

			const vLen = this.vertices.length;
			const uvLen = this.uvs.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

			}

			for ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

				this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

			}

		}

	};

	state.startObject( '', false );

	return state;

}

//

class OBJLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.materials = null;

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	setMaterials( materials ) {

		this.materials = materials;

		return this;

	}

	parse( text ) {

		const state = new ParserState();

		if ( text.indexOf( '\r\n' ) !== -1 ) {

			// This is faster than String.split with regex that splits on both
			text = text.replace( /\r\n/g, '\n' );

		}

		if ( text.indexOf( '\\\n' ) !== -1 ) {

			// join lines separated by a line continuation character (\)
			text = text.replace( /\\\n/g, '' );

		}

		const lines = text.split( '\n' );
		let result = [];

		for ( let i = 0, l = lines.length; i < l; i ++ ) {

			const line = lines[ i ].trimStart();

			if ( line.length === 0 ) continue;

			const lineFirstChar = line.charAt( 0 );

			// @todo invoke passed in handler if any
			if ( lineFirstChar === '#' ) continue; // skip comments

			if ( lineFirstChar === 'v' ) {

				const data = line.split( _face_vertex_data_separator_pattern );

				switch ( data[ 0 ] ) {

					case 'v':
						state.vertices.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						if ( data.length >= 7 ) {

							_color.setRGB(
								parseFloat( data[ 4 ] ),
								parseFloat( data[ 5 ] ),
								parseFloat( data[ 6 ] ),
								SRGBColorSpace
							);

							state.colors.push( _color.r, _color.g, _color.b );

						} else {

							// if no colors are defined, add placeholders so color and vertex indices match

							state.colors.push( undefined, undefined, undefined );

						}

						break;
					case 'vn':
						state.normals.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						break;
					case 'vt':
						state.uvs.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] )
						);
						break;

				}

			} else if ( lineFirstChar === 'f' ) {

				const lineData = line.slice( 1 ).trim();
				const vertexData = lineData.split( _face_vertex_data_separator_pattern );
				const faceVertices = [];

				// Parse the face vertex data into an easy to work with format

				for ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {

					const vertex = vertexData[ j ];

					if ( vertex.length > 0 ) {

						const vertexParts = vertex.split( '/' );
						faceVertices.push( vertexParts );

					}

				}

				// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

				const v1 = faceVertices[ 0 ];

				for ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {

					const v2 = faceVertices[ j ];
					const v3 = faceVertices[ j + 1 ];

					state.addFace(
						v1[ 0 ], v2[ 0 ], v3[ 0 ],
						v1[ 1 ], v2[ 1 ], v3[ 1 ],
						v1[ 2 ], v2[ 2 ], v3[ 2 ]
					);

				}

			} else if ( lineFirstChar === 'l' ) {

				const lineParts = line.substring( 1 ).trim().split( ' ' );
				let lineVertices = [];
				const lineUVs = [];

				if ( line.indexOf( '/' ) === -1 ) {

					lineVertices = lineParts;

				} else {

					for ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {

						const parts = lineParts[ li ].split( '/' );

						if ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );
						if ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );

					}

				}

				state.addLineGeometry( lineVertices, lineUVs );

			} else if ( lineFirstChar === 'p' ) {

				const lineData = line.slice( 1 ).trim();
				const pointData = lineData.split( ' ' );

				state.addPointGeometry( pointData );

			} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {

				// o object_name
				// or
				// g group_name

				// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
				// let name = result[ 0 ].slice( 1 ).trim();
				const name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 );

				state.startObject( name );

			} else if ( _material_use_pattern.test( line ) ) {

				// material

				state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

			} else if ( _material_library_pattern.test( line ) ) {

				// mtl file

				state.materialLibraries.push( line.substring( 7 ).trim() );

			} else if ( _map_use_pattern.test( line ) ) {

				// the line is parsed but ignored since the loader assumes textures are defined MTL files
				// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)

				console.warn( 'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.' );

			} else if ( lineFirstChar === 's' ) {

				result = line.split( ' ' );

				// smooth shading

				// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
				// but does not define a usemtl for each face set.
				// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
				// This requires some care to not create extra material on each smooth value for "normal" obj files.
				// where explicit usemtl defines geometry groups.
				// Example asset: examples/models/obj/cerberus/Cerberus.obj

				/*
					 * http://paulbourke.net/dataformats/obj/
					 *
					 * From chapter "Grouping" Syntax explanation "s group_number":
					 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
					 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
					 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
					 * than 0."
					 */
				if ( result.length > 1 ) {

					const value = result[ 1 ].trim().toLowerCase();
					state.object.smooth = ( value !== '0' && value !== 'off' );

				} else {

					// ZBrush can produce "s" lines #11707
					state.object.smooth = true;

				}

				const material = state.object.currentMaterial();
				if ( material ) material.smooth = state.object.smooth;

			} else {

				// Handle null terminated files without exception
				if ( line === '\0' ) continue;

				console.warn( 'THREE.OBJLoader: Unexpected line: "' + line + '"' );

			}

		}

		state.finalize();

		const container = new Group();
		container.materialLibraries = [].concat( state.materialLibraries );

		const hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );

		if ( hasPrimitives === true ) {

			for ( let i = 0, l = state.objects.length; i < l; i ++ ) {

				const object = state.objects[ i ];
				const geometry = object.geometry;
				const materials = object.materials;
				const isLine = ( geometry.type === 'Line' );
				const isPoints = ( geometry.type === 'Points' );
				let hasVertexColors = false;

				// Skip o/g line declarations that did not follow with any faces
				if ( geometry.vertices.length === 0 ) continue;

				const buffergeometry = new BufferGeometry();

				buffergeometry.setAttribute( 'position', new Float32BufferAttribute( geometry.vertices, 3 ) );

				if ( geometry.normals.length > 0 ) {

					buffergeometry.setAttribute( 'normal', new Float32BufferAttribute( geometry.normals, 3 ) );

				}

				if ( geometry.colors.length > 0 ) {

					hasVertexColors = true;
					buffergeometry.setAttribute( 'color', new Float32BufferAttribute( geometry.colors, 3 ) );

				}

				if ( geometry.hasUVIndices === true ) {

					buffergeometry.setAttribute( 'uv', new Float32BufferAttribute( geometry.uvs, 2 ) );

				}

				// Create materials

				const createdMaterials = [];

				for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

					const sourceMaterial = materials[ mi ];
					const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
					let material = state.materials[ materialHash ];

					if ( this.materials !== null ) {

						material = this.materials.create( sourceMaterial.name );

						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if ( isLine && material && ! ( material instanceof LineBasicMaterial ) ) {

							const materialLine = new LineBasicMaterial();
							Material.prototype.copy.call( materialLine, material );
							materialLine.color.copy( material.color );
							material = materialLine;

						} else if ( isPoints && material && ! ( material instanceof PointsMaterial ) ) {

							const materialPoints = new PointsMaterial( { size: 10, sizeAttenuation: false } );
							Material.prototype.copy.call( materialPoints, material );
							materialPoints.color.copy( material.color );
							materialPoints.map = material.map;
							material = materialPoints;

						}

					}

					if ( material === undefined ) {

						if ( isLine ) {

							material = new LineBasicMaterial();

						} else if ( isPoints ) {

							material = new PointsMaterial( { size: 1, sizeAttenuation: false } );

						} else {

							material = new MeshPhongMaterial();

						}

						material.name = sourceMaterial.name;
						material.flatShading = sourceMaterial.smooth ? false : true;
						material.vertexColors = hasVertexColors;

						state.materials[ materialHash ] = material;

					}

					createdMaterials.push( material );

				}

				// Create mesh

				let mesh;

				if ( createdMaterials.length > 1 ) {

					for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

						const sourceMaterial = materials[ mi ];
						buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

					}

					if ( isLine ) {

						mesh = new LineSegments( buffergeometry, createdMaterials );

					} else if ( isPoints ) {

						mesh = new Points( buffergeometry, createdMaterials );

					} else {

						mesh = new Mesh( buffergeometry, createdMaterials );

					}

				} else {

					if ( isLine ) {

						mesh = new LineSegments( buffergeometry, createdMaterials[ 0 ] );

					} else if ( isPoints ) {

						mesh = new Points( buffergeometry, createdMaterials[ 0 ] );

					} else {

						mesh = new Mesh( buffergeometry, createdMaterials[ 0 ] );

					}

				}

				mesh.name = object.name;

				container.add( mesh );

			}

		} else {

			// if there is only the default parser state object with no geometry data, interpret data as point cloud

			if ( state.vertices.length > 0 ) {

				const material = new PointsMaterial( { size: 1, sizeAttenuation: false } );

				const buffergeometry = new BufferGeometry();

				buffergeometry.setAttribute( 'position', new Float32BufferAttribute( state.vertices, 3 ) );

				if ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {

					buffergeometry.setAttribute( 'color', new Float32BufferAttribute( state.colors, 3 ) );
					material.vertexColors = true;

				}

				const points = new Points( buffergeometry, material );
				container.add( points );

			}

		}

		return container;

	}

}

var __defProp$Q = Object.defineProperty;
var __defNormalProp$Q = (obj, key, value) => key in obj ? __defProp$Q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$Q = (obj, key, value) => __defNormalProp$Q(obj, typeof key !== "symbol" ? key + "" : key, value);
const DefaultLoadFun = {
  after: () => {
  },
  before: () => {
  },
  tail: () => {
  }
};
class AssetManager extends Component {
  constructor(options) {
    super(options);
    __publicField$Q(this, "loadingManager");
    __publicField$Q(this, "dracoLoader");
    __publicField$Q(this, "sdkUrl", "");
    __publicField$Q(this, "gLTFLoader");
    __publicField$Q(this, "textureLoader");
    __publicField$Q(this, "kTX2Loader");
    __publicField$Q(this, "startSubject", new Subject());
    __publicField$Q(this, "loadSubject", new Subject());
    __publicField$Q(this, "progressSubject", new Subject());
    __publicField$Q(this, "errorSubject", new Subject());
    __publicField$Q(this, "cubeTextureLoader");
    __publicField$Q(this, "rGBELoader");
    __publicField$Q(this, "eXRLoader");
    __publicField$Q(this, "hDRJPGLoader");
    __publicField$Q(this, "gainMapLoader");
    __publicField$Q(this, "fileLoader");
    __publicField$Q(this, "objectLoader");
    __publicField$Q(this, "tGALoader");
    __publicField$Q(this, "pDBLoader");
    __publicField$Q(this, "pCDLoader");
    __publicField$Q(this, "mMDLoader");
    __publicField$Q(this, "lUTCubeLoader");
    __publicField$Q(this, "lUT3dlLoader");
    __publicField$Q(this, "lDrawLoader");
    __publicField$Q(this, "rhino3dmLoader");
    __publicField$Q(this, "oBJLoader");
    __publicField$Q(this, "audioLoader");
    __publicField$Q(this, "dainLoader");
    __publicField$Q(this, "onStart", (url, loaded, total) => {
      this.startSubject.next({ url, loaded, total });
    });
    __publicField$Q(this, "onLoad", () => {
      this.loadSubject.next({});
    });
    __publicField$Q(this, "onProgress", (url, loaded, total) => {
      this.progressSubject.next({ url, loaded, total });
    });
    __publicField$Q(this, "onError", (url) => {
      this.errorSubject.next({ url });
    });
    this.loadingManager = new LoadingManager();
    this.loadingManager.onStart = this.onStart;
    this.loadingManager.onLoad = this.onLoad;
    this.loadingManager.onProgress = this.onProgress;
    this.loadingManager.onError = this.onError;
    this.addDrop();
    this.dracoLoader = new DRACOLoader(this.loadingManager);
    this.dracoLoader.setDecoderPath(`${this.sdkUrl}/libs/draco/`);
    this.dracoLoader.preload();
    this.textureLoader = new TextureLoader();
    this.kTX2Loader = new KTX2Loader();
    this.kTX2Loader.setTranscoderPath(`${this.sdkUrl}/libs/basis/`);
    this.kTX2Loader.detectSupport(this.viewer.renderManager.defaultWebGLRenderer);
    this.gLTFLoader = new GLTFLoader(this.loadingManager);
    this.gLTFLoader.setDRACOLoader(this.dracoLoader);
    this.gLTFLoader.setKTX2Loader(this.kTX2Loader);
    this.cubeTextureLoader = new CubeTextureLoader(this.loadingManager);
    this.rGBELoader = new RGBELoader(this.loadingManager);
    this.eXRLoader = new EXRLoader(this.loadingManager);
    this.hDRJPGLoader = new HDRJPGLoader();
    this.tGALoader = new TGALoader(this.loadingManager);
    this.gainMapLoader = new GainMapLoader();
    this.fileLoader = new FileLoader(this.loadingManager);
    this.objectLoader = new ObjectLoader(this.loadingManager);
    this.pDBLoader = new PDBLoader(this.loadingManager);
    this.pCDLoader = new PCDLoader(this.loadingManager);
    this.mMDLoader = new MMDLoader(this.loadingManager);
    this.lUTCubeLoader = new LUTCubeLoader(this.loadingManager);
    this.lUT3dlLoader = new LUT3dlLoader(this.loadingManager);
    this.lDrawLoader = new LDrawLoader(this.loadingManager);
    this.rhino3dmLoader = new Rhino3dmLoader(this.loadingManager);
    this.oBJLoader = new OBJLoader(this.loadingManager);
    this.audioLoader = new AudioLoader(this.loadingManager);
    this.cubeTextureLoader = new CubeTextureLoader(this.loadingManager);
    this.eXRLoader = new EXRLoader(this.loadingManager);
  }
  loadRGBE(asset, option = DefaultLoadFun) {
    return new Promise((resolve, reject) => {
      let loader = this.rGBELoader;
      const { before, after, tail } = option;
      if (loader) {
        let {
          url,
          result,
          name,
          file,
          fileReader,
          loadSubject,
          progressSubject,
          onLoad,
          onProgress,
          onError,
          loadFile
        } = asset;
        before && before(loader);
        if (!isNil(url)) {
          loader.load(url, onLoad, onProgress, onError);
        } else if (!isNil(file)) {
          loadFile((event) => {
            const contents = event.target?.result;
            if (!contents) return;
            const blobURL = URL.createObjectURL(new Blob([contents]));
            loader.load(blobURL, onLoad, onProgress, onError);
          });
        }
      }
    });
  }
  buildPromise(asset, fun) {
    const { loadSubject, errorSubject } = asset;
    return new Promise((resolve, reject) => {
      loadSubject.subscribe((value) => {
        resolve(value);
      });
      errorSubject.subscribe((error) => {
        reject(error);
      });
      fun && fun();
    });
  }
  loadTGA(asset, option = DefaultLoadFun) {
    return new Promise((resolve, reject) => {
      let loader = this.tGALoader;
      const { before, after, tail } = option;
      if (loader) {
        let {
          url,
          file,
          onLoad,
          onProgress,
          onError,
          loadFile
        } = asset;
        before && before(loader);
        if (!isNil(url)) {
          loader.load(url, onLoad, onProgress, onError);
        } else if (!isNil(file)) {
          loadFile((event) => {
            const contents = event.target?.result;
            if (!isString(contents)) return;
            loader.load(contents, onLoad, onProgress, onError);
          });
        }
      }
    });
  }
  loadKtx2(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.kTX2Loader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        name,
        file,
        onLoad,
        onProgress,
        onError,
        loadFile
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      } else if (!isNil(file)) {
        loadFile((event) => {
          const contents = event.target?.result;
          if (!contents) return;
          const blobURL = URL.createObjectURL(new Blob([contents]));
          loader.load(blobURL, onLoad, onProgress, onError);
        });
      }
    });
  }
  loadTexture(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.textureLoader;
      const { before, after, tail } = option;
      let {
        url,
        file,
        onLoad,
        onProgress,
        onError,
        loadFile
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      } else if (!isNil(file)) {
        loadFile((event) => {
          const contents = event.target?.result;
          if (!contents) return;
          const blobURL = URL.createObjectURL(new Blob([contents]));
          loader.load(blobURL, onLoad, onProgress, onError);
        });
      }
    });
  }
  loadGltf(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.gLTFLoader;
      const { before, after, tail } = option;
      let {
        url,
        name,
        file,
        loadSubject,
        onProgress,
        onError,
        loadFile
      } = asset;
      const loadFun = (data) => {
        if (data.scene) {
          data.scene.name = name;
          Object.assign(data, buildGraph(data.scene));
        }
        loadSubject.next(data.scene);
      };
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, loadFun, onProgress, onError);
      } else if (!isNil(file)) {
        loadFile((event) => {
          const contents = event.target?.result;
          if (!isNil(contents) && !isString(contents)) {
            loader.parseAsync(contents, "").then((res) => {
              loadFun(res);
            });
          }
        });
      }
    });
  }
  loadObject(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.objectLoader;
      const { before, after, tail } = option;
      let { url, result, loadSubject, onLoad, onProgress, onError } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      } else if (!isNil(result)) {
        loader.parse(
          result,
          (data) => {
            console.log("\u89E3\u6790\u5B8C\u6210");
            loadSubject.next(data);
          }
        );
      }
    });
  }
  loadPDB(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.pDBLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        onLoad,
        onProgress,
        onError,
        loadFile
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(
          url,
          onLoad,
          onProgress,
          onError
        );
      } else if (!isNil(result)) {
        loader.parse(result);
      }
    });
  }
  loadPCD(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.pCDLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        onLoad,
        onProgress,
        onError
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      } else if (!isNil(result)) {
        loader.parse(result);
      }
    });
  }
  loadMMD(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.mMDLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        name,
        file,
        fileReader,
        loadSubject,
        progressSubject,
        onLoad,
        onProgress,
        onError,
        loadFile
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      }
    });
  }
  loadLUTCube(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.lUTCubeLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        name,
        file,
        fileReader,
        loadSubject,
        progressSubject,
        onLoad,
        onProgress,
        onError,
        loadFile
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      }
    });
  }
  loadLUT3d(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.lUT3dlLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        name,
        file,
        fileReader,
        loadSubject,
        progressSubject,
        onLoad,
        onProgress,
        onError,
        loadFile
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      }
    });
  }
  loadLDraw(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.lDrawLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        onLoad,
        onProgress,
        onError,
        loadFile
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      }
    });
  }
  loadRhino3dm(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.rhino3dmLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        onLoad,
        onProgress,
        onError,
        loadFile
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      }
    });
  }
  loadOBJ(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.oBJLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        name,
        file,
        fileReader,
        loadSubject,
        progressSubject,
        onLoad,
        onProgress,
        onError,
        loadFile
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      }
    });
  }
  loadAudio(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.audioLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        onLoad,
        onProgress,
        onError
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      }
    });
  }
  loadCubeTexture(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.cubeTextureLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        onLoad,
        onProgress,
        onError
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      }
    });
  }
  loadEXR(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.eXRLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        onLoad,
        onProgress,
        onError
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      }
    });
  }
  loadFile(asset, option = DefaultLoadFun) {
    return this.buildPromise(asset, () => {
      let loader = this.eXRLoader;
      const { before, after, tail } = option;
      let {
        url,
        result,
        onLoad,
        onProgress,
        onError
      } = asset;
      before && before(loader);
      if (!isNil(url)) {
        loader.load(url, onLoad, onProgress, onError);
      }
    });
  }
  loadAsset(asset, option = DefaultLoadFun) {
    const extension = asset.extension;
    switch (extension) {
      case "object":
        return this.loadObject(asset, option);
      case "blob":
      case "zip":
        return this.loadFile(asset, option);
      case "tga":
        return this.loadTGA(asset, option);
      case "ktx2":
        return this.loadKtx2(asset, option);
      case "pdb":
        return this.loadPDB(asset, option);
      case "pcd":
        return this.loadPCD(asset, option);
      case "pmd":
        return this.loadMMD(asset, option);
      // case "cube":
      //     return this.lUTCubeLoad(asset, option)
      case "3dl":
        return this.loadLUT3d(asset, option);
      case "ldr":
      case "dat":
        return this.loadLDraw(asset, option);
      case "3dm":
        return this.loadRhino3dm(asset, option);
      case "obj":
        return this.loadOBJ(asset, option);
      case "ogg":
        return this.loadAudio(asset, option);
      case "gltf":
      case "glb":
        return this.loadGltf(asset, option);
      case "cube":
        return this.loadCubeTexture(asset, option);
      case "hdr":
      case "pic":
        return this.loadRGBE(asset, option);
      case "exr":
        return this.loadEXR(asset, option);
      case "jpg":
      case "png":
      case "jpeg":
        return this.loadTexture(asset, option);
      default:
        throw new Error(`\u65E0\u6CD5\u8BC6\u522B\u7684\u6587\u4EF6\u7C7B\u578B\uFF1A${extension}`);
    }
  }
  //------------------------- 离线文件加载 开始 -------------------
  // 注册拖放事件
  addDrop() {
    this.eventManager.dropSubject.subscribe((event) => {
    });
  }
  // 拖动事件
  dragHandler(event) {
    const items = event.dataTransfer.items;
    const files = event.dataTransfer.files;
    if (items) {
      this.loadItemList(items, this.loadDragFile);
    } else {
      this.loadFiles(files, this.loadDragFile);
    }
  }
  // 定义函数getFilesFromItemList，用于从DataTransferItemList中获取文件相关信息
  // 参数items是要处理的DataTransferItemList对象，包含了拖放操作等传递过来的文件或目录相关条目
  // 参数onDone是一个回调函数，当所有文件处理完成后会被调用，接收处理后的文件数组和文件映射作为参数
  getFilesFromItemList(items, onDone) {
    let itemsCount = 0;
    let itemsTotal = 0;
    const files = [];
    const filesMap = /* @__PURE__ */ new Map();
    const onEntryHandled = () => {
      itemsCount++;
      if (itemsCount === itemsTotal) {
        onDone(files, filesMap);
      }
    };
    const handleEntry = (entry) => {
      if (entry === null) {
        return;
      }
      if (entry.isDirectory) {
        const reader = entry.createReader();
        reader.readEntries((entries) => {
          for (let i = 0; i < entries.length; i++) {
            handleEntry(entries[i]);
          }
          onEntryHandled();
        });
      } else if (entry.isFile) {
        entry.file((file) => {
          files.push(file);
          filesMap.set(entry.fullPath.slice(1), file);
          onEntryHandled();
        });
      }
      itemsTotal++;
    };
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (item.kind === "file") {
        handleEntry(item.webkitGetAsEntry());
      }
    }
  }
  // 定义函数loadItemList，用于加载给定的DataTransferItemList中的文件信息
  // 参数items是要加载的DataTransferItemList，它包含了通过拖放等操作传递过来的文件相关条目
  loadItemList(items, callbackFun) {
    this.getFilesFromItemList(items, (files, filesMap) => {
      this.loadFiles(files, callbackFun, filesMap);
    });
  }
  // 定义函数loadFiles，用于加载给定的文件数组以及可选的文件映射中的文件信息
  // 参数files是要加载的文件数组，每个元素都是一个File对象
  // 参数filesMap是一个可选的文件路径到文件对象的映射，用于更方便地根据路径查找文件
  loadFiles(files, callbackFun, filesMap) {
    const getMap = () => {
      const map = /* @__PURE__ */ new Map();
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        map.set(file.name, file);
      }
      return map;
    };
    if (files.length > 0) {
      const map = filesMap ?? getMap();
      for (const [value, mapElement] of map) {
        this.loadDragFile(mapElement);
      }
    }
  }
  formatNumber(number) {
    return new Intl.NumberFormat("en-us", { useGrouping: true }).format(number);
  }
  loadDragFile(file, manager) {
    const filename = file.name;
    const splitArray = filename.split(".");
    const extension = splitArray.pop()?.toLowerCase();
    switch (extension) {
      case "gltf":
      case "glb":
        const asset = new Asset({
          name: filename,
          file,
          extension
        });
        this.loadGltf(asset).then((gltf) => {
          this.scene.add(gltf);
          this.editor.editorEventManager.sceneGraphChanged.next(true);
        });
        break;
    }
  }
  //------------------------- 离线文件加载 结束 -------------------
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var stats_min$1 = {exports: {}};

var stats_min = stats_min$1.exports;

var hasRequiredStats_min;

function requireStats_min () {
	if (hasRequiredStats_min) return stats_min$1.exports;
	hasRequiredStats_min = 1;
	(function (module, exports) {
		// stats.js - http://github.com/mrdoob/stats.js
		(function(f,e){module.exports=e();})(stats_min,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a;}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
		u(++l%c.children.length);},false);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return {REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now();},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/
		1048576,d.jsHeapSizeLimit/1048576);}return c},update:function(){k=this.end();},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
		b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return {dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p));}}};return f}); 
	} (stats_min$1));
	return stats_min$1.exports;
}

var stats_minExports = requireStats_min();
var Stats = /*@__PURE__*/getDefaultExportFromCjs(stats_minExports);

var __defProp$P = Object.defineProperty;
var __typeError$2 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp$P = (obj, key, value) => key in obj ? __defProp$P(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$P = (obj, key, value) => __defNormalProp$P(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck$1 = (obj, member, msg) => member.has(obj) || __typeError$2("Cannot " + msg);
var __privateGet$1 = (obj, member, getter) => (__accessCheck$1(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$2 = (obj, member, value) => member.has(obj) ? __typeError$2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$1 = (obj, member, value, setter) => (__accessCheck$1(obj, member, "write to private field"), member.set(obj, value), value);
var _enable;
var DebugPosition = /* @__PURE__ */ ((DebugPosition2) => {
  DebugPosition2[DebugPosition2["TopLeft"] = 0] = "TopLeft";
  DebugPosition2[DebugPosition2["TopRight"] = 1] = "TopRight";
  DebugPosition2[DebugPosition2["BottomLeft"] = 2] = "BottomLeft";
  DebugPosition2[DebugPosition2["BottomRight"] = 3] = "BottomRight";
  return DebugPosition2;
})(DebugPosition || {});
class DebugManager extends Component {
  constructor(options) {
    super(options);
    __publicField$P(this, "stats");
    __publicField$P(this, "subscription");
    __privateAdd$2(this, _enable, false);
    this.options = deepMergeRetain$1(options, {
      showFps: true,
      showMs: true,
      showMb: true,
      position: 2 /* BottomLeft */
    });
  }
  get enable() {
    return __privateGet$1(this, _enable);
  }
  set enable(value) {
    if (value) {
      if (!this.stats) {
        this.stats = new Stats();
        this.setStats();
        this.stats.dom.style.position = "absolute";
        this.setPosition(this.options.position);
        this.addToDom();
      }
      if (!this.subscription) {
        this.subscription = this.eventManager.renderSubject.subscribe(() => {
          this.update();
        });
      }
    } else {
      if (this.subscription) {
        this.subscription.unsubscribe();
        this.subscription = void 0;
      }
      if (this.stats) {
        this.dispose();
      }
    }
    __privateSet$1(this, _enable, value);
  }
  setStats() {
    if (!this.stats) return;
    const getElement = (index) => {
      return this.stats.dom.children[index];
    };
    if (this.options.showFps) {
      getElement(0).style.display = "block";
    } else {
      getElement(0).style.display = "none";
    }
    if (this.options.showMs) {
      getElement(1).style.display = "block";
    } else {
      getElement(1).style.display = "none";
    }
    if (this.options.showMb) {
      getElement(2).style.display = "block";
    } else {
      getElement(2).style.display = "none";
    }
  }
  setPosition(value) {
    if (!this.stats) return;
    this.stats.dom.style.left = "";
    this.stats.dom.style.top = "";
    this.stats.dom.style.right = "";
    this.stats.dom.style.bottom = "";
    switch (value) {
      case 0 /* TopLeft */:
        this.stats.dom.style.left = "0px";
        this.stats.dom.style.top = "0px";
        break;
      case 1 /* TopRight */:
        this.stats.dom.style.right = "0px";
        this.stats.dom.style.top = "0px";
        break;
      case 2 /* BottomLeft */:
        this.stats.dom.style.left = "0px";
        this.stats.dom.style.bottom = "0px";
        break;
      case 3 /* BottomRight */:
        this.stats.dom.style.right = "0px";
        this.stats.dom.style.bottom = "0px";
        break;
    }
  }
  addToDom() {
    if (!this.stats) return;
    const container = this.viewer.container;
    container.appendChild(this.stats.dom);
  }
  update() {
    if (!this.stats) return;
    this.stats.update();
  }
  dispose() {
    if (!this.stats) return;
    const container = this.viewer.container;
    container.removeChild(this.stats.dom);
    this.stats = void 0;
  }
}
_enable = new WeakMap();

var __defProp$O = Object.defineProperty;
var __defNormalProp$O = (obj, key, value) => key in obj ? __defProp$O(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$O = (obj, key, value) => __defNormalProp$O(obj, typeof key !== "symbol" ? key + "" : key, value);
class EventManager extends Component {
  constructor(options) {
    super(options);
    __publicField$O(this, "dblClickSubject", new Subject());
    // 容器重置
    __publicField$O(this, "resizeSubject", new Subject());
    // 每次渲染更新时候触发
    __publicField$O(this, "renderSubject", new Subject());
    // 对外暴露的点击事件
    __publicField$O(this, "clickSubject", new Subject());
    // div 原生的点击事件
    __publicField$O(this, "domClickSubject", new Subject());
    __publicField$O(this, "dragoverSubject", new Subject());
    __publicField$O(this, "dropSubject", new Subject());
    // 记录 点击事件的位置
    __publicField$O(this, "onLeftDownPosition", new THREE$2.Vector2());
    __publicField$O(this, "onLeftUpPosition", new THREE$2.Vector2());
    __publicField$O(this, "onRightDownPosition", new THREE$2.Vector2());
    __publicField$O(this, "onRightUpPosition", new THREE$2.Vector2());
    // 排除拖动的点击事件
    __publicField$O(this, "leftClickSubject", new Subject());
    __publicField$O(this, "rightClickSubject", new Subject());
    __publicField$O(this, "pointerMoveSubject", new Subject());
    // 射线检测后点击事件
    __publicField$O(this, "leftClickPickSubject", new Subject());
    __publicField$O(this, "rightClickPickSubject", new Subject());
    __publicField$O(this, "dblClickPickSubject", new Subject());
    // 鼠标移动事件, 经过射线检测
    __publicField$O(this, "pointerMovePickSubject", new Subject());
    this.initializeEventListeners();
  }
  initializeEventListeners() {
    const click = fromEvent(this.container, "click");
    const dblClick = fromEvent(this.container, "dblclick");
    const rightClick = fromEvent(this.container, "contextmenu");
    const resize = fromEvent(window, "resize");
    const dragover = fromEvent(this.container, "dragover");
    const drop = fromEvent(this.container, "drop");
    const pointermove = fromEvent(this.container, "pointermove");
    pointermove.subscribe((event) => {
      this.pointerMoveSubject.next(event);
    });
    const pointerdown = fromEvent(this.container, "pointerdown");
    pointerdown.subscribe((event) => {
      const array = Tool$1.getMousePosition(event, this.container);
      if (event.button === 0) {
        this.onLeftDownPosition.fromArray(array);
      } else if (event.button === 2) {
        this.onRightDownPosition.fromArray(array);
      }
    });
    const pointerup = fromEvent(this.container, "pointerup");
    pointerup.subscribe((event) => {
      const array = Tool$1.getMousePosition(event, this.container);
      if (event.button === 0) {
        this.onLeftUpPosition.fromArray(array);
        if (this.onLeftDownPosition.distanceTo(this.onLeftUpPosition) === 0) {
          this.leftClickSubject.next(event);
        }
      } else if (event.button === 2) {
        this.onRightUpPosition.fromArray(array);
        if (this.onRightDownPosition.distanceTo(this.onRightUpPosition) === 0) {
          this.rightClickSubject.next(event);
        }
      }
    });
    dblClick.subscribe((event) => {
      this.dblClickSubject.next(event);
    });
    dragover.subscribe((event) => {
      event.preventDefault();
      event.dataTransfer.dropEffect = "copy";
      this.dragoverSubject.next(event);
    });
    drop.subscribe((event) => {
      {
        event.preventDefault();
        this.dropSubject.next(event);
      }
    });
    click.subscribe((event) => {
      this.domClickSubject.next(event);
    });
    rightClick.subscribe((event) => {
      event.preventDefault();
      this.rightClickSubject.next(event);
    });
    resize.subscribe((event) => {
      this.resizeSubject.next(true);
    });
  }
}

class HelperManager extends Component {
  constructor(options) {
    super(options);
  }
  addGridHelper(size, divisions) {
    const gridHelper = new THREE$2.GridHelper(size, divisions);
    this.viewer.scene.add(gridHelper);
  }
  addAxesHelper(size) {
    const axesHelper = new THREE$2.AxesHelper(size);
    this.viewer.scene.add(axesHelper);
  }
  addCameraHelper(camera = this.viewer.cameraManager.perspectiveCamera) {
    const cameraHelper = new THREE$2.CameraHelper(camera);
    this.viewer.scene.add(cameraHelper);
  }
  addSkeletonHelper(object) {
    const skeletonHelper = new THREE$2.SkeletonHelper(object);
    this.viewer.scene.add(skeletonHelper);
  }
}

var __defProp$N = Object.defineProperty;
var __defNormalProp$N = (obj, key, value) => key in obj ? __defProp$N(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$N = (obj, key, value) => __defNormalProp$N(obj, typeof key !== "symbol" ? key + "" : key, value);
class Loop extends Component {
  constructor(options) {
    super(options);
    __publicField$N(this, "globalEffects", /* @__PURE__ */ new Set());
    __publicField$N(this, "globalAfterEffects", /* @__PURE__ */ new Set());
    __publicField$N(this, "globalTailEffects", /* @__PURE__ */ new Set());
    __publicField$N(this, "running", false);
    __publicField$N(this, "useFrameInProgress", false);
    __publicField$N(this, "repeat", 0);
    __publicField$N(this, "frame", 0);
    __publicField$N(this, "startTime", 0);
    __publicField$N(this, "endTime", 0);
    __publicField$N(this, "renderTime", 0);
    // 每次渲染完成后触发
    __publicField$N(this, "sceneRendered", new Subject());
    __publicField$N(this, "addEffect", (callback) => {
      this.globalEffects.add(callback);
    });
    __publicField$N(this, "addAfterEffect", (callback) => {
      this.globalAfterEffects.add(callback);
    });
    __publicField$N(this, "addTail", (callback) => {
      this.globalTailEffects.add(callback);
    });
    /**
     * 循环函数
     * @param timestamp 时间戳
     */
    __publicField$N(this, "frameLoop", (timestamp) => {
      try {
        this.frame = requestAnimationFrame(this.frameLoop);
        this.startTime = performance.now();
        this.running = true;
        this.repeat = 0;
        this.flushGlobalEffects("before", timestamp);
        const clock = this.viewer.clock;
        const delta = clock.getDelta();
        const cameraControls = this.cameraManager.cameraControls;
        const updated = cameraControls.update(delta);
        if (this.postProcessingComponent.enable) {
          this.postProcessingComponent.render(timestamp);
        } else {
          this.renderManager.render(timestamp);
        }
        this.cssRenderer.render();
        this.eventManager.renderSubject.next(timestamp);
        this.flushGlobalEffects("after", timestamp);
        this.endTime = performance.now();
        this.renderTime = this.endTime - this.startTime;
        this.sceneRendered.next(this.renderTime);
      } catch (e) {
      }
    });
    /**
     * 开始循环
     */
    __publicField$N(this, "startLoop", () => {
      this.running = true;
      this.frame = requestAnimationFrame(this.frameLoop);
    });
    /**
     * 停止循环
     */
    __publicField$N(this, "stopLoop", () => {
      this.running = false;
      return cancelAnimationFrame(this.frame);
    });
  }
  flushGlobalEffects(type, timestamp) {
    switch (type) {
      case "before":
        this.run(this.globalEffects, timestamp);
        break;
      case "after":
        this.run(this.globalAfterEffects, timestamp);
        break;
      case "tail":
        this.run(this.globalTailEffects, timestamp);
        break;
    }
  }
  /**
   *  执行全局回调
   * @param effects
   * @param timestamp
   */
  run(effects, timestamp) {
    if (!effects.size) return;
    for (const callback of effects.values()) {
      callback({
        viewer: this.viewer
      });
    }
  }
}

var __defProp$M = Object.defineProperty;
var __defNormalProp$M = (obj, key, value) => key in obj ? __defProp$M(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$M = (obj, key, value) => __defNormalProp$M(obj, key + "" , value);
class RenderManager extends Component {
  constructor(options) {
    super(options);
    __publicField$M(this, "defaultWebGLRenderer");
    this.defaultWebGLRenderer = this.createWebGLRenderer();
  }
  setSize(width, height, updateStyle) {
    this.defaultWebGLRenderer.setSize(width, height, updateStyle);
  }
  createWebGLRenderer() {
    const webGLRenderer = new WebGLRenderer({
      powerPreference: "high-performance",
      // alpha: true,
      antialias: true,
      stencil: false,
      depth: true
    });
    webGLRenderer.outputColorSpace = SRGBColorSpace;
    webGLRenderer.debug.checkShaderErrors = true;
    console.log(webGLRenderer);
    return webGLRenderer;
  }
  initAnimate() {
    this.defaultWebGLRenderer.setAnimationLoop(this.animate.bind(this));
  }
  animate() {
    const clock = this.viewer.clock;
    clock.getDelta();
  }
  render(timestamp) {
    this.viewer.scene;
    this.viewer.eventManager;
    const clock = this.viewer.clock;
    clock.getDelta();
    this.defaultWebGLRenderer.render(this.scene, this.camera);
    if (this.sceneHelpers.visible) {
      this.defaultWebGLRenderer.render(this.sceneHelpers, this.camera);
    }
  }
}

/**
 * postprocessing v6.37.1 build Thu Mar 06 2025
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2025 Raoul van Rüschen
 * @license Zlib
 */


// src/core/Timer.js
var MILLISECONDS_TO_SECONDS = 1 / 1e3;
var SECONDS_TO_MILLISECONDS = 1e3;
var Timer = class {
  /**
   * Constructs a new timer.
   */
  constructor() {
    this.startTime = performance.now();
    this.previousTime = 0;
    this.currentTime = 0;
    this._delta = 0;
    this._elapsed = 0;
    this._fixedDelta = 1e3 / 60;
    this.timescale = 1;
    this.useFixedDelta = false;
    this._autoReset = false;
  }
  /**
   * Enables or disables auto reset based on page visibility.
   *
   * If enabled, the timer will be reset when the page becomes visible. This effectively pauses the timer when the page
   * is hidden. Has no effect if the API is not supported.
   *
   * @type {Boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API
   */
  get autoReset() {
    return this._autoReset;
  }
  set autoReset(value) {
    if (typeof document !== "undefined" && document.hidden !== void 0) {
      if (value) {
        document.addEventListener("visibilitychange", this);
      } else {
        document.removeEventListener("visibilitychange", this);
      }
      this._autoReset = value;
    }
  }
  get delta() {
    return this._delta * MILLISECONDS_TO_SECONDS;
  }
  get fixedDelta() {
    return this._fixedDelta * MILLISECONDS_TO_SECONDS;
  }
  set fixedDelta(value) {
    this._fixedDelta = value * SECONDS_TO_MILLISECONDS;
  }
  get elapsed() {
    return this._elapsed * MILLISECONDS_TO_SECONDS;
  }
  /**
   * Updates this timer.
   *
   * @param {Boolean} [timestamp] - The current time in milliseconds.
   */
  update(timestamp) {
    if (this.useFixedDelta) {
      this._delta = this.fixedDelta;
    } else {
      this.previousTime = this.currentTime;
      this.currentTime = (timestamp !== void 0 ? timestamp : performance.now()) - this.startTime;
      this._delta = this.currentTime - this.previousTime;
    }
    this._delta *= this.timescale;
    this._elapsed += this._delta;
  }
  /**
   * Resets this timer.
   */
  reset() {
    this._delta = 0;
    this._elapsed = 0;
    this.currentTime = performance.now() - this.startTime;
  }
  getDelta() {
    return this.delta;
  }
  getElapsed() {
    return this.elapsed;
  }
  handleEvent(e) {
    if (!document.hidden) {
      this.currentTime = performance.now() - this.startTime;
    }
  }
  dispose() {
    this.autoReset = false;
  }
};
var fullscreenGeometry = /* @__PURE__ */ (() => {
  const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
  const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", new BufferAttribute(vertices, 3));
  geometry.setAttribute("uv", new BufferAttribute(uvs, 2));
  return geometry;
})();
var Pass = class _Pass {
  /**
   * A shared fullscreen triangle.
   *
   * The screen size is 2x2 units (NDC). A triangle needs to be 4x4 units to fill the screen.
   * @see https://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/
   * @type {BufferGeometry}
   * @internal
   */
  static get fullscreenGeometry() {
    return fullscreenGeometry;
  }
  /**
   * Constructs a new pass.
   *
   * @param {String} [name] - The name of this pass. Does not have to be unique.
   * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.
   * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.
   */
  constructor(name = "Pass", scene = new Scene(), camera = new Camera()) {
    this.name = name;
    this.renderer = null;
    this.scene = scene;
    this.camera = camera;
    this.screen = null;
    this.rtt = true;
    this.needsSwap = true;
    this.needsDepthTexture = false;
    this.enabled = true;
  }
  /**
   * Sets the render to screen flag.
   *
   * If this flag is changed, the fullscreen material will be updated as well.
   *
   * @type {Boolean}
   */
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(value) {
    if (this.rtt === value) {
      const material = this.fullscreenMaterial;
      if (material !== null) {
        material.needsUpdate = true;
      }
      this.rtt = !value;
    }
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Sets the renderer
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Indicates whether this pass is enabled.
   *
   * @deprecated Use enabled instead.
   * @return {Boolean} Whether this pass is enabled.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables this pass.
   *
   * @deprecated Use enabled instead.
   * @param {Boolean} value - Whether the pass should be enabled.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * The fullscreen material.
   *
   * @type {Material}
   */
  get fullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  set fullscreenMaterial(value) {
    let screen = this.screen;
    if (screen !== null) {
      screen.material = value;
    } else {
      screen = new Mesh(_Pass.fullscreenGeometry, value);
      screen.frustumCulled = false;
      if (this.scene === null) {
        this.scene = new Scene();
      }
      this.scene.add(screen);
      this.screen = screen;
    }
  }
  /**
   * Returns the current fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @return {Material} The current fullscreen material, or null if there is none.
   */
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  /**
   * Sets the fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @protected
   * @param {Material} value - A fullscreen material.
   */
  setFullscreenMaterial(value) {
    this.fullscreenMaterial = value;
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return null;
  }
  /**
   * Sets the depth texture.
   *
   * This method will be called automatically by the {@link EffectComposer}.
   * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategy} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  /**
   * Renders this pass.
   *
   * This is an abstract method that must be overridden.
   *
   * @abstract
   * @throws {Error} An error is thrown if the method is not overridden.
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    throw new Error("Render method not implemented!");
  }
  /**
   * Sets the size.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when this pass is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for disposable properties and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free
   * memory when you're certain that you don't need this pass anymore.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof _Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
    if (this.fullscreenMaterial !== null) {
      this.fullscreenMaterial.dispose();
    }
  }
};

// src/passes/ClearMaskPass.js
var ClearMaskPass = class extends Pass {
  /**
   * Constructs a new clear mask pass.
   */
  constructor() {
    super("ClearMaskPass", null, null);
    this.needsSwap = false;
  }
  /**
   * Disables the global stencil test.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const stencil = renderer.state.buffers.stencil;
    stencil.setLocked(false);
    stencil.setTest(false);
  }
};

// src/materials/glsl/copy.frag
var copy_default = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}";

// src/materials/glsl/common.vert
var common_default = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/CopyMaterial.js
var CopyMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new copy material.
   */
  constructor() {
    super({
      name: "CopyMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        opacity: new Uniform(1)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: copy_default,
      vertexShader: common_default
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Number} value - The buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Returns the opacity.
   *
   * @deprecated Use opacity instead.
   * @return {Number} The opacity.
   */
  getOpacity(value) {
    return this.uniforms.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @deprecated Use opacity instead.
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.uniforms.opacity.value = value;
  }
};

// src/passes/CopyPass.js
var CopyPass = class extends Pass {
  /**
   * Constructs a new save pass.
   *
   * @param {WebGLRenderTarget} [renderTarget] - A render target.
   * @param {Boolean} [autoResize=true] - Whether the render target size should be updated automatically.
   */
  constructor(renderTarget, autoResize = true) {
    super("CopyPass");
    this.fullscreenMaterial = new CopyMaterial();
    this.needsSwap = false;
    this.renderTarget = renderTarget;
    if (renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      });
      this.renderTarget.texture.name = "CopyPass.Target";
    }
    this.autoResize = autoResize;
  }
  /**
   * Enables or disables auto resizing of the render target.
   *
   * @deprecated Use autoResize instead.
   * @type {Boolean}
   */
  get resize() {
    return this.autoResize;
  }
  set resize(value) {
    this.autoResize = value;
  }
  /**
   * The output texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the output texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Enables or disables auto resizing of the render target.
   *
   * @deprecated Use autoResize instead.
   * @param {Boolean} value - Whether the render target size should be updated automatically.
   */
  setAutoResizeEnabled(value) {
    this.autoResize = value;
  }
  /**
   * Saves the input buffer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    this.fullscreenMaterial.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    if (this.autoResize) {
      this.renderTarget.setSize(width, height);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
};
var color$2 = /* @__PURE__ */ new Color();
var ClearPass = class extends Pass {
  /**
   * Constructs a new clear pass.
   *
   * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.
   * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.
   * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.
   */
  constructor(color2 = true, depth = true, stencil = false) {
    super("ClearPass", null, null);
    this.needsSwap = false;
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
    this.overrideClearColor = null;
    this.overrideClearAlpha = -1;
  }
  /**
   * Sets the clear flags.
   *
   * @param {Boolean} color - Whether the color buffer should be cleared.
   * @param {Boolean} depth - Whether the depth buffer should be cleared.
   * @param {Boolean} stencil - Whether the stencil buffer should be cleared.
   */
  setClearFlags(color2, depth, stencil) {
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
  }
  /**
   * Returns the override clear color. Default is null.
   *
   * @deprecated Use overrideClearColor instead.
   * @return {Color} The clear color.
   */
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  /**
   * Sets the override clear color.
   *
   * @deprecated Use overrideClearColor instead.
   * @param {Color} value - The clear color.
   */
  setOverrideClearColor(value) {
    this.overrideClearColor = value;
  }
  /**
   * Returns the override clear alpha. Default is -1.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @return {Number} The clear alpha.
   */
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  /**
   * Sets the override clear alpha.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @param {Number} value - The clear alpha.
   */
  setOverrideClearAlpha(value) {
    this.overrideClearAlpha = value;
  }
  /**
   * Clears the input buffer or the screen.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const overrideClearColor = this.overrideClearColor;
    const overrideClearAlpha = this.overrideClearAlpha;
    const clearAlpha = renderer.getClearAlpha();
    const hasOverrideClearColor = overrideClearColor !== null;
    const hasOverrideClearAlpha = overrideClearAlpha >= 0;
    if (hasOverrideClearColor) {
      renderer.getClearColor(color$2);
      renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(overrideClearAlpha);
    }
    renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);
    renderer.clear(this.color, this.depth, this.stencil);
    if (hasOverrideClearColor) {
      renderer.setClearColor(color$2, clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(clearAlpha);
    }
  }
};

// src/passes/MaskPass.js
var MaskPass = class extends Pass {
  /**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use.
   */
  constructor(scene, camera) {
    super("MaskPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass(false, false, true);
    this.inverse = false;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  /**
   * Indicates whether the mask should be inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this.inverse;
  }
  set inverted(value) {
    this.inverse = value;
  }
  /**
   * Indicates whether this pass should clear the stencil buffer.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the internal clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Indicates whether the mask is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the mask is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Enables or disable mask inversion.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether the mask should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const context = renderer.getContext();
    const buffers = renderer.state.buffers;
    const scene = this.scene;
    const camera = this.camera;
    const clearPass = this.clearPass;
    const writeValue = this.inverted ? 0 : 1;
    const clearValue = 1 - writeValue;
    buffers.color.setMask(false);
    buffers.depth.setMask(false);
    buffers.color.setLocked(true);
    buffers.depth.setLocked(true);
    buffers.stencil.setTest(true);
    buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    buffers.stencil.setClear(clearValue);
    buffers.stencil.setLocked(true);
    if (this.clearPass.enabled) {
      if (this.renderToScreen) {
        clearPass.render(renderer, null);
      } else {
        clearPass.render(renderer, inputBuffer);
        clearPass.render(renderer, outputBuffer);
      }
    }
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
    } else {
      renderer.setRenderTarget(inputBuffer);
      renderer.render(scene, camera);
      renderer.setRenderTarget(outputBuffer);
      renderer.render(scene, camera);
    }
    buffers.color.setLocked(false);
    buffers.depth.setLocked(false);
    buffers.stencil.setLocked(false);
    buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    buffers.stencil.setLocked(true);
  }
};

// src/core/EffectComposer.js
var EffectComposer = class {
  /**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} renderer - The renderer that should be used.
   * @param {Object} [options] - The options.
   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.
   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.
   * @param {Boolean} [options.alpha] - Deprecated. Buffers are always RGBA since three r137.
   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.
   * @param {Number} [options.frameBufferType] - The type of the internal frame buffers. It's recommended to use HalfFloatType if possible.
   */
  constructor(renderer = null, {
    depthBuffer = true,
    stencilBuffer = false,
    multisampling = 0,
    frameBufferType
  } = {}) {
    this.renderer = null;
    this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);
    this.outputBuffer = this.inputBuffer.clone();
    this.copyPass = new CopyPass();
    this.depthTexture = null;
    this.passes = [];
    this.timer = new Timer();
    this.autoRenderToScreen = true;
    this.setRenderer(renderer);
  }
  /**
   * The current amount of samples used for multisample anti-aliasing.
   *
   * @type {Number}
   */
  get multisampling() {
    return this.inputBuffer.samples || 0;
  }
  /**
   * Sets the amount of MSAA samples.
   *
   * Requires WebGL 2. Set to zero to disable multisampling.
   *
   * @type {Number}
   */
  set multisampling(value) {
    const buffer = this.inputBuffer;
    const multisampling = this.multisampling;
    if (multisampling > 0 && value > 0) {
      this.inputBuffer.samples = value;
      this.outputBuffer.samples = value;
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
    } else if (multisampling !== value) {
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
      this.inputBuffer = this.createBuffer(
        buffer.depthBuffer,
        buffer.stencilBuffer,
        buffer.texture.type,
        value
      );
      this.inputBuffer.depthTexture = this.depthTexture;
      this.outputBuffer = this.inputBuffer.clone();
    }
  }
  /**
   * Returns the internal timer.
   *
   * @return {Timer} The timer.
   */
  getTimer() {
    return this.timer;
  }
  /**
   * Returns the renderer.
   *
   * @return {WebGLRenderer} The renderer.
   */
  getRenderer() {
    return this.renderer;
  }
  /**
   * Sets the renderer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
    if (renderer !== null) {
      const size = renderer.getSize(new Vector2());
      const alpha = renderer.getContext().getContextAttributes().alpha;
      const frameBufferType = this.inputBuffer.texture.type;
      if (frameBufferType === UnsignedByteType && renderer.outputColorSpace === SRGBColorSpace) {
        this.inputBuffer.texture.colorSpace = SRGBColorSpace;
        this.outputBuffer.texture.colorSpace = SRGBColorSpace;
        this.inputBuffer.dispose();
        this.outputBuffer.dispose();
      }
      renderer.autoClear = false;
      this.setSize(size.width, size.height);
      for (const pass of this.passes) {
        pass.initialize(renderer, alpha, frameBufferType);
      }
    }
  }
  /**
   * Replaces the current renderer with the given one.
   *
   * The auto clear mechanism of the provided renderer will be disabled. If the new render size differs from the
   * previous one, all passes will be updated.
   *
   * By default, the DOM element of the current renderer will automatically be removed from its parent node and the DOM
   * element of the new renderer will take its place.
   *
   * @deprecated Use setRenderer instead.
   * @param {WebGLRenderer} renderer - The new renderer.
   * @param {Boolean} updateDOM - Indicates whether the old canvas should be replaced by the new one in the DOM.
   * @return {WebGLRenderer} The old renderer.
   */
  replaceRenderer(renderer, updateDOM = true) {
    const oldRenderer = this.renderer;
    const parent = oldRenderer.domElement.parentNode;
    this.setRenderer(renderer);
    if (updateDOM && parent !== null) {
      parent.removeChild(oldRenderer.domElement);
      parent.appendChild(renderer.domElement);
    }
    return oldRenderer;
  }
  /**
   * Creates a depth texture attachment that will be provided to all passes.
   *
   * Note: When a shader reads from a depth texture and writes to a render target that uses the same depth texture
   * attachment, the depth information will be lost. This happens even if `depthWrite` is disabled.
   *
   * @private
   * @return {DepthTexture} The depth texture.
   */
  createDepthTexture() {
    const depthTexture = this.depthTexture = new DepthTexture();
    this.inputBuffer.depthTexture = depthTexture;
    this.inputBuffer.dispose();
    if (this.inputBuffer.stencilBuffer) {
      depthTexture.format = DepthStencilFormat;
      depthTexture.type = UnsignedInt248Type;
    } else {
      depthTexture.type = UnsignedIntType;
    }
    return depthTexture;
  }
  /**
   * Deletes the current depth texture.
   *
   * @private
   */
  deleteDepthTexture() {
    if (this.depthTexture !== null) {
      this.depthTexture.dispose();
      this.depthTexture = null;
      this.inputBuffer.depthTexture = null;
      this.inputBuffer.dispose();
      for (const pass of this.passes) {
        pass.setDepthTexture(null);
      }
    }
  }
  /**
   * Creates a new render target.
   *
   * @deprecated Create buffers manually via WebGLRenderTarget instead.
   * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.
   * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.
   * @param {Number} type - The frame buffer type.
   * @param {Number} multisampling - The number of samples to use for antialiasing.
   * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.
   */
  createBuffer(depthBuffer, stencilBuffer, type, multisampling) {
    const renderer = this.renderer;
    const size = renderer === null ? new Vector2() : renderer.getDrawingBufferSize(new Vector2());
    const options = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer,
      depthBuffer,
      type
    };
    const renderTarget = new WebGLRenderTarget(size.width, size.height, options);
    if (multisampling > 0) {
      renderTarget.ignoreDepthForMultisampleCopy = false;
      renderTarget.samples = multisampling;
    }
    if (type === UnsignedByteType && renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
      renderTarget.texture.colorSpace = SRGBColorSpace;
    }
    renderTarget.texture.name = "EffectComposer.Buffer";
    renderTarget.texture.generateMipmaps = false;
    return renderTarget;
  }
  /**
   * Can be used to change the main scene for all registered passes and effects.
   *
   * @param {Scene} scene - The scene.
   */
  setMainScene(scene) {
    for (const pass of this.passes) {
      pass.mainScene = scene;
    }
  }
  /**
   * Can be used to change the main camera for all registered passes and effects.
   *
   * @param {Camera} camera - The camera.
   */
  setMainCamera(camera) {
    for (const pass of this.passes) {
      pass.mainCamera = camera;
    }
  }
  /**
   * Adds a pass, optionally at a specific index.
   *
   * @param {Pass} pass - A new pass.
   * @param {Number} [index] - An index at which the pass should be inserted.
   */
  addPass(pass, index) {
    const passes = this.passes;
    const renderer = this.renderer;
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    const alpha = renderer.getContext().getContextAttributes().alpha;
    const frameBufferType = this.inputBuffer.texture.type;
    pass.setRenderer(renderer);
    pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    pass.initialize(renderer, alpha, frameBufferType);
    if (this.autoRenderToScreen) {
      if (passes.length > 0) {
        passes[passes.length - 1].renderToScreen = false;
      }
      if (pass.renderToScreen) {
        this.autoRenderToScreen = false;
      }
    }
    if (index !== void 0) {
      passes.splice(index, 0, pass);
    } else {
      passes.push(pass);
    }
    if (this.autoRenderToScreen) {
      passes[passes.length - 1].renderToScreen = true;
    }
    if (pass.needsDepthTexture || this.depthTexture !== null) {
      if (this.depthTexture === null) {
        const depthTexture = this.createDepthTexture();
        for (pass of passes) {
          pass.setDepthTexture(depthTexture);
        }
      } else {
        pass.setDepthTexture(this.depthTexture);
      }
    }
  }
  /**
   * Removes a pass.
   *
   * @param {Pass} pass - The pass.
   */
  removePass(pass) {
    const passes = this.passes;
    const index = passes.indexOf(pass);
    const exists = index !== -1;
    const removed = exists && passes.splice(index, 1).length > 0;
    if (removed) {
      if (this.depthTexture !== null) {
        const reducer = (a, b) => a || b.needsDepthTexture;
        const depthTextureRequired = passes.reduce(reducer, false);
        if (!depthTextureRequired) {
          if (pass.getDepthTexture() === this.depthTexture) {
            pass.setDepthTexture(null);
          }
          this.deleteDepthTexture();
        }
      }
      if (this.autoRenderToScreen) {
        if (index === passes.length) {
          pass.renderToScreen = false;
          if (passes.length > 0) {
            passes[passes.length - 1].renderToScreen = true;
          }
        }
      }
    }
  }
  /**
   * Removes all passes.
   */
  removeAllPasses() {
    const passes = this.passes;
    this.deleteDepthTexture();
    if (passes.length > 0) {
      if (this.autoRenderToScreen) {
        passes[passes.length - 1].renderToScreen = false;
      }
      this.passes = [];
    }
  }
  /**
   * Renders all enabled passes in the order in which they were added.
   *
   * @param {Number} [deltaTime] - The time since the last frame in seconds.
   */
  render(deltaTime) {
    const renderer = this.renderer;
    const copyPass = this.copyPass;
    let inputBuffer = this.inputBuffer;
    let outputBuffer = this.outputBuffer;
    let stencilTest = false;
    let context, stencil, buffer;
    if (deltaTime === void 0) {
      this.timer.update();
      deltaTime = this.timer.getDelta();
    }
    for (const pass of this.passes) {
      if (pass.enabled) {
        pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
        if (pass.needsSwap) {
          if (stencilTest) {
            copyPass.renderToScreen = pass.renderToScreen;
            context = renderer.getContext();
            stencil = renderer.state.buffers.stencil;
            stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
            copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
            stencil.setFunc(context.EQUAL, 1, 4294967295);
          }
          buffer = inputBuffer;
          inputBuffer = outputBuffer;
          outputBuffer = buffer;
        }
        if (pass instanceof MaskPass) {
          stencilTest = true;
        } else if (pass instanceof ClearMaskPass) {
          stencilTest = false;
        }
      }
    }
  }
  /**
   * Sets the size of the buffers, passes and the renderer.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   * @param {Boolean} [updateStyle] - Determines whether the style of the canvas should be updated.
   */
  setSize(width, height, updateStyle) {
    const renderer = this.renderer;
    const currentSize = renderer.getSize(new Vector2());
    if (width === void 0 || height === void 0) {
      width = currentSize.width;
      height = currentSize.height;
    }
    if (currentSize.width !== width || currentSize.height !== height) {
      renderer.setSize(width, height, updateStyle);
    }
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    for (const pass of this.passes) {
      pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    }
  }
  /**
   * Resets this composer by deleting all passes and creating new buffers.
   */
  reset() {
    this.dispose();
    this.autoRenderToScreen = true;
  }
  /**
   * Disposes this composer and all passes.
   */
  dispose() {
    for (const pass of this.passes) {
      pass.dispose();
    }
    this.passes = [];
    if (this.inputBuffer !== null) {
      this.inputBuffer.dispose();
    }
    if (this.outputBuffer !== null) {
      this.outputBuffer.dispose();
    }
    this.deleteDepthTexture();
    this.copyPass.dispose();
    this.timer.dispose();
    Pass.fullscreenGeometry.dispose();
  }
};

// src/enums/EffectAttribute.js
var EffectAttribute = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
};

// src/enums/EffectShaderSection.js
var EffectShaderSection = {
  FRAGMENT_HEAD: "FRAGMENT_HEAD",
  FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
  FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
  VERTEX_HEAD: "VERTEX_HEAD",
  VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
};

// src/core/EffectShaderData.js
var EffectShaderData = class {
  /**
   * Constructs new shader data.
   */
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([
      [EffectShaderSection.FRAGMENT_HEAD, null],
      [EffectShaderSection.FRAGMENT_MAIN_UV, null],
      [EffectShaderSection.FRAGMENT_MAIN_IMAGE, null],
      [EffectShaderSection.VERTEX_HEAD, null],
      [EffectShaderSection.VERTEX_MAIN_SUPPORT, null]
    ]);
    this.defines = /* @__PURE__ */ new Map();
    this.uniforms = /* @__PURE__ */ new Map();
    this.blendModes = /* @__PURE__ */ new Map();
    this.extensions = /* @__PURE__ */ new Set();
    this.attributes = EffectAttribute.NONE;
    this.varyings = /* @__PURE__ */ new Set();
    this.uvTransformation = false;
    this.readDepth = false;
    this.colorSpace = LinearSRGBColorSpace;
  }
};
var workaroundEnabled = false;
var OverrideMaterialManager = class {
  /**
   * Constructs a new override material manager.
   *
   * @param {Material} [material=null] - An override material.
   */
  constructor(material = null) {
    this.originalMaterials = /* @__PURE__ */ new Map();
    this.material = null;
    this.materials = null;
    this.materialsBackSide = null;
    this.materialsDoubleSide = null;
    this.materialsFlatShaded = null;
    this.materialsFlatShadedBackSide = null;
    this.materialsFlatShadedDoubleSide = null;
    this.setMaterial(material);
    this.meshCount = 0;
    this.replaceMaterial = (node) => {
      if (node.isMesh) {
        let materials;
        if (node.material.flatShading) {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsFlatShadedDoubleSide;
              break;
            case BackSide:
              materials = this.materialsFlatShadedBackSide;
              break;
            default:
              materials = this.materialsFlatShaded;
              break;
          }
        } else {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsDoubleSide;
              break;
            case BackSide:
              materials = this.materialsBackSide;
              break;
            default:
              materials = this.materials;
              break;
          }
        }
        this.originalMaterials.set(node, node.material);
        if (node.isSkinnedMesh) {
          node.material = materials[2];
        } else if (node.isInstancedMesh) {
          node.material = materials[1];
        } else {
          node.material = materials[0];
        }
        ++this.meshCount;
      }
    };
  }
  /**
   * Clones the given material.
   *
   * @private
   * @param {Material} material - The material.
   * @return {Material} The cloned material.
   */
  cloneMaterial(material) {
    if (!(material instanceof ShaderMaterial)) {
      return material.clone();
    }
    const uniforms = material.uniforms;
    const textureUniforms = /* @__PURE__ */ new Map();
    for (const key in uniforms) {
      const value = uniforms[key].value;
      if (value.isRenderTargetTexture) {
        uniforms[key].value = null;
        textureUniforms.set(key, value);
      }
    }
    const clone = material.clone();
    for (const entry of textureUniforms) {
      uniforms[entry[0]].value = entry[1];
      clone.uniforms[entry[0]].value = entry[1];
    }
    return clone;
  }
  /**
   * Sets the override material.
   *
   * @param {Material} material - The material.
   */
  setMaterial(material) {
    this.disposeMaterials();
    this.material = material;
    if (material !== null) {
      const materials = this.materials = [
        this.cloneMaterial(material),
        this.cloneMaterial(material),
        this.cloneMaterial(material)
      ];
      for (const m2 of materials) {
        m2.uniforms = Object.assign({}, material.uniforms);
        m2.side = FrontSide;
      }
      materials[2].skinning = true;
      this.materialsBackSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = BackSide;
        return c2;
      });
      this.materialsDoubleSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = DoubleSide;
        return c2;
      });
      this.materialsFlatShaded = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        return c2;
      });
      this.materialsFlatShadedBackSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = BackSide;
        return c2;
      });
      this.materialsFlatShadedDoubleSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = DoubleSide;
        return c2;
      });
    }
  }
  /**
   * Renders the scene with the override material.
   *
   * @private
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - A scene.
   * @param {Camera} camera - A camera.
   */
  render(renderer, scene, camera) {
    const shadowMapEnabled = renderer.shadowMap.enabled;
    renderer.shadowMap.enabled = false;
    if (workaroundEnabled) {
      const originalMaterials = this.originalMaterials;
      this.meshCount = 0;
      scene.traverse(this.replaceMaterial);
      renderer.render(scene, camera);
      for (const entry of originalMaterials) {
        entry[0].material = entry[1];
      }
      if (this.meshCount !== originalMaterials.size) {
        originalMaterials.clear();
      }
    } else {
      const overrideMaterial = scene.overrideMaterial;
      scene.overrideMaterial = this.material;
      renderer.render(scene, camera);
      scene.overrideMaterial = overrideMaterial;
    }
    renderer.shadowMap.enabled = shadowMapEnabled;
  }
  /**
   * Deletes cloned override materials.
   *
   * @private
   */
  disposeMaterials() {
    if (this.material !== null) {
      const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const m2 of materials) {
        m2.dispose();
      }
    }
  }
  /**
   * Performs cleanup tasks.
   */
  dispose() {
    this.originalMaterials.clear();
    this.disposeMaterials();
  }
  /**
   * Indicates whether the override material workaround is enabled.
   *
   * @type {Boolean}
   */
  static get workaroundEnabled() {
    return workaroundEnabled;
  }
  /**
   * Enables or disables the override material workaround globally.
   *
   * This only affects post processing passes and effects.
   *
   * @type {Boolean}
   */
  static set workaroundEnabled(value) {
    workaroundEnabled = value;
  }
};
var AUTO_SIZE = -1;
var Resolution = class extends EventDispatcher$1 {
  /**
   * Constructs a new resolution.
   *
   * TODO Remove resizable param.
   * @param {Resizable} resizable - A resizable object.
   * @param {Number} [width=Resolution.AUTO_SIZE] - The preferred width.
   * @param {Number} [height=Resolution.AUTO_SIZE] - The preferred height.
   * @param {Number} [scale=1.0] - A resolution scale.
   */
  constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1) {
    super();
    this.resizable = resizable;
    this.baseSize = new Vector2(1, 1);
    this.preferredSize = new Vector2(width, height);
    this.target = this.preferredSize;
    this.s = scale;
    this.effectiveSize = new Vector2();
    this.addEventListener("change", () => this.updateEffectiveSize());
    this.updateEffectiveSize();
  }
  /**
   * Calculates the effective size.
   *
   * @private
   */
  updateEffectiveSize() {
    const base = this.baseSize;
    const preferred = this.preferredSize;
    const effective = this.effectiveSize;
    const scale = this.scale;
    if (preferred.width !== AUTO_SIZE) {
      effective.width = preferred.width;
    } else if (preferred.height !== AUTO_SIZE) {
      effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));
    } else {
      effective.width = Math.round(base.width * scale);
    }
    if (preferred.height !== AUTO_SIZE) {
      effective.height = preferred.height;
    } else if (preferred.width !== AUTO_SIZE) {
      effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));
    } else {
      effective.height = Math.round(base.height * scale);
    }
  }
  /**
   * The effective width.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
   *
   * @type {Number}
   */
  get width() {
    return this.effectiveSize.width;
  }
  set width(value) {
    this.preferredWidth = value;
  }
  /**
   * The effective height.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
   *
   * @type {Number}
   */
  get height() {
    return this.effectiveSize.height;
  }
  set height(value) {
    this.preferredHeight = value;
  }
  /**
   * Returns the effective width.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
   *
   * @deprecated Use width instead.
   * @return {Number} The effective width.
   */
  getWidth() {
    return this.width;
  }
  /**
   * Returns the effective height.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
   *
   * @deprecated Use height instead.
   * @return {Number} The effective height.
   */
  getHeight() {
    return this.height;
  }
  /**
   * The resolution scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.s;
  }
  set scale(value) {
    if (this.s !== value) {
      this.s = value;
      this.preferredSize.setScalar(AUTO_SIZE);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the current resolution scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * Also sets the preferred resolution to {@link Resizer.AUTO_SIZE}.
   *
   * @deprecated Use scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.scale = value;
  }
  /**
   * The base width.
   *
   * @type {Number}
   */
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(value) {
    if (this.baseSize.width !== value) {
      this.baseSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the base width.
   *
   * @deprecated Use baseWidth instead.
   * @return {Number} The base width.
   */
  getBaseWidth() {
    return this.baseWidth;
  }
  /**
   * Sets the base width.
   *
   * @deprecated Use baseWidth instead.
   * @param {Number} value - The width.
   */
  setBaseWidth(value) {
    this.baseWidth = value;
  }
  /**
   * The base height.
   *
   * @type {Number}
   */
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(value) {
    if (this.baseSize.height !== value) {
      this.baseSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the base height.
   *
   * @deprecated Use baseHeight instead.
   * @return {Number} The base height.
   */
  getBaseHeight() {
    return this.baseHeight;
  }
  /**
   * Sets the base height.
   *
   * @deprecated Use baseHeight instead.
   * @param {Number} value - The height.
   */
  setBaseHeight(value) {
    this.baseHeight = value;
  }
  /**
   * Sets the base size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setBaseSize(width, height) {
    if (this.baseSize.width !== width || this.baseSize.height !== height) {
      this.baseSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * The preferred width.
   *
   * @type {Number}
   */
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(value) {
    if (this.preferredSize.width !== value) {
      this.preferredSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the preferred width.
   *
   * @deprecated Use preferredWidth instead.
   * @return {Number} The preferred width.
   */
  getPreferredWidth() {
    return this.preferredWidth;
  }
  /**
   * Sets the preferred width.
   *
   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the width based on the height and aspect ratio.
   *
   * @deprecated Use preferredWidth instead.
   * @param {Number} value - The width.
   */
  setPreferredWidth(value) {
    this.preferredWidth = value;
  }
  /**
   * The preferred height.
   *
   * @type {Number}
   */
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(value) {
    if (this.preferredSize.height !== value) {
      this.preferredSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the preferred height.
   *
   * @deprecated Use preferredHeight instead.
   * @return {Number} The preferred height.
   */
  getPreferredHeight() {
    return this.preferredHeight;
  }
  /**
   * Sets the preferred height.
   *
   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the height based on the width and aspect ratio.
   *
   * @deprecated Use preferredHeight instead.
   * @param {Number} value - The height.
   */
  setPreferredHeight(value) {
    this.preferredHeight = value;
  }
  /**
   * Sets the preferred size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setPreferredSize(width, height) {
    if (this.preferredSize.width !== width || this.preferredSize.height !== height) {
      this.preferredSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Copies the given resolution.
   *
   * @param {Resolution} resolution - The resolution.
   */
  copy(resolution) {
    this.s = resolution.scale;
    this.baseSize.set(resolution.baseWidth, resolution.baseHeight);
    this.preferredSize.set(resolution.preferredWidth, resolution.preferredHeight);
    this.dispatchEvent({ type: "change" });
    this.resizable.setSize(this.baseSize.width, this.baseSize.height);
  }
  /**
   * An auto sizing constant.
   *
   * Can be used to automatically calculate the width or height based on the original aspect ratio.
   *
   * @type {Number}
   */
  static get AUTO_SIZE() {
    return AUTO_SIZE;
  }
};

// src/utils/IdManager.js
var IdManager = class {
  /**
   * Constructs a new ID manager.
   *
   * @param initialId - The first ID.
   */
  constructor(initialId = 0) {
    this.nextId = initialId;
  }
  /**
   * Returns the next unique ID.
   *
   * @return The ID.
   */
  getNextId() {
    return this.nextId++;
  }
  /**
   * Resets the ID counter.
   *
   * @param initialId - The first ID.
   * @return This manager.
   */
  reset(initialId = 0) {
    this.nextId = initialId;
    return this;
  }
};

// src/core/Selection.js
var idManager = /* @__PURE__ */ new IdManager(2);
var Selection = class extends Set {
  /**
   * Constructs a new selection.
   *
   * @param {Iterable<Object3D>} [iterable] - A collection of objects that should be added to this selection.
   * @param {Number} [layer] - A dedicated render layer for selected objects. Range is `[2, 31]`. Starts at 2 if omitted.
   */
  constructor(iterable, layer = idManager.getNextId()) {
    super();
    this.exclusive = false;
    this._layer = layer;
    if (this._layer < 1 || this._layer > 31) {
      console.warn("Layer out of range, resetting to 2");
      idManager.reset(2);
      this._layer = idManager.getNextId();
    }
    if (iterable !== void 0) {
      this.set(iterable);
    }
  }
  /**
   * The render layer for selected objects.
   *
   * @type {Number}
   */
  get layer() {
    return this._layer;
  }
  set layer(value) {
    const currentLayer = this._layer;
    for (const object of this) {
      object.layers.disable(currentLayer);
      object.layers.enable(value);
    }
    this._layer = value;
  }
  /**
   * Returns the current render layer for selected objects.
   *
   * The default layer is 2. If this collides with your own custom layers, please change it before rendering!
   *
   * @deprecated Use layer instead.
   * @return {Number} The layer.
   */
  getLayer() {
    return this.layer;
  }
  /**
   * Sets the render layer for selected objects.
   *
   * The current selection will be updated accordingly.
   *
   * @deprecated Use layer instead.
   * @param {Number} value - The layer. Range is [0, 31].
   */
  setLayer(value) {
    this.layer = value;
  }
  /**
   * Indicates whether objects that are added to this selection will be removed from all other layers.
   *
   * @deprecated Use exclusive instead.
   * @return {Number} Whether this selection is exclusive. Default is false.
   */
  isExclusive() {
    return this.exclusive;
  }
  /**
   * Controls whether objects that are added to this selection should be removed from all other layers.
   *
   * @deprecated Use exclusive instead.
   * @param {Number} value - Whether this selection should be exclusive.
   */
  setExclusive(value) {
    this.exclusive = value;
  }
  /**
   * Clears this selection.
   *
   * @return {Selection} This selection.
   */
  clear() {
    const layer = this.layer;
    for (const object of this) {
      object.layers.disable(layer);
    }
    return super.clear();
  }
  /**
   * Clears this selection and adds the given objects.
   *
   * @param {Iterable<Object3D>} objects - The objects that should be selected.
   * @return {Selection} This selection.
   */
  set(objects) {
    this.clear();
    for (const object of objects) {
      this.add(object);
    }
    return this;
  }
  /**
   * An alias for {@link has}.
   *
   * @param {Object3D} object - An object.
   * @return {Number} Returns 0 if the given object is currently selected, or -1 otherwise.
   * @deprecated Added for backward-compatibility.
   */
  indexOf(object) {
    return this.has(object) ? 0 : -1;
  }
  /**
   * Adds an object to this selection.
   *
   * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.
   *
   * @param {Object3D} object - The object that should be selected.
   * @return {Selection} This selection.
   */
  add(object) {
    if (this.exclusive) {
      object.layers.set(this.layer);
    } else {
      object.layers.enable(this.layer);
    }
    return super.add(object);
  }
  /**
   * Removes an object from this selection.
   *
   * @param {Object3D} object - The object that should be deselected.
   * @return {Boolean} Returns true if an object has successfully been removed from this selection; otherwise false.
   */
  delete(object) {
    if (this.has(object)) {
      object.layers.disable(this.layer);
    }
    return super.delete(object);
  }
  /**
   * Removes an existing object from the selection. If the object doesn't exist it's added instead.
   *
   * @param {Object3D} object - The object.
   * @return {Boolean} Returns true if the object is added, false otherwise.
   */
  toggle(object) {
    let result;
    if (this.has(object)) {
      this.delete(object);
      result = false;
    } else {
      this.add(object);
      result = true;
    }
    return result;
  }
  /**
   * Sets the visibility of all selected objects.
   *
   * This method enables or disables render layer 0 of all selected objects.
   *
   * @param {Boolean} visible - Whether the selected objects should be visible.
   * @return {Selection} This selection.
   */
  setVisible(visible) {
    for (const object of this) {
      if (visible) {
        object.layers.enable(0);
      } else {
        object.layers.disable(0);
      }
    }
    return this;
  }
};

// src/enums/BlendFunction.js
var BlendFunction = {
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
};

// src/effects/blending/glsl/add.frag
var add_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}";

// src/effects/blending/glsl/alpha.frag
var alpha_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}";

// src/effects/blending/glsl/average.frag
var average_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}";

// src/effects/blending/glsl/color.frag
var color_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/color-burn.frag
var color_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}";

// src/effects/blending/glsl/color-dodge.frag
var color_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/darken.frag
var darken_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}";

// src/effects/blending/glsl/difference.frag
var difference_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}";

// src/effects/blending/glsl/divide.frag
var divide_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}";

// src/effects/blending/glsl/exclusion.frag
var exclusion_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}";

// src/effects/blending/glsl/hard-light.frag
var hard_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/hard-mix.frag
var hard_mix_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}";

// src/effects/blending/glsl/hue.frag
var hue_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/invert.frag
var invert_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}";

// src/effects/blending/glsl/invert-rgb.frag
var invert_rgb_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}";

// src/effects/blending/glsl/lighten.frag
var lighten_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}";

// src/effects/blending/glsl/linear-burn.frag
var linear_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}";

// src/effects/blending/glsl/linear-dodge.frag
var linear_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}";

// src/effects/blending/glsl/linear-light.frag
var linear_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}";

// src/effects/blending/glsl/luminosity.frag
var luminosity_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/multiply.frag
var multiply_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}";

// src/effects/blending/glsl/negation.frag
var negation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}";

// src/effects/blending/glsl/normal.frag
var normal_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}";

// src/effects/blending/glsl/overlay.frag
var overlay_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}";

// src/effects/blending/glsl/pin-light.frag
var pin_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}";

// src/effects/blending/glsl/reflect.frag
var reflect_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/saturation.frag
var saturation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/screen.frag
var screen_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}";

// src/effects/blending/glsl/soft-light.frag
var soft_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}";

// src/effects/blending/glsl/src.frag
var src_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}";

// src/effects/blending/glsl/subtract.frag
var subtract_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}";

// src/effects/blending/glsl/vivid-light.frag
var vivid_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}";

// src/effects/blending/BlendMode.js
var blendFunctions = /* @__PURE__ */ new Map([
  [BlendFunction.ADD, add_default],
  [BlendFunction.ALPHA, alpha_default],
  [BlendFunction.AVERAGE, average_default],
  [BlendFunction.COLOR, color_default],
  [BlendFunction.COLOR_BURN, color_burn_default],
  [BlendFunction.COLOR_DODGE, color_dodge_default],
  [BlendFunction.DARKEN, darken_default],
  [BlendFunction.DIFFERENCE, difference_default],
  [BlendFunction.DIVIDE, divide_default],
  [BlendFunction.DST, null],
  [BlendFunction.EXCLUSION, exclusion_default],
  [BlendFunction.HARD_LIGHT, hard_light_default],
  [BlendFunction.HARD_MIX, hard_mix_default],
  [BlendFunction.HUE, hue_default],
  [BlendFunction.INVERT, invert_default],
  [BlendFunction.INVERT_RGB, invert_rgb_default],
  [BlendFunction.LIGHTEN, lighten_default],
  [BlendFunction.LINEAR_BURN, linear_burn_default],
  [BlendFunction.LINEAR_DODGE, linear_dodge_default],
  [BlendFunction.LINEAR_LIGHT, linear_light_default],
  [BlendFunction.LUMINOSITY, luminosity_default],
  [BlendFunction.MULTIPLY, multiply_default],
  [BlendFunction.NEGATION, negation_default],
  [BlendFunction.NORMAL, normal_default],
  [BlendFunction.OVERLAY, overlay_default],
  [BlendFunction.PIN_LIGHT, pin_light_default],
  [BlendFunction.REFLECT, reflect_default],
  [BlendFunction.SATURATION, saturation_default],
  [BlendFunction.SCREEN, screen_default],
  [BlendFunction.SOFT_LIGHT, soft_light_default],
  [BlendFunction.SRC, src_default],
  [BlendFunction.SUBTRACT, subtract_default],
  [BlendFunction.VIVID_LIGHT, vivid_light_default]
]);
var BlendMode = class extends EventDispatcher$1 {
  /**
   * Constructs a new blend mode.
   *
   * @param {BlendFunction} blendFunction - The blend function.
   * @param {Number} opacity - The opacity of the color that will be blended with the base color.
   */
  constructor(blendFunction, opacity = 1) {
    super();
    this._blendFunction = blendFunction;
    this.opacity = new Uniform(opacity);
  }
  /**
   * Returns the opacity.
   *
   * @return {Number} The opacity.
   */
  getOpacity() {
    return this.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.opacity.value = value;
  }
  /**
   * The blend function.
   *
   * @type {BlendFunction}
   */
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(value) {
    this._blendFunction = value;
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Returns the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @return {BlendFunction} The blend function.
   */
  getBlendFunction() {
    return this.blendFunction;
  }
  /**
   * Sets the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @param {BlendFunction} value - The blend function.
   */
  setBlendFunction(value) {
    this.blendFunction = value;
  }
  /**
   * Returns the blend function shader code.
   *
   * @return {String} The blend function shader code.
   */
  getShaderCode() {
    return blendFunctions.get(this.blendFunction);
  }
};
var Effect = class extends EventDispatcher$1 {
  /**
   * Constructs a new effect.
   *
   * @param {String} name - The name of this effect. Doesn't have to be unique.
   * @param {String} fragmentShader - The fragment shader. This shader is required.
   * @param {Object} [options] - Additional options.
   * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
   * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.
   * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.
   * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.
   * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.
   */
  constructor(name, fragmentShader, {
    attributes = EffectAttribute.NONE,
    blendFunction = BlendFunction.NORMAL,
    defines = /* @__PURE__ */ new Map(),
    uniforms = /* @__PURE__ */ new Map(),
    extensions = null,
    vertexShader = null
  } = {}) {
    super();
    this.name = name;
    this.renderer = null;
    this.attributes = attributes;
    this.fragmentShader = fragmentShader;
    this.vertexShader = vertexShader;
    this.defines = defines;
    this.uniforms = uniforms;
    this.extensions = extensions;
    this.blendMode = new BlendMode(blendFunction);
    this.blendMode.addEventListener("change", (event) => this.setChanged());
    this._inputColorSpace = LinearSRGBColorSpace;
    this._outputColorSpace = NoColorSpace;
  }
  /**
   * The input color space.
   *
   * @type {ColorSpace}
   * @experimental
   */
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  /**
   * @type {ColorSpace}
   * @protected
   * @experimental
   */
  set inputColorSpace(value) {
    this._inputColorSpace = value;
    this.setChanged();
  }
  /**
   * The output color space.
   *
   * Should only be changed if this effect converts the input colors to a different color space.
   *
   * @type {ColorSpace}
   * @experimental
   */
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  /**
   * @type {ColorSpace}
   * @protected
   * @experimental
   */
  set outputColorSpace(value) {
    this._outputColorSpace = value;
    this.setChanged();
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Returns the name of this effect.
   *
   * @deprecated Use name instead.
   * @return {String} The name.
   */
  getName() {
    return this.name;
  }
  /**
   * Sets the renderer.
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Returns the preprocessor macro definitions.
   *
   * @deprecated Use defines instead.
   * @return {Map<String, String>} The extensions.
   */
  getDefines() {
    return this.defines;
  }
  /**
   * Returns the uniforms of this effect.
   *
   * @deprecated Use uniforms instead.
   * @return {Map<String, Uniform>} The extensions.
   */
  getUniforms() {
    return this.uniforms;
  }
  /**
   * Returns the WebGL extensions that are required by this effect.
   *
   * @deprecated Use extensions instead.
   * @return {Set<WebGLExtension>} The extensions.
   */
  getExtensions() {
    return this.extensions;
  }
  /**
   * Returns the blend mode.
   *
   * The result of this effect will be blended with the result of the previous effect using this blend mode.
   *
   * @deprecated Use blendMode instead.
   * @return {BlendMode} The blend mode.
   */
  getBlendMode() {
    return this.blendMode;
  }
  /**
   * Returns the effect attributes.
   *
   * @return {EffectAttribute} The attributes.
   */
  getAttributes() {
    return this.attributes;
  }
  /**
   * Sets the effect attributes.
   *
   * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes
   * imply a higher priority.
   *
   * @protected
   * @param {EffectAttribute} attributes - The attributes.
   */
  setAttributes(attributes) {
    this.attributes = attributes;
    this.setChanged();
  }
  /**
   * Returns the fragment shader.
   *
   * @return {String} The fragment shader.
   */
  getFragmentShader() {
    return this.fragmentShader;
  }
  /**
   * Sets the fragment shader.
   *
   * @protected
   * @param {String} fragmentShader - The fragment shader.
   */
  setFragmentShader(fragmentShader) {
    this.fragmentShader = fragmentShader;
    this.setChanged();
  }
  /**
   * Returns the vertex shader.
   *
   * @return {String} The vertex shader.
   */
  getVertexShader() {
    return this.vertexShader;
  }
  /**
   * Sets the vertex shader.
   *
   * @protected
   * @param {String} vertexShader - The vertex shader.
   */
  setVertexShader(vertexShader) {
    this.vertexShader = vertexShader;
    this.setChanged();
  }
  /**
   * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.
   *
   * Should be called after changing macros or extensions and after adding/removing uniforms.
   *
   * @protected
   */
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Sets the depth texture.
   *
   * You may override this method if your effect requires direct access to the depth texture that is bound to the
   * associated {@link EffectPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  /**
   * Updates this effect by performing supporting operations.
   *
   * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the
   * blend function is set to `SKIP`.
   *
   * You may override this method if you need to update custom uniforms or render additional off-screen textures.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
  }
  /**
   * Updates the size of this effect.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for properties that define a dispose method and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};

// src/enums/KernelSize.js
var KernelSize = {
  VERY_SMALL: 0,
  MEDIUM: 2,
  LARGE: 3};

// src/materials/glsl/convolution.kawase.frag
var convolution_kawase_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.kawase.vert
var convolution_kawase_default2 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/KawaseBlurMaterial.js
var kernelPresets = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
];
var KawaseBlurMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new convolution material.
   *
   * TODO Remove texelSize param.
   * @param {Vector4} [texelSize] - Deprecated.
   */
  constructor(texelSize = new Vector4()) {
    super({
      name: "KawaseBlurMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector4()),
        scale: new Uniform(1),
        kernel: new Uniform(0)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_kawase_default,
      vertexShader: convolution_kawase_default2
    });
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernelSize = KernelSize.MEDIUM;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.inputBuffer = value;
  }
  /**
   * The kernel sequence for the current kernel size.
   *
   * @type {Float32Array}
   */
  get kernelSequence() {
    return kernelPresets[this.kernelSize];
  }
  /**
   * The blur scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.uniforms.scale.value;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} value - The scale.
   */
  setScale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the kernel.
   *
   * @return {Float32Array} The kernel.
   * @deprecated Implementation detail, removed with no replacement.
   */
  getKernel() {
    return null;
  }
  /**
   * The current kernel.
   *
   * @type {Number}
   */
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(value) {
    this.uniforms.kernel.value = value;
  }
  /**
   * Sets the current kernel.
   *
   * @deprecated Use kernel instead.
   * @param {Number} value - The kernel.
   */
  setKernel(value) {
    this.kernel = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const x = 1 / width, y = 1 / height;
    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);
  }
};

// src/passes/KawaseBlurPass.js
var KawaseBlurPass = class extends Pass {
  /**
   * Constructs a new Kawase blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("KawaseBlurPass");
    this.renderTargetA = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetA.texture.name = "Blur.Target.A";
    this.renderTargetB = this.renderTargetA.clone();
    this.renderTargetB.texture.name = "Blur.Target.B";
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this._blurMaterial = new KawaseBlurMaterial();
    this._blurMaterial.kernelSize = kernelSize;
    this.copyMaterial = new CopyMaterial();
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The blur material.
   *
   * @type {KawaseBlurMaterial}
   */
  get blurMaterial() {
    return this._blurMaterial;
  }
  /**
   * The blur material.
   *
   * @type {KawaseBlurMaterial}
   * @protected
   */
  set blurMaterial(value) {
    this._blurMaterial = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated Use copyMaterial.dithering instead.
   */
  get dithering() {
    return this.copyMaterial.dithering;
  }
  set dithering(value) {
    this.copyMaterial.dithering = value;
  }
  /**
   * The kernel size.
   *
   * @type {KernelSize}
   * @deprecated Use blurMaterial.kernelSize instead.
   */
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(value) {
    this.blurMaterial.kernelSize = value;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.width instead.
   */
  get width() {
    return this.resolution.width;
  }
  /**
   * Sets the render width.
   *
   * @type {Number}
   * @deprecated Use resolution.preferredWidth instead.
   */
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.height instead.
   */
  get height() {
    return this.resolution.height;
  }
  /**
   * Sets the render height.
   *
   * @type {Number}
   * @deprecated Use resolution.preferredHeight instead.
   */
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * The current blur scale.
   *
   * @type {Number}
   * @deprecated Use blurMaterial.scale instead.
   */
  get scale() {
    return this.blurMaterial.scale;
  }
  set scale(value) {
    this.blurMaterial.scale = value;
  }
  /**
   * Returns the current blur scale.
   *
   * @deprecated Use blurMaterial.scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.blurMaterial.scale;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use blurMaterial.scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.blurMaterial.scale = value;
  }
  /**
   * Returns the kernel size.
   *
   * @deprecated Use blurMaterial.kernelSize instead.
   * @return {KernelSize} The kernel size.
   */
  getKernelSize() {
    return this.kernelSize;
  }
  /**
   * Sets the kernel size.
   *
   * Larger kernels require more processing power but scale well with larger render resolutions.
   *
   * @deprecated Use blurMaterial.kernelSize instead.
   * @param {KernelSize} value - The kernel size.
   */
  setKernelSize(value) {
    this.kernelSize = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    const material = this.blurMaterial;
    const kernelSequence = material.kernelSequence;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = material;
    for (let i = 0, l = kernelSequence.length; i < l; ++i) {
      const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;
      material.kernel = kernelSequence[i];
      material.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(buffer);
      renderer.render(scene, camera);
      previousBuffer = buffer;
    }
    this.fullscreenMaterial = this.copyMaterial;
    this.copyMaterial.inputBuffer = previousBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.renderTargetA.setSize(w, h);
    this.renderTargetB.setSize(w, h);
    this.blurMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTargetA.texture.colorSpace = SRGBColorSpace;
        this.renderTargetB.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
  /**
   * An auto sizing flag.
   *
   * @type {Number}
   * @deprecated Use {@link Resolution.AUTO_SIZE} instead.
   */
  static get AUTO_SIZE() {
    return Resolution.AUTO_SIZE;
  }
};

// src/materials/glsl/luminance.frag
var luminance_default = "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}";

// src/materials/LuminanceMaterial.js
var LuminanceMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new luminance material.
   *
   * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colors scaled with their luminance value.
   * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.
   */
  constructor(colorOutput = false, luminanceRange = null) {
    super({
      name: "LuminanceMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, "")
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        threshold: new Uniform(0),
        smoothing: new Uniform(1),
        range: new Uniform(null)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: luminance_default,
      vertexShader: common_default
    });
    this.colorOutput = colorOutput;
    this.luminanceRange = luminanceRange;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The luminance threshold.
   *
   * @type {Number}
   */
  get threshold() {
    return this.uniforms.threshold.value;
  }
  set threshold(value) {
    if (this.smoothing > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.threshold.value = value;
  }
  /**
   * Returns the luminance threshold.
   *
   * @deprecated Use threshold instead.
   * @return {Number} The threshold.
   */
  getThreshold() {
    return this.threshold;
  }
  /**
   * Sets the luminance threshold.
   *
   * @deprecated Use threshold instead.
   * @param {Number} value - The threshold.
   */
  setThreshold(value) {
    this.threshold = value;
  }
  /**
   * The luminance threshold smoothing.
   *
   * @type {Number}
   */
  get smoothing() {
    return this.uniforms.smoothing.value;
  }
  set smoothing(value) {
    if (this.threshold > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.smoothing.value = value;
  }
  /**
   * Returns the luminance threshold smoothing factor.
   *
   * @deprecated Use smoothing instead.
   * @return {Number} The smoothing factor.
   */
  getSmoothingFactor() {
    return this.smoothing;
  }
  /**
   * Sets the luminance threshold smoothing factor.
   *
   * @deprecated Use smoothing instead.
   * @param {Number} value - The smoothing factor.
   */
  setSmoothingFactor(value) {
    this.smoothing = value;
  }
  /**
   * Indicates whether the luminance threshold is enabled.
   *
   * @type {Boolean}
   * @deprecated Adjust the threshold or smoothing factor instead.
   */
  get useThreshold() {
    return this.threshold > 0 || this.smoothing > 0;
  }
  set useThreshold(value) {
  }
  /**
   * Indicates whether color output is enabled.
   *
   * @type {Boolean}
   */
  get colorOutput() {
    return this.defines.COLOR !== void 0;
  }
  set colorOutput(value) {
    if (value) {
      this.defines.COLOR = "1";
    } else {
      delete this.defines.COLOR;
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether color output is enabled.
   *
   * @deprecated Use colorOutput instead.
   * @return {Boolean} Whether color output is enabled.
   */
  isColorOutputEnabled(value) {
    return this.colorOutput;
  }
  /**
   * Enables or disables color output.
   *
   * @deprecated Use colorOutput instead.
   * @param {Boolean} value - Whether color output should be enabled.
   */
  setColorOutputEnabled(value) {
    this.colorOutput = value;
  }
  /**
   * Indicates whether luminance masking is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get useRange() {
    return this.luminanceRange !== null;
  }
  set useRange(value) {
    this.luminanceRange = null;
  }
  /**
   * The luminance range. Set to null to disable.
   *
   * @type {Boolean}
   */
  get luminanceRange() {
    return this.uniforms.range.value;
  }
  set luminanceRange(value) {
    if (value !== null) {
      this.defines.RANGE = "1";
    } else {
      delete this.defines.RANGE;
    }
    this.uniforms.range.value = value;
    this.needsUpdate = true;
  }
  /**
   * Returns the current luminance range.
   *
   * @deprecated Use luminanceRange instead.
   * @return {Vector2} The luminance range.
   */
  getLuminanceRange() {
    return this.luminanceRange;
  }
  /**
   * Sets a luminance range. Set to null to disable.
   *
   * @deprecated Use luminanceRange instead.
   * @param {Vector2} value - The luminance range.
   */
  setLuminanceRange(value) {
    this.luminanceRange = value;
  }
};

// src/passes/LuminancePass.js
var LuminancePass = class extends Pass {
  /**
   * Constructs a new luminance pass.
   *
   * @param {Object} [options] - The options. See {@link LuminanceMaterial} for additional options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    renderTarget,
    luminanceRange,
    colorOutput,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("LuminancePass");
    this.fullscreenMaterial = new LuminanceMaterial(colorOutput, luminanceRange);
    this.needsSwap = false;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
      this.renderTarget.texture.name = "LuminancePass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * The luminance texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the luminance texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Renders the luminance.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const material = this.fullscreenMaterial;
    material.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.renderTarget.texture.type = frameBufferType;
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};

// src/materials/glsl/convolution.downsampling.frag
var convolution_downsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.downsampling.vert
var convolution_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/DownsamplingMaterial.js
var DownsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new downsampling material.
   */
  constructor() {
    super({
      name: "DownsamplingMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_downsampling_default,
      vertexShader: convolution_downsampling_default2
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/glsl/convolution.upsampling.frag
var convolution_upsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.upsampling.vert
var convolution_upsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/UpsamplingMaterial.js
var UpsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new upsampling material.
   */
  constructor() {
    super({
      name: "UpsamplingMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        supportBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2()),
        radius: new Uniform(0.85)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_upsampling_default,
      vertexShader: convolution_upsampling_default2
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * A support buffer.
   *
   * @type {Texture}
   */
  set supportBuffer(value) {
    this.uniforms.supportBuffer.value = value;
  }
  /**
   * The blur radius.
   *
   * @type {Number}
   */
  get radius() {
    return this.uniforms.radius.value;
  }
  set radius(value) {
    this.uniforms.radius.value = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/passes/MipmapBlurPass.js
var MipmapBlurPass = class extends Pass {
  /**
   * Constructs a new mipmap blur pass.
   *
   * @param {Object} [options] - The options.
   */
  constructor() {
    super("MipmapBlurPass");
    this.needsSwap = false;
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Upsampling.Mipmap0";
    this.downsamplingMipmaps = [];
    this.upsamplingMipmaps = [];
    this.downsamplingMaterial = new DownsamplingMaterial();
    this.upsamplingMaterial = new UpsamplingMaterial();
    this.resolution = new Vector2();
  }
  /**
   * A texture that contains the blurred result.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * The MIP levels. Default is 8.
   *
   * @type {Number}
   */
  get levels() {
    return this.downsamplingMipmaps.length;
  }
  set levels(value) {
    if (this.levels !== value) {
      const renderTarget = this.renderTarget;
      this.dispose();
      this.downsamplingMipmaps = [];
      this.upsamplingMipmaps = [];
      for (let i = 0; i < value; ++i) {
        const mipmap = renderTarget.clone();
        mipmap.texture.name = "Downsampling.Mipmap" + i;
        this.downsamplingMipmaps.push(mipmap);
      }
      this.upsamplingMipmaps.push(renderTarget);
      for (let i = 1, l = value - 1; i < l; ++i) {
        const mipmap = renderTarget.clone();
        mipmap.texture.name = "Upsampling.Mipmap" + i;
        this.upsamplingMipmaps.push(mipmap);
      }
      this.setSize(this.resolution.x, this.resolution.y);
    }
  }
  /**
   * The blur radius.
   *
   * @type {Number}
   */
  get radius() {
    return this.upsamplingMaterial.radius;
  }
  set radius(value) {
    this.upsamplingMaterial.radius = value;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const { scene, camera } = this;
    const { downsamplingMaterial, upsamplingMaterial } = this;
    const { downsamplingMipmaps, upsamplingMipmaps } = this;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = downsamplingMaterial;
    for (let i = 0, l = downsamplingMipmaps.length; i < l; ++i) {
      const mipmap = downsamplingMipmaps[i];
      downsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      downsamplingMaterial.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
    this.fullscreenMaterial = upsamplingMaterial;
    for (let i = upsamplingMipmaps.length - 1; i >= 0; --i) {
      const mipmap = upsamplingMipmaps[i];
      upsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      upsamplingMaterial.inputBuffer = previousBuffer.texture;
      upsamplingMaterial.supportBuffer = downsamplingMipmaps[i].texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.set(width, height);
    let w = resolution.width, h = resolution.height;
    for (let i = 0, l = this.downsamplingMipmaps.length; i < l; ++i) {
      w = Math.round(w * 0.5);
      h = Math.round(h * 0.5);
      this.downsamplingMipmaps[i].setSize(w, h);
      if (i < this.upsamplingMipmaps.length) {
        this.upsamplingMipmaps[i].setSize(w, h);
      }
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      const mipmaps = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
      for (const mipmap of mipmaps) {
        mipmap.texture.type = frameBufferType;
      }
      if (frameBufferType !== UnsignedByteType) {
        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        for (const mipmap of mipmaps) {
          mipmap.texture.colorSpace = SRGBColorSpace;
        }
      }
    }
  }
  /**
   * Deletes internal render targets and textures.
   */
  dispose() {
    super.dispose();
    for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) {
      mipmap.dispose();
    }
  }
};

// src/effects/glsl/bloom.frag
var bloom_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}";

// src/effects/BloomEffect.js
var BloomEffect = class extends Effect {
  /**
   * Constructs a new bloom effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
   * @param {Number} [options.luminanceThreshold=0.9] - The luminance threshold. Raise this value to mask out darker elements in the scene.
   * @param {Number} [options.luminanceSmoothing=0.025] - Controls the smoothness of the luminance threshold.
   * @param {Boolean} [options.mipmapBlur=false] - Enables or disables mipmap blur.
   * @param {Number} [options.intensity=1.0] - The bloom intensity.
   * @param {Number} [options.radius=0.85] - The blur radius. Only applies to mipmap blur.
   * @param {Number} [options.levels=8] - The amount of MIP levels. Only applies to mipmap blur.
   * @param {KernelSize} [options.kernelSize=KernelSize.LARGE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionScale=0.5] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   */
  constructor({
    blendFunction = BlendFunction.SCREEN,
    luminanceThreshold = 0.9,
    luminanceSmoothing = 0.025,
    mipmapBlur = false,
    intensity = 1,
    radius = 0.85,
    levels = 8,
    kernelSize = KernelSize.LARGE,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("BloomEffect", bloom_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new Uniform(null)],
        ["intensity", new Uniform(intensity)]
      ])
    });
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Bloom.Target";
    this.blurPass = new KawaseBlurPass({ kernelSize });
    this.luminancePass = new LuminancePass({ colorOutput: true });
    this.luminanceMaterial.threshold = luminanceThreshold;
    this.luminanceMaterial.smoothing = luminanceSmoothing;
    this.mipmapBlurPass = new MipmapBlurPass();
    this.mipmapBlurPass.enabled = mipmapBlur;
    this.mipmapBlurPass.radius = radius;
    this.mipmapBlurPass.levels = levels;
    this.uniforms.get("map").value = mipmapBlur ? this.mipmapBlurPass.texture : this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * A texture that contains the intermediate result of this effect.
   *
   * @type {Texture}
   */
  get texture() {
    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;
  }
  /**
   * Returns the generated bloom texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the blur pass.
   *
   * @deprecated
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * Returns the luminance pass.
   *
   * @deprecated Use luminancePass instead.
   * @return {LuminancePass} The luminance pass.
   */
  getLuminancePass() {
    return this.luminancePass;
  }
  /**
   * The luminance material.
   *
   * @type {LuminanceMaterial}
   */
  get luminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  /**
   * Returns the luminance material.
   *
   * @deprecated Use luminanceMaterial instead.
   * @return {LuminanceMaterial} The material.
   */
  getLuminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated
   */
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated
   */
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated Use EffectPass.dithering instead.
   */
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  /**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @deprecated
   */
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  /**
   * @type {Number}
   * @deprecated
   */
  get distinction() {
    console.warn(this.name, "distinction was removed");
    return 1;
  }
  set distinction(value) {
    console.warn(this.name, "distinction was removed");
  }
  /**
   * The bloom intensity.
   *
   * @type {Number}
   */
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  /**
   * The bloom intensity.
   *
   * @deprecated Use intensity instead.
   * @return {Number} The intensity.
   */
  getIntensity() {
    return this.intensity;
  }
  /**
   * Sets the bloom intensity.
   *
   * @deprecated Use intensity instead.
   * @param {Number} value - The intensity.
   */
  setIntensity(value) {
    this.intensity = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    const luminancePass = this.luminancePass;
    if (luminancePass.enabled) {
      luminancePass.render(renderer, inputBuffer);
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, luminancePass.renderTarget);
      } else {
        this.blurPass.render(renderer, luminancePass.renderTarget, renderTarget);
      }
    } else {
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, inputBuffer);
      } else {
        this.blurPass.render(renderer, inputBuffer, renderTarget);
      }
    }
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.blurPass.resolution.copy(resolution);
    this.luminancePass.setSize(width, height);
    this.mipmapBlurPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    this.luminancePass.initialize(renderer, alpha, frameBufferType);
    this.mipmapBlurPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
};

// src/utils/orthographicDepthToViewZ.js
function orthographicDepthToViewZ(depth, near, far) {
  return depth * (near - far) - near;
}

// src/utils/viewZToOrthographicDepth.js
function viewZToOrthographicDepth(viewZ, near, far) {
  return Math.min(Math.max((viewZ + near) / (near - far), 0), 1);
}
var ShaderPass = class extends Pass {
  /**
   * Constructs a new shader pass.
   *
   * @param {ShaderMaterial} material - A shader material.
   * @param {String} [input="inputBuffer"] - The name of the input buffer uniform.
   */
  constructor(material, input = "inputBuffer") {
    super("ShaderPass");
    this.fullscreenMaterial = material;
    this.input = input;
  }
  /**
   * Sets the name of the input buffer uniform.
   *
   * @param {String} input - The name of the input buffer uniform.
   * @deprecated Use input instead.
   */
  setInput(input) {
    this.input = input;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const uniforms = this.fullscreenMaterial.uniforms;
    if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {
      uniforms[this.input].value = inputBuffer.texture;
    }
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};

// src/effects/glsl/fxaa.frag
var fxaa_default = "#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\n#define ONE_OVER_TWELVE 0.08333333333333333\nvarying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}";

// src/effects/glsl/fxaa.vert
var fxaa_default2 = "varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}";

// src/effects/FXAAEffect.js
var FXAAEffect = class extends Effect {
  /**
   * Constructs a new FXAA effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   */
  constructor({ blendFunction = BlendFunction.SRC } = {}) {
    super("FXAAEffect", fxaa_default, {
      vertexShader: fxaa_default2,
      blendFunction,
      defines: /* @__PURE__ */ new Map([
        ["EDGE_THRESHOLD_MIN", "0.0312"],
        ["EDGE_THRESHOLD_MAX", "0.125"],
        ["SUBPIXEL_QUALITY", "0.75"],
        ["SAMPLES", "12"]
      ])
    });
  }
  /**
   * The minimum edge detection threshold. Range is [0.0, 1.0].
   *
   * @type {Number}
   */
  get minEdgeThreshold() {
    return Number(this.defines.get("EDGE_THRESHOLD_MIN"));
  }
  set minEdgeThreshold(value) {
    this.defines.set("EDGE_THRESHOLD_MIN", value.toFixed(12));
    this.setChanged();
  }
  /**
   * The maximum edge detection threshold. Range is [0.0, 1.0].
   *
   * @type {Number}
   */
  get maxEdgeThreshold() {
    return Number(this.defines.get("EDGE_THRESHOLD_MAX"));
  }
  set maxEdgeThreshold(value) {
    this.defines.set("EDGE_THRESHOLD_MAX", value.toFixed(12));
    this.setChanged();
  }
  /**
   * The subpixel blend quality. Range is [0.0, 1.0].
   *
   * @type {Number}
   */
  get subpixelQuality() {
    return Number(this.defines.get("SUBPIXEL_QUALITY"));
  }
  set subpixelQuality(value) {
    this.defines.set("SUBPIXEL_QUALITY", value.toFixed(12));
    this.setChanged();
  }
  /**
   * The maximum amount of edge detection samples.
   *
   * @type {Number}
   */
  get samples() {
    return Number(this.defines.get("SAMPLES"));
  }
  set samples(value) {
    this.defines.set("SAMPLES", value.toFixed(0));
    this.setChanged();
  }
};
function getNoise(size, format, type) {
  const channels = /* @__PURE__ */ new Map([
    [LuminanceFormat, 1],
    [RedFormat, 1],
    [RGFormat, 2],
    [RGBAFormat, 4]
  ]);
  let data;
  if (!channels.has(format)) {
    console.error("Invalid noise texture format");
  }
  if (type === UnsignedByteType) {
    data = new Uint8Array(size * channels.get(format));
    for (let i = 0, l = data.length; i < l; ++i) {
      data[i] = Math.random() * 255 + 0.5;
    }
  } else {
    data = new Float32Array(size * channels.get(format));
    for (let i = 0, l = data.length; i < l; ++i) {
      data[i] = Math.random();
    }
  }
  return data;
}
var NoiseTexture = class extends DataTexture {
  /**
   * Constructs a new noise texture.
   *
   * The texture format can be either `LuminanceFormat` or `RGBAFormat`. Additionally, the formats `RedFormat` and
   * `RGFormat` can be used in a WebGL 2 context.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   * @param {Number} [format=LuminanceFormat] - The texture format.
   * @param {Number} [type=UnsignedByteType] - The texture type.
   */
  constructor(width, height, format = LuminanceFormat, type = UnsignedByteType) {
    super(getNoise(width * height, format, type), width, height, format, type);
    this.needsUpdate = true;
  }
};

// src/enums/DepthTestStrategy.js
var DepthTestStrategy = {
  KEEP_MAX_DEPTH: 1,
  DISCARD_MAX_DEPTH: 2
};

// src/materials/glsl/depth-mask.frag
var depth_mask_default = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;\n#else\nuniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;\n#endif\nuniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}varying vec2 vUv;void main(){vec2 depth;\n#if DEPTH_PACKING_0 == 3201\ndepth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));\n#else\ndepth.x=texture2D(depthBuffer0,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;\n#endif\n#endif\n#if DEPTH_PACKING_1 == 3201\ndepth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));\n#else\ndepth.y=texture2D(depthBuffer1,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;\n#endif\n#endif\nbool isMaxDepth=(depth.x==1.0);\n#ifdef PERSPECTIVE_CAMERA\ndepth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);\n#endif\n#if DEPTH_TEST_STRATEGY == 0\nbool keep=depthTest(depth.x,depth.y);\n#elif DEPTH_TEST_STRATEGY == 1\nbool keep=isMaxDepth||depthTest(depth.x,depth.y);\n#else\nbool keep=!isMaxDepth&&depthTest(depth.x,depth.y);\n#endif\nif(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}";

// src/materials/DepthMaskMaterial.js
var DepthMaskMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new depth mask material.
   */
  constructor() {
    super({
      name: "DepthMaskMaterial",
      defines: {
        DEPTH_EPSILON: "0.0001",
        DEPTH_PACKING_0: "0",
        DEPTH_PACKING_1: "0",
        DEPTH_TEST_STRATEGY: DepthTestStrategy.KEEP_MAX_DEPTH
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer0: new Uniform(null),
        depthBuffer1: new Uniform(null),
        cameraNearFar: new Uniform(new Vector2(1, 1))
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_mask_default,
      vertexShader: common_default
    });
    this.depthMode = LessDepth;
  }
  /**
   * The primary depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer0(value) {
    this.uniforms.depthBuffer0.value = value;
  }
  /**
   * The primary depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking0(value) {
    this.defines.DEPTH_PACKING_0 = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the base depth buffer.
   *
   * @deprecated Use depthBuffer0 and depthPacking0 instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer0(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer0 = buffer;
    this.depthPacking0 = depthPacking;
  }
  /**
   * The secondary depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer1(value) {
    this.uniforms.depthBuffer1.value = value;
  }
  /**
   * The secondary depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking1(value) {
    this.defines.DEPTH_PACKING_1 = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer that will be compared with the base depth buffer.
   *
   * @deprecated Use depthBuffer1 and depthPacking1 instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer1(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer1 = buffer;
    this.depthPacking1 = depthPacking;
  }
  /**
   * The strategy for handling maximum depth.
   *
   * @type {DepthTestStrategy}
   */
  get maxDepthStrategy() {
    return Number(this.defines.DEPTH_TEST_STRATEGY);
  }
  set maxDepthStrategy(value) {
    this.defines.DEPTH_TEST_STRATEGY = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Indicates whether maximum depth values should be preserved.
   *
   * @type {Boolean}
   * @deprecated Use maxDepthStrategy instead.
   */
  get keepFar() {
    return this.maxDepthStrategy;
  }
  set keepFar(value) {
    this.maxDepthStrategy = value ? DepthTestStrategy.KEEP_MAX_DEPTH : DepthTestStrategy.DISCARD_MAX_DEPTH;
  }
  /**
   * Returns the strategy for dealing with maximum depth values.
   *
   * @deprecated Use maxDepthStrategy instead.
   * @return {DepthTestStrategy} The strategy.
   */
  getMaxDepthStrategy() {
    return this.maxDepthStrategy;
  }
  /**
   * Sets the strategy for dealing with maximum depth values.
   *
   * @deprecated Use maxDepthStrategy instead.
   * @param {DepthTestStrategy} value - The strategy.
   */
  setMaxDepthStrategy(value) {
    this.maxDepthStrategy = value;
  }
  /**
   * A small error threshold that is used for `EqualDepth` and `NotEqualDepth` tests. Default is `1e-4`.
   *
   * @type {Number}
   */
  get epsilon() {
    return Number(this.defines.DEPTH_EPSILON);
  }
  set epsilon(value) {
    this.defines.DEPTH_EPSILON = value.toFixed(16);
    this.needsUpdate = true;
  }
  /**
   * Returns the current error threshold for depth comparisons.
   *
   * @deprecated Use epsilon instead.
   * @return {Number} The error threshold.
   */
  getEpsilon() {
    return this.epsilon;
  }
  /**
   * Sets the depth comparison error threshold.
   *
   * @deprecated Use epsilon instead.
   * @param {Number} value - The new error threshold.
   */
  setEpsilon(value) {
    this.epsilon = value;
  }
  /**
   * The depth mode.
   *
   * @see https://threejs.org/docs/#api/en/constants/Materials
   * @type {DepthModes}
   */
  get depthMode() {
    return Number(this.defines.DEPTH_MODE);
  }
  set depthMode(value) {
    let depthTest;
    switch (value) {
      case NeverDepth:
        depthTest = "false";
        break;
      case AlwaysDepth:
        depthTest = "true";
        break;
      case EqualDepth:
        depthTest = "abs(d1 - d0) <= DEPTH_EPSILON";
        break;
      case NotEqualDepth:
        depthTest = "abs(d1 - d0) > DEPTH_EPSILON";
        break;
      case LessDepth:
        depthTest = "d0 > d1";
        break;
      case LessEqualDepth:
        depthTest = "d0 >= d1";
        break;
      case GreaterEqualDepth:
        depthTest = "d0 <= d1";
        break;
      case GreaterDepth:
      default:
        depthTest = "d0 < d1";
        break;
    }
    this.defines.DEPTH_MODE = value.toFixed(0);
    this.defines["depthTest(d0, d1)"] = depthTest;
    this.needsUpdate = true;
  }
  /**
   * Returns the current depth mode.
   *
   * @deprecated Use depthMode instead.
   * @return {DepthModes} The depth mode. Default is `LessDepth`.
   */
  getDepthMode() {
    return this.depthMode;
  }
  /**
   * Sets the depth mode.
   *
   * @deprecated Use depthMode instead.
   * @param {DepthModes} mode - The depth mode.
   */
  setDepthMode(mode) {
    this.depthMode = mode;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};

// src/passes/RenderPass.js
var RenderPass = class extends Pass {
  /**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Material} [overrideMaterial=null] - An override material.
   */
  constructor(scene, camera, overrideMaterial = null) {
    super("RenderPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass();
    this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);
    this.ignoreBackground = false;
    this.skipShadowMapUpdate = false;
    this.selection = null;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(value) {
    super.renderToScreen = value;
    this.clearPass.renderToScreen = value;
  }
  /**
   * The current override material.
   *
   * @type {Material}
   */
  get overrideMaterial() {
    const manager = this.overrideMaterialManager;
    return manager !== null ? manager.material : null;
  }
  set overrideMaterial(value) {
    const manager = this.overrideMaterialManager;
    if (value !== null) {
      if (manager !== null) {
        manager.setMaterial(value);
      } else {
        this.overrideMaterialManager = new OverrideMaterialManager(value);
      }
    } else if (manager !== null) {
      manager.dispose();
      this.overrideMaterialManager = null;
    }
  }
  /**
   * Returns the current override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} The material.
   */
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  /**
   * Sets the override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} value - The material.
   */
  setOverrideMaterial(value) {
    this.overrideMaterial = value;
  }
  /**
   * Indicates whether the target buffer should be cleared before rendering.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the selection. Default is `null` (no restriction).
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * Sets the selection. Set to `null` to disable.
   *
   * @deprecated Use selection instead.
   * @param {Selection} value - The selection.
   */
  setSelection(value) {
    this.selection = value;
  }
  /**
   * Indicates whether the scene background is disabled.
   *
   * @deprecated Use ignoreBackground instead.
   * @return {Boolean} Whether the scene background is disabled.
   */
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  /**
   * Enables or disables the scene background.
   *
   * @deprecated Use ignoreBackground instead.
   * @param {Boolean} value - Whether the scene background should be disabled.
   */
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  /**
   * Indicates whether the shadow map auto update is disabled.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @return {Boolean} Whether the shadow map update is disabled.
   */
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  /**
   * Enables or disables the shadow map auto update.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @param {Boolean} value - Whether the shadow map auto update should be disabled.
   */
  setShadowMapDisabled(value) {
    this.skipShadowMapUpdate = value;
  }
  /**
   * Returns the clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Renders the scene.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const mask = camera.layers.mask;
    const background = scene.background;
    const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;
    const renderTarget = this.renderToScreen ? null : inputBuffer;
    if (selection !== null) {
      camera.layers.set(selection.getLayer());
    }
    if (this.skipShadowMapUpdate) {
      renderer.shadowMap.autoUpdate = false;
    }
    if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {
      scene.background = null;
    }
    if (this.clearPass.enabled) {
      this.clearPass.render(renderer, inputBuffer);
    }
    renderer.setRenderTarget(renderTarget);
    if (this.overrideMaterialManager !== null) {
      this.overrideMaterialManager.render(renderer, scene, camera);
    } else {
      renderer.render(scene, camera);
    }
    camera.layers.mask = mask;
    scene.background = background;
    renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;
  }
};

// src/effects/glsl/grid.frag
var grid_default = "uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}";

// src/effects/GridEffect.js
var GridEffect = class extends Effect {
  /**
   * Constructs a new grid effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.
   * @param {Number} [options.scale=1.0] - The scale of the grid pattern.
   * @param {Number} [options.lineWidth=0.0] - The line width of the grid pattern.
   */
  constructor({ blendFunction = BlendFunction.OVERLAY, scale = 1, lineWidth = 0 } = {}) {
    super("GridEffect", grid_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["scale", new Uniform(new Vector2())],
        ["lineWidth", new Uniform(lineWidth)]
      ])
    });
    this.resolution = new Vector2();
    this.s = 0;
    this.scale = scale;
    this.l = 0;
    this.lineWidth = lineWidth;
  }
  /**
   * The scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.s;
  }
  set scale(value) {
    this.s = Math.max(value, 1e-6);
    this.setSize(this.resolution.width, this.resolution.height);
  }
  /**
   * Returns the current grid scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The grid scale.
   */
  getScale() {
    return this.scale;
  }
  /**
   * Sets the grid scale.
   *
   * @deprecated Use scale instead.
   * @param {Number} value - The new grid scale.
   */
  setScale(value) {
    this.scale = value;
  }
  /**
   * The line width.
   *
   * @type {Number}
   */
  get lineWidth() {
    return this.l;
  }
  set lineWidth(value) {
    this.l = value;
    this.setSize(this.resolution.width, this.resolution.height);
  }
  /**
   * Returns the current grid line width.
   *
   * @deprecated Use lineWidth instead.
   * @return {Number} The grid line width.
   */
  getLineWidth() {
    return this.lineWidth;
  }
  /**
   * Sets the grid line width.
   *
   * @deprecated Use lineWidth instead.
   * @param {Number} value - The new grid line width.
   */
  setLineWidth(value) {
    this.lineWidth = value;
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.resolution.set(width, height);
    const aspect = width / height;
    const scale = this.scale * (height * 0.125);
    this.uniforms.get("scale").value.set(aspect * scale, scale);
    this.uniforms.get("lineWidth").value = scale / height + this.lineWidth;
  }
};

// src/enums/EdgeDetectionMode.js
var EdgeDetectionMode = {
  COLOR: 2
};

// src/enums/PredicationMode.js
var PredicationMode = {
  DISABLED: 0};

// src/enums/SMAAPreset.js
var SMAAPreset = {
  LOW: 0,
  MEDIUM: 1,
  HIGH: 2,
  ULTRA: 3
};

// src/materials/glsl/depth-comparison.frag
var depth_comparison_default = "#include <packing>\n#include <clipping_planes_pars_fragment>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){\n#include <clipping_planes_fragment>\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);\n#if DEPTH_PACKING == 3201\nfloat fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\n#else\nfloat fragCoordZ=texture2D(depthBuffer,projTexCoord).r;\n#endif\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#else\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#endif\nfloat depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}";

// src/materials/glsl/depth-comparison.vert
var depth_comparison_default2 = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\n#include <clipping_planes_vertex>\n}";

// src/materials/DepthComparisonMaterial.js
var DepthComparisonMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new depth comparison material.
   *
   * @param {Texture} [depthTexture=null] - A depth texture.
   * @param {PerspectiveCamera} [camera] - A camera.
   */
  constructor(depthTexture = null, camera) {
    super({
      name: "DepthComparisonMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        cameraNear: new Uniform(0.3),
        cameraFar: new Uniform(1e3)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_comparison_default,
      vertexShader: depth_comparison_default2
    });
    this.depthBuffer = depthTexture;
    this.depthPacking = RGBADepthPacking;
    this.copyCameraSettings(camera);
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=RGBADepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = RGBADepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};

// src/materials/glsl/outline.frag
var outline_default = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}";

// src/materials/glsl/outline.vert
var outline_default2 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/OutlineMaterial.js
var OutlineMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new outline material.
   *
   * TODO Remove texelSize param.
   * @param {Vector2} [texelSize] - The screen texel size.
   */
  constructor(texelSize = new Vector2()) {
    super({
      name: "OutlineMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: outline_default,
      vertexShader: outline_default2
    });
    this.uniforms.texelSize.value.set(texelSize.x, texelSize.y);
    this.uniforms.maskTexture = this.uniforms.inputBuffer;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var DepthPass = class extends Pass {
  /**
   * Constructs a new depth pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Object} [options] - The options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(scene, camera, {
    renderTarget,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthPass");
    this.needsSwap = false;
    this.renderPass = new RenderPass(scene, camera, new MeshDepthMaterial({
      depthPacking: RGBADepthPacking
    }));
    const renderPass = this.renderPass;
    renderPass.skipShadowMapUpdate = true;
    renderPass.ignoreBackground = true;
    const clearPass = renderPass.clearPass;
    clearPass.overrideClearColor = new Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: NearestFilter,
        magFilter: NearestFilter
      });
      this.renderTarget.texture.name = "DepthPass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainScene(value) {
    this.renderPass.mainScene = value;
  }
  set mainCamera(value) {
    this.renderPass.mainCamera = value;
  }
  /**
   * The depth texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the depth texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the scene depth.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const renderTarget = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(renderer, renderTarget);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
};

// src/effects/glsl/outline.frag
var outline_default3 = "uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\n#ifdef USE_PATTERN\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\n#ifndef X_RAY\nedge.y=0.0;\n#endif\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\n#ifdef USE_PATTERN\nvec4 patternColor=texture2D(patternTexture,vUvPattern);\n#ifdef X_RAY\nfloat hiddenFactor=0.5;\n#else\nfloat hiddenFactor=0.0;\n#endif\nvisibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\n#endif\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\n#ifdef ALPHA\noutputColor=vec4(color,alpha);\n#else\noutputColor=vec4(color,max(alpha,inputColor.a));\n#endif\n}";

// src/effects/glsl/outline.vert
var outline_default4 = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}";

// src/effects/OutlineEffect.js
var OutlineEffect = class extends Effect {
  /**
   * Constructs a new outline effect.
   *
   * @param {Scene} scene - The main scene.
   * @param {Camera} camera - The main camera.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function. Use `BlendFunction.ALPHA` for dark outlines.
   * @param {Texture} [options.patternTexture=null] - A pattern texture.
   * @param {Number} [options.patternScale=1.0] - The pattern scale.
   * @param {Number} [options.edgeStrength=1.0] - The edge strength.
   * @param {Number} [options.pulseSpeed=0.0] - The pulse speed. A value of zero disables the pulse effect.
   * @param {Number} [options.visibleEdgeColor=0xffffff] - The color of visible edges.
   * @param {Number} [options.hiddenEdgeColor=0x22090a] - The color of hidden edges.
   * @param {KernelSize} [options.kernelSize=KernelSize.VERY_SMALL] - The blur kernel size.
   * @param {Boolean} [options.blur=false] - Whether the outline should be blurred.
   * @param {Boolean} [options.xRay=true] - Whether occluded parts of selected objects should be visible.
   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(scene, camera, {
    blendFunction = BlendFunction.SCREEN,
    patternTexture = null,
    patternScale = 1,
    edgeStrength = 1,
    pulseSpeed = 0,
    visibleEdgeColor = 16777215,
    hiddenEdgeColor = 2230538,
    kernelSize = KernelSize.VERY_SMALL,
    blur = false,
    xRay = true,
    multisampling = 0,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("OutlineEffect", outline_default3, {
      uniforms: /* @__PURE__ */ new Map([
        ["maskTexture", new Uniform(null)],
        ["edgeTexture", new Uniform(null)],
        ["edgeStrength", new Uniform(edgeStrength)],
        ["visibleEdgeColor", new Uniform(new Color(visibleEdgeColor))],
        ["hiddenEdgeColor", new Uniform(new Color(hiddenEdgeColor))],
        ["pulse", new Uniform(1)],
        ["patternScale", new Uniform(patternScale)],
        ["patternTexture", new Uniform(null)]
      ])
    });
    this.blendMode.addEventListener("change", (event) => {
      if (this.blendMode.blendFunction === BlendFunction.ALPHA) {
        this.defines.set("ALPHA", "1");
      } else {
        this.defines.delete("ALPHA");
      }
      this.setChanged();
    });
    this.blendMode.blendFunction = blendFunction;
    this.patternTexture = patternTexture;
    this.xRay = xRay;
    this.scene = scene;
    this.camera = camera;
    this.renderTargetMask = new WebGLRenderTarget(1, 1);
    this.renderTargetMask.samples = multisampling;
    this.renderTargetMask.texture.name = "Outline.Mask";
    this.uniforms.get("maskTexture").value = this.renderTargetMask.texture;
    this.renderTargetOutline = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetOutline.texture.name = "Outline.Edges";
    this.uniforms.get("edgeTexture").value = this.renderTargetOutline.texture;
    this.clearPass = new ClearPass();
    this.clearPass.overrideClearColor = new Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.depthPass = new DepthPass(scene, camera);
    this.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(this.depthPass.texture, camera));
    const clearPass = this.maskPass.clearPass;
    clearPass.overrideClearColor = new Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize });
    this.blurPass.enabled = blur;
    const resolution = this.blurPass.resolution;
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.outlinePass = new ShaderPass(new OutlineMaterial());
    const outlineMaterial = this.outlinePass.fullscreenMaterial;
    outlineMaterial.inputBuffer = this.renderTargetMask.texture;
    this.time = 0;
    this.forceUpdate = true;
    this.selection = new Selection();
    this.pulseSpeed = pulseSpeed;
  }
  set mainScene(value) {
    this.scene = value;
    this.depthPass.mainScene = value;
    this.maskPass.mainScene = value;
  }
  set mainCamera(value) {
    this.camera = value;
    this.depthPass.mainCamera = value;
    this.maskPass.mainCamera = value;
    this.maskPass.overrideMaterial.copyCameraSettings(value);
  }
  /**
   * The resolution of this effect.
   *
   * @type {Resolution}
   */
  get resolution() {
    return this.blurPass.resolution;
  }
  /**
   * Returns the resolution.
   *
   * @return {Resizer} The resolution.
   */
  getResolution() {
    return this.blurPass.getResolution();
  }
  /**
   * The amount of MSAA samples.
   *
   * Requires WebGL 2. Set to zero to disable multisampling.
   *
   * @experimental Requires three >= r138.
   * @type {Number}
   */
  get multisampling() {
    return this.renderTargetMask.samples;
  }
  set multisampling(value) {
    this.renderTargetMask.samples = value;
    this.renderTargetMask.dispose();
  }
  /**
   * The pattern scale.
   *
   * @type {Number}
   */
  get patternScale() {
    return this.uniforms.get("patternScale").value;
  }
  set patternScale(value) {
    this.uniforms.get("patternScale").value = value;
  }
  /**
   * The edge strength.
   *
   * @type {Number}
   */
  get edgeStrength() {
    return this.uniforms.get("edgeStrength").value;
  }
  set edgeStrength(value) {
    this.uniforms.get("edgeStrength").value = value;
  }
  /**
   * The visible edge color.
   *
   * @type {Color}
   */
  get visibleEdgeColor() {
    return this.uniforms.get("visibleEdgeColor").value;
  }
  set visibleEdgeColor(value) {
    this.uniforms.get("visibleEdgeColor").value = value;
  }
  /**
   * The hidden edge color.
   *
   * @type {Color}
   */
  get hiddenEdgeColor() {
    return this.uniforms.get("hiddenEdgeColor").value;
  }
  set hiddenEdgeColor(value) {
    this.uniforms.get("hiddenEdgeColor").value = value;
  }
  /**
   * Returns the blur pass.
   *
   * @deprecated Use blurPass instead.
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * Returns the selection.
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * Returns the pulse speed.
   *
   * @deprecated Use pulseSpeed instead.
   * @return {Number} The speed.
   */
  getPulseSpeed() {
    return this.pulseSpeed;
  }
  /**
   * Sets the pulse speed. Set to zero to disable.
   *
   * @deprecated Use pulseSpeed instead.
   * @param {Number} value - The speed.
   */
  setPulseSpeed(value) {
    this.pulseSpeed = value;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.width instead.
   */
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.height instead.
   */
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * The selection layer.
   *
   * @type {Number}
   * @deprecated Use selection.layer instead.
   */
  get selectionLayer() {
    return this.selection.layer;
  }
  set selectionLayer(value) {
    this.selection.layer = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  /**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @deprecated Use blurPass.kernelSize instead.
   */
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  /**
   * Indicates whether the outlines should be blurred.
   *
   * @type {Boolean}
   * @deprecated Use blurPass.enabled instead.
   */
  get blur() {
    return this.blurPass.enabled;
  }
  set blur(value) {
    this.blurPass.enabled = value;
  }
  /**
   * Indicates whether X-ray mode is enabled.
   *
   * @type {Boolean}
   */
  get xRay() {
    return this.defines.has("X_RAY");
  }
  set xRay(value) {
    if (this.xRay !== value) {
      if (value) {
        this.defines.set("X_RAY", "1");
      } else {
        this.defines.delete("X_RAY");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether X-ray mode is enabled.
   *
   * @deprecated Use xRay instead.
   * @return {Boolean} Whether X-ray mode is enabled.
   */
  isXRayEnabled() {
    return this.xRay;
  }
  /**
   * Enables or disables X-ray outlines.
   *
   * @deprecated Use xRay instead.
   * @param {Boolean} value - Whether X-ray should be enabled.
   */
  setXRayEnabled(value) {
    this.xRay = value;
  }
  /**
   * The pattern texture. Set to `null` to disable.
   *
   * @type {Texture}
   */
  get patternTexture() {
    return this.uniforms.get("patternTexture").value;
  }
  set patternTexture(value) {
    if (value !== null) {
      value.wrapS = value.wrapT = RepeatWrapping;
      this.defines.set("USE_PATTERN", "1");
      this.setVertexShader(outline_default4);
    } else {
      this.defines.delete("USE_PATTERN");
      this.setVertexShader(null);
    }
    this.uniforms.get("patternTexture").value = value;
    this.setChanged();
  }
  /**
   * Sets the pattern texture.
   *
   * @deprecated Use patternTexture instead.
   * @param {Texture} value - The new texture.
   */
  setPatternTexture(value) {
    this.patternTexture = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Clears the current selection and selects a list of objects.
   *
   * @param {Object3D[]} objects - The objects that should be outlined. This array will be copied.
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.set() instead.
   */
  setSelection(objects) {
    this.selection.set(objects);
    return this;
  }
  /**
   * Clears the list of selected objects.
   *
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.clear() instead.
   */
  clearSelection() {
    this.selection.clear();
    return this;
  }
  /**
   * Selects an object.
   *
   * @param {Object3D} object - The object that should be outlined.
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.add() instead.
   */
  selectObject(object) {
    this.selection.add(object);
    return this;
  }
  /**
   * Deselects an object.
   *
   * @param {Object3D} object - The object that should no longer be outlined.
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.delete() instead.
   */
  deselectObject(object) {
    this.selection.delete(object);
    return this;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const uniforms = this.uniforms;
    const pulse = uniforms.get("pulse");
    const background = scene.background;
    const mask = camera.layers.mask;
    if (this.forceUpdate || selection.size > 0) {
      scene.background = null;
      pulse.value = 1;
      if (this.pulseSpeed > 0) {
        pulse.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625;
      }
      this.time += deltaTime;
      selection.setVisible(false);
      this.depthPass.render(renderer);
      selection.setVisible(true);
      camera.layers.set(selection.layer);
      this.maskPass.render(renderer, this.renderTargetMask);
      camera.layers.mask = mask;
      scene.background = background;
      this.outlinePass.render(renderer, null, this.renderTargetOutline);
      if (this.blurPass.enabled) {
        this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetOutline);
      }
    }
    this.forceUpdate = selection.size > 0;
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.blurPass.setSize(width, height);
    this.renderTargetMask.setSize(width, height);
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.depthPass.setSize(w, h);
    this.renderTargetOutline.setSize(w, h);
    this.outlinePass.fullscreenMaterial.setSize(w, h);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, UnsignedByteType);
    if (frameBufferType !== void 0) {
      this.depthPass.initialize(renderer, alpha, frameBufferType);
      this.maskPass.initialize(renderer, alpha, frameBufferType);
      this.outlinePass.initialize(renderer, alpha, frameBufferType);
    }
  }
};

// src/effects/glsl/pixelation.frag
var pixelation_default = "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}";

// src/effects/PixelationEffect.js
var PixelationEffect = class extends Effect {
  /**
   * Constructs a new pixelation effect.
   *
   * @param {Object} [granularity=30.0] - The pixel granularity.
   */
  constructor(granularity = 30) {
    super("PixelationEffect", pixelation_default, {
      uniforms: /* @__PURE__ */ new Map([
        ["active", new Uniform(false)],
        ["d", new Uniform(new Vector4())]
      ])
    });
    this.resolution = new Vector2();
    this._granularity = 0;
    this.granularity = granularity;
  }
  /**
   * The pixel granularity.
   *
   * A higher value yields coarser visuals.
   *
   * @type {Number}
   */
  get granularity() {
    return this._granularity;
  }
  set granularity(value) {
    let d = Math.floor(value);
    if (d % 2 > 0) {
      d += 1;
    }
    this._granularity = d;
    this.uniforms.get("active").value = d > 0;
    this.setSize(this.resolution.width, this.resolution.height);
  }
  /**
   * Returns the pixel granularity.
   *
   * @deprecated Use granularity instead.
   * @return {Number} The granularity.
   */
  getGranularity() {
    return this.granularity;
  }
  /**
   * Sets the pixel granularity.
   *
   * @deprecated Use granularity instead.
   * @param {Number} value - The new granularity.
   */
  setGranularity(value) {
    this.granularity = value;
  }
  /**
   * Updates the granularity.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.set(width, height);
    const d = this.granularity;
    const x = d / resolution.x;
    const y = d / resolution.y;
    this.uniforms.get("d").value.set(x, y, 1 / x, 1 / y);
  }
};
var SelectiveBloomEffect = class extends BloomEffect {
  /**
   * Constructs a new selective bloom effect.
   *
   * @param {Scene} scene - The main scene.
   * @param {Camera} camera - The main camera.
   * @param {Object} [options] - The options. See {@link BloomEffect} for details.
   */
  constructor(scene, camera, options) {
    super(options);
    this.setAttributes(this.getAttributes() | EffectAttribute.DEPTH);
    this.camera = camera;
    this.depthPass = new DepthPass(scene, camera);
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new Color(0);
    this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());
    const depthMaskMaterial = this.depthMaskMaterial;
    depthMaskMaterial.copyCameraSettings(camera);
    depthMaskMaterial.depthBuffer1 = this.depthPass.texture;
    depthMaskMaterial.depthPacking1 = RGBADepthPacking;
    depthMaskMaterial.depthMode = EqualDepth;
    this.renderTargetMasked = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetMasked.texture.name = "Bloom.Masked";
    this.selection = new Selection();
    this._inverted = false;
    this._ignoreBackground = false;
  }
  set mainScene(value) {
    this.depthPass.mainScene = value;
  }
  set mainCamera(value) {
    this.camera = value;
    this.depthPass.mainCamera = value;
    this.depthMaskMaterial.copyCameraSettings(value);
  }
  /**
   * Returns the selection.
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * The depth mask material.
   *
   * @type {DepthMaskMaterial}
   * @private
   */
  get depthMaskMaterial() {
    return this.depthMaskPass.fullscreenMaterial;
  }
  /**
   * Indicates whether the selection should be considered inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this._inverted;
  }
  set inverted(value) {
    this._inverted = value;
    this.depthMaskMaterial.depthMode = value ? NotEqualDepth : EqualDepth;
  }
  /**
   * Indicates whether the mask is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the mask is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Enables or disable mask inversion.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether the mask should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
  /**
   * Indicates whether the background colors will be ignored.
   *
   * @type {Boolean}
   */
  get ignoreBackground() {
    return this._ignoreBackground;
  }
  set ignoreBackground(value) {
    this._ignoreBackground = value;
    this.depthMaskMaterial.maxDepthStrategy = value ? DepthTestStrategy.DISCARD_MAX_DEPTH : DepthTestStrategy.KEEP_MAX_DEPTH;
  }
  /**
   * Indicates whether the background is disabled.
   *
   * @deprecated Use ignoreBackground instead.
   * @return {Boolean} Whether the background is disabled.
   */
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  /**
   * Enables or disables the background.
   *
   * @deprecated Use ignoreBackground instead.
   * @param {Boolean} value - Whether the background should be disabled.
   */
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.depthMaskMaterial.depthBuffer0 = depthTexture;
    this.depthMaskMaterial.depthPacking0 = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const camera = this.camera;
    const selection = this.selection;
    const inverted = this.inverted;
    let renderTarget = inputBuffer;
    if (this.ignoreBackground || !inverted || selection.size > 0) {
      const mask = camera.layers.mask;
      camera.layers.set(selection.layer);
      this.depthPass.render(renderer);
      camera.layers.mask = mask;
      renderTarget = this.renderTargetMasked;
      this.clearPass.render(renderer, renderTarget);
      this.depthMaskPass.render(renderer, inputBuffer, renderTarget);
    }
    super.update(renderer, renderTarget, deltaTime);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    super.setSize(width, height);
    this.renderTargetMasked.setSize(width, height);
    this.depthPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    super.initialize(renderer, alpha, frameBufferType);
    this.clearPass.initialize(renderer, alpha, frameBufferType);
    this.depthPass.initialize(renderer, alpha, frameBufferType);
    this.depthMaskPass.initialize(renderer, alpha, frameBufferType);
    if (renderer !== null && renderer.capabilities.logarithmicDepthBuffer) {
      this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = "1";
    }
    if (frameBufferType !== void 0) {
      this.renderTargetMasked.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTargetMasked.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
};

// src/materials/glsl/edge-detection.frag
var edge_detection_default = "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}";

// src/materials/glsl/edge-detection.vert
var edge_detection_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/EdgeDetectionMaterial.js
var EdgeDetectionMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new edge detection material.
   *
   * TODO Remove parameters.
   * @param {Vector2} [texelSize] - The screen texel size.
   * @param {EdgeDetectionMode} [mode=EdgeDetectionMode.COLOR] - The edge detection mode.
   */
  constructor(texelSize = new Vector2(), mode = EdgeDetectionMode.COLOR) {
    super({
      name: "EdgeDetectionMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
        EDGE_THRESHOLD: "0.1",
        DEPTH_THRESHOLD: "0.01",
        PREDICATION_MODE: "0",
        PREDICATION_THRESHOLD: "0.01",
        PREDICATION_SCALE: "2.0",
        PREDICATION_STRENGTH: "1.0",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        predicationBuffer: new Uniform(null),
        texelSize: new Uniform(texelSize)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: edge_detection_default,
      vertexShader: edge_detection_default2
    });
    this.edgeDetectionMode = mode;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The edge detection mode.
   *
   * @type {EdgeDetectionMode}
   */
  get edgeDetectionMode() {
    return Number(this.defines.EDGE_DETECTION_MODE);
  }
  set edgeDetectionMode(value) {
    this.defines.EDGE_DETECTION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the edge detection mode.
   *
   * @deprecated Use edgeDetectionMode instead.
   * @return {EdgeDetectionMode} The mode.
   */
  getEdgeDetectionMode() {
    return this.edgeDetectionMode;
  }
  /**
   * Sets the edge detection mode.
   *
   * @deprecated Use edgeDetectionMode instead.
   * @param {EdgeDetectionMode} value - The edge detection mode.
   */
  setEdgeDetectionMode(value) {
    this.edgeDetectionMode = value;
  }
  /**
   * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH. Default is 2.0.
   *
   * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.
   *
   * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a
   * direction, the perceptual contrast in the other neighbors will be hidden.
   *
   * @type {Number}
   */
  get localContrastAdaptationFactor() {
    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
  }
  set localContrastAdaptationFactor(value) {
    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the local contrast adaptation factor.
   *
   * @deprecated Use localContrastAdaptationFactor instead.
   * @return {Number} The factor.
   */
  getLocalContrastAdaptationFactor() {
    return this.localContrastAdaptationFactor;
  }
  /**
   * Sets the local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.
   *
   * @deprecated Use localContrastAdaptationFactor instead.
   * @param {Number} value - The local contrast adaptation factor. Default is 2.0.
   */
  setLocalContrastAdaptationFactor(value) {
    this.localContrastAdaptationFactor = value;
  }
  /**
   * The edge detection threshold. Range: [0.0, 0.5].
   *
   * A lower value results in more edges being detected at the expense of performance.
   *
   * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05
   * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.
   *
   * If depth-based edge detection is used, the threshold will depend on the scene depth.
   *
   * @type {Number}
   */
  get edgeDetectionThreshold() {
    return Number(this.defines.EDGE_THRESHOLD);
  }
  set edgeDetectionThreshold(value) {
    this.defines.EDGE_THRESHOLD = value.toFixed("6");
    this.defines.DEPTH_THRESHOLD = (value * 0.1).toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the edge detection threshold.
   *
   * @deprecated Use edgeDetectionThreshold instead.
   * @return {Number} The threshold.
   */
  getEdgeDetectionThreshold() {
    return this.edgeDetectionThreshold;
  }
  /**
   * Sets the edge detection threshold.
   *
   * @deprecated Use edgeDetectionThreshold instead.
   * @param {Number} value - The edge detection threshold. Range: [0.0, 0.5].
   */
  setEdgeDetectionThreshold(value) {
    this.edgeDetectionThreshold = value;
  }
  /**
   * The predication mode.
   *
   * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional
   * buffer such as a light accumulation or depth buffer.
   *
   * @type {PredicationMode}
   */
  get predicationMode() {
    return Number(this.defines.PREDICATION_MODE);
  }
  set predicationMode(value) {
    this.defines.PREDICATION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the predication mode.
   *
   * @deprecated Use predicationMode instead.
   * @return {PredicationMode} The mode.
   */
  getPredicationMode() {
    return this.predicationMode;
  }
  /**
   * Sets the predication mode.
   *
   * @deprecated Use predicationMode instead.
   * @param {PredicationMode} value - The predication mode.
   */
  setPredicationMode(value) {
    this.predicationMode = value;
  }
  /**
   * The predication buffer.
   *
   * @type {Texture}
   */
  set predicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * Sets a custom predication buffer.
   *
   * @deprecated Use predicationBuffer instead.
   * @param {Texture} value - The predication buffer.
   */
  setPredicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * The predication threshold.
   *
   * @type {Number}
   */
  get predicationThreshold() {
    return Number(this.defines.PREDICATION_THRESHOLD);
  }
  set predicationThreshold(value) {
    this.defines.PREDICATION_THRESHOLD = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication threshold.
   *
   * @deprecated Use predicationThreshold instead.
   * @return {Number} The threshold.
   */
  getPredicationThreshold() {
    return this.predicationThreshold;
  }
  /**
   * Sets the predication threshold.
   *
   * @deprecated Use predicationThreshold instead.
   * @param {Number} value - The threshold.
   */
  setPredicationThreshold(value) {
    this.predicationThreshold = value;
  }
  /**
   * The predication scale. Range: [1.0, 5.0].
   *
   * Determines how much the edge detection threshold should be scaled when using predication.
   *
   * @type {Boolean|Texture|Number}
   */
  get predicationScale() {
    return Number(this.defines.PREDICATION_SCALE);
  }
  set predicationScale(value) {
    this.defines.PREDICATION_SCALE = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication scale.
   *
   * @deprecated Use predicationScale instead.
   * @return {Number} The scale.
   */
  getPredicationScale() {
    return this.predicationScale;
  }
  /**
   * Sets the predication scale.
   *
   * @deprecated Use predicationScale instead.
   * @param {Number} value - The scale. Range: [1.0, 5.0].
   */
  setPredicationScale(value) {
    this.predicationScale = value;
  }
  /**
   * The predication strength. Range: [0.0, 1.0].
   *
   * Determines how much the edge detection threshold should be decreased locally when using predication.
   *
   * @type {Number}
   */
  get predicationStrength() {
    return Number(this.defines.PREDICATION_STRENGTH);
  }
  set predicationStrength(value) {
    this.defines.PREDICATION_STRENGTH = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication strength.
   *
   * @deprecated Use predicationStrength instead.
   * @return {Number} The strength.
   */
  getPredicationStrength() {
    return this.predicationStrength;
  }
  /**
   * Sets the predication strength.
   *
   * @deprecated Use predicationStrength instead.
   * @param {Number} value - The strength. Range: [0.0, 1.0].
   */
  setPredicationStrength(value) {
    this.predicationStrength = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/glsl/smaa-weights.frag
var smaa_weights_default = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}";

// src/materials/glsl/smaa-weights.vert
var smaa_weights_default2 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/SMAAWeightsMaterial.js
var SMAAWeightsMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new SMAA weights material.
   *
   * @param {Vector2} [texelSize] - The absolute screen texel size.
   * @param {Vector2} [resolution] - The resolution.
   */
  constructor(texelSize = new Vector2(), resolution = new Vector2()) {
    super({
      name: "SMAAWeightsMaterial",
      defines: {
        // Configurable settings:
        MAX_SEARCH_STEPS_INT: "16",
        MAX_SEARCH_STEPS_FLOAT: "16.0",
        MAX_SEARCH_STEPS_DIAG_INT: "8",
        MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
        CORNER_ROUNDING: "25",
        CORNER_ROUNDING_NORM: "0.25",
        // Non-configurable settings:
        AREATEX_MAX_DISTANCE: "16.0",
        AREATEX_MAX_DISTANCE_DIAG: "20.0",
        AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
        AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
        SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
        SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        searchTexture: new Uniform(null),
        areaTexture: new Uniform(null),
        resolution: new Uniform(resolution),
        texelSize: new Uniform(texelSize)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: smaa_weights_default,
      vertexShader: smaa_weights_default2
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The search lookup texture.
   *
   * @type {Texture}
   */
  get searchTexture() {
    return this.uniforms.searchTexture.value;
  }
  set searchTexture(value) {
    this.uniforms.searchTexture.value = value;
  }
  /**
   * The area lookup texture.
   *
   * @type {Texture}
   */
  get areaTexture() {
    return this.uniforms.areaTexture.value;
  }
  set areaTexture(value) {
    this.uniforms.areaTexture.value = value;
  }
  /**
   * Sets the search and area lookup textures.
   *
   * @deprecated Use searchTexture and areaTexture instead.
   * @param {Texture} search - The search lookup texture.
   * @param {Texture} area - The area lookup texture.
   */
  setLookupTextures(search, area2) {
    this.searchTexture = search;
    this.areaTexture = area2;
  }
  /**
   * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   * Range: [0, 112].
   *
   * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is
   * 64 (perfectly means that longer lines won't look as good, but are still antialiased).
   *
   * @type {Number}
   */
  get orthogonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_INT);
  }
  set orthogonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 112);
    this.defines.MAX_SEARCH_STEPS_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  /**
   * Sets the maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   *
   * @deprecated Use orthogonalSearchSteps instead.
   * @param {Number} value - The search steps. Range: [0, 112].
   */
  setOrthogonalSearchSteps(value) {
    this.orthogonalSearchSteps = value;
  }
  /**
   * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search
   * jumps one pixel at a time. Range: [0, 20].
   *
   * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a
   * significant impact on older machines.
   *
   * @type {Number}
   */
  get diagonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
  }
  set diagonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 20);
    this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  /**
   * Specifies the maximum steps performed in the diagonal pattern searches, at each side of the pixel.
   *
   * @deprecated Use diagonalSearchSteps instead.
   * @param {Number} value - The search steps. Range: [0, 20].
   */
  setDiagonalSearchSteps(value) {
    this.diagonalSearchSteps = value;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   *
   * @type {Boolean}
   */
  get diagonalDetection() {
    return this.defines.DISABLE_DIAG_DETECTION === void 0;
  }
  set diagonalDetection(value) {
    if (value) {
      delete this.defines.DISABLE_DIAG_DETECTION;
    } else {
      this.defines.DISABLE_DIAG_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   *
   * @deprecated Use diagonalDetection instead.
   * @return {Boolean} Whether diagonal pattern detection is enabled.
   */
  isDiagonalDetectionEnabled() {
    return this.diagonalDetection;
  }
  /**
   * Enables or disables diagonal pattern detection.
   *
   * @deprecated Use diagonalDetection instead.
   * @param {Boolean} value - Whether diagonal pattern detection should be enabled.
   */
  setDiagonalDetectionEnabled(value) {
    this.diagonalDetection = value;
  }
  /**
   * Specifies how much sharp corners will be rounded. Range: [0, 100].
   *
   * @type {Number}
   */
  get cornerRounding() {
    return Number(this.defines.CORNER_ROUNDING);
  }
  set cornerRounding(value) {
    const r = Math.min(Math.max(value, 0), 100);
    this.defines.CORNER_ROUNDING = r.toFixed("4");
    this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed("4");
    this.needsUpdate = true;
  }
  /**
   * Specifies how much sharp corners will be rounded.
   *
   * @deprecated Use cornerRounding instead.
   * @param {Number} value - The corner rounding amount. Range: [0, 100].
   */
  setCornerRounding(value) {
    this.cornerRounding = value;
  }
  /**
   * Indicates whether corner detection is enabled.
   *
   * @type {Number}
   */
  get cornerDetection() {
    return this.defines.DISABLE_CORNER_DETECTION === void 0;
  }
  set cornerDetection(value) {
    if (value) {
      delete this.defines.DISABLE_CORNER_DETECTION;
    } else {
      this.defines.DISABLE_CORNER_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether corner rounding is enabled.
   *
   * @deprecated Use cornerDetection instead.
   * @return {Boolean} Whether corner rounding is enabled.
   */
  isCornerRoundingEnabled() {
    return this.cornerDetection;
  }
  /**
   * Enables or disables corner rounding.
   *
   * @deprecated Use cornerDetection instead.
   * @param {Boolean} value - Whether corner rounding should be enabled.
   */
  setCornerRoundingEnabled(value) {
    this.cornerDetection = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.resolution.value.set(width, height);
  }
};

// src/textures/smaa/searchImageDataURL.js
var searchImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC";

// src/textures/smaa/areaImageDataURL.js
var areaImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC";

// src/effects/glsl/smaa.frag
var smaa_default = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}";

// src/effects/glsl/smaa.vert
var smaa_default2 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}";

// src/effects/SMAAEffect.js
var SMAAEffect = class extends Effect {
  /**
   * Constructs a new SMAA effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {SMAAPreset} [options.preset=SMAAPreset.MEDIUM] - The quality preset.
   * @param {EdgeDetectionMode} [options.edgeDetectionMode=EdgeDetectionMode.COLOR] - The edge detection mode.
   * @param {PredicationMode} [options.predicationMode=PredicationMode.DISABLED] - The predication mode.
   */
  constructor({
    blendFunction = BlendFunction.SRC,
    preset = SMAAPreset.MEDIUM,
    edgeDetectionMode = EdgeDetectionMode.COLOR,
    predicationMode = PredicationMode.DISABLED
  } = {}) {
    super("SMAAEffect", smaa_default, {
      vertexShader: smaa_default2,
      blendFunction,
      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["weightMap", new Uniform(null)]
      ])
    });
    let searchImage, areaImage;
    if (arguments.length > 1) {
      searchImage = arguments[0];
      areaImage = arguments[1];
      if (arguments.length > 2) {
        preset = arguments[2];
      }
      if (arguments.length > 3) {
        edgeDetectionMode = arguments[3];
      }
    }
    this.renderTargetEdges = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetEdges.texture.name = "SMAA.Edges";
    this.renderTargetWeights = this.renderTargetEdges.clone();
    this.renderTargetWeights.texture.name = "SMAA.Weights";
    this.uniforms.get("weightMap").value = this.renderTargetWeights.texture;
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial());
    this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;
    this.edgeDetectionMaterial.predicationMode = predicationMode;
    this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());
    const loadingManager = new LoadingManager();
    loadingManager.onLoad = () => {
      const searchTexture = new Texture(searchImage);
      searchTexture.name = "SMAA.Search";
      searchTexture.magFilter = NearestFilter;
      searchTexture.minFilter = NearestFilter;
      searchTexture.generateMipmaps = false;
      searchTexture.needsUpdate = true;
      searchTexture.flipY = true;
      this.weightsMaterial.searchTexture = searchTexture;
      const areaTexture = new Texture(areaImage);
      areaTexture.name = "SMAA.Area";
      areaTexture.magFilter = LinearFilter;
      areaTexture.minFilter = LinearFilter;
      areaTexture.generateMipmaps = false;
      areaTexture.needsUpdate = true;
      areaTexture.flipY = false;
      this.weightsMaterial.areaTexture = areaTexture;
      this.dispatchEvent({ type: "load" });
    };
    loadingManager.itemStart("search");
    loadingManager.itemStart("area");
    if (searchImage !== void 0 && areaImage !== void 0) {
      loadingManager.itemEnd("search");
      loadingManager.itemEnd("area");
    } else if (typeof Image !== "undefined") {
      searchImage = new Image();
      areaImage = new Image();
      searchImage.addEventListener("load", () => loadingManager.itemEnd("search"));
      areaImage.addEventListener("load", () => loadingManager.itemEnd("area"));
      searchImage.src = searchImageDataURL_default;
      areaImage.src = areaImageDataURL_default;
    }
    this.applyPreset(preset);
  }
  /**
   * The edges texture.
   *
   * @type {Texture}
   */
  get edgesTexture() {
    return this.renderTargetEdges.texture;
  }
  /**
   * Returns the edges texture.
   *
   * @deprecated Use edgesTexture instead.
   * @return {Texture} The texture.
   */
  getEdgesTexture() {
    return this.edgesTexture;
  }
  /**
   * The edge weights texture.
   *
   * @type {Texture}
   */
  get weightsTexture() {
    return this.renderTargetWeights.texture;
  }
  /**
   * Returns the edge weights texture.
   *
   * @deprecated Use weightsTexture instead.
   * @return {Texture} The texture.
   */
  getWeightsTexture() {
    return this.weightsTexture;
  }
  /**
   * The edge detection material.
   *
   * @type {EdgeDetectionMaterial}
   */
  get edgeDetectionMaterial() {
    return this.edgeDetectionPass.fullscreenMaterial;
  }
  /**
   * The edge detection material.
   *
   * @type {EdgeDetectionMaterial}
   * @deprecated Use edgeDetectionMaterial instead.
   */
  get colorEdgesMaterial() {
    return this.edgeDetectionMaterial;
  }
  /**
   * Returns the edge detection material.
   *
   * @deprecated Use edgeDetectionMaterial instead.
   * @return {EdgeDetectionMaterial} The material.
   */
  getEdgeDetectionMaterial() {
    return this.edgeDetectionMaterial;
  }
  /**
   * The edge weights material.
   *
   * @type {SMAAWeightsMaterial}
   */
  get weightsMaterial() {
    return this.weightsPass.fullscreenMaterial;
  }
  /**
   * Returns the edge weights material.
   *
   * @deprecated Use weightsMaterial instead.
   * @return {SMAAWeightsMaterial} The material.
   */
  getWeightsMaterial() {
    return this.weightsMaterial;
  }
  /**
   * Sets the edge detection sensitivity.
   *
   * See {@link EdgeDetectionMaterial#setEdgeDetectionThreshold} for more details.
   *
   * @deprecated Use edgeDetectionMaterial instead.
   * @param {Number} threshold - The edge detection sensitivity. Range: [0.05, 0.5].
   */
  setEdgeDetectionThreshold(threshold) {
    this.edgeDetectionMaterial.edgeDetectionThreshold = threshold;
  }
  /**
   * Sets the maximum amount of horizontal/vertical search steps.
   *
   * See {@link SMAAWeightsMaterial#setOrthogonalSearchSteps} for more details.
   *
   * @deprecated Use weightsMaterial instead.
   * @param {Number} steps - The search steps. Range: [0, 112].
   */
  setOrthogonalSearchSteps(steps) {
    this.weightsMaterial.orthogonalSearchSteps = steps;
  }
  /**
   * Applies the given quality preset.
   *
   * @param {SMAAPreset} preset - The preset.
   */
  applyPreset(preset) {
    const edgeDetectionMaterial = this.edgeDetectionMaterial;
    const weightsMaterial = this.weightsMaterial;
    switch (preset) {
      case SMAAPreset.LOW:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.15;
        weightsMaterial.orthogonalSearchSteps = 4;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.MEDIUM:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 8;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.HIGH:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 16;
        weightsMaterial.diagonalSearchSteps = 8;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
      case SMAAPreset.ULTRA:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.05;
        weightsMaterial.orthogonalSearchSteps = 32;
        weightsMaterial.diagonalSearchSteps = 16;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
    }
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.edgeDetectionMaterial.depthBuffer = depthTexture;
    this.edgeDetectionMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    this.clearPass.render(renderer, this.renderTargetEdges);
    this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);
    this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.edgeDetectionMaterial.setSize(width, height);
    this.weightsMaterial.setSize(width, height);
    this.renderTargetEdges.setSize(width, height);
    this.renderTargetWeights.setSize(width, height);
  }
  /**
   * Deletes internal render targets and textures.
   */
  dispose() {
    const { searchTexture, areaTexture } = this.weightsMaterial;
    if (searchTexture !== null && areaTexture !== null) {
      searchTexture.dispose();
      areaTexture.dispose();
    }
    super.dispose();
  }
  /**
   * The SMAA search image, encoded as a base64 data URL.
   *
   * @type {String}
   * @deprecated
   */
  static get searchImageDataURL() {
    return searchImageDataURL_default;
  }
  /**
   * The SMAA area image, encoded as a base64 data URL.
   *
   * @type {String}
   * @deprecated
   */
  static get areaImageDataURL() {
    return areaImageDataURL_default;
  }
};

// src/materials/glsl/ssao.frag
var ssao_default = "#include <common>\n#include <packing>\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\nuniform lowp sampler2D normalBuffer;\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\n#ifdef NORMAL_DEPTH\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\n#else\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\n#endif\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\n#ifdef LEGACY_INTENSITY\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\n#endif\n}gl_FragColor.r=ao;}";

// src/materials/glsl/ssao.vert
var ssao_default2 = "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/SSAOMaterial.js
var SSAOMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new SSAO material.
   *
   * @param {Camera} camera - A camera.
   */
  constructor(camera) {
    super({
      name: "SSAOMaterial",
      defines: {
        SAMPLES_INT: "0",
        INV_SAMPLES_FLOAT: "0.0",
        SPIRAL_TURNS: "0.0",
        RADIUS: "1.0",
        RADIUS_SQ: "1.0",
        DISTANCE_SCALING: "1",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        normalBuffer: new Uniform(null),
        normalDepthBuffer: new Uniform(null),
        noiseTexture: new Uniform(null),
        inverseProjectionMatrix: new Uniform(new Matrix4()),
        projectionMatrix: new Uniform(new Matrix4()),
        texelSize: new Uniform(new Vector2()),
        cameraNearFar: new Uniform(new Vector2()),
        distanceCutoff: new Uniform(new Vector2()),
        proximityCutoff: new Uniform(new Vector2()),
        noiseScale: new Uniform(new Vector2()),
        minRadiusScale: new Uniform(0.33),
        intensity: new Uniform(1),
        fade: new Uniform(0.01),
        bias: new Uniform(0)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: ssao_default,
      vertexShader: ssao_default2
    });
    this.copyCameraSettings(camera);
    this.resolution = new Vector2();
    this.r = 1;
  }
  /**
   * The current near plane setting.
   *
   * @type {Number}
   * @private
   */
  get near() {
    return this.uniforms.cameraNearFar.value.x;
  }
  /**
   * The current far plane setting.
   *
   * @type {Number}
   * @private
   */
  get far() {
    return this.uniforms.cameraNearFar.value.y;
  }
  /**
   * A combined normal-depth buffer.
   *
   * @type {Texture}
   */
  set normalDepthBuffer(value) {
    this.uniforms.normalDepthBuffer.value = value;
    if (value !== null) {
      this.defines.NORMAL_DEPTH = "1";
    } else {
      delete this.defines.NORMAL_DEPTH;
    }
    this.needsUpdate = true;
  }
  /**
   * Sets the combined normal-depth buffer.
   *
   * @deprecated Use normalDepthBuffer instead.
   * @param {Number} value - The buffer.
   */
  setNormalDepthBuffer(value) {
    this.normalDepthBuffer = value;
  }
  /**
   * The normal buffer.
   *
   * @type {Texture}
   */
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
  }
  /**
   * Sets the normal buffer.
   *
   * @deprecated Use normalBuffer instead.
   * @param {Number} value - The buffer.
   */
  setNormalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The noise texture.
   *
   * @type {Texture}
   */
  set noiseTexture(value) {
    this.uniforms.noiseTexture.value = value;
  }
  /**
   * Sets the noise texture.
   *
   * @deprecated Use noiseTexture instead.
   * @param {Number} value - The texture.
   */
  setNoiseTexture(value) {
    this.uniforms.noiseTexture.value = value;
  }
  /**
   * The sample count.
   *
   * @type {Number}
   */
  get samples() {
    return Number(this.defines.SAMPLES_INT);
  }
  set samples(value) {
    this.defines.SAMPLES_INT = value.toFixed(0);
    this.defines.INV_SAMPLES_FLOAT = (1 / value).toFixed(9);
    this.needsUpdate = true;
  }
  /**
   * Returns the amount of occlusion samples per pixel.
   *
   * @deprecated Use samples instead.
   * @return {Number} The sample count.
   */
  getSamples() {
    return this.samples;
  }
  /**
   * Sets the amount of occlusion samples per pixel.
   *
   * @deprecated Use samples instead.
   * @param {Number} value - The sample count.
   */
  setSamples(value) {
    this.samples = value;
  }
  /**
   * The sampling spiral ring count.
   *
   * @type {Number}
   */
  get rings() {
    return Number(this.defines.SPIRAL_TURNS);
  }
  set rings(value) {
    this.defines.SPIRAL_TURNS = value.toFixed(1);
    this.needsUpdate = true;
  }
  /**
   * Returns the amount of spiral turns in the occlusion sampling pattern.
   *
   * @deprecated Use rings instead.
   * @return {Number} The radius.
   */
  getRings() {
    return this.rings;
  }
  /**
   * Sets the amount of spiral turns in the occlusion sampling pattern.
   *
   * @deprecated Use rings instead.
   * @param {Number} value - The radius.
   */
  setRings(value) {
    this.rings = value;
  }
  /**
   * The intensity.
   *
   * @type {Number}
   * @deprecated Use SSAOEffect.intensity instead.
   */
  get intensity() {
    return this.uniforms.intensity.value;
  }
  set intensity(value) {
    this.uniforms.intensity.value = value;
    if (this.defines.LEGACY_INTENSITY === void 0) {
      this.defines.LEGACY_INTENSITY = "1";
      this.needsUpdate = true;
    }
  }
  /**
   * Returns the intensity.
   *
   * @deprecated Use SSAOEffect.intensity instead.
   * @return {Number} The intensity.
   */
  getIntensity() {
    return this.uniforms.intensity.value;
  }
  /**
   * Sets the intensity.
   *
   * @deprecated Use SSAOEffect.intensity instead.
   * @param {Number} value - The intensity.
   */
  setIntensity(value) {
    this.uniforms.intensity.value = value;
  }
  /**
   * The depth fade factor.
   *
   * @type {Number}
   */
  get fade() {
    return this.uniforms.fade.value;
  }
  set fade(value) {
    this.uniforms.fade.value = value;
  }
  /**
   * Returns the depth fade factor.
   *
   * @deprecated Use fade instead.
   * @return {Number} The fade factor.
   */
  getFade() {
    return this.uniforms.fade.value;
  }
  /**
   * Sets the depth fade factor.
   *
   * @deprecated Use fade instead.
   * @param {Number} value - The fade factor.
   */
  setFade(value) {
    this.uniforms.fade.value = value;
  }
  /**
   * The depth bias. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get bias() {
    return this.uniforms.bias.value;
  }
  set bias(value) {
    this.uniforms.bias.value = value;
  }
  /**
   * Returns the depth bias.
   *
   * @deprecated Use bias instead.
   * @return {Number} The bias.
   */
  getBias() {
    return this.uniforms.bias.value;
  }
  /**
   * Sets the depth bias.
   *
   * @deprecated Use bias instead.
   * @param {Number} value - The bias.
   */
  setBias(value) {
    this.uniforms.bias.value = value;
  }
  /**
   * The minimum radius scale for distance scaling. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get minRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  set minRadiusScale(value) {
    this.uniforms.minRadiusScale.value = value;
  }
  /**
   * Returns the minimum radius scale for distance scaling.
   *
   * @deprecated Use minRadiusScale instead.
   * @return {Number} The minimum radius scale.
   */
  getMinRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  /**
   * Sets the minimum radius scale for distance scaling.
   *
   * @deprecated Use minRadiusScale instead.
   * @param {Number} value - The minimum radius scale.
   */
  setMinRadiusScale(value) {
    this.uniforms.minRadiusScale.value = value;
  }
  /**
   * Updates the absolute radius.
   *
   * @private
   */
  updateRadius() {
    const radius = this.r * this.resolution.height;
    this.defines.RADIUS = radius.toFixed(11);
    this.defines.RADIUS_SQ = (radius * radius).toFixed(11);
    this.needsUpdate = true;
  }
  /**
   * The occlusion sampling radius. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get radius() {
    return this.r;
  }
  set radius(value) {
    this.r = Math.min(Math.max(value, 1e-6), 1);
    this.updateRadius();
  }
  /**
   * Returns the occlusion sampling radius.
   *
   * @deprecated Use radius instead.
   * @return {Number} The radius.
   */
  getRadius() {
    return this.radius;
  }
  /**
   * Sets the occlusion sampling radius.
   *
   * @deprecated Use radius instead.
   * @param {Number} value - The radius. Range [1e-6, 1.0].
   */
  setRadius(value) {
    this.radius = value;
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get distanceScaling() {
    return true;
  }
  set distanceScaling(value) {
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @deprecated
   * @return {Boolean} Whether distance scaling is enabled.
   */
  isDistanceScalingEnabled() {
    return this.distanceScaling;
  }
  /**
   * Enables or disables distance-based radius scaling.
   *
   * @deprecated
   * @param {Boolean} value - Whether distance scaling should be enabled.
   */
  setDistanceScalingEnabled(value) {
    this.distanceScaling = value;
  }
  /**
   * The occlusion distance threshold. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get distanceThreshold() {
    return this.uniforms.distanceCutoff.value.x;
  }
  set distanceThreshold(value) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(value, 0), 1),
      Math.min(Math.max(value + this.distanceFalloff, 0), 1)
    );
  }
  /**
   * The occlusion distance threshold in world units.
   *
   * @type {Number}
   */
  get worldDistanceThreshold() {
    return -orthographicDepthToViewZ(this.distanceThreshold, this.near, this.far);
  }
  set worldDistanceThreshold(value) {
    this.distanceThreshold = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * The occlusion distance falloff. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get distanceFalloff() {
    return this.uniforms.distanceCutoff.value.y - this.distanceThreshold;
  }
  set distanceFalloff(value) {
    this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + value, 0), 1);
  }
  /**
   * The occlusion distance falloff in world units.
   *
   * @type {Number}
   */
  get worldDistanceFalloff() {
    return -orthographicDepthToViewZ(this.distanceFalloff, this.near, this.far);
  }
  set worldDistanceFalloff(value) {
    this.distanceFalloff = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Sets the occlusion distance cutoff.
   *
   * @deprecated Use distanceThreshold and distanceFalloff instead.
   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setDistanceCutoff(threshold, falloff) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(threshold, 0), 1),
      Math.min(Math.max(threshold + falloff, 0), 1)
    );
  }
  /**
   * The occlusion proximity threshold. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get proximityThreshold() {
    return this.uniforms.proximityCutoff.value.x;
  }
  set proximityThreshold(value) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(value, 0), 1),
      Math.min(Math.max(value + this.proximityFalloff, 0), 1)
    );
  }
  /**
   * The occlusion proximity threshold in world units.
   *
   * @type {Number}
   */
  get worldProximityThreshold() {
    return -orthographicDepthToViewZ(this.proximityThreshold, this.near, this.far);
  }
  set worldProximityThreshold(value) {
    this.proximityThreshold = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * The occlusion proximity falloff. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get proximityFalloff() {
    return this.uniforms.proximityCutoff.value.y - this.proximityThreshold;
  }
  set proximityFalloff(value) {
    this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + value, 0), 1);
  }
  /**
   * The occlusion proximity falloff in world units.
   *
   * @type {Number}
   */
  get worldProximityFalloff() {
    return -orthographicDepthToViewZ(this.proximityFalloff, this.near, this.far);
  }
  set worldProximityFalloff(value) {
    this.proximityFalloff = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Sets the occlusion proximity cutoff.
   *
   * @deprecated Use proximityThreshold and proximityFalloff instead.
   * @param {Number} threshold - The range threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setProximityCutoff(threshold, falloff) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(threshold, 0), 1),
      Math.min(Math.max(threshold + falloff, 0), 1)
    );
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      this.uniforms.projectionMatrix.value.copy(camera.projectionMatrix);
      this.uniforms.inverseProjectionMatrix.value.copy(camera.projectionMatrix).invert();
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    const noiseTexture = uniforms.noiseTexture.value;
    if (noiseTexture !== null) {
      uniforms.noiseScale.value.set(
        width / noiseTexture.image.width,
        height / noiseTexture.image.height
      );
    }
    uniforms.texelSize.value.set(1 / width, 1 / height);
    this.resolution.set(width, height);
    this.updateRadius();
  }
};

// src/materials/glsl/depth-downsampling.frag
var depth_downsampling_default = "#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\n#ifdef DOWNSAMPLE_NORMALS\nuniform lowp sampler2D normalBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);\n#ifdef DOWNSAMPLE_NORMALS\nvec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;\n#else\nvec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);\n#endif\ngl_FragColor=vec4(n[index],d[index]);}";

// src/materials/glsl/depth-downsampling.vert
var depth_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/DepthDownsamplingMaterial.js
var DepthDownsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new depth downsampling material.
   */
  constructor() {
    super({
      name: "DepthDownsamplingMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        normalBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_downsampling_default,
      vertexShader: depth_downsampling_default2
    });
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The normal buffer.
   *
   * @type {Texture}
   */
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
    if (value !== null) {
      this.defines.DOWNSAMPLE_NORMALS = "1";
    } else {
      delete this.defines.DOWNSAMPLE_NORMALS;
    }
    this.needsUpdate = true;
  }
  /**
   * Sets the normal buffer.
   *
   * @deprecated Use normalBuffer instead.
   * @param {Texture} value - The normal buffer.
   */
  setNormalBuffer(value) {
    this.normalBuffer = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/passes/DepthDownsamplingPass.js
var DepthDownsamplingPass = class extends Pass {
  /**
   * Constructs a new depth downsampling pass.
   *
   * @param {Object} [options] - The options.
   * @param {Texture} [options.normalBuffer=null] - A texture that contains view space normals. See {@link NormalPass}.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    normalBuffer = null,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthDownsamplingPass");
    const material = new DepthDownsamplingMaterial();
    material.normalBuffer = normalBuffer;
    this.fullscreenMaterial = material;
    this.needsDepthTexture = true;
    this.needsSwap = false;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthBuffer: false,
      type: FloatType
    });
    this.renderTarget.texture.name = "DepthDownsamplingPass.Target";
    this.renderTarget.texture.generateMipmaps = false;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * The normal(RGB) + depth(A) texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the normal(RGB) + depth(A) texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
  }
  /**
   * Downsamples depth and scene normals.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.fullscreenMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    const gl = renderer.getContext();
    const renderable = gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float");
    if (!renderable) {
      throw new Error("Rendering to float texture is not supported.");
    }
  }
};

// src/effects/glsl/ssao.frag
var ssao_default3 = "uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#endif\n#ifdef COLORIZE\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\n#else\nfloat ao=aoLinear;\n#endif\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\n#ifdef COLORIZE\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\n#else\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\n#endif\n}";

// src/effects/SSAOEffect.js
var NOISE_TEXTURE_SIZE = 64;
var SSAOEffect = class extends Effect {
  /**
   * Constructs a new SSAO effect.
   *
   * @todo Move normalBuffer to options.
   * @param {Camera} [camera] - The main camera.
   * @param {Texture} [normalBuffer] - A texture that contains the scene normals.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.MULTIPLY] - The blend function of this effect.
   * @param {Boolean} [options.distanceScaling=true] - Deprecated.
   * @param {Boolean} [options.depthAwareUpsampling=true] - Enables or disables depth-aware upsampling. Has no effect if WebGL 2 is not supported.
   * @param {Texture} [options.normalDepthBuffer=null] - Deprecated.
   * @param {Number} [options.samples=9] - The amount of samples per pixel. Should not be a multiple of the ring count.
   * @param {Number} [options.rings=7] - The amount of spiral turns in the occlusion sampling pattern. Should be a prime number.
   * @param {Number} [options.worldDistanceThreshold] - The world distance threshold at which the occlusion effect starts to fade out.
   * @param {Number} [options.worldDistanceFalloff] - The world distance falloff. Influences the smoothness of the occlusion cutoff.
   * @param {Number} [options.worldProximityThreshold] - The world proximity threshold at which the occlusion starts to fade out.
   * @param {Number} [options.worldProximityFalloff] - The world proximity falloff. Influences the smoothness of the proximity cutoff.
   * @param {Number} [options.distanceThreshold=0.97] - Deprecated.
   * @param {Number} [options.distanceFalloff=0.03] - Deprecated.
   * @param {Number} [options.rangeThreshold=0.0005] - Deprecated.
   * @param {Number} [options.rangeFalloff=0.001] - Deprecated.
   * @param {Number} [options.minRadiusScale=0.1] - The minimum radius scale.
   * @param {Number} [options.luminanceInfluence=0.7] - Determines how much the luminance of the scene influences the ambient occlusion.
   * @param {Number} [options.radius=0.1825] - The occlusion sampling radius, expressed as a scale relative to the resolution. Range [1e-6, 1.0].
   * @param {Number} [options.intensity=1.0] - The intensity of the ambient occlusion.
   * @param {Number} [options.bias=0.025] - An occlusion bias. Eliminates artifacts caused by depth discontinuities.
   * @param {Number} [options.fade=0.01] - Influences the smoothness of the shadows. A lower value results in higher contrast.
   * @param {Color} [options.color=null] - The color of the ambient occlusion.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(camera, normalBuffer, {
    blendFunction = BlendFunction.MULTIPLY,
    samples = 9,
    rings = 7,
    normalDepthBuffer = null,
    depthAwareUpsampling = true,
    worldDistanceThreshold,
    worldDistanceFalloff,
    worldProximityThreshold,
    worldProximityFalloff,
    distanceThreshold = 0.97,
    distanceFalloff = 0.03,
    rangeThreshold = 5e-4,
    rangeFalloff = 1e-3,
    minRadiusScale = 0.1,
    luminanceInfluence = 0.7,
    radius = 0.1825,
    intensity = 1,
    bias = 0.025,
    fade = 0.01,
    color: color2 = null,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("SSAOEffect", ssao_default3, {
      blendFunction,
      attributes: EffectAttribute.DEPTH,
      defines: /* @__PURE__ */ new Map([
        ["THRESHOLD", "0.997"]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["aoBuffer", new Uniform(null)],
        ["normalDepthBuffer", new Uniform(normalDepthBuffer)],
        ["luminanceInfluence", new Uniform(luminanceInfluence)],
        ["color", new Uniform(null)],
        ["intensity", new Uniform(intensity)],
        ["scale", new Uniform(0)]
        // Unused.
      ])
    });
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "AO.Target";
    this.uniforms.get("aoBuffer").value = this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.camera = camera;
    this.depthDownsamplingPass = new DepthDownsamplingPass({ normalBuffer, resolutionScale });
    this.depthDownsamplingPass.enabled = normalDepthBuffer === null;
    this.ssaoPass = new ShaderPass(new SSAOMaterial(camera));
    const noiseTexture = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, RGBAFormat);
    noiseTexture.wrapS = noiseTexture.wrapT = RepeatWrapping;
    const ssaoMaterial = this.ssaoMaterial;
    ssaoMaterial.normalBuffer = normalBuffer;
    ssaoMaterial.noiseTexture = noiseTexture;
    ssaoMaterial.minRadiusScale = minRadiusScale;
    ssaoMaterial.samples = samples;
    ssaoMaterial.radius = radius;
    ssaoMaterial.rings = rings;
    ssaoMaterial.fade = fade;
    ssaoMaterial.bias = bias;
    ssaoMaterial.distanceThreshold = distanceThreshold;
    ssaoMaterial.distanceFalloff = distanceFalloff;
    ssaoMaterial.proximityThreshold = rangeThreshold;
    ssaoMaterial.proximityFalloff = rangeFalloff;
    if (worldDistanceThreshold !== void 0) {
      ssaoMaterial.worldDistanceThreshold = worldDistanceThreshold;
    }
    if (worldDistanceFalloff !== void 0) {
      ssaoMaterial.worldDistanceFalloff = worldDistanceFalloff;
    }
    if (worldProximityThreshold !== void 0) {
      ssaoMaterial.worldProximityThreshold = worldProximityThreshold;
    }
    if (worldProximityFalloff !== void 0) {
      ssaoMaterial.worldProximityFalloff = worldProximityFalloff;
    }
    if (normalDepthBuffer !== null) {
      this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;
      this.defines.set("NORMAL_DEPTH", "1");
    }
    this.depthAwareUpsampling = depthAwareUpsampling;
    this.color = color2;
  }
  set mainCamera(value) {
    this.camera = value;
    this.ssaoMaterial.copyCameraSettings(value);
  }
  /**
   * Sets the normal buffer.
   *
   * @type {Texture}
   */
  get normalBuffer() {
    return this.ssaoMaterial.normalBuffer;
  }
  set normalBuffer(value) {
    this.ssaoMaterial.normalBuffer = value;
    this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = value;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The SSAO material.
   *
   * @type {SSAOMaterial}
   */
  get ssaoMaterial() {
    return this.ssaoPass.fullscreenMaterial;
  }
  /**
   * Returns the SSAO material.
   *
   * @deprecated Use ssaoMaterial instead.
   * @return {SSAOMaterial} The material.
   */
  getSSAOMaterial() {
    return this.ssaoMaterial;
  }
  /**
   * The amount of occlusion samples per pixel.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.samples instead.
   */
  get samples() {
    return this.ssaoMaterial.samples;
  }
  set samples(value) {
    this.ssaoMaterial.samples = value;
  }
  /**
   * The amount of spiral turns in the occlusion sampling pattern.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.rings instead.
   */
  get rings() {
    return this.ssaoMaterial.rings;
  }
  set rings(value) {
    this.ssaoMaterial.rings = value;
  }
  /**
   * The occlusion sampling radius.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.radius instead.
   */
  get radius() {
    return this.ssaoMaterial.radius;
  }
  set radius(value) {
    this.ssaoMaterial.radius = value;
  }
  /**
   * Indicates whether depth-aware upsampling is enabled.
   *
   * @type {Boolean}
   */
  get depthAwareUpsampling() {
    return this.defines.has("DEPTH_AWARE_UPSAMPLING");
  }
  set depthAwareUpsampling(value) {
    if (this.depthAwareUpsampling !== value) {
      if (value) {
        this.defines.set("DEPTH_AWARE_UPSAMPLING", "1");
      } else {
        this.defines.delete("DEPTH_AWARE_UPSAMPLING");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether depth-aware upsampling is enabled.
   *
   * @deprecated Use depthAwareUpsampling instead.
   * @return {Boolean} Whether depth-aware upsampling is enabled.
   */
  isDepthAwareUpsamplingEnabled() {
    return this.depthAwareUpsampling;
  }
  /**
   * Enables or disables depth-aware upsampling.
   *
   * @deprecated Use depthAwareUpsampling instead.
   * @param {Boolean} value - Whether depth-aware upsampling should be enabled.
   */
  setDepthAwareUpsamplingEnabled(value) {
    this.depthAwareUpsampling = value;
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get distanceScaling() {
    return true;
  }
  set distanceScaling(value) {
  }
  /**
   * The color of the ambient occlusion. Set to `null` to disable.
   *
   * @type {Color}
   */
  get color() {
    return this.uniforms.get("color").value;
  }
  set color(value) {
    const uniforms = this.uniforms;
    const defines = this.defines;
    if (value !== null) {
      if (defines.has("COLORIZE")) {
        uniforms.get("color").value.set(value);
      } else {
        defines.set("COLORIZE", "1");
        uniforms.get("color").value = new Color(value);
        this.setChanged();
      }
    } else if (defines.has("COLORIZE")) {
      defines.delete("COLORIZE");
      uniforms.get("color").value = null;
      this.setChanged();
    }
  }
  /**
   * The luminance influence factor. Range: [0.0, 1.0].
   *
   * @type {Boolean}
   */
  get luminanceInfluence() {
    return this.uniforms.get("luminanceInfluence").value;
  }
  set luminanceInfluence(value) {
    this.uniforms.get("luminanceInfluence").value = value;
  }
  /**
   * The intensity.
   *
   * @type {Number}
   */
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  /**
   * Returns the color of the ambient occlusion.
   *
   * @deprecated Use color instead.
   * @return {Color} The color.
   */
  getColor() {
    return this.color;
  }
  /**
   * Sets the color of the ambient occlusion. Set to `null` to disable colorization.
   *
   * @deprecated Use color instead.
   * @param {Color} value - The color.
   */
  setColor(value) {
    this.color = value;
  }
  /**
   * Sets the occlusion distance cutoff.
   *
   * @deprecated Use ssaoMaterial instead.
   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setDistanceCutoff(threshold, falloff) {
    this.ssaoMaterial.distanceThreshold = threshold;
    this.ssaoMaterial.distanceFalloff = falloff;
  }
  /**
   * Sets the occlusion proximity cutoff.
   *
   * @deprecated Use ssaoMaterial instead.
   * @param {Number} threshold - The proximity threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setProximityCutoff(threshold, falloff) {
    this.ssaoMaterial.proximityThreshold = threshold;
    this.ssaoMaterial.proximityFalloff = falloff;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.depthDownsamplingPass.setDepthTexture(depthTexture, depthPacking);
    this.ssaoMaterial.depthBuffer = depthTexture;
    this.ssaoMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    if (this.depthDownsamplingPass.enabled) {
      this.depthDownsamplingPass.render(renderer);
    }
    this.ssaoPass.render(renderer, null, renderTarget);
  }
  /**
   * Sets the size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.ssaoMaterial.copyCameraSettings(this.camera);
    this.ssaoMaterial.setSize(w, h);
    this.renderTarget.setSize(w, h);
    this.depthDownsamplingPass.resolution.scale = resolution.scale;
    this.depthDownsamplingPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    try {
      let normalDepthBuffer = this.uniforms.get("normalDepthBuffer").value;
      if (normalDepthBuffer === null) {
        this.depthDownsamplingPass.initialize(renderer, alpha, frameBufferType);
        normalDepthBuffer = this.depthDownsamplingPass.texture;
        this.uniforms.get("normalDepthBuffer").value = normalDepthBuffer;
        this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;
        this.defines.set("NORMAL_DEPTH", "1");
      }
    } catch (e) {
      this.depthDownsamplingPass.enabled = false;
    }
  }
};

// src/materials/glsl/effect.frag
var effect_default = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}";

// src/materials/glsl/effect.vert
var effect_default2 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/EffectMaterial.js
var EffectMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new effect material.
   *
   * @param {Map<String, String>} [shaderParts] - Deprecated. Use setShaderData instead.
   * @param {Map<String, String>} [defines] - Deprecated. Use setShaderData instead.
   * @param {Map<String, Uniform>} [uniforms] - Deprecated. Use setShaderData instead.
   * @param {Camera} [camera] - A camera.
   * @param {Boolean} [dithering=false] - Deprecated.
   */
  constructor(shaderParts, defines, uniforms, camera, dithering = false) {
    super({
      name: "EffectMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        DEPTH_PACKING: "0",
        ENCODE_OUTPUT: "1"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        resolution: new Uniform(new Vector2()),
        texelSize: new Uniform(new Vector2()),
        cameraNear: new Uniform(0.3),
        cameraFar: new Uniform(1e3),
        aspect: new Uniform(1),
        time: new Uniform(0)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      dithering
    });
    if (shaderParts) {
      this.setShaderParts(shaderParts);
    }
    if (defines) {
      this.setDefines(defines);
    }
    if (uniforms) {
      this.setUniforms(uniforms);
    }
    this.copyCameraSettings(camera);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * Sets the shader data.
   *
   * @param {EffectShaderData} data - The shader data.
   * @return {EffectMaterial} This material.
   */
  setShaderData(data) {
    this.setShaderParts(data.shaderParts);
    this.setDefines(data.defines);
    this.setUniforms(data.uniforms);
    this.setExtensions(data.extensions);
  }
  /**
   * Sets the shader parts.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, String>} shaderParts - A collection of shader snippets. See {@link EffectShaderSection}.
   * @return {EffectMaterial} This material.
   */
  setShaderParts(shaderParts) {
    this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || "").replace(EffectShaderSection.FRAGMENT_MAIN_UV, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || "");
    this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, shaderParts.get(EffectShaderSection.VERTEX_HEAD) || "").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || "");
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader macros.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, String>} defines - A collection of preprocessor macro definitions.
   * @return {EffectMaterial} This material.
   */
  setDefines(defines) {
    for (const entry of defines.entries()) {
      this.defines[entry[0]] = entry[1];
    }
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader uniforms.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, Uniform>} uniforms - A collection of uniforms.
   * @return {EffectMaterial} This material.
   */
  setUniforms(uniforms) {
    for (const entry of uniforms.entries()) {
      this.uniforms[entry[0]] = entry[1];
    }
    return this;
  }
  /**
   * Sets the required shader extensions.
   *
   * @deprecated Use setShaderData instead.
   * @param {Set<WebGLExtension>} extensions - A collection of extensions.
   * @return {EffectMaterial} This material.
   */
  setExtensions(extensions) {
    this.extensions = {};
    for (const extension of extensions) {
      this.extensions[extension] = true;
    }
    return this;
  }
  /**
   * Indicates whether output encoding is enabled.
   *
   * @type {Boolean}
   */
  get encodeOutput() {
    return this.defines.ENCODE_OUTPUT !== void 0;
  }
  set encodeOutput(value) {
    if (this.encodeOutput !== value) {
      if (value) {
        this.defines.ENCODE_OUTPUT = "1";
      } else {
        delete this.defines.ENCODE_OUTPUT;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Indicates whether output encoding is enabled.
   *
   * @deprecated Use encodeOutput instead.
   * @return {Boolean} Whether output encoding is enabled.
   */
  isOutputEncodingEnabled(value) {
    return this.encodeOutput;
  }
  /**
   * Enables or disables output encoding.
   *
   * @deprecated Use encodeOutput instead.
   * @param {Boolean} value - Whether output encoding should be enabled.
   */
  setOutputEncodingEnabled(value) {
    this.encodeOutput = value;
  }
  /**
   * The time in seconds.
   *
   * @type {Number}
   */
  get time() {
    return this.uniforms.time.value;
  }
  set time(value) {
    this.uniforms.time.value = value;
  }
  /**
   * Sets the delta time.
   *
   * @deprecated Use time instead.
   * @param {Number} value - The delta time in seconds.
   */
  setDeltaTime(value) {
    this.uniforms.time.value += value;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Sets the resolution.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.resolution.value.set(width, height);
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.aspect.value = width / height;
  }
  /**
   * An enumeration of shader code placeholders.
   *
   * @deprecated Use EffectShaderSection instead.
   * @type {Object}
   */
  static get Section() {
    return EffectShaderSection;
  }
};

// src/passes/DepthPickingPass.js
Number(REVISION.replace(/\D+/g, ""));
function prefixSubstrings(prefix, substrings, strings) {
  for (const substring of substrings) {
    const prefixed = "$1" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);
    const regExp = new RegExp("([^\\.])(\\b" + substring + "\\b)", "g");
    for (const entry of strings.entries()) {
      if (entry[1] !== null) {
        strings.set(entry[0], entry[1].replace(regExp, prefixed));
      }
    }
  }
}
function integrateEffect(prefix, effect, data) {
  let fragmentShader = effect.getFragmentShader();
  let vertexShader = effect.getVertexShader();
  const mainImageExists = fragmentShader !== void 0 && /mainImage/.test(fragmentShader);
  const mainUvExists = fragmentShader !== void 0 && /mainUv/.test(fragmentShader);
  data.attributes |= effect.getAttributes();
  if (fragmentShader === void 0) {
    throw new Error(`Missing fragment shader (${effect.name})`);
  } else if (mainUvExists && (data.attributes & EffectAttribute.CONVOLUTION) !== 0) {
    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effect.name})`);
  } else if (!mainImageExists && !mainUvExists) {
    throw new Error(`Could not find mainImage or mainUv function (${effect.name})`);
  } else {
    const functionRegExp = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g;
    const shaderParts = data.shaderParts;
    let fragmentHead = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || "";
    let fragmentMainUv = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "";
    let fragmentMainImage = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || "";
    let vertexHead = shaderParts.get(EffectShaderSection.VERTEX_HEAD) || "";
    let vertexMainSupport = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || "";
    const varyings = /* @__PURE__ */ new Set();
    const names = /* @__PURE__ */ new Set();
    if (mainUvExists) {
      fragmentMainUv += `	${prefix}MainUv(UV);
`;
      data.uvTransformation = true;
    }
    if (vertexShader !== null && /mainSupport/.test(vertexShader)) {
      const needsUv = /mainSupport *\([\w\s]*?uv\s*?\)/.test(vertexShader);
      vertexMainSupport += `	${prefix}MainSupport(`;
      vertexMainSupport += needsUv ? "vUv);\n" : ");\n";
      for (const m2 of vertexShader.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g)) {
        for (const n of m2[1].split(/\s*,\s*/)) {
          data.varyings.add(n);
          varyings.add(n);
          names.add(n);
        }
      }
      for (const m2 of vertexShader.matchAll(functionRegExp)) {
        names.add(m2[1]);
      }
    }
    for (const m2 of fragmentShader.matchAll(functionRegExp)) {
      names.add(m2[1]);
    }
    for (const d of effect.defines.keys()) {
      names.add(d.replace(/\([\w\s,]*\)/g, ""));
    }
    for (const u of effect.uniforms.keys()) {
      names.add(u);
    }
    names.delete("while");
    names.delete("for");
    names.delete("if");
    effect.uniforms.forEach((val, key) => data.uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));
    effect.defines.forEach((val, key) => data.defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));
    const shaders = /* @__PURE__ */ new Map([["fragment", fragmentShader], ["vertex", vertexShader]]);
    prefixSubstrings(prefix, names, data.defines);
    prefixSubstrings(prefix, names, shaders);
    fragmentShader = shaders.get("fragment");
    vertexShader = shaders.get("vertex");
    const blendMode = effect.blendMode;
    data.blendModes.set(blendMode.blendFunction, blendMode);
    if (mainImageExists) {
      if (effect.inputColorSpace !== null && effect.inputColorSpace !== data.colorSpace) {
        fragmentMainImage += effect.inputColorSpace === SRGBColorSpace ? "color0 = sRGBTransferOETF(color0);\n	" : "color0 = sRGBToLinear(color0);\n	";
      }
      if (effect.outputColorSpace !== NoColorSpace) {
        data.colorSpace = effect.outputColorSpace;
      } else if (effect.inputColorSpace !== null) {
        data.colorSpace = effect.inputColorSpace;
      }
      const depthParamRegExp = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      fragmentMainImage += `${prefix}MainImage(color0, UV, `;
      if ((data.attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(fragmentShader)) {
        fragmentMainImage += "depth, ";
        data.readDepth = true;
      }
      fragmentMainImage += "color1);\n	";
      const blendOpacity = prefix + "BlendOpacity";
      data.uniforms.set(blendOpacity, blendMode.opacity);
      fragmentMainImage += `color0 = blend${blendMode.blendFunction}(color0, color1, ${blendOpacity});

	`;
      fragmentHead += `uniform float ${blendOpacity};

`;
    }
    fragmentHead += fragmentShader + "\n";
    if (vertexShader !== null) {
      vertexHead += vertexShader + "\n";
    }
    shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    shaderParts.set(EffectShaderSection.VERTEX_HEAD, vertexHead);
    shaderParts.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, vertexMainSupport);
    if (effect.extensions !== null) {
      for (const extension of effect.extensions) {
        data.extensions.add(extension);
      }
    }
  }
}
var EffectPass = class extends Pass {
  /**
   * Constructs a new effect pass.
   *
   * @param {Camera} camera - The main camera.
   * @param {...Effect} effects - The effects that will be rendered by this pass.
   */
  constructor(camera, ...effects) {
    super("EffectPass");
    this.fullscreenMaterial = new EffectMaterial(null, null, null, camera);
    this.listener = (event) => this.handleEvent(event);
    this.effects = [];
    this.setEffects(effects);
    this.skipRendering = false;
    this.minTime = 1;
    this.maxTime = Number.POSITIVE_INFINITY;
    this.timeScale = 1;
  }
  set mainScene(value) {
    for (const effect of this.effects) {
      effect.mainScene = value;
    }
  }
  set mainCamera(value) {
    this.fullscreenMaterial.copyCameraSettings(value);
    for (const effect of this.effects) {
      effect.mainCamera = value;
    }
  }
  /**
   * Indicates whether this pass encodes its output when rendering to screen.
   *
   * @type {Boolean}
   * @deprecated Use fullscreenMaterial.encodeOutput instead.
   */
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(value) {
    this.fullscreenMaterial.encodeOutput = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   */
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(value) {
    const material = this.fullscreenMaterial;
    material.dithering = value;
    material.needsUpdate = true;
  }
  /**
   * Sets the effects.
   *
   * @param {Effect[]} effects - The effects.
   * @protected
   */
  setEffects(effects) {
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
    }
    this.effects = effects.sort((a, b) => b.attributes - a.attributes);
    for (const effect of this.effects) {
      effect.addEventListener("change", this.listener);
    }
  }
  /**
   * Updates the compound shader material.
   *
   * @protected
   */
  updateMaterial() {
    const data = new EffectShaderData();
    let id = 0;
    for (const effect of this.effects) {
      if (effect.blendMode.blendFunction === BlendFunction.DST) {
        data.attributes |= effect.getAttributes() & EffectAttribute.DEPTH;
      } else if ((data.attributes & effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {
        throw new Error(`Convolution effects cannot be merged (${effect.name})`);
      } else {
        integrateEffect("e" + id++, effect, data);
      }
    }
    let fragmentHead = data.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD);
    let fragmentMainImage = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE);
    let fragmentMainUv = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);
    const blendRegExp = /\bblend\b/g;
    for (const blendMode of data.blendModes.values()) {
      fragmentHead += blendMode.getShaderCode().replace(blendRegExp, `blend${blendMode.blendFunction}`) + "\n";
    }
    if ((data.attributes & EffectAttribute.DEPTH) !== 0) {
      if (data.readDepth) {
        fragmentMainImage = "float depth = readDepth(UV);\n\n	" + fragmentMainImage;
      }
      this.needsDepthTexture = this.getDepthTexture() === null;
    } else {
      this.needsDepthTexture = false;
    }
    if (data.colorSpace === SRGBColorSpace) {
      fragmentMainImage += "color0 = sRGBToLinear(color0);\n	";
    }
    if (data.uvTransformation) {
      fragmentMainUv = "vec2 transformedUv = vUv;\n" + fragmentMainUv;
      data.defines.set("UV", "transformedUv");
    } else {
      data.defines.set("UV", "vUv");
    }
    data.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    for (const [key, value] of data.shaderParts) {
      if (value !== null) {
        data.shaderParts.set(key, value.trim().replace(/^#/, "\n#"));
      }
    }
    this.skipRendering = id === 0;
    this.needsSwap = !this.skipRendering;
    this.fullscreenMaterial.setShaderData(data);
  }
  /**
   * Rebuilds the shader material.
   */
  recompile() {
    this.updateMaterial();
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
    for (const effect of this.effects) {
      effect.setDepthTexture(depthTexture, depthPacking);
    }
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    for (const effect of this.effects) {
      effect.update(renderer, inputBuffer, deltaTime);
    }
    if (!this.skipRendering || this.renderToScreen) {
      const material = this.fullscreenMaterial;
      material.inputBuffer = inputBuffer.texture;
      material.time += deltaTime * this.timeScale;
      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
      renderer.render(this.scene, this.camera);
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.fullscreenMaterial.setSize(width, height);
    for (const effect of this.effects) {
      effect.setSize(width, height);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.renderer = renderer;
    for (const effect of this.effects) {
      effect.initialize(renderer, alpha, frameBufferType);
    }
    this.updateMaterial();
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
  /**
   * Deletes disposable objects.
   */
  dispose() {
    super.dispose();
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
      effect.dispose();
    }
  }
  /**
   * Handles events.
   *
   * @param {Event} event - An event.
   */
  handleEvent(event) {
    switch (event.type) {
      case "change":
        this.recompile();
        break;
    }
  }
};

var __defProp$L = Object.defineProperty;
var __typeError$1 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp$L = (obj, key, value) => key in obj ? __defProp$L(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$L = (obj, key, value) => __defNormalProp$L(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError$1("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$1 = (obj, member, value) => member.has(obj) ? __typeError$1("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var _enabled;
class PostProcessingComponent extends Component {
  constructor(options) {
    super(options);
    // @ts-ignore
    __publicField$L(this, "pixelationEffect");
    __publicField$L(this, "composer");
    __publicField$L(this, "renderPass");
    __publicField$L(this, "outputPass");
    __publicField$L(this, "bloomEffect");
    __publicField$L(this, "gridEffect");
    __publicField$L(this, "smaaEffect");
    __publicField$L(this, "ssaoEffect");
    __publicField$L(this, "fxaaEffect");
    __publicField$L(this, "selectiveBloomEffectOptions");
    __publicField$L(this, "bloomEffectOptions");
    // gridEffectOptions!: GridEffectOptions;
    // outlineEffectOptions!: OutlineEffectOptions;
    // smaaEffectOptions!: SMAAEffectOptions;
    // ssaoEffectOptions!: SSAOEffectOptions;
    // fxaaEffectOptions!: FXAAEffectOptions;
    __publicField$L(this, "effectPass");
    __publicField$L(this, "effects", []);
    /**
     * 是否启用后处理
     * @private
     */
    __privateAdd$1(this, _enabled, false);
    //-------------------- 辉光
    __publicField$L(this, "selectiveBloomEffect");
    __publicField$L(this, "selectiveBloomEffectPass");
    //------------------------------ 模糊
    __publicField$L(this, "kawaseBlurPass");
    //------------------------------ 描边
    __publicField$L(this, "outlineEffect");
    __publicField$L(this, "outlinePass");
    const renderer = this.viewer.renderManager.defaultWebGLRenderer;
    this.composer = new EffectComposer(renderer, {
      frameBufferType: HalfFloatType
    });
    const renderPass = new RenderPass(this.scene, this.camera);
    this.composer.addPass(renderPass);
  }
  render(timestamp) {
    if (__privateGet(this, _enabled)) {
      this.composer.render();
    }
  }
  get enable() {
    return __privateGet(this, _enabled);
  }
  set enable(enable) {
    __privateSet(this, _enabled, enable);
  }
  addRenderPass() {
    const scene = this.viewer.scene;
    this.renderPass = new RenderPass(scene, this.viewer.cameraManager.camera);
    this.composer.addPass(this.renderPass);
  }
  /**
   * 初始化辉光效果
   * @param options
   */
  initSelectiveBloomEffect(options) {
    this.selectiveBloomEffect = new SelectiveBloomEffect(this.scene, this.camera, {
      blendFunction: BlendFunction.ADD,
      mipmapBlur: false,
      luminanceThreshold: 0.4,
      luminanceSmoothing: 0.2,
      intensity: 5
    });
    this.selectiveBloomEffect.ignoreBackground = true;
    this.selectiveBloomEffectPass = new EffectPass(this.camera, this.selectiveBloomEffect);
    this.composer.addPass(this.selectiveBloomEffectPass);
  }
  /**
   * 销毁辉光效果
   */
  disposeSelectiveBloomEffect() {
    if (this.selectiveBloomEffectPass) {
      this.composer.removePass(this.selectiveBloomEffectPass);
      this.selectiveBloomEffectPass.dispose();
    }
    if (this.selectiveBloomEffect) {
      this.selectiveBloomEffect.dispose();
    }
  }
  /**
   * 添加辉光对象
   * @param object
   */
  addSelectiveBloomEffectObject(object) {
    if (this.selectiveBloomEffect) {
      if (isGroup(object)) {
        this.selectiveBloomEffect.selection.add(object);
        object.traverse((child) => {
          if (isMesh(child)) {
            this.selectiveBloomEffect?.selection.add(child);
          }
        });
      } else {
        this.selectiveBloomEffect.selection.add(object);
      }
    }
  }
  /**
   * 移除辉光对象
   * @param object
   */
  removeSelectiveBloomEffectObject(object) {
    if (this.selectiveBloomEffect) {
      if (isGroup(object)) {
        this.selectiveBloomEffect.selection.delete(object);
        object.traverse((child) => {
          if (isMesh(child)) {
            this.selectiveBloomEffect?.selection.delete(child);
          }
        });
      } else {
        this.selectiveBloomEffect.selection.delete(object);
      }
    }
  }
  /**
   * 检查辉光对象是否存在
   * @param object
   */
  hasSelectiveBloomEffectObject(object) {
    return this.selectiveBloomEffect?.selection.has(object);
  }
  initBlurEffect(options = {}) {
    this.kawaseBlurPass = new KawaseBlurPass({
      height: 480
    });
    this.composer.addPass(this.kawaseBlurPass);
  }
  disposeBlurEffect() {
    if (this.kawaseBlurPass) {
      this.composer.removePass(this.kawaseBlurPass);
      this.kawaseBlurPass.dispose();
    }
  }
  initOutlineEffect(options = {}) {
    const renderer = this.composer.getRenderer();
    this.outlineEffect = new OutlineEffect(this.scene, this.camera, {
      blendFunction: BlendFunction.SCREEN,
      multisampling: Math.min(4, renderer.capabilities.maxSamples),
      edgeStrength: 2.5,
      pulseSpeed: 0,
      visibleEdgeColor: 16777215,
      hiddenEdgeColor: 2230538,
      height: 480,
      blur: false,
      xRay: true,
      ...options
    });
    this.outlinePass = new EffectPass(this.camera, this.outlineEffect);
    this.composer.addPass(this.outlinePass);
  }
  disposeOutlineEffect() {
    if (this.outlinePass) {
      this.composer.removePass(this.outlinePass);
      this.outlinePass.dispose();
    }
    if (this.outlineEffect) {
      this.outlineEffect.dispose();
    }
  }
  /**
   * 是否包含描边对象
   * @param object
   */
  objectHasOutline(object) {
    if (this.outlineEffect) {
      return this.outlineEffect.selection.has(object);
    }
    return false;
  }
  /**
   * 添加描边对象
   * @param object
   */
  addOutlineObject(object) {
    if (this.outlineEffect) {
      if (isGroup(object)) {
        this.outlineEffect.selection.add(object);
        object.traverse((child) => {
          if (isMesh(child)) {
            this.outlineEffect?.selection.add(child);
          }
        });
      } else {
        this.outlineEffect.selection.add(object);
      }
    }
  }
  /**
   * 移除描边对象
   * @param object
   */
  removeOutlineObject(object) {
    if (this.outlineEffect) {
      if (isGroup(object)) {
        this.outlineEffect.selection.delete(object);
        object.traverse((child) => {
          if (isMesh(child)) {
            this.outlineEffect?.selection.delete(child);
          }
        });
      } else {
        this.outlineEffect.selection.delete(object);
      }
    }
  }
  //----------------- pixelationEffect -----------------
  initPixelationEffect(granularity) {
    this.pixelationEffect = new PixelationEffect(granularity);
  }
  addPixelationEffect() {
    this.effects.push(this.pixelationEffect);
  }
  //----------------- smaaEffect -----------------
  initBloomEffect(options) {
    const _options = deepMergeRetain$1({
      blendFunction: BlendFunction.ADD,
      // 混合函数
      luminanceThreshold: 0.1,
      // 亮度阈值
      luminanceSmoothing: 0.2,
      // 亮度平滑度
      mipmapBlur: true,
      // 是否启用 MIP 模糊
      intensity: 10,
      // 辉光强度
      radius: 0.34,
      // 模糊半径
      levels: 8
      // MIP 级别数量
    }, options);
    this.bloomEffect = new BloomEffect(_options);
  }
  addBloomEffect() {
    this.effects.push(this.bloomEffect);
  }
  //----------------- gridEffect -----------------
  initGridEffect(options) {
    this.gridEffect = new GridEffect(options);
  }
  //----------------- smaaEffect -----------------
  initSMAAEffect(options) {
    this.smaaEffect = new SMAAEffect(options);
  }
  addSMAAEffect() {
    this.effects.push(this.smaaEffect);
  }
  //----------------- ssaoEffect -----------------
  initSSAOEffect(options) {
    this.ssaoEffect = new SSAOEffect(options);
  }
  addSSAOEffect() {
    this.effects.push(this.ssaoEffect);
  }
  //----------------- fxaaEffect -----------------
  initFXAAEffect(options) {
    this.fxaaEffect = new FXAAEffect(options);
  }
  addFXAAEffect() {
    this.effects.push(this.fxaaEffect);
  }
  //----------------- effectPass -----------------
  initEffectPass() {
    this.effectPass = new EffectPass(this.viewer.cameraManager.camera, ...this.effects);
  }
  addEffectPass() {
    if (this.effectPass) {
      this.composer.addPass(this.effectPass);
    }
  }
  //----------------- setSize -----------------
  setSize(width, height) {
    this.composer.setSize(width, height);
  }
}
_enabled = new WeakMap();

const SelectiveBloomEffectOptionsDefault = {
  selection: [],
  // 填入选择的对象
  lights: [],
  // 填入灯光对象
  blendFunction: BlendFunction.SCREEN,
  width: Resolution.AUTO_SIZE,
  // 假设 Resizer 是一个已定义的对象
  height: Resolution.AUTO_SIZE,
  selectionLayer: 0,
  blurPass: null,
  kernelSize: KernelSize.LARGE,
  luminanceThreshold: 0.9,
  luminanceSmoothing: 0.025,
  intensity: 1
};

var __defProp$K = Object.defineProperty;
var __defNormalProp$K = (obj, key, value) => key in obj ? __defProp$K(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$K = (obj, key, value) => __defNormalProp$K(obj, typeof key !== "symbol" ? key + "" : key, value);
class History {
  constructor(editor) {
    __publicField$K(this, "editor");
    __publicField$K(this, "undos", []);
    __publicField$K(this, "redos", []);
    __publicField$K(this, "lastCmdTime", Date.now());
    __publicField$K(this, "idCounter", 0);
    __publicField$K(this, "historyDisabled", false);
    __publicField$K(this, "config");
    this.editor = editor;
  }
  execute(cmd, optionalName = void 0) {
    cmd.editor = this.editor;
    const lastCmd = this.undos[this.undos.length - 1];
    const timeDifference = Date.now() - this.lastCmdTime;
    const isUpdatableCmd = lastCmd && lastCmd.updatable && cmd.updatable && lastCmd.object === cmd.object && lastCmd.type === cmd.type && // lastCmd.script === cmd.script &&
    lastCmd.attributeName === cmd.attributeName;
    if (isUpdatableCmd && timeDifference < 500) {
      lastCmd.update(cmd);
      cmd = lastCmd;
    } else {
      this.undos.push(cmd);
      cmd.id = ++this.idCounter;
    }
    cmd.name = optionalName !== void 0 ? optionalName : cmd.name;
    cmd.execute();
    cmd.inMemory = true;
    this.lastCmdTime = Date.now();
    this.redos = [];
  }
  undo() {
    let cmd = void 0;
    if (this.undos.length > 0) {
      cmd = this.undos.pop();
    }
    if (cmd !== void 0) {
      cmd.undo();
      this.redos.push(cmd);
    }
    return cmd;
  }
  redo() {
    if (this.historyDisabled) {
      return;
    }
    let cmd = void 0;
    if (this.redos.length > 0) {
      cmd = this.redos.pop();
    }
    if (cmd !== void 0) {
      cmd.execute();
      this.undos.push(cmd);
    }
    return cmd;
  }
  toJSON() {
  }
  fromJSON(json) {
  }
  clear() {
    this.undos = [];
    this.redos = [];
    this.idCounter = 0;
  }
  goToState(id) {
    if (this.historyDisabled) {
      return;
    }
    let cmd = this.undos.length > 0 ? this.undos[this.undos.length - 1] : void 0;
    if (cmd === void 0 || id > cmd.id) {
      cmd = this.redo();
      while (cmd !== void 0 && id > cmd.id) {
        cmd = this.redo();
      }
    } else {
      while (true) {
        cmd = this.undos[this.undos.length - 1];
        if (cmd === void 0 || id === cmd.id) break;
        this.undo();
      }
    }
  }
  enableSerialization(id) {
    this.goToState(-1);
    let cmd = this.redo();
    while (cmd !== void 0) {
      if (!cmd.hasOwnProperty("json")) {
        cmd.json = cmd.toJSON();
      }
      cmd = this.redo();
    }
    this.goToState(id);
  }
}

var __defProp$J = Object.defineProperty;
var __defNormalProp$J = (obj, key, value) => key in obj ? __defProp$J(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$J = (obj, key, value) => __defNormalProp$J(obj, typeof key !== "symbol" ? key + "" : key, value);
class Command {
  constructor() {
    __publicField$J(this, "id", 0);
    __publicField$J(this, "inMemory", false);
    __publicField$J(this, "updatable", false);
    __publicField$J(this, "type", "");
    __publicField$J(this, "name", "");
    __publicField$J(this, "editor");
    __publicField$J(this, "attributeName", []);
    __publicField$J(this, "object");
    __publicField$J(this, "oldValue");
    __publicField$J(this, "newValue");
    this.type = this.constructor.name;
  }
  getAttributeName() {
    return toPath(this.attributeName);
  }
  toJSON() {
    return {
      type: this.type,
      id: this.id,
      name: this.name
    };
  }
  fromJSON(json) {
    this.inMemory = true;
    this.type = json.type;
    this.id = json.id;
    this.name = json.name;
  }
}

var __defProp$I = Object.defineProperty;
var __defNormalProp$I = (obj, key, value) => key in obj ? __defProp$I(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$I = (obj, key, value) => __defNormalProp$I(obj, key + "" , value);
class SetValueCommand extends Command {
  /**
   * 构造函数
   * @param object 要修改的三维对象
   * @param attributeName 属性路径，可以是字符串或字符串数组，指向具体的属性
   * @param newValue 新的属性值
   * @param oldValue 旧的属性值，如果未提供，则从对象中获取
   */
  constructor(object, attributeName, newValue, oldValue) {
    super();
    __publicField$I(this, "type", "SetValueCommand");
    this.attributeName = attributeName;
    this.name = "command/SetValue: " + this.getAttributeName();
    this.object = object;
    this.newValue = newValue;
    if (oldValue) {
      this.oldValue = oldValue;
    } else {
      this.oldValue = isNil(object) ? null : get(object, attributeName);
    }
  }
  /**
   * 设置对象的属性值
   * @param isExecute 是否执行命令，true为执行，false为撤销
   */
  setValue(isExecute) {
    const value = isExecute ? this.newValue : this.oldValue;
    if (isArray$1(this.attributeName) && this.attributeName.length > 0) {
      set(this.object, this.attributeName, value);
      if (["position", "rotation", "scale"].includes(this.attributeName[0])) {
        this.editor.editorEventManager.objectChanged.next(this.object);
      }
    } else {
      set(this.object, this.attributeName, value);
      if (this.attributeName === "visible") {
        this.editor.editorEventManager.sceneGraphChanged.next(null);
      }
    }
  }
  /**
   * 执行命令
   */
  execute() {
    this.setValue(true);
  }
  /**
   * 撤销命令
   */
  undo() {
    this.setValue(false);
  }
  /**
   * 更新命令，主要用于在命令被修改时更新其内部值
   * @param cmd 更新用的新命令对象
   */
  update(cmd) {
    this.newValue = cmd.newValue;
  }
  /**
   * 将命令对象转换为JSON格式
   * @returns JSON格式的对象
   */
  toJSON() {
    const output = super.toJSON();
    output.objectUuid = this.object.uuid;
    output.attributeName = this.attributeName;
    output.oldValue = this.oldValue;
    output.newValue = this.newValue;
    return output;
  }
  /**
   * 从JSON对象反序列化命令
   * @param json JSON格式的对象
   */
  fromJSON(json) {
    super.fromJSON(json);
    this.attributeName = json.attributeName;
    this.oldValue = json.oldValue;
    this.newValue = json.newValue;
    this.object = this.editor.objectByUuid(json.objectUuid);
  }
}

var __defProp$H = Object.defineProperty;
var __defNormalProp$H = (obj, key, value) => key in obj ? __defProp$H(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$H = (obj, key, value) => __defNormalProp$H(obj, typeof key !== "symbol" ? key + "" : key, value);
const color$1 = new THREE$2.Color();
class SetMaterialColorCommand extends Command {
  constructor(object, attributeName, newValue, materialSlot = -1) {
    super();
    __publicField$H(this, "type", "SetMaterialColorCommand");
    __publicField$H(this, "materialSlot");
    this.updatable = true;
    this.name = "command/SetMaterialColor: " + attributeName;
    this.object = object;
    this.materialSlot = materialSlot;
    const material = Tool$1.getObjectMaterial(object, materialSlot);
    this.newValue = color$1.setStyle(newValue).getHex();
    this.attributeName = attributeName;
    this.oldValue = invoke(material, [attributeName, "getHex"]);
  }
  /**
   * 设置对象的属性值
   * @param isExecute 是否执行命令，true为执行，false为撤销
   */
  setValue(isExecute) {
    const material = Tool$1.getObjectMaterial(this.object, this.materialSlot);
    const value = isExecute ? this.newValue : this.oldValue;
    invoke(material, [this.attributeName, "setHex"], value);
  }
  execute() {
    this.setValue(true);
  }
  undo() {
    this.setValue(false);
  }
  update(cmd) {
    this.newValue = cmd.newValue;
  }
  toJSON() {
    const output = super.toJSON();
    output.objectUuid = this.object.uuid;
    output.attributeName = this.attributeName;
    output.oldValue = this.oldValue;
    output.newValue = this.newValue;
    output.materialSlot = this.materialSlot;
    return output;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.object = this.editor.objectByUuid(json.objectUuid);
    this.attributeName = json.attributeName;
    this.oldValue = json.oldValue;
    this.newValue = json.newValue;
    this.materialSlot = json.materialSlot;
  }
}

var __defProp$G = Object.defineProperty;
var __defNormalProp$G = (obj, key, value) => key in obj ? __defProp$G(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$G = (obj, key, value) => __defNormalProp$G(obj, typeof key !== "symbol" ? key + "" : key, value);
class SetMaterialCommand extends Command {
  constructor(object, newValue, materialSlot = -1) {
    super();
    __publicField$G(this, "type", "SetMaterialCommand");
    __publicField$G(this, "materialSlot");
    this.name = "command/SetMaterial";
    this.object = object;
    this.materialSlot = materialSlot;
    this.oldValue = isMesh(object) ? Tool$1.getObjectMaterial(object, materialSlot) : null;
    this.newValue = newValue;
  }
  execute() {
    Tool$1.setObjectMaterial(this.object, this.materialSlot, this.newValue);
  }
  undo() {
    Tool$1.setObjectMaterial(this.object, this.materialSlot, this.oldValue);
  }
  toJSON() {
    const output = super.toJSON();
    output.objectUuid = this.object?.uuid;
    output.oldValue = this.oldValue?.toJSON();
    output.newValue = this.newValue?.toJSON();
    output.materialSlot = this.materialSlot;
    return output;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.object = this.editor.objectByUuid(json.objectUuid);
    this.oldValue = parseMaterial(json.oldValue);
    this.newValue = parseMaterial(json.newValue);
    this.materialSlot = json.materialSlot;
    function parseMaterial(json2) {
      const loader = new ObjectLoader();
      const images = loader.parseImages(json2.images);
      const textures = loader.parseTextures(json2.textures, images);
      const materials = loader.parseMaterials([json2], textures);
      return materials[json2.uuid] || null;
    }
  }
  update(command) {
  }
}

var __defProp$F = Object.defineProperty;
var __defNormalProp$F = (obj, key, value) => key in obj ? __defProp$F(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$F = (obj, key, value) => __defNormalProp$F(obj, typeof key !== "symbol" ? key + "" : key, value);
class SetMaterialMapCommand extends Command {
  constructor(object, mapName = "", newValue, materialSlot = -1) {
    super();
    __publicField$F(this, "materialSlot");
    __publicField$F(this, "mapName");
    this.type = "SetMaterialMapCommand";
    this.name = "command/SetMaterialMap: " + mapName;
    this.object = object;
    this.materialSlot = materialSlot;
    const material = object !== null ? Tool.getObjectMaterial(object, materialSlot) : null;
    this.oldValue = material !== null ? get(material, mapName) : void 0;
    this.newValue = newValue;
    this.mapName = mapName;
  }
  execute() {
    if (this.oldValue !== null && this.oldValue !== void 0) this.oldValue.dispose();
    const material = Tool.getObjectMaterial(this.object, this.materialSlot);
    set(material, this.mapName, this.newValue);
    material.needsUpdate = true;
  }
  undo() {
    const material = Tool.getObjectMaterial(this.object, this.materialSlot);
    set(material, this.mapName, this.oldValue);
    material.needsUpdate = true;
  }
  update(command) {
  }
  toJSON() {
  }
  fromJSON(json) {
  }
}

var __defProp$E = Object.defineProperty;
var __defNormalProp$E = (obj, key, value) => key in obj ? __defProp$E(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$E = (obj, key, value) => __defNormalProp$E(obj, typeof key !== "symbol" ? key + "" : key, value);
class SetMaterialValueCommand extends Command {
  constructor(object, attributeName, newValue, materialSlot = -1) {
    super();
    __publicField$E(this, "type", "SetMaterialValueCommand");
    __publicField$E(this, "materialSlot");
    __publicField$E(this, "attributeName");
    this.updatable = true;
    this.name = "command/SetMaterialValue: " + attributeName;
    this.object = object;
    this.materialSlot = materialSlot;
    const material = Tool$1.getObjectMaterial(object, materialSlot);
    this.oldValue = get(material, attributeName);
    this.newValue = newValue;
    this.attributeName = attributeName;
  }
  /**
   * 设置对象的属性值
   * @param isExecute 是否执行命令，true为执行，false为撤销
   */
  setValue(isExecute) {
    const material = Tool$1.getObjectMaterial(this.object, this.materialSlot);
    const value = isExecute ? this.newValue : this.oldValue;
    set(material, this.attributeName, value);
    material.needsUpdate = true;
  }
  /**
   * 执行命令
   */
  execute() {
    this.setValue(true);
  }
  /**
   * 撤销命令
   */
  undo() {
    this.setValue(false);
  }
  fromJSON(json2) {
    super.fromJSON(json2);
    this.attributeName = json2.attributeName;
    this.oldValue = json2.oldValue;
    this.newValue = json2.newValue;
    this.object = this.editor.objectByUuid(json2.objectUuid);
    this.materialSlot = json2.materialSlot;
  }
  update(command) {
  }
}

var __defProp$D = Object.defineProperty;
var __defNormalProp$D = (obj, key, value) => key in obj ? __defProp$D(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$D = (obj, key, value) => __defNormalProp$D(obj, key + "" , value);
class AddObjectCommand extends Command {
  constructor(object) {
    super();
    __publicField$D(this, "type", "AddObjectCommand");
    this.object = object;
    if (object !== null) {
      this.name = "command/AddObject: " + object.name;
    }
  }
  execute() {
    this.editor.addObject(this.object);
    this.editor.selector.select(this.object);
  }
  undo() {
    this.editor.removeObject(this.object);
    this.editor.selector.deselect();
  }
  update(command) {
  }
  toJSON() {
    const output = super.toJSON();
    output.object = this.object?.toJSON();
    return output;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.object = this.editor.objectByUuid(json.object.object.uuid);
    if (this.object === void 0) {
      const loader = new ObjectLoader();
      this.object = loader.parse(json.object);
    }
  }
}

var __defProp$C = Object.defineProperty;
var __defNormalProp$C = (obj, key, value) => key in obj ? __defProp$C(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$C = (obj, key, value) => __defNormalProp$C(obj, typeof key !== "symbol" ? key + "" : key, value);
class MoveObjectCommand extends Command {
  constructor(object, newParent, newBefore) {
    super();
    __publicField$C(this, "type", "MoveObjectCommand");
    __publicField$C(this, "oldParent");
    __publicField$C(this, "oldIndex");
    __publicField$C(this, "newParent");
    __publicField$C(this, "newIndex");
    __publicField$C(this, "newBefore");
    this.name = "command/MoveObject";
    this.object = object;
    this.oldParent = object ? object.parent : null;
    this.oldIndex = this.oldParent ? this.oldParent.children.indexOf(this.object) : null;
    this.newParent = newParent;
    if (newBefore !== null) {
      this.newIndex = this.newParent ? this.newParent.children.indexOf(newBefore) : null;
    } else {
      this.newIndex = this.newParent ? this.newParent.children.length : null;
    }
    if (this.oldParent === this.newParent && this.newIndex > this.oldIndex) {
      if (isNumber(this.newIndex)) {
        this.newIndex--;
      }
    }
    this.newBefore = newBefore;
  }
  execute() {
    this.oldParent.remove(this.object);
    const children = this.newParent.children;
    children.splice(this.newIndex, 0, this.object);
    this.object.parent = this.newParent;
    this.editor.eventManager.sceneGraphChanged.next(null);
  }
  undo() {
    this.newParent.remove(this.object);
    const children = this.oldParent.children;
    children.splice(this.oldIndex, 0, this.object);
    this.object.parent = this.oldParent;
    this.editor.eventManager.sceneGraphChanged.next(null);
  }
  toJSON() {
    const output = super.toJSON();
    output.objectUuid = this.object.uuid;
    output.newParentUuid = this.newParent.uuid;
    output.oldParentUuid = this.oldParent.uuid;
    output.newIndex = this.newIndex;
    output.oldIndex = this.oldIndex;
    return output;
  }
  fromJSON(json) {
  }
  update(command) {
  }
}

var __defProp$B = Object.defineProperty;
var __defNormalProp$B = (obj, key, value) => key in obj ? __defProp$B(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$B = (obj, key, value) => __defNormalProp$B(obj, typeof key !== "symbol" ? key + "" : key, value);
class RemoveObjectCommand extends Command {
  constructor(object) {
    super();
    __publicField$B(this, "parent");
    __publicField$B(this, "index", -1);
    this.type = "RemoveObjectCommand";
    this.object = object;
    this.parent = this.object?.parent || null;
    if (this.parent !== null) {
      this.index = this.parent.children.indexOf(this.object);
    }
    if (object !== null) {
      this.name = "command/RemoveObject: " + object.name;
    }
  }
  execute() {
    this.editor.removeObject(this.object);
    this.editor.selector.deselect();
  }
  undo() {
    this.editor.addObject(this.object, this.parent, this.index);
    this.editor.selector.select(this.object);
  }
  toJSON() {
    const output = super.toJSON();
    output.object = this.object?.toJSON();
    output.index = this.index;
    output.parentUuid = this.parent?.uuid;
    return output;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.parent = this.editor.objectByUuid(json.parentUuid);
    if (!this.parent) {
      this.parent = this.editor.scene;
    }
    this.index = json.index;
    let object = this.editor.objectByUuid(json.object?.object.uuid);
    if (!isNil(object)) {
      this.object = object;
    } else {
      const loader = new ObjectLoader();
      this.object = loader.parse(json.object);
    }
  }
  update(command) {
  }
}

var __defProp$A = Object.defineProperty;
var __defNormalProp$A = (obj, key, value) => key in obj ? __defProp$A(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$A = (obj, key, value) => __defNormalProp$A(obj, key + "" , value);
const color = new THREE$2.Color();
class SetColorCommand extends SetValueCommand {
  constructor(object, attributeName, newValue, oldValue) {
    super(object, attributeName, newValue, oldValue);
    __publicField$A(this, "type", "SetColorCommand");
    this.attributeName = attributeName;
    this.name = "command/SetColorCommand: " + this.getAttributeName();
    this.object = object;
    this.newValue = newValue;
    this.newValue = color.setStyle(newValue).getHex();
    if (oldValue) {
      this.oldValue = oldValue;
    } else {
      this.oldValue = invoke(object, [attributeName, "getHex"]);
    }
  }
  /**
   * 设置对象的属性值
   * @param isExecute 是否执行命令，true为执行，false为撤销
   */
  setValue(isExecute) {
    const value = isExecute ? this.newValue : this.oldValue;
    if (isArray$1(this.attributeName) && this.attributeName.length > 0) {
      invoke(this.object, [this.attributeName, "setHex"], value);
    }
  }
  update(cmd) {
    this.newValue = cmd.newValue;
  }
  execute() {
    this.setValue(true);
  }
  undo() {
    this.setValue(false);
  }
}

var __defProp$z = Object.defineProperty;
var __defNormalProp$z = (obj, key, value) => key in obj ? __defProp$z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$z = (obj, key, value) => __defNormalProp$z(obj, typeof key !== "symbol" ? key + "" : key, value);
class EditorEventManager extends Component {
  constructor(options) {
    super(options);
    __publicField$z(this, "editScript", new Subject());
    __publicField$z(this, "startPlayer", new Subject());
    __publicField$z(this, "stopPlayer", new Subject());
    __publicField$z(this, "enterXR", new Subject());
    __publicField$z(this, "offerXR", new Subject());
    __publicField$z(this, "leaveXR", new Subject());
    __publicField$z(this, "editorCleared", new Subject());
    __publicField$z(this, "savingStarted", new Subject());
    __publicField$z(this, "savingFinished", new Subject());
    __publicField$z(this, "transformModeChanged", new Subject());
    __publicField$z(this, "snapChanged", new Subject());
    __publicField$z(this, "spaceChanged", new Subject());
    __publicField$z(this, "rendererCreated", new Subject());
    __publicField$z(this, "rendererUpdated", new Subject());
    __publicField$z(this, "rendererDetectKTX2Support", new Subject());
    __publicField$z(this, "sceneBackgroundChanged", new Subject());
    __publicField$z(this, "sceneEnvironmentChanged", new Subject());
    __publicField$z(this, "sceneFogChanged", new Subject());
    __publicField$z(this, "sceneFogSettingsChanged", new Subject());
    // 场景变化事件
    __publicField$z(this, "sceneGraphChanged", new BehaviorSubject(false));
    __publicField$z(this, "cameraChanged", new Subject());
    __publicField$z(this, "cameraResetted", new Subject());
    __publicField$z(this, "geometryChanged", new Subject());
    // 在三维中选择物体
    __publicField$z(this, "objectSelected", new Subject());
    // 定义一个名为objectFocused的Subject，用于处理对象被聚焦相关的事件或操作
    // 当场景中的某个对象被聚焦（可能是视觉上的突出显示等）时，可通过这个Subject传播相关信息
    __publicField$z(this, "objectFocused", new Subject());
    // 对象天加事件
    __publicField$z(this, "objectAdded", new Subject());
    // 对象属性改变事件
    __publicField$z(this, "objectChanged", new Subject());
    // 对象移除事件
    __publicField$z(this, "objectRemoved", new Subject());
    __publicField$z(this, "cameraAdded", new Subject());
    __publicField$z(this, "cameraRemoved", new Subject());
    __publicField$z(this, "helperAdded", new Subject());
    __publicField$z(this, "helperRemoved", new Subject());
    __publicField$z(this, "materialAdded", new Subject());
    __publicField$z(this, "materialChanged", new Subject());
    __publicField$z(this, "materialRemoved", new Subject());
    __publicField$z(this, "scriptAdded", new Subject());
    __publicField$z(this, "scriptChanged", new Subject());
    __publicField$z(this, "scriptRemoved", new Subject());
    __publicField$z(this, "windowResize", new Subject());
    __publicField$z(this, "showHelpersChanged", new Subject());
    __publicField$z(this, "refreshSidebarObject3D", new Subject());
    __publicField$z(this, "refreshSidebarEnvironment", new Subject());
    __publicField$z(this, "historyChanged", new Subject());
    __publicField$z(this, "viewportCameraChanged", new Subject());
    __publicField$z(this, "viewportShadingChanged", new Subject());
    __publicField$z(this, "intersectionsDetected", new Subject());
    __publicField$z(this, "pathTracerUpdated", new Subject());
    this.mergeSubject();
  }
  mergeSubject() {
    merge(this.objectAdded, this.objectRemoved).subscribe((value) => {
      this.sceneGraphChanged.next(value);
    });
  }
}

var __defProp$y = Object.defineProperty;
var __defNormalProp$y = (obj, key, value) => key in obj ? __defProp$y(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$y = (obj, key, value) => __defNormalProp$y(obj, typeof key !== "symbol" ? key + "" : key, value);
class Selector extends Component {
  constructor(options) {
    super(options);
    __publicField$y(this, "selectObject");
    __publicField$y(this, "selectionBox", new THREE$2.BoxHelper(new THREE$2.Object3D()));
    this.initSelectionBox();
    this.initEvent();
  }
  /**
   * 初始化包围盒
   */
  initSelectionBox() {
    if (isArray$1(this.selectionBox.material)) ; else {
      this.selectionBox.material.depthTest = false;
      this.selectionBox.material.transparent = true;
    }
    this.selectionBox.visible = false;
    this.sceneHelpers.add(this.selectionBox);
  }
  /**
   * 初始化事件
   */
  initEvent() {
    this.eventManager.leftClickPickSubject.subscribe((value) => {
      const { intersects } = value;
      if (intersects.length > 0) {
        const object = intersects[0].object;
        this.select(object);
      } else {
        this.select(void 0);
      }
    });
    this.editor.editorEventManager.objectSelected.subscribe((object) => {
      this.selectionBox.visible = false;
      this.editor.transformControlsWarp.transformControls.detach();
      if (isNil(object)) {
        this.editor.transformControlsWarp.transformControls.detach();
      } else {
        this.selectionBox.setFromObject(object);
        this.selectionBox.visible = true;
        this.editor.transformControlsWarp.transformControls.attach(object);
      }
    });
    console.log("111111111111111111");
    this.editor.editorEventManager.objectChanged.subscribe((object) => {
      console.log("object", object);
      this.selectionBox.setFromObject(object);
      this.editor.helperUpdate(object);
    });
  }
  /**
   * 选择对象
   * @param object
   */
  select(object) {
    if (!isNil(object) && this.selectObject != object) {
      this.selectObject = object;
      this.editor.editorEventManager.objectSelected.next(object);
    }
    if (isNil(object)) {
      this.selectObject = object;
      this.editor.editorEventManager.objectSelected.next(object);
    }
  }
  /**
   * 取消选择对象
   */
  deselect() {
    this.select(void 0);
  }
}

const _raycaster$1 = new Raycaster();

const _tempVector = new Vector3();
const _tempVector2 = new Vector3();
const _tempQuaternion = new Quaternion();
const _unit = {
	X: new Vector3( 1, 0, 0 ),
	Y: new Vector3( 0, 1, 0 ),
	Z: new Vector3( 0, 0, 1 )
};

const _changeEvent = { type: 'change' };
const _mouseDownEvent = { type: 'mouseDown', mode: null };
const _mouseUpEvent = { type: 'mouseUp', mode: null };
const _objectChangeEvent = { type: 'objectChange' };

class TransformControls extends Controls {

	constructor( camera, domElement = null ) {

		super( undefined, domElement );

		const root = new TransformControlsRoot( this );
		this._root = root;

		const gizmo = new TransformControlsGizmo();
		this._gizmo = gizmo;
		root.add( gizmo );

		const plane = new TransformControlsPlane();
		this._plane = plane;
		root.add( plane );

		const scope = this;

		// Defined getter, setter and store for a property
		function defineProperty( propName, defaultValue ) {

			let propValue = defaultValue;

			Object.defineProperty( scope, propName, {

				get: function () {

					return propValue !== undefined ? propValue : defaultValue;

				},

				set: function ( value ) {

					if ( propValue !== value ) {

						propValue = value;
						plane[ propName ] = value;
						gizmo[ propName ] = value;

						scope.dispatchEvent( { type: propName + '-changed', value: value } );
						scope.dispatchEvent( _changeEvent );

					}

				}

			} );

			scope[ propName ] = defaultValue;
			plane[ propName ] = defaultValue;
			gizmo[ propName ] = defaultValue;

		}

		// Define properties with getters/setter
		// Setting the defined property will automatically trigger change event
		// Defined properties are passed down to gizmo and plane

		defineProperty( 'camera', camera );
		defineProperty( 'object', undefined );
		defineProperty( 'enabled', true );
		defineProperty( 'axis', null );
		defineProperty( 'mode', 'translate' );
		defineProperty( 'translationSnap', null );
		defineProperty( 'rotationSnap', null );
		defineProperty( 'scaleSnap', null );
		defineProperty( 'space', 'world' );
		defineProperty( 'size', 1 );
		defineProperty( 'dragging', false );
		defineProperty( 'showX', true );
		defineProperty( 'showY', true );
		defineProperty( 'showZ', true );
		defineProperty( 'minX', - Infinity );
		defineProperty( 'maxX', Infinity );
		defineProperty( 'minY', - Infinity );
		defineProperty( 'maxY', Infinity );
		defineProperty( 'minZ', - Infinity );
		defineProperty( 'maxZ', Infinity );

		// Reusable utility variables

		const worldPosition = new Vector3();
		const worldPositionStart = new Vector3();
		const worldQuaternion = new Quaternion();
		const worldQuaternionStart = new Quaternion();
		const cameraPosition = new Vector3();
		const cameraQuaternion = new Quaternion();
		const pointStart = new Vector3();
		const pointEnd = new Vector3();
		const rotationAxis = new Vector3();
		const rotationAngle = 0;
		const eye = new Vector3();

		// TODO: remove properties unused in plane and gizmo

		defineProperty( 'worldPosition', worldPosition );
		defineProperty( 'worldPositionStart', worldPositionStart );
		defineProperty( 'worldQuaternion', worldQuaternion );
		defineProperty( 'worldQuaternionStart', worldQuaternionStart );
		defineProperty( 'cameraPosition', cameraPosition );
		defineProperty( 'cameraQuaternion', cameraQuaternion );
		defineProperty( 'pointStart', pointStart );
		defineProperty( 'pointEnd', pointEnd );
		defineProperty( 'rotationAxis', rotationAxis );
		defineProperty( 'rotationAngle', rotationAngle );
		defineProperty( 'eye', eye );

		this._offset = new Vector3();
		this._startNorm = new Vector3();
		this._endNorm = new Vector3();
		this._cameraScale = new Vector3();

		this._parentPosition = new Vector3();
		this._parentQuaternion = new Quaternion();
		this._parentQuaternionInv = new Quaternion();
		this._parentScale = new Vector3();

		this._worldScaleStart = new Vector3();
		this._worldQuaternionInv = new Quaternion();
		this._worldScale = new Vector3();

		this._positionStart = new Vector3();
		this._quaternionStart = new Quaternion();
		this._scaleStart = new Vector3();

		this._getPointer = getPointer.bind( this );
		this._onPointerDown = onPointerDown.bind( this );
		this._onPointerHover = onPointerHover.bind( this );
		this._onPointerMove = onPointerMove.bind( this );
		this._onPointerUp = onPointerUp.bind( this );

		if ( domElement !== null ) {

			this.connect();

		}

	}

	connect() {

		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
		this.domElement.addEventListener( 'pointermove', this._onPointerHover );
		this.domElement.addEventListener( 'pointerup', this._onPointerUp );

		this.domElement.style.touchAction = 'none'; // disable touch scroll

	}

	disconnect() {

		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
		this.domElement.removeEventListener( 'pointermove', this._onPointerHover );
		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );

		this.domElement.style.touchAction = 'auto';

	}

	getHelper() {

		return this._root;

	}

	pointerHover( pointer ) {

		if ( this.object === undefined || this.dragging === true ) return;

		if ( pointer !== null ) _raycaster$1.setFromCamera( pointer, this.camera );

		const intersect = intersectObjectWithRay( this._gizmo.picker[ this.mode ], _raycaster$1 );

		if ( intersect ) {

			this.axis = intersect.object.name;

		} else {

			this.axis = null;

		}

	}

	pointerDown( pointer ) {

		if ( this.object === undefined || this.dragging === true || ( pointer != null && pointer.button !== 0 ) ) return;

		if ( this.axis !== null ) {

			if ( pointer !== null ) _raycaster$1.setFromCamera( pointer, this.camera );

			const planeIntersect = intersectObjectWithRay( this._plane, _raycaster$1, true );

			if ( planeIntersect ) {

				this.object.updateMatrixWorld();
				this.object.parent.updateMatrixWorld();

				this._positionStart.copy( this.object.position );
				this._quaternionStart.copy( this.object.quaternion );
				this._scaleStart.copy( this.object.scale );

				this.object.matrixWorld.decompose( this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart );

				this.pointStart.copy( planeIntersect.point ).sub( this.worldPositionStart );

			}

			this.dragging = true;
			_mouseDownEvent.mode = this.mode;
			this.dispatchEvent( _mouseDownEvent );

		}

	}

	pointerMove( pointer ) {

		const axis = this.axis;
		const mode = this.mode;
		const object = this.object;
		let space = this.space;

		if ( mode === 'scale' ) {

			space = 'local';

		} else if ( axis === 'E' || axis === 'XYZE' || axis === 'XYZ' ) {

			space = 'world';

		}

		if ( object === undefined || axis === null || this.dragging === false || ( pointer !== null && pointer.button !== -1 ) ) return;

		if ( pointer !== null ) _raycaster$1.setFromCamera( pointer, this.camera );

		const planeIntersect = intersectObjectWithRay( this._plane, _raycaster$1, true );

		if ( ! planeIntersect ) return;

		this.pointEnd.copy( planeIntersect.point ).sub( this.worldPositionStart );

		if ( mode === 'translate' ) {

			// Apply translate

			this._offset.copy( this.pointEnd ).sub( this.pointStart );

			if ( space === 'local' && axis !== 'XYZ' ) {

				this._offset.applyQuaternion( this._worldQuaternionInv );

			}

			if ( axis.indexOf( 'X' ) === -1 ) this._offset.x = 0;
			if ( axis.indexOf( 'Y' ) === -1 ) this._offset.y = 0;
			if ( axis.indexOf( 'Z' ) === -1 ) this._offset.z = 0;

			if ( space === 'local' && axis !== 'XYZ' ) {

				this._offset.applyQuaternion( this._quaternionStart ).divide( this._parentScale );

			} else {

				this._offset.applyQuaternion( this._parentQuaternionInv ).divide( this._parentScale );

			}

			object.position.copy( this._offset ).add( this._positionStart );

			// Apply translation snap

			if ( this.translationSnap ) {

				if ( space === 'local' ) {

					object.position.applyQuaternion( _tempQuaternion.copy( this._quaternionStart ).invert() );

					if ( axis.search( 'X' ) !== -1 ) {

						object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Y' ) !== -1 ) {

						object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Z' ) !== -1 ) {

						object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;

					}

					object.position.applyQuaternion( this._quaternionStart );

				}

				if ( space === 'world' ) {

					if ( object.parent ) {

						object.position.add( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );

					}

					if ( axis.search( 'X' ) !== -1 ) {

						object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Y' ) !== -1 ) {

						object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Z' ) !== -1 ) {

						object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;

					}

					if ( object.parent ) {

						object.position.sub( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );

					}

				}

			}

			object.position.x = Math.max( this.minX, Math.min( this.maxX, object.position.x ) );
			object.position.y = Math.max( this.minY, Math.min( this.maxY, object.position.y ) );
			object.position.z = Math.max( this.minZ, Math.min( this.maxZ, object.position.z ) );

		} else if ( mode === 'scale' ) {

			if ( axis.search( 'XYZ' ) !== -1 ) {

				let d = this.pointEnd.length() / this.pointStart.length();

				if ( this.pointEnd.dot( this.pointStart ) < 0 ) d *= -1;

				_tempVector2.set( d, d, d );

			} else {

				_tempVector.copy( this.pointStart );
				_tempVector2.copy( this.pointEnd );

				_tempVector.applyQuaternion( this._worldQuaternionInv );
				_tempVector2.applyQuaternion( this._worldQuaternionInv );

				_tempVector2.divide( _tempVector );

				if ( axis.search( 'X' ) === -1 ) {

					_tempVector2.x = 1;

				}

				if ( axis.search( 'Y' ) === -1 ) {

					_tempVector2.y = 1;

				}

				if ( axis.search( 'Z' ) === -1 ) {

					_tempVector2.z = 1;

				}

			}

			// Apply scale

			object.scale.copy( this._scaleStart ).multiply( _tempVector2 );

			if ( this.scaleSnap ) {

				if ( axis.search( 'X' ) !== -1 ) {

					object.scale.x = Math.round( object.scale.x / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;

				}

				if ( axis.search( 'Y' ) !== -1 ) {

					object.scale.y = Math.round( object.scale.y / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;

				}

				if ( axis.search( 'Z' ) !== -1 ) {

					object.scale.z = Math.round( object.scale.z / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;

				}

			}

		} else if ( mode === 'rotate' ) {

			this._offset.copy( this.pointEnd ).sub( this.pointStart );

			const ROTATION_SPEED = 20 / this.worldPosition.distanceTo( _tempVector.setFromMatrixPosition( this.camera.matrixWorld ) );

			let _inPlaneRotation = false;

			if ( axis === 'XYZE' ) {

				this.rotationAxis.copy( this._offset ).cross( this.eye ).normalize();
				this.rotationAngle = this._offset.dot( _tempVector.copy( this.rotationAxis ).cross( this.eye ) ) * ROTATION_SPEED;

			} else if ( axis === 'X' || axis === 'Y' || axis === 'Z' ) {

				this.rotationAxis.copy( _unit[ axis ] );

				_tempVector.copy( _unit[ axis ] );

				if ( space === 'local' ) {

					_tempVector.applyQuaternion( this.worldQuaternion );

				}

				_tempVector.cross( this.eye );

				// When _tempVector is 0 after cross with this.eye the vectors are parallel and should use in-plane rotation logic.
				if ( _tempVector.length() === 0 ) {

					_inPlaneRotation = true;

				} else {

					this.rotationAngle = this._offset.dot( _tempVector.normalize() ) * ROTATION_SPEED;

				}


			}

			if ( axis === 'E' || _inPlaneRotation ) {

				this.rotationAxis.copy( this.eye );
				this.rotationAngle = this.pointEnd.angleTo( this.pointStart );

				this._startNorm.copy( this.pointStart ).normalize();
				this._endNorm.copy( this.pointEnd ).normalize();

				this.rotationAngle *= ( this._endNorm.cross( this._startNorm ).dot( this.eye ) < 0 ? 1 : -1 );

			}

			// Apply rotation snap

			if ( this.rotationSnap ) this.rotationAngle = Math.round( this.rotationAngle / this.rotationSnap ) * this.rotationSnap;

			// Apply rotate
			if ( space === 'local' && axis !== 'E' && axis !== 'XYZE' ) {

				object.quaternion.copy( this._quaternionStart );
				object.quaternion.multiply( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) ).normalize();

			} else {

				this.rotationAxis.applyQuaternion( this._parentQuaternionInv );
				object.quaternion.copy( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) );
				object.quaternion.multiply( this._quaternionStart ).normalize();

			}

		}

		this.dispatchEvent( _changeEvent );
		this.dispatchEvent( _objectChangeEvent );

	}

	pointerUp( pointer ) {

		if ( pointer !== null && pointer.button !== 0 ) return;

		if ( this.dragging && ( this.axis !== null ) ) {

			_mouseUpEvent.mode = this.mode;
			this.dispatchEvent( _mouseUpEvent );

		}

		this.dragging = false;
		this.axis = null;

	}

	dispose() {

		this.disconnect();

		this._root.dispose();

	}

	// Set current object
	attach( object ) {

		this.object = object;
		this._root.visible = true;

		return this;

	}

	// Detach from object
	detach() {

		this.object = undefined;
		this.axis = null;

		this._root.visible = false;

		return this;

	}

	reset() {

		if ( ! this.enabled ) return;

		if ( this.dragging ) {

			this.object.position.copy( this._positionStart );
			this.object.quaternion.copy( this._quaternionStart );
			this.object.scale.copy( this._scaleStart );

			this.dispatchEvent( _changeEvent );
			this.dispatchEvent( _objectChangeEvent );

			this.pointStart.copy( this.pointEnd );

		}

	}

	getRaycaster() {

		return _raycaster$1;

	}

	// TODO: deprecate

	getMode() {

		return this.mode;

	}

	setMode( mode ) {

		this.mode = mode;

	}

	setTranslationSnap( translationSnap ) {

		this.translationSnap = translationSnap;

	}

	setRotationSnap( rotationSnap ) {

		this.rotationSnap = rotationSnap;

	}

	setScaleSnap( scaleSnap ) {

		this.scaleSnap = scaleSnap;

	}

	setSize( size ) {

		this.size = size;

	}

	setSpace( space ) {

		this.space = space;

	}

}

// mouse / touch event handlers

function getPointer( event ) {

	if ( this.domElement.ownerDocument.pointerLockElement ) {

		return {
			x: 0,
			y: 0,
			button: event.button
		};

	} else {

		const rect = this.domElement.getBoundingClientRect();

		return {
			x: ( event.clientX - rect.left ) / rect.width * 2 - 1,
			y: - ( event.clientY - rect.top ) / rect.height * 2 + 1,
			button: event.button
		};

	}

}

function onPointerHover( event ) {

	if ( ! this.enabled ) return;

	switch ( event.pointerType ) {

		case 'mouse':
		case 'pen':
			this.pointerHover( this._getPointer( event ) );
			break;

	}

}

function onPointerDown( event ) {

	if ( ! this.enabled ) return;

	if ( ! document.pointerLockElement ) {

		this.domElement.setPointerCapture( event.pointerId );

	}

	this.domElement.addEventListener( 'pointermove', this._onPointerMove );

	this.pointerHover( this._getPointer( event ) );
	this.pointerDown( this._getPointer( event ) );

}

function onPointerMove( event ) {

	if ( ! this.enabled ) return;

	this.pointerMove( this._getPointer( event ) );

}

function onPointerUp( event ) {

	if ( ! this.enabled ) return;

	this.domElement.releasePointerCapture( event.pointerId );

	this.domElement.removeEventListener( 'pointermove', this._onPointerMove );

	this.pointerUp( this._getPointer( event ) );

}

function intersectObjectWithRay( object, raycaster, includeInvisible ) {

	const allIntersections = raycaster.intersectObject( object, true );

	for ( let i = 0; i < allIntersections.length; i ++ ) {

		if ( allIntersections[ i ].object.visible || includeInvisible ) {

			return allIntersections[ i ];

		}

	}

	return false;

}

//

// Reusable utility variables

const _tempEuler = new Euler();
const _alignVector = new Vector3( 0, 1, 0 );
const _zeroVector = new Vector3( 0, 0, 0 );
const _lookAtMatrix = new Matrix4();
const _tempQuaternion2 = new Quaternion();
const _identityQuaternion = new Quaternion();
const _dirVector = new Vector3();
const _tempMatrix = new Matrix4();

const _unitX = new Vector3( 1, 0, 0 );
const _unitY = new Vector3( 0, 1, 0 );
const _unitZ = new Vector3( 0, 0, 1 );

const _v1 = new Vector3();
const _v2$1 = new Vector3();
const _v3 = new Vector3();

class TransformControlsRoot extends Object3D {

	constructor( controls ) {

		super();

		this.isTransformControlsRoot = true;

		this.controls = controls;
		this.visible = false;

	}

	// updateMatrixWorld updates key transformation variables
	updateMatrixWorld( force ) {

		const controls = this.controls;

		if ( controls.object !== undefined ) {

			controls.object.updateMatrixWorld();

			if ( controls.object.parent === null ) {

				console.error( 'TransformControls: The attached 3D object must be a part of the scene graph.' );

			} else {

				controls.object.parent.matrixWorld.decompose( controls._parentPosition, controls._parentQuaternion, controls._parentScale );

			}

			controls.object.matrixWorld.decompose( controls.worldPosition, controls.worldQuaternion, controls._worldScale );

			controls._parentQuaternionInv.copy( controls._parentQuaternion ).invert();
			controls._worldQuaternionInv.copy( controls.worldQuaternion ).invert();

		}

		controls.camera.updateMatrixWorld();
		controls.camera.matrixWorld.decompose( controls.cameraPosition, controls.cameraQuaternion, controls._cameraScale );

		if ( controls.camera.isOrthographicCamera ) {

			controls.camera.getWorldDirection( controls.eye ).negate();

		} else {

			controls.eye.copy( controls.cameraPosition ).sub( controls.worldPosition ).normalize();

		}

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.traverse( function ( child ) {

			if ( child.geometry ) child.geometry.dispose();
			if ( child.material ) child.material.dispose();

		} );

	}

}

class TransformControlsGizmo extends Object3D {

	constructor() {

		super();

		this.isTransformControlsGizmo = true;

		this.type = 'TransformControlsGizmo';

		// shared materials

		const gizmoMaterial = new MeshBasicMaterial( {
			depthTest: false,
			depthWrite: false,
			fog: false,
			toneMapped: false,
			transparent: true
		} );

		const gizmoLineMaterial = new LineBasicMaterial( {
			depthTest: false,
			depthWrite: false,
			fog: false,
			toneMapped: false,
			transparent: true
		} );

		// Make unique material for each axis/color

		const matInvisible = gizmoMaterial.clone();
		matInvisible.opacity = 0.15;

		const matHelper = gizmoLineMaterial.clone();
		matHelper.opacity = 0.5;

		const matRed = gizmoMaterial.clone();
		matRed.color.setHex( 0xff0000 );

		const matGreen = gizmoMaterial.clone();
		matGreen.color.setHex( 0x00ff00 );

		const matBlue = gizmoMaterial.clone();
		matBlue.color.setHex( 0x0000ff );

		const matRedTransparent = gizmoMaterial.clone();
		matRedTransparent.color.setHex( 0xff0000 );
		matRedTransparent.opacity = 0.5;

		const matGreenTransparent = gizmoMaterial.clone();
		matGreenTransparent.color.setHex( 0x00ff00 );
		matGreenTransparent.opacity = 0.5;

		const matBlueTransparent = gizmoMaterial.clone();
		matBlueTransparent.color.setHex( 0x0000ff );
		matBlueTransparent.opacity = 0.5;

		const matWhiteTransparent = gizmoMaterial.clone();
		matWhiteTransparent.opacity = 0.25;

		const matYellowTransparent = gizmoMaterial.clone();
		matYellowTransparent.color.setHex( 0xffff00 );
		matYellowTransparent.opacity = 0.25;

		const matYellow = gizmoMaterial.clone();
		matYellow.color.setHex( 0xffff00 );

		const matGray = gizmoMaterial.clone();
		matGray.color.setHex( 0x787878 );

		// reusable geometry

		const arrowGeometry = new CylinderGeometry( 0, 0.04, 0.1, 12 );
		arrowGeometry.translate( 0, 0.05, 0 );

		const scaleHandleGeometry = new BoxGeometry( 0.08, 0.08, 0.08 );
		scaleHandleGeometry.translate( 0, 0.04, 0 );

		const lineGeometry = new BufferGeometry();
		lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0,	1, 0, 0 ], 3 ) );

		const lineGeometry2 = new CylinderGeometry( 0.0075, 0.0075, 0.5, 3 );
		lineGeometry2.translate( 0, 0.25, 0 );

		function CircleGeometry( radius, arc ) {

			const geometry = new TorusGeometry( radius, 0.0075, 3, 64, arc * Math.PI * 2 );
			geometry.rotateY( Math.PI / 2 );
			geometry.rotateX( Math.PI / 2 );
			return geometry;

		}

		// Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position

		function TranslateHelperGeometry() {

			const geometry = new BufferGeometry();

			geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 1, 1, 1 ], 3 ) );

			return geometry;

		}

		// Gizmo definitions - custom hierarchy definitions for setupGizmo() function

		const gizmoTranslate = {
			X: [
				[ new Mesh( arrowGeometry, matRed ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( arrowGeometry, matRed ), [ -0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]],
				[ new Mesh( lineGeometry2, matRed ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]]
			],
			Y: [
				[ new Mesh( arrowGeometry, matGreen ), [ 0, 0.5, 0 ]],
				[ new Mesh( arrowGeometry, matGreen ), [ 0, -0.5, 0 ], [ Math.PI, 0, 0 ]],
				[ new Mesh( lineGeometry2, matGreen ) ]
			],
			Z: [
				[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, -0.5 ], [ - Math.PI / 2, 0, 0 ]],
				[ new Mesh( lineGeometry2, matBlue ), null, [ Math.PI / 2, 0, 0 ]]
			],
			XYZ: [
				[ new Mesh( new OctahedronGeometry( 0.1, 0 ), matWhiteTransparent.clone() ), [ 0, 0, 0 ]]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matBlueTransparent.clone() ), [ 0.15, 0.15, 0 ]]
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matRedTransparent.clone() ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matGreenTransparent.clone() ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]
			]
		};

		const pickerTranslate = {
			X: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0.3, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ -0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]]
			],
			Y: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0.3, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, -0.3, 0 ], [ 0, 0, Math.PI ]]
			],
			Z: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, 0.3 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, -0.3 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XYZ: [
				[ new Mesh( new OctahedronGeometry( 0.2, 0 ), matInvisible ) ]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0.15, 0 ]]
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]
			]
		};

		const helperTranslate = {
			START: [
				[ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]
			],
			END: [
				[ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]
			],
			DELTA: [
				[ new Line$1( TranslateHelperGeometry(), matHelper ), null, null, null, 'helper' ]
			],
			X: [
				[ new Line$1( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
			],
			Y: [
				[ new Line$1( lineGeometry, matHelper.clone() ), [ 0, -1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]
			],
			Z: [
				[ new Line$1( lineGeometry, matHelper.clone() ), [ 0, 0, -1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]
			]
		};

		const gizmoRotate = {
			XYZE: [
				[ new Mesh( CircleGeometry( 0.5, 1 ), matGray ), null, [ 0, Math.PI / 2, 0 ]]
			],
			X: [
				[ new Mesh( CircleGeometry( 0.5, 0.5 ), matRed ) ]
			],
			Y: [
				[ new Mesh( CircleGeometry( 0.5, 0.5 ), matGreen ), null, [ 0, 0, - Math.PI / 2 ]]
			],
			Z: [
				[ new Mesh( CircleGeometry( 0.5, 0.5 ), matBlue ), null, [ 0, Math.PI / 2, 0 ]]
			],
			E: [
				[ new Mesh( CircleGeometry( 0.75, 1 ), matYellowTransparent ), null, [ 0, Math.PI / 2, 0 ]]
			]
		};

		const helperRotate = {
			AXIS: [
				[ new Line$1( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
			]
		};

		const pickerRotate = {
			XYZE: [
				[ new Mesh( new SphereGeometry( 0.25, 10, 8 ), matInvisible ) ]
			],
			X: [
				[ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, - Math.PI / 2, - Math.PI / 2 ]],
			],
			Y: [
				[ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],
			],
			Z: [
				[ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
			],
			E: [
				[ new Mesh( new TorusGeometry( 0.75, 0.1, 2, 24 ), matInvisible ) ]
			]
		};

		const gizmoScale = {
			X: [
				[ new Mesh( scaleHandleGeometry, matRed ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( lineGeometry2, matRed ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( scaleHandleGeometry, matRed ), [ -0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]],
			],
			Y: [
				[ new Mesh( scaleHandleGeometry, matGreen ), [ 0, 0.5, 0 ]],
				[ new Mesh( lineGeometry2, matGreen ) ],
				[ new Mesh( scaleHandleGeometry, matGreen ), [ 0, -0.5, 0 ], [ 0, 0, Math.PI ]],
			],
			Z: [
				[ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( lineGeometry2, matBlue ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, -0.5 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matBlueTransparent ), [ 0.15, 0.15, 0 ]]
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matRedTransparent ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matGreenTransparent ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XYZ: [
				[ new Mesh( new BoxGeometry( 0.1, 0.1, 0.1 ), matWhiteTransparent.clone() ) ],
			]
		};

		const pickerScale = {
			X: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0.3, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ -0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]]
			],
			Y: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0.3, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, -0.3, 0 ], [ 0, 0, Math.PI ]]
			],
			Z: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, 0.3 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, -0.3 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0.15, 0 ]],
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]],
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]],
			],
			XYZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 0, 0 ]],
			]
		};

		const helperScale = {
			X: [
				[ new Line$1( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
			],
			Y: [
				[ new Line$1( lineGeometry, matHelper.clone() ), [ 0, -1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]
			],
			Z: [
				[ new Line$1( lineGeometry, matHelper.clone() ), [ 0, 0, -1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]
			]
		};

		// Creates an Object3D with gizmos described in custom hierarchy definition.

		function setupGizmo( gizmoMap ) {

			const gizmo = new Object3D();

			for ( const name in gizmoMap ) {

				for ( let i = gizmoMap[ name ].length; i --; ) {

					const object = gizmoMap[ name ][ i ][ 0 ].clone();
					const position = gizmoMap[ name ][ i ][ 1 ];
					const rotation = gizmoMap[ name ][ i ][ 2 ];
					const scale = gizmoMap[ name ][ i ][ 3 ];
					const tag = gizmoMap[ name ][ i ][ 4 ];

					// name and tag properties are essential for picking and updating logic.
					object.name = name;
					object.tag = tag;

					if ( position ) {

						object.position.set( position[ 0 ], position[ 1 ], position[ 2 ] );

					}

					if ( rotation ) {

						object.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ] );

					}

					if ( scale ) {

						object.scale.set( scale[ 0 ], scale[ 1 ], scale[ 2 ] );

					}

					object.updateMatrix();

					const tempGeometry = object.geometry.clone();
					tempGeometry.applyMatrix4( object.matrix );
					object.geometry = tempGeometry;
					object.renderOrder = Infinity;

					object.position.set( 0, 0, 0 );
					object.rotation.set( 0, 0, 0 );
					object.scale.set( 1, 1, 1 );

					gizmo.add( object );

				}

			}

			return gizmo;

		}

		// Gizmo creation

		this.gizmo = {};
		this.picker = {};
		this.helper = {};

		this.add( this.gizmo[ 'translate' ] = setupGizmo( gizmoTranslate ) );
		this.add( this.gizmo[ 'rotate' ] = setupGizmo( gizmoRotate ) );
		this.add( this.gizmo[ 'scale' ] = setupGizmo( gizmoScale ) );
		this.add( this.picker[ 'translate' ] = setupGizmo( pickerTranslate ) );
		this.add( this.picker[ 'rotate' ] = setupGizmo( pickerRotate ) );
		this.add( this.picker[ 'scale' ] = setupGizmo( pickerScale ) );
		this.add( this.helper[ 'translate' ] = setupGizmo( helperTranslate ) );
		this.add( this.helper[ 'rotate' ] = setupGizmo( helperRotate ) );
		this.add( this.helper[ 'scale' ] = setupGizmo( helperScale ) );

		// Pickers should be hidden always

		this.picker[ 'translate' ].visible = false;
		this.picker[ 'rotate' ].visible = false;
		this.picker[ 'scale' ].visible = false;

	}

	// updateMatrixWorld will update transformations and appearance of individual handles

	updateMatrixWorld( force ) {

		const space = ( this.mode === 'scale' ) ? 'local' : this.space; // scale always oriented to local rotation

		const quaternion = ( space === 'local' ) ? this.worldQuaternion : _identityQuaternion;

		// Show only gizmos for current transform mode

		this.gizmo[ 'translate' ].visible = this.mode === 'translate';
		this.gizmo[ 'rotate' ].visible = this.mode === 'rotate';
		this.gizmo[ 'scale' ].visible = this.mode === 'scale';

		this.helper[ 'translate' ].visible = this.mode === 'translate';
		this.helper[ 'rotate' ].visible = this.mode === 'rotate';
		this.helper[ 'scale' ].visible = this.mode === 'scale';


		let handles = [];
		handles = handles.concat( this.picker[ this.mode ].children );
		handles = handles.concat( this.gizmo[ this.mode ].children );
		handles = handles.concat( this.helper[ this.mode ].children );

		for ( let i = 0; i < handles.length; i ++ ) {

			const handle = handles[ i ];

			// hide aligned to camera

			handle.visible = true;
			handle.rotation.set( 0, 0, 0 );
			handle.position.copy( this.worldPosition );

			let factor;

			if ( this.camera.isOrthographicCamera ) {

				factor = ( this.camera.top - this.camera.bottom ) / this.camera.zoom;

			} else {

				factor = this.worldPosition.distanceTo( this.cameraPosition ) * Math.min( 1.9 * Math.tan( Math.PI * this.camera.fov / 360 ) / this.camera.zoom, 7 );

			}

			handle.scale.set( 1, 1, 1 ).multiplyScalar( factor * this.size / 4 );

			// TODO: simplify helpers and consider decoupling from gizmo

			if ( handle.tag === 'helper' ) {

				handle.visible = false;

				if ( handle.name === 'AXIS' ) {

					handle.visible = !! this.axis;

					if ( this.axis === 'X' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, 0 ) );
						handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );

						if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {

							handle.visible = false;

						}

					}

					if ( this.axis === 'Y' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, Math.PI / 2 ) );
						handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );

						if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {

							handle.visible = false;

						}

					}

					if ( this.axis === 'Z' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) );
						handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );

						if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {

							handle.visible = false;

						}

					}

					if ( this.axis === 'XYZE' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) );
						_alignVector.copy( this.rotationAxis );
						handle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( _zeroVector, _alignVector, _unitY ) );
						handle.quaternion.multiply( _tempQuaternion );
						handle.visible = this.dragging;

					}

					if ( this.axis === 'E' ) {

						handle.visible = false;

					}


				} else if ( handle.name === 'START' ) {

					handle.position.copy( this.worldPositionStart );
					handle.visible = this.dragging;

				} else if ( handle.name === 'END' ) {

					handle.position.copy( this.worldPosition );
					handle.visible = this.dragging;

				} else if ( handle.name === 'DELTA' ) {

					handle.position.copy( this.worldPositionStart );
					handle.quaternion.copy( this.worldQuaternionStart );
					_tempVector.set( 1e-10, 1e-10, 1e-10 ).add( this.worldPositionStart ).sub( this.worldPosition ).multiplyScalar( -1 );
					_tempVector.applyQuaternion( this.worldQuaternionStart.clone().invert() );
					handle.scale.copy( _tempVector );
					handle.visible = this.dragging;

				} else {

					handle.quaternion.copy( quaternion );

					if ( this.dragging ) {

						handle.position.copy( this.worldPositionStart );

					} else {

						handle.position.copy( this.worldPosition );

					}

					if ( this.axis ) {

						handle.visible = this.axis.search( handle.name ) !== -1;

					}

				}

				// If updating helper, skip rest of the loop
				continue;

			}

			// Align handles to current local or world rotation

			handle.quaternion.copy( quaternion );

			if ( this.mode === 'translate' || this.mode === 'scale' ) {

				// Hide translate and scale axis facing the camera

				const AXIS_HIDE_THRESHOLD = 0.99;
				const PLANE_HIDE_THRESHOLD = 0.2;

				if ( handle.name === 'X' ) {

					if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'Y' ) {

					if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'Z' ) {

					if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'XY' ) {

					if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'YZ' ) {

					if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'XZ' ) {

					if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

			} else if ( this.mode === 'rotate' ) {

				// Align handles to current local or world rotation

				_tempQuaternion2.copy( quaternion );
				_alignVector.copy( this.eye ).applyQuaternion( _tempQuaternion.copy( quaternion ).invert() );

				if ( handle.name.search( 'E' ) !== -1 ) {

					handle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( this.eye, _zeroVector, _unitY ) );

				}

				if ( handle.name === 'X' ) {

					_tempQuaternion.setFromAxisAngle( _unitX, Math.atan2( - _alignVector.y, _alignVector.z ) );
					_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );
					handle.quaternion.copy( _tempQuaternion );

				}

				if ( handle.name === 'Y' ) {

					_tempQuaternion.setFromAxisAngle( _unitY, Math.atan2( _alignVector.x, _alignVector.z ) );
					_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );
					handle.quaternion.copy( _tempQuaternion );

				}

				if ( handle.name === 'Z' ) {

					_tempQuaternion.setFromAxisAngle( _unitZ, Math.atan2( _alignVector.y, _alignVector.x ) );
					_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );
					handle.quaternion.copy( _tempQuaternion );

				}

			}

			// Hide disabled axes
			handle.visible = handle.visible && ( handle.name.indexOf( 'X' ) === -1 || this.showX );
			handle.visible = handle.visible && ( handle.name.indexOf( 'Y' ) === -1 || this.showY );
			handle.visible = handle.visible && ( handle.name.indexOf( 'Z' ) === -1 || this.showZ );
			handle.visible = handle.visible && ( handle.name.indexOf( 'E' ) === -1 || ( this.showX && this.showY && this.showZ ) );

			// highlight selected axis

			handle.material._color = handle.material._color || handle.material.color.clone();
			handle.material._opacity = handle.material._opacity || handle.material.opacity;

			handle.material.color.copy( handle.material._color );
			handle.material.opacity = handle.material._opacity;

			if ( this.enabled && this.axis ) {

				if ( handle.name === this.axis ) {

					handle.material.color.setHex( 0xffff00 );
					handle.material.opacity = 1.0;

				} else if ( this.axis.split( '' ).some( function ( a ) {

					return handle.name === a;

				} ) ) {

					handle.material.color.setHex( 0xffff00 );
					handle.material.opacity = 1.0;

				}

			}

		}

		super.updateMatrixWorld( force );

	}

}

//

class TransformControlsPlane extends Mesh {

	constructor() {

		super(
			new PlaneGeometry( 100000, 100000, 2, 2 ),
			new MeshBasicMaterial( { visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false } )
		);

		this.isTransformControlsPlane = true;

		this.type = 'TransformControlsPlane';

	}

	updateMatrixWorld( force ) {

		let space = this.space;

		this.position.copy( this.worldPosition );

		if ( this.mode === 'scale' ) space = 'local'; // scale always oriented to local rotation

		_v1.copy( _unitX ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );
		_v2$1.copy( _unitY ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );
		_v3.copy( _unitZ ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );

		// Align the plane for current transform mode, axis and space.

		_alignVector.copy( _v2$1 );

		switch ( this.mode ) {

			case 'translate':
			case 'scale':
				switch ( this.axis ) {

					case 'X':
						_alignVector.copy( this.eye ).cross( _v1 );
						_dirVector.copy( _v1 ).cross( _alignVector );
						break;
					case 'Y':
						_alignVector.copy( this.eye ).cross( _v2$1 );
						_dirVector.copy( _v2$1 ).cross( _alignVector );
						break;
					case 'Z':
						_alignVector.copy( this.eye ).cross( _v3 );
						_dirVector.copy( _v3 ).cross( _alignVector );
						break;
					case 'XY':
						_dirVector.copy( _v3 );
						break;
					case 'YZ':
						_dirVector.copy( _v1 );
						break;
					case 'XZ':
						_alignVector.copy( _v3 );
						_dirVector.copy( _v2$1 );
						break;
					case 'XYZ':
					case 'E':
						_dirVector.set( 0, 0, 0 );
						break;

				}

				break;
			case 'rotate':
			default:
				// special case for rotate
				_dirVector.set( 0, 0, 0 );

		}

		if ( _dirVector.length() === 0 ) {

			// If in rotate mode, make the plane parallel to camera
			this.quaternion.copy( this.cameraQuaternion );

		} else {

			_tempMatrix.lookAt( _tempVector.set( 0, 0, 0 ), _dirVector, _alignVector );

			this.quaternion.setFromRotationMatrix( _tempMatrix );

		}

		super.updateMatrixWorld( force );

	}

}

var __defProp$x = Object.defineProperty;
var __defNormalProp$x = (obj, key, value) => key in obj ? __defProp$x(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$x = (obj, key, value) => __defNormalProp$x(obj, typeof key !== "symbol" ? key + "" : key, value);
class TransformControlsWarp extends Component {
  constructor(options) {
    super(options);
    __publicField$x(this, "transformControls");
    __publicField$x(this, "objectPositionOnDown", new THREE$2.Vector3());
    __publicField$x(this, "objectRotationOnDown", new THREE$2.Euler());
    __publicField$x(this, "objectScaleOnDown", new THREE$2.Vector3());
    this.initTransformControls();
  }
  setSpace(space) {
    this.transformControls.setSpace(space);
  }
  initTransformControls() {
    this.transformControls = new TransformControls(this.camera, this.canvas);
    this.transformControls.addEventListener("axis-changed", () => {
    });
    this.transformControls.addEventListener("objectChange", () => {
      if (this.transformControls.object) {
        this.editor.editorEventManager.objectChanged.next(this.transformControls.object);
      }
    });
    this.transformControls.addEventListener("mouseDown", () => {
      const object = this.transformControls.object;
      if (object) {
        this.objectPositionOnDown = object.position.clone();
        this.objectRotationOnDown = object.rotation.clone();
        this.objectScaleOnDown = object.scale.clone();
      }
      this.cameraManager.cameraControls.enabled = false;
    });
    this.transformControls.addEventListener("mouseUp", () => {
      const object = this.transformControls.object;
      if (object !== void 0) {
        switch (this.transformControls.getMode()) {
          case "translate":
            if (!this.objectPositionOnDown.equals(object.position)) {
              this.editor.setValueExecute(object, ["position"], object.position, this.objectPositionOnDown);
            }
            break;
          case "rotate":
            if (!this.objectRotationOnDown.equals(object.rotation)) {
              this.editor.setValueExecute(object, "rotation", object.rotation, this.objectRotationOnDown);
            }
            break;
          case "scale":
            if (!this.objectScaleOnDown.equals(object.scale)) {
              this.editor.setValueExecute(object, "scale", object.rotation, this.objectScaleOnDown);
            }
            break;
        }
      }
      this.cameraManager.cameraControls.enabled = true;
    });
    const gizmo = this.transformControls.getHelper();
    this.sceneHelpers.add(gizmo);
  }
}

var __defProp$w = Object.defineProperty;
var __defNormalProp$w = (obj, key, value) => key in obj ? __defProp$w(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$w = (obj, key, value) => __defNormalProp$w(obj, typeof key !== "symbol" ? key + "" : key, value);
class Editor extends Component {
  constructor(options) {
    super(options);
    __publicField$w(this, "editorEventManager");
    __publicField$w(this, "history");
    __publicField$w(this, "selector");
    __publicField$w(this, "transformControlsWarp");
    //------------
    __publicField$w(this, "geometries", /* @__PURE__ */ new Map());
    __publicField$w(this, "cameras", /* @__PURE__ */ new Map());
    __publicField$w(this, "helpers", /* @__PURE__ */ new Map());
    __publicField$w(this, "materials", /* @__PURE__ */ new Map());
    // 材质引用计数
    __publicField$w(this, "materialsRefCounter", /* @__PURE__ */ new Map());
  }
  initComponent() {
    this.history = new History(this);
    this.editorEventManager = new EditorEventManager({
      viewer: this.viewer
    });
    this.transformControlsWarp = new TransformControlsWarp({
      viewer: this.viewer
    });
    this.selector = new Selector({
      viewer: this.viewer
    });
  }
  objectByUuid(uuid) {
    return this.scene.getObjectByProperty("uuid", uuid);
  }
  //------------------ 回退 开始-----------------
  execute(cmd, optionalName) {
    this.history.execute(cmd, optionalName);
  }
  undo() {
    this.history.undo();
  }
  redo() {
    this.history.redo();
  }
  setValueExecute(object, attributeName, newValue, oldValue = void 0) {
    this.execute(new SetValueCommand(object, attributeName, newValue, oldValue));
  }
  setColorValueCommand(object, attributeName, newValue, oldValue = void 0) {
    this.execute(new SetColorCommand(object, attributeName, newValue, oldValue));
  }
  setMaterialExecute(object, newValue, materialSlot = -1) {
    this.execute(new SetMaterialCommand(object, newValue, materialSlot));
  }
  setMaterialColorExecute(object, attributeName, newValue, materialSlot = -1) {
    this.execute(new SetMaterialColorCommand(object, attributeName, newValue, materialSlot));
  }
  setMaterialValueExecute(object, attributeName, newValue, materialSlot = -1) {
    this.execute(new SetMaterialValueCommand(object, attributeName, newValue, materialSlot));
  }
  // setMaterialMapExecute(object: THREE.Object3D, attributeName: string = '', newValue: TexImageSource | OffscreenCanvas, materialSlot: number = -1) {
  //     // 
  //     const texture = new THREE.Texture(newValue)
  //     this.command(new SetMaterialMapCommand(object, attributeName, texture, materialSlot,))
  // }
  setMaterialMapExecute(object, attributeName = "", newValue, materialSlot = -1) {
    this.execute(new SetMaterialMapCommand(object, attributeName, newValue, materialSlot));
  }
  removeObjectExecute(object) {
    this.execute(new RemoveObjectCommand(object));
  }
  addObjectExecute(object) {
    this.execute(new AddObjectCommand(object));
  }
  moveObjectExecute(objectUUid, newParentUUid, newBefore) {
    const object = Tool$1.getObjectByUuid(this.scene, objectUUid);
    const newParent = Tool$1.getObjectByUuid(this.scene, newParentUUid);
    this.execute(new MoveObjectCommand(object, newParent, newBefore));
  }
  //------------------ 回退 结束-----------------
  addObject(object, parent = void 0, index = 0) {
    object.traverse((child) => {
      if (isMesh(child)) {
        if (child.geometry !== void 0) {
          this.addGeometry(child.geometry);
        }
        if (child.material !== void 0) {
          this.addMaterial(child.material);
        }
      }
      this.addCamera(child);
      this.addHelper(child);
    });
    if (parent === void 0) {
      this.scene.add(object);
    } else {
      parent.children.splice(index, 0, object);
      object.parent = parent;
    }
    this.editorEventManager.objectAdded.next(object);
  }
  addGeometry(geometry) {
    this.geometries.set(geometry.uuid, geometry);
  }
  addMaterial(material) {
    if (Array.isArray(material)) {
      for (let i = 0, l = material.length; i < l; i++) {
        this.addMaterialToRefCounter(material[i]);
      }
    } else {
      this.addMaterialToRefCounter(material);
    }
    this.editorEventManager.materialAdded.next(null);
  }
  addMaterialToRefCounter(material) {
    let materialsRefCounter = this.materialsRefCounter;
    let count = materialsRefCounter.get(material);
    if (count === void 0) {
      materialsRefCounter.set(material, 1);
      this.materials[material.uuid] = material;
    } else {
      count++;
      materialsRefCounter.set(material, count);
    }
  }
  addCamera(camera) {
    if (isCamera(camera)) {
      this.cameras.set(camera.uuid, camera);
    }
  }
  nameObject(object, name) {
    object.name = name;
    this.editorEventManager.sceneGraphChanged.next(null);
  }
  removeObject(object) {
    if (object.parent === null) return;
    object.traverse((child) => {
      this.removeCamera(child);
      this.removeHelper(child);
      if (isMesh(child)) {
        this.removeMaterial(child.material);
      }
    });
    object.parent.remove(object);
    this.editor.editorEventManager.objectRemoved.next(object);
  }
  removeMaterial(material) {
    if (Array.isArray(material)) {
      for (let i = 0, l = material.length; i < l; i++) {
        this.removeMaterialFromRefCounter(material[i]);
      }
    } else {
      this.removeMaterialFromRefCounter(material);
    }
    this.editor.editorEventManager.materialRemoved.next(null);
  }
  removeMaterialFromRefCounter(material) {
    let count = this.materialsRefCounter.get(material);
    count--;
    if (count === 0) {
      this.materialsRefCounter.delete(material);
      this.materials.delete(material.uuid);
      material.dispose();
    } else {
      this.materialsRefCounter.set(material, count);
    }
  }
  removeCamera(camera) {
    if (this.cameras.get(camera.uuid) !== void 0) {
      this.cameras.delete(camera.uuid);
      camera = void 0;
    }
  }
  //-------------------- 帮助对象相关 开始-------------------
  addHelper(object, helper = void 0) {
    let geometry = new THREE$2.SphereGeometry(2, 4, 2);
    let material = new THREE$2.MeshBasicMaterial({ color: 16711680, visible: false });
    if (helper === void 0) {
      if (isCamera(object)) {
        helper = new THREE$2.CameraHelper(object);
      } else if (isPointLight(object)) {
        helper = new THREE$2.PointLightHelper(object, 1);
      } else if (isDirectionalLight(object)) {
        helper = new THREE$2.DirectionalLightHelper(object, 1);
      } else if (isSpotLight(object)) {
        helper = new THREE$2.SpotLightHelper(object);
      } else if (isHemisphereLight(object)) {
        helper = new THREE$2.HemisphereLightHelper(object, 1);
      } else if (isSkinnedMesh(object)) {
        helper = new THREE$2.SkeletonHelper(object.skeleton.bones[0]);
      } else if (object.isBone === true && object.parent && object.parent.isBone !== true) {
        helper = new THREE$2.SkeletonHelper(object);
      } else {
        return;
      }
      const picker = new THREE$2.Mesh(geometry, material);
      picker.name = "picker";
      picker.userData.object = object;
      helper.add(picker);
    }
    this.sceneHelpers.add(helper);
    this.helpers.set(object.uuid, helper);
    this.editorEventManager.helperAdded.next(helper);
  }
  removeHelper(object) {
    if (this.helpers.get(object.uuid) !== void 0) {
      let helper = this.helpers.get(object.uuid);
      if (helper) {
        helper?.parent?.remove(helper);
        helper?.dispose();
        this.helpers.delete(object.uuid);
      }
    }
  }
  showNormals(object) {
    if (this.helpers.get(object.uuid) === void 0) {
      this.addHelper(object, new VertexNormalsHelper(object));
    } else {
      this.removeHelper(object);
    }
  }
  helperUpdate(object) {
    let helper = this.helpers.get(object.uuid);
    if (helper) {
      Reflect.apply(Reflect.get(helper, "update"), helper, []);
    }
  }
  setSpace(space) {
    this.transformControlsWarp.setSpace(space);
  }
}

const presetsObj = {
  apartment: "/hdr/lebombo_1k.hdr",
  city: "/hdr/potsdamer_platz_1k.hdr",
  dawn: "/hdr/kiara_1_dawn_1k.hdr",
  forest: "/hdr/forest_slope_1k.hdr",
  lobby: "/hdr/st_fagans_interior_1k.hdr",
  night: "/hdr/dikhololo_night_1k.hdr",
  park: "/hdr/rooitou_park_1k.hdr",
  studio: "/hdr/studio_small_03_1k.hdr",
  sunset: "/hdr/venice_sunset_1k.hdr",
  warehouse: "/hdr/empty_warehouse_01_1k.hdr"
};

var __defProp$v = Object.defineProperty;
var __defNormalProp$v = (obj, key, value) => key in obj ? __defProp$v(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$v = (obj, key, value) => __defNormalProp$v(obj, typeof key !== "symbol" ? key + "" : key, value);
class Asset {
  /**
   * 构造函数，初始化资产类的实例。
   * @param options 资产的配置选项，包含了初始时的URL、结果数据、名称和扩展名。
   */
  constructor(options) {
    __publicField$v(this, "options");
    // 资产选项，包含了初始化时的所有可能属性
    __publicField$v(this, "url");
    // 资源的URL
    __publicField$v(this, "result");
    // 加载完成的资源数据
    __publicField$v(this, "name");
    // 资源的名称
    __publicField$v(this, "extension");
    // 资源的文件扩展名
    __publicField$v(this, "loadSubject", new Subject());
    // 加载完成的观察者主题，用于通知加载的GLTF资源
    __publicField$v(this, "errorSubject", new Subject());
    // 加载完成的观察者主题，用于通知加载的GLTF资源
    __publicField$v(this, "progressSubject", new Subject());
    // 加载进度的观察者主题，用于通知加载进度
    __publicField$v(this, "fileReader");
    __publicField$v(this, "file");
    __publicField$v(this, "onLoad", (data) => {
      this.loadSubject.next(data);
    });
    __publicField$v(this, "onProgress", (event) => {
      const progress = Math.floor(event.loaded / event.total * 100);
      this.progressSubject.next(progress);
    });
    __publicField$v(this, "onError", (err) => {
      this.errorSubject.error(err);
    });
    __publicField$v(this, "loadFile", (loadFun) => {
      if (!this.fileReader) return;
      if (!this.file) return;
      this.fileReader.addEventListener("progress", (event) => {
        const progress = Math.floor(event.loaded / event.total * 100);
        this.progressSubject.next(progress);
      });
      this.fileReader.addEventListener("load", async (event) => {
        loadFun(event);
      });
      this.fileReader.readAsArrayBuffer(this.file);
    });
    this.options = options;
    if (!isNil(this.options.loadUrl)) {
      this.url = this.options.loadUrl;
      let urlExtension = isArray$1(this.url) ? this.url[0] : this.url;
      const _isUrl = isUrl(urlExtension);
      if (_isUrl) {
        const _url = new URL(urlExtension);
        urlExtension = _url.pathname;
      }
      const splitList = split(urlExtension, ".");
      const len = splitList.length;
      this.name = splitList[len - 2];
      this.extension = splitList[len - 1];
      if (_isUrl) {
        this.name = decodeURIComponent(this.name);
      }
    }
    if (!isNil(this.options.result)) {
      this.result = this.options.result;
    }
    if (!isNil(this.options.name)) {
      this.name = this.options.name;
    }
    if (!isNil(this.options.extension)) {
      this.extension = this.options.extension;
    }
    this.parseFile();
    if (isNil(this.extension)) {
      throw new Error("\u8BF7\u4F20\u5165\u6587\u4EF6\u540E\u7F00\u7C7B\u578B");
    }
  }
  parseFile() {
    if (!isNil(this.options.file)) {
      this.file = this.options.file;
      this.fileReader = new FileReader();
      let [fileName, fileExtension] = extractFileNameAndExtension(this.file);
      this.name = fileName;
      this.extension = fileExtension;
    }
  }
}

var EnvironmentMode = /* @__PURE__ */ ((EnvironmentMode2) => {
  EnvironmentMode2[EnvironmentMode2["ENVIRONMENT"] = 0] = "ENVIRONMENT";
  EnvironmentMode2[EnvironmentMode2["BACKGROUND"] = 1] = "BACKGROUND";
  EnvironmentMode2[EnvironmentMode2["ALL"] = 2] = "ALL";
  EnvironmentMode2[EnvironmentMode2["NUll"] = 3] = "NUll";
  return EnvironmentMode2;
})(EnvironmentMode || {});
class EnvironmentManage extends Component {
  constructor(options) {
    super(options);
    const { preset } = options;
  }
  setEnv(options) {
    const _options = deepMergeRetain$1({}, options);
    const { background, texture, mode, sceneEnvAttribute } = _options;
    this.scene.background;
    this.scene.environment;
    ({
      backgroundBlurriness: this.scene.backgroundBlurriness,
      backgroundIntensity: this.scene.backgroundIntensity,
      backgroundRotation: this.scene.backgroundRotation?.clone?.() ?? [0, 0, 0],
      environmentIntensity: this.scene.environmentIntensity,
      environmentRotation: this.scene.environmentRotation?.clone?.() ?? [0, 0, 0]
    });
    for (const [key, value] of Object.entries(sceneEnvAttribute)) {
      this.scene[key] = value;
    }
    switch (mode) {
      case 0 /* ENVIRONMENT */:
        this.scene.environment = texture;
        break;
      case 1 /* BACKGROUND */:
        this.scene.background = texture;
        break;
      case 2 /* ALL */:
        this.scene.environment = texture;
        this.scene.background = texture;
        break;
    }
  }
  setEnvironment(options = {}) {
    const _options = deepMergeRetain$1(options, {
      files: ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"],
      path: "",
      preset: void 0,
      encoding: void 0,
      mode: 2 /* ALL */,
      sceneEnvAttribute: {}
    });
    let { background, files, path, preset, encoding, mode, color } = _options;
    if (mode === 3 /* NUll */) {
      this.setEnv({
        mode: 3 /* NUll */,
        texture: null,
        color: null,
        ..._options
      });
      return;
    }
    if (!isNil(color)) {
      this.setEnv({
        texture: color,
        ..._options
      });
      return;
    }
    if (preset) {
      if (!(preset in presetsObj)) throw new Error("Preset must be one of: " + Object.keys(presetsObj).join(", "));
      files = presetsObj[preset];
    }
    const isCubeMap = isArray$1(files) && files.length === 6;
    const isGainMap = isArray$1(files) && files.length === 3 && files.some((file) => file.endsWith("json"));
    const firstEntry = isArray$1(files) ? files[0] : files;
    let extension = void 0;
    if (isCubeMap) {
      extension = "cube";
    } else if (isGainMap) {
      extension = "webp";
    } else if (firstEntry.startsWith("data:application/exr")) {
      extension = "exr";
    } else if (firstEntry.startsWith("data:application/hdr")) {
      extension = "hdr";
    } else if (firstEntry.startsWith("data:image/jpeg")) {
      extension = "jpg";
    } else ;
    const asset = new Asset({
      loadUrl: files,
      extension
    });
    this.assetManager.loadAsset(asset).then((result) => {
      this.setEnv({
        texture: result,
        ..._options
      });
    });
  }
  createDefaultLight() {
    let isHasDirectionalLight = false;
    this.scene.traverse((obj) => {
      if (isDirectionalLight(obj)) {
        isHasDirectionalLight = true;
      }
    });
    if (!isHasDirectionalLight) {
      const light = new THREE$2.DirectionalLight(16777215, 2);
      light.name = "DefaultDirectionalLight";
      light.position.set(5, 10, 7.5);
      this.scene.add(light);
    }
  }
  createDefaultEnvironment() {
  }
}

/**
 * Based on "A Practical Analytic Model for Daylight"
 * aka The Preetham Model, the de facto standard analytic skydome model
 * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight
 *
 * First implemented by Simon Wallner
 * http://simonwallner.at/project/atmospheric-scattering/
 *
 * Improved by Martin Upitis
 * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR
 *
 * Three.js integration by zz85 http://twitter.com/blurspline
*/

class Sky extends Mesh {

	constructor() {

		const shader = Sky.SkyShader;

		const material = new ShaderMaterial( {
			name: shader.name,
			uniforms: UniformsUtils.clone( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			depthWrite: false
		} );

		super( new BoxGeometry( 1, 1, 1 ), material );

		this.isSky = true;

	}

}

Sky.SkyShader = {

	name: 'SkyShader',

	uniforms: {
		'turbidity': { value: 2 },
		'rayleigh': { value: 1 },
		'mieCoefficient': { value: 0.005 },
		'mieDirectionalG': { value: 0.8 },
		'sunPosition': { value: new Vector3() },
		'up': { value: new Vector3( 0, 1, 0 ) }
	},

	vertexShader: /* glsl */`
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calculation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorption + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,

	fragmentShader: /* glsl */`
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`

};

function calcPosFromAngles(inclination, azimuth, vector = new THREE$2.Vector3()) {
  const theta = Math.PI * (inclination - 0.5);
  const phi = 2 * Math.PI * (azimuth - 0.5);
  vector.x = Math.cos(phi);
  vector.y = Math.sin(theta);
  vector.z = Math.sin(phi);
  return vector;
}
class PlumSky extends Sky {
  updateConfig({
    inclination = 0.6,
    azimuth = 0.1,
    distance = 1e3,
    mieCoefficient = 5e-3,
    mieDirectionalG = 0.8,
    rayleigh = 0.5,
    turbidity = 10,
    sunPosition = calcPosFromAngles(inclination, azimuth)
  }) {
    new THREE$2.Vector3().setScalar(distance);
    this.material.uniforms.turbidity.value = turbidity;
    this.material.uniforms.mieCoefficient.value = mieCoefficient;
    this.material.uniforms.mieDirectionalG.value = mieDirectionalG;
    this.material.uniforms.rayleigh.value = rayleigh;
    this.material.uniforms.sunPosition.value = sunPosition;
    this.material.uniforms.turbidity.value = turbidity;
  }
}

var __defProp$u = Object.defineProperty;
var __defNormalProp$u = (obj, key, value) => key in obj ? __defProp$u(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$u = (obj, key, value) => __defNormalProp$u(obj, typeof key !== "symbol" ? key + "" : key, value);
var DrawType = /* @__PURE__ */ ((DrawType2) => {
  DrawType2[DrawType2["Line"] = 0] = "Line";
  DrawType2[DrawType2["Point"] = 1] = "Point";
  return DrawType2;
})(DrawType || {});
class DrawLine extends Component {
  constructor(options) {
    super(options);
    __publicField$u(this, "pointGroup", new THREE$2.Group());
    __publicField$u(this, "points", []);
    __publicField$u(this, "line");
    __publicField$u(this, "drawType", 0 /* Line */);
    __publicField$u(this, "DrawLineType");
    __publicField$u(this, "DrawLineParams");
    __publicField$u(this, "DrawControlPointType", THREE$2.BoxGeometry);
    __publicField$u(this, "onAddPointSubscription");
    __publicField$u(this, "onStopSubscription");
    this.eventManager.leftClickPickSubject.subscribe((value) => {
    });
  }
  init() {
    this.scene.add(this.pointGroup);
  }
  start() {
    this.initEvent();
  }
  stop() {
    this.onAddPointSubscription?.unsubscribe();
    this.onStopSubscription?.unsubscribe();
  }
  initEvent() {
    this.onAddPointSubscription = this.eventManager.leftClickPickSubject.subscribe((value) => {
      this.onAddPoint(value);
    });
    this.onStopSubscription = this.eventManager.dblClickPickSubject.subscribe((value) => {
      this.onStopEvent(value);
    });
  }
  onStopEvent(value) {
    this.stop();
  }
  onAddPoint(value) {
    const { position, intersects } = value;
    this.points.push(position);
    switch (this.drawType) {
      case 1 /* Point */:
        this.drawPoint(value);
        break;
      case 0 /* Line */:
        this.drawControlPoint(value);
        this.drawLine(value);
        break;
    }
  }
  drawPoint(value) {
  }
  drawControlPoint(value) {
    const { position, intersects } = value;
    if (this.DrawControlPointType) {
      const boxGeometry = new this.DrawControlPointType(1, 1, 1);
      const boxMaterial = new THREE$2.MeshBasicMaterial({ color: 16777215 });
      const box = new THREE$2.Mesh(boxGeometry, boxMaterial);
      box.position.copy(position);
      this.pointGroup.add(box);
    }
  }
  drawLine(value) {
    if (this.points.length > 1) {
      if (isNil(this.line)) {
        if (this.DrawLineType) {
          this.line = new this.DrawLineType(this.DrawLineParams);
          this.scene.add(this.line);
        }
      } else {
        this.line.setPoints(this.points);
      }
    }
  }
  addLine() {
  }
}

/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
// see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#value
const MOUSE_BUTTON = {
    LEFT: 1,
    RIGHT: 2,
    MIDDLE: 4,
};
const ACTION = Object.freeze({
    NONE: 0b0,
    ROTATE: 0b1,
    TRUCK: 0b10,
    SCREEN_PAN: 0b100,
    OFFSET: 0b1000,
    DOLLY: 0b10000,
    ZOOM: 0b100000,
    TOUCH_ROTATE: 0b1000000,
    TOUCH_TRUCK: 0b10000000,
    TOUCH_SCREEN_PAN: 0b100000000,
    TOUCH_OFFSET: 0b1000000000,
    TOUCH_DOLLY: 0b10000000000,
    TOUCH_ZOOM: 0b100000000000,
    TOUCH_DOLLY_TRUCK: 0b1000000000000,
    TOUCH_DOLLY_SCREEN_PAN: 0b10000000000000,
    TOUCH_DOLLY_OFFSET: 0b100000000000000,
    TOUCH_DOLLY_ROTATE: 0b1000000000000000,
    TOUCH_ZOOM_TRUCK: 0b10000000000000000,
    TOUCH_ZOOM_OFFSET: 0b100000000000000000,
    TOUCH_ZOOM_SCREEN_PAN: 0b1000000000000000000,
    TOUCH_ZOOM_ROTATE: 0b10000000000000000000,
});
const DOLLY_DIRECTION = {
    NONE: 0,
    IN: 1,
    OUT: -1,
};
function isPerspectiveCamera(camera) {
    return camera.isPerspectiveCamera;
}
function isOrthographicCamera(camera) {
    return camera.isOrthographicCamera;
}

const PI_2 = Math.PI * 2;
const PI_HALF = Math.PI / 2;

const EPSILON = 1e-5;
const DEG2RAD = Math.PI / 180;
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
function approxZero(number, error = EPSILON) {
    return Math.abs(number) < error;
}
function approxEquals(a, b, error = EPSILON) {
    return approxZero(a - b, error);
}
function roundToStep(value, step) {
    return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
    if (isFinite(value))
        return value;
    if (value < 0)
        return -Number.MAX_VALUE;
    return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
    if (Math.abs(value) < Number.MAX_VALUE)
        return value;
    return value * Infinity;
}
// https://docs.unity3d.com/ScriptReference/Mathf.SmoothDamp.html
// https://github.com/Unity-Technologies/UnityCsReference/blob/a2bdfe9b3c4cd4476f44bf52f848063bfaf7b6b9/Runtime/Export/Math/Mathf.cs#L308
function smoothDamp(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {
    // Based on Game Programming Gems 4 Chapter 1.10
    smoothTime = Math.max(0.0001, smoothTime);
    const omega = 2 / smoothTime;
    const x = omega * deltaTime;
    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
    let change = current - target;
    const originalTo = target;
    // Clamp maximum speed
    const maxChange = maxSpeed * smoothTime;
    change = clamp(change, -maxChange, maxChange);
    target = current - change;
    const temp = (currentVelocityRef.value + omega * change) * deltaTime;
    currentVelocityRef.value = (currentVelocityRef.value - omega * temp) * exp;
    let output = target + (change + temp) * exp;
    // Prevent overshooting
    if (originalTo - current > 0.0 === output > originalTo) {
        output = originalTo;
        currentVelocityRef.value = (output - originalTo) / deltaTime;
    }
    return output;
}
// https://docs.unity3d.com/ScriptReference/Vector3.SmoothDamp.html
// https://github.com/Unity-Technologies/UnityCsReference/blob/a2bdfe9b3c4cd4476f44bf52f848063bfaf7b6b9/Runtime/Export/Math/Vector3.cs#L97
function smoothDampVec3(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {
    // Based on Game Programming Gems 4 Chapter 1.10
    smoothTime = Math.max(0.0001, smoothTime);
    const omega = 2 / smoothTime;
    const x = omega * deltaTime;
    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
    let targetX = target.x;
    let targetY = target.y;
    let targetZ = target.z;
    let changeX = current.x - targetX;
    let changeY = current.y - targetY;
    let changeZ = current.z - targetZ;
    const originalToX = targetX;
    const originalToY = targetY;
    const originalToZ = targetZ;
    // Clamp maximum speed
    const maxChange = maxSpeed * smoothTime;
    const maxChangeSq = maxChange * maxChange;
    const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;
    if (magnitudeSq > maxChangeSq) {
        const magnitude = Math.sqrt(magnitudeSq);
        changeX = changeX / magnitude * maxChange;
        changeY = changeY / magnitude * maxChange;
        changeZ = changeZ / magnitude * maxChange;
    }
    targetX = current.x - changeX;
    targetY = current.y - changeY;
    targetZ = current.z - changeZ;
    const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;
    const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;
    const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;
    currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;
    currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;
    currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;
    out.x = targetX + (changeX + tempX) * exp;
    out.y = targetY + (changeY + tempY) * exp;
    out.z = targetZ + (changeZ + tempZ) * exp;
    // Prevent overshooting
    const origMinusCurrentX = originalToX - current.x;
    const origMinusCurrentY = originalToY - current.y;
    const origMinusCurrentZ = originalToZ - current.z;
    const outMinusOrigX = out.x - originalToX;
    const outMinusOrigY = out.y - originalToY;
    const outMinusOrigZ = out.z - originalToZ;
    if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {
        out.x = originalToX;
        out.y = originalToY;
        out.z = originalToZ;
        currentVelocityRef.x = (out.x - originalToX) / deltaTime;
        currentVelocityRef.y = (out.y - originalToY) / deltaTime;
        currentVelocityRef.z = (out.z - originalToZ) / deltaTime;
    }
    return out;
}

function extractClientCoordFromEvent(pointers, out) {
    out.set(0, 0);
    pointers.forEach((pointer) => {
        out.x += pointer.clientX;
        out.y += pointer.clientY;
    });
    out.x /= pointers.length;
    out.y /= pointers.length;
}

function notSupportedInOrthographicCamera(camera, message) {
    if (isOrthographicCamera(camera)) {
        console.warn(`${message} is not supported in OrthographicCamera`);
        return true;
    }
    return false;
}

class EventDispatcher {
    constructor() {
        this._listeners = {};
    }
    /**
     * Adds the specified event listener.
     * @param type event name
     * @param listener handler function
     * @category Methods
     */
    addEventListener(type, listener) {
        const listeners = this._listeners;
        if (listeners[type] === undefined)
            listeners[type] = [];
        if (listeners[type].indexOf(listener) === -1)
            listeners[type].push(listener);
    }
    /**
     * Presence of the specified event listener.
     * @param type event name
     * @param listener handler function
     * @category Methods
     */
    hasEventListener(type, listener) {
        const listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    }
    /**
     * Removes the specified event listener
     * @param type event name
     * @param listener handler function
     * @category Methods
     */
    removeEventListener(type, listener) {
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1)
                listenerArray.splice(index, 1);
        }
    }
    /**
     * Removes all event listeners
     * @param type event name
     * @category Methods
     */
    removeAllEventListeners(type) {
        if (!type) {
            this._listeners = {};
            return;
        }
        if (Array.isArray(this._listeners[type]))
            this._listeners[type].length = 0;
    }
    /**
     * Fire an event type.
     * @param event DispatcherEvent
     * @category Methods
     */
    dispatchEvent(event) {
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            const array = listenerArray.slice(0);
            for (let i = 0, l = array.length; i < l; i++) {
                array[i].call(this, event);
            }
        }
    }
}

var _a;
const VERSION = '2.10.0'; // will be replaced with `version` in package.json during the build process.
const TOUCH_DOLLY_FACTOR = 1 / 8;
const isMac = /Mac/.test((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.platform);
let THREE$1;
let _ORIGIN;
let _AXIS_Y;
let _AXIS_Z;
let _v2;
let _v3A;
let _v3B;
let _v3C;
let _cameraDirection;
let _xColumn;
let _yColumn;
let _zColumn;
let _deltaTarget;
let _deltaOffset;
let _sphericalA;
let _sphericalB;
let _box3A;
let _box3B;
let _sphere$1;
let _quaternionA;
let _quaternionB;
let _rotationMatrix;
let _raycaster;
class CameraControls extends EventDispatcher {
    /**
     * Injects THREE as the dependency. You can then proceed to use CameraControls.
     *
     * e.g
     * ```javascript
     * CameraControls.install( { THREE: THREE } );
     * ```
     *
     * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
     *
     * ```js
     * import {
     * 	Vector2,
     * 	Vector3,
     * 	Vector4,
     * 	Quaternion,
     * 	Matrix4,
     * 	Spherical,
     * 	Box3,
     * 	Sphere,
     * 	Raycaster,
     * 	MathUtils,
     * } from 'three';
     *
     * const subsetOfTHREE = {
     * 	Vector2   : Vector2,
     * 	Vector3   : Vector3,
     * 	Vector4   : Vector4,
     * 	Quaternion: Quaternion,
     * 	Matrix4   : Matrix4,
     * 	Spherical : Spherical,
     * 	Box3      : Box3,
     * 	Sphere    : Sphere,
     * 	Raycaster : Raycaster,
     * };

     * CameraControls.install( { THREE: subsetOfTHREE } );
     * ```
     * @category Statics
     */
    static install(libs) {
        THREE$1 = libs.THREE;
        _ORIGIN = Object.freeze(new THREE$1.Vector3(0, 0, 0));
        _AXIS_Y = Object.freeze(new THREE$1.Vector3(0, 1, 0));
        _AXIS_Z = Object.freeze(new THREE$1.Vector3(0, 0, 1));
        _v2 = new THREE$1.Vector2();
        _v3A = new THREE$1.Vector3();
        _v3B = new THREE$1.Vector3();
        _v3C = new THREE$1.Vector3();
        _cameraDirection = new THREE$1.Vector3();
        _xColumn = new THREE$1.Vector3();
        _yColumn = new THREE$1.Vector3();
        _zColumn = new THREE$1.Vector3();
        _deltaTarget = new THREE$1.Vector3();
        _deltaOffset = new THREE$1.Vector3();
        _sphericalA = new THREE$1.Spherical();
        _sphericalB = new THREE$1.Spherical();
        _box3A = new THREE$1.Box3();
        _box3B = new THREE$1.Box3();
        _sphere$1 = new THREE$1.Sphere();
        _quaternionA = new THREE$1.Quaternion();
        _quaternionB = new THREE$1.Quaternion();
        _rotationMatrix = new THREE$1.Matrix4();
        _raycaster = new THREE$1.Raycaster();
    }
    /**
     * list all ACTIONs
     * @category Statics
     */
    static get ACTION() {
        return ACTION;
    }
    /**
     * Creates a `CameraControls` instance.
     *
     * Note:
     * You **must install** three.js before using camera-controls. see [#install](#install)
     * Not doing so will lead to runtime errors (`undefined` references to THREE).
     *
     * e.g.
     * ```
     * CameraControls.install( { THREE } );
     * const cameraControls = new CameraControls( camera, domElement );
     * ```
     *
     * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
     * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
     * @category Constructor
     */
    constructor(camera, domElement) {
        super();
        /**
         * Minimum vertical angle in radians.
         * The angle has to be between `0` and `.maxPolarAngle` inclusive.
         * The default value is `0`.
         *
         * e.g.
         * ```
         * cameraControls.maxPolarAngle = 0;
         * ```
         * @category Properties
         */
        this.minPolarAngle = 0; // radians
        /**
         * Maximum vertical angle in radians.
         * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.
         * The default value is `Math.PI`.
         *
         * e.g.
         * ```
         * cameraControls.maxPolarAngle = Math.PI;
         * ```
         * @category Properties
         */
        this.maxPolarAngle = Math.PI; // radians
        /**
         * Minimum horizontal angle in radians.
         * The angle has to be less than `.maxAzimuthAngle`.
         * The default value is `- Infinity`.
         *
         * e.g.
         * ```
         * cameraControls.minAzimuthAngle = - Infinity;
         * ```
         * @category Properties
         */
        this.minAzimuthAngle = -Infinity; // radians
        /**
         * Maximum horizontal angle in radians.
         * The angle has to be greater than `.minAzimuthAngle`.
         * The default value is `Infinity`.
         *
         * e.g.
         * ```
         * cameraControls.maxAzimuthAngle = Infinity;
         * ```
         * @category Properties
         */
        this.maxAzimuthAngle = Infinity; // radians
        // How far you can dolly in and out ( PerspectiveCamera only )
        /**
         * Minimum distance for dolly. The value must be higher than `0`. Default is `Number.EPSILON`.
         * PerspectiveCamera only.
         * @category Properties
         */
        this.minDistance = Number.EPSILON;
        /**
         * Maximum distance for dolly. The value must be higher than `minDistance`. Default is `Infinity`.
         * PerspectiveCamera only.
         * @category Properties
         */
        this.maxDistance = Infinity;
        /**
         * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`
         * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`), `infinityDolly` will keep the distance and pushes the target position instead.
         * @category Properties
         */
        this.infinityDolly = false;
        /**
         * Minimum camera zoom.
         * @category Properties
         */
        this.minZoom = 0.01;
        /**
         * Maximum camera zoom.
         * @category Properties
         */
        this.maxZoom = Infinity;
        /**
         * Approximate time in seconds to reach the target. A smaller value will reach the target faster.
         * @category Properties
         */
        this.smoothTime = 0.25;
        /**
         * the smoothTime while dragging
         * @category Properties
         */
        this.draggingSmoothTime = 0.125;
        /**
         * Max transition speed in unit-per-seconds
         * @category Properties
         */
        this.maxSpeed = Infinity;
        /**
         * Speed of azimuth (horizontal) rotation.
         * @category Properties
         */
        this.azimuthRotateSpeed = 1.0;
        /**
         * Speed of polar (vertical) rotation.
         * @category Properties
         */
        this.polarRotateSpeed = 1.0;
        /**
         * Speed of mouse-wheel dollying.
         * @category Properties
         */
        this.dollySpeed = 1.0;
        /**
         * `true` to invert direction when dollying or zooming via drag
         * @category Properties
         */
        this.dollyDragInverted = false;
        /**
         * Speed of drag for truck and pedestal.
         * @category Properties
         */
        this.truckSpeed = 2.0;
        /**
         * `true` to enable Dolly-in to the mouse cursor coords.
         * @category Properties
         */
        this.dollyToCursor = false;
        /**
         * @category Properties
         */
        this.dragToOffset = false;
        /**
         * Friction ratio of the boundary.
         * @category Properties
         */
        this.boundaryFriction = 0.0;
        /**
         * Controls how soon the `rest` event fires as the camera slows.
         * @category Properties
         */
        this.restThreshold = 0.01;
        /**
         * An array of Meshes to collide with camera.
         * Be aware colliderMeshes may decrease performance. The collision test uses 4 raycasters from the camera since the near plane has 4 corners.
         * @category Properties
         */
        this.colliderMeshes = [];
        /**
         * Force cancel user dragging.
         * @category Methods
         */
        // cancel will be overwritten in the constructor.
        this.cancel = () => { };
        this._enabled = true;
        this._state = ACTION.NONE;
        this._viewport = null;
        this._changedDolly = 0;
        this._changedZoom = 0;
        this._hasRested = true;
        this._boundaryEnclosesCamera = false;
        this._needsUpdate = true;
        this._updatedLastTime = false;
        this._elementRect = new DOMRect();
        this._isDragging = false;
        this._dragNeedsUpdate = true;
        this._activePointers = [];
        this._lockedPointer = null;
        this._interactiveArea = new DOMRect(0, 0, 1, 1);
        // Use draggingSmoothTime over smoothTime while true.
        // set automatically true on user-dragging start.
        // set automatically false on programmable methods call.
        this._isUserControllingRotate = false;
        this._isUserControllingDolly = false;
        this._isUserControllingTruck = false;
        this._isUserControllingOffset = false;
        this._isUserControllingZoom = false;
        this._lastDollyDirection = DOLLY_DIRECTION.NONE;
        // velocities for smoothDamp
        this._thetaVelocity = { value: 0 };
        this._phiVelocity = { value: 0 };
        this._radiusVelocity = { value: 0 };
        this._targetVelocity = new THREE$1.Vector3();
        this._focalOffsetVelocity = new THREE$1.Vector3();
        this._zoomVelocity = { value: 0 };
        this._truckInternal = (deltaX, deltaY, dragToOffset, screenSpacePanning) => {
            let truckX;
            let pedestalY;
            if (isPerspectiveCamera(this._camera)) {
                const offset = _v3A.copy(this._camera.position).sub(this._target);
                // half of the fov is center to top of screen
                const fov = this._camera.getEffectiveFOV() * DEG2RAD;
                const targetDistance = offset.length() * Math.tan(fov * 0.5);
                truckX = (this.truckSpeed * deltaX * targetDistance / this._elementRect.height);
                pedestalY = (this.truckSpeed * deltaY * targetDistance / this._elementRect.height);
            }
            else if (isOrthographicCamera(this._camera)) {
                const camera = this._camera;
                truckX = this.truckSpeed * deltaX * (camera.right - camera.left) / camera.zoom / this._elementRect.width;
                pedestalY = this.truckSpeed * deltaY * (camera.top - camera.bottom) / camera.zoom / this._elementRect.height;
            }
            else {
                return;
            }
            if (screenSpacePanning) {
                dragToOffset ?
                    this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) :
                    this.truck(truckX, 0, true);
                this.forward(-pedestalY, true);
            }
            else {
                dragToOffset ?
                    this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) :
                    this.truck(truckX, pedestalY, true);
            }
        };
        this._rotateInternal = (deltaX, deltaY) => {
            const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height; // divide by *height* to refer the resolution
            const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
            this.rotate(theta, phi, true);
        };
        this._dollyInternal = (delta, x, y) => {
            const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
            const lastDistance = this._sphericalEnd.radius;
            const distance = this._sphericalEnd.radius * dollyScale;
            const clampedDistance = clamp(distance, this.minDistance, this.maxDistance);
            const overflowedDistance = clampedDistance - distance;
            if (this.infinityDolly && this.dollyToCursor) {
                this._dollyToNoClamp(distance, true);
            }
            else if (this.infinityDolly && !this.dollyToCursor) {
                this.dollyInFixed(overflowedDistance, true);
                this._dollyToNoClamp(clampedDistance, true);
            }
            else {
                this._dollyToNoClamp(clampedDistance, true);
            }
            if (this.dollyToCursor) {
                this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;
                this._dollyControlCoord.set(x, y);
            }
            this._lastDollyDirection = Math.sign(-delta);
        };
        this._zoomInternal = (delta, x, y) => {
            const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
            const lastZoom = this._zoom;
            const zoom = this._zoom * zoomScale;
            // for both PerspectiveCamera and OrthographicCamera
            this.zoomTo(zoom, true);
            if (this.dollyToCursor) {
                this._changedZoom += zoom - lastZoom;
                this._dollyControlCoord.set(x, y);
            }
        };
        // Check if the user has installed THREE
        if (typeof THREE$1 === 'undefined') {
            console.error('camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.');
        }
        this._camera = camera;
        this._yAxisUpSpace = new THREE$1.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
        this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();
        this._state = ACTION.NONE;
        // the location
        this._target = new THREE$1.Vector3();
        this._targetEnd = this._target.clone();
        this._focalOffset = new THREE$1.Vector3();
        this._focalOffsetEnd = this._focalOffset.clone();
        // rotation
        this._spherical = new THREE$1.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
        this._sphericalEnd = this._spherical.clone();
        this._lastDistance = this._spherical.radius;
        this._zoom = this._camera.zoom;
        this._zoomEnd = this._zoom;
        this._lastZoom = this._zoom;
        // collisionTest uses nearPlane.s
        this._nearPlaneCorners = [
            new THREE$1.Vector3(),
            new THREE$1.Vector3(),
            new THREE$1.Vector3(),
            new THREE$1.Vector3(),
        ];
        this._updateNearPlaneCorners();
        // Target cannot move outside of this box
        this._boundary = new THREE$1.Box3(new THREE$1.Vector3(-Infinity, -Infinity, -Infinity), new THREE$1.Vector3(Infinity, Infinity, Infinity));
        // reset
        this._cameraUp0 = this._camera.up.clone();
        this._target0 = this._target.clone();
        this._position0 = this._camera.position.clone();
        this._zoom0 = this._zoom;
        this._focalOffset0 = this._focalOffset.clone();
        this._dollyControlCoord = new THREE$1.Vector2();
        // configs
        this.mouseButtons = {
            left: ACTION.ROTATE,
            middle: ACTION.DOLLY,
            right: ACTION.TRUCK,
            wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY :
                isOrthographicCamera(this._camera) ? ACTION.ZOOM :
                    ACTION.NONE,
        };
        this.touches = {
            one: ACTION.TOUCH_ROTATE,
            two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK :
                isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK :
                    ACTION.NONE,
            three: ACTION.TOUCH_TRUCK,
        };
        const dragStartPosition = new THREE$1.Vector2();
        const lastDragPosition = new THREE$1.Vector2();
        const dollyStart = new THREE$1.Vector2();
        const onPointerDown = (event) => {
            if (!this._enabled || !this._domElement)
                return;
            if (this._interactiveArea.left !== 0 ||
                this._interactiveArea.top !== 0 ||
                this._interactiveArea.width !== 1 ||
                this._interactiveArea.height !== 1) {
                const elRect = this._domElement.getBoundingClientRect();
                const left = event.clientX / elRect.width;
                const top = event.clientY / elRect.height;
                // check if the interactiveArea contains the drag start position.
                if (left < this._interactiveArea.left ||
                    left > this._interactiveArea.right ||
                    top < this._interactiveArea.top ||
                    top > this._interactiveArea.bottom)
                    return;
            }
            // Don't call `event.preventDefault()` on the pointerdown event
            // to keep receiving pointermove evens outside dragging iframe
            // https://taye.me/blog/tips/2015/11/16/mouse-drag-outside-iframe/
            const mouseButton = event.pointerType !== 'mouse' ? null :
                (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT :
                    (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE :
                        (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT :
                            null;
            if (mouseButton !== null) {
                const zombiePointer = this._findPointerByMouseButton(mouseButton);
                zombiePointer && this._disposePointer(zombiePointer);
            }
            if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)
                return;
            const pointer = {
                pointerId: event.pointerId,
                clientX: event.clientX,
                clientY: event.clientY,
                deltaX: 0,
                deltaY: 0,
                mouseButton,
            };
            this._activePointers.push(pointer);
            // eslint-disable-next-line no-undef
            this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });
            this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
            this._domElement.ownerDocument.addEventListener('pointermove', onPointerMove, { passive: false });
            this._domElement.ownerDocument.addEventListener('pointerup', onPointerUp);
            this._isDragging = true;
            startDragging(event);
        };
        const onPointerMove = (event) => {
            if (event.cancelable)
                event.preventDefault();
            const pointerId = event.pointerId;
            const pointer = this._lockedPointer || this._findPointerById(pointerId);
            if (!pointer)
                return;
            pointer.clientX = event.clientX;
            pointer.clientY = event.clientY;
            pointer.deltaX = event.movementX;
            pointer.deltaY = event.movementY;
            this._state = 0;
            if (event.pointerType === 'touch') {
                switch (this._activePointers.length) {
                    case 1:
                        this._state = this.touches.one;
                        break;
                    case 2:
                        this._state = this.touches.two;
                        break;
                    case 3:
                        this._state = this.touches.three;
                        break;
                }
            }
            else {
                if ((!this._isDragging && this._lockedPointer) ||
                    this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
                    this._state = this._state | this.mouseButtons.left;
                }
                if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
                    this._state = this._state | this.mouseButtons.middle;
                }
                if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
                    this._state = this._state | this.mouseButtons.right;
                }
            }
            dragging();
        };
        const onPointerUp = (event) => {
            const pointer = this._findPointerById(event.pointerId);
            if (pointer && pointer === this._lockedPointer)
                return;
            pointer && this._disposePointer(pointer);
            if (event.pointerType === 'touch') {
                switch (this._activePointers.length) {
                    case 0:
                        this._state = ACTION.NONE;
                        break;
                    case 1:
                        this._state = this.touches.one;
                        break;
                    case 2:
                        this._state = this.touches.two;
                        break;
                    case 3:
                        this._state = this.touches.three;
                        break;
                }
            }
            else {
                this._state = ACTION.NONE;
            }
            endDragging();
        };
        let lastScrollTimeStamp = -1;
        const onMouseWheel = (event) => {
            if (!this._domElement)
                return;
            if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
                return;
            if (this._interactiveArea.left !== 0 ||
                this._interactiveArea.top !== 0 ||
                this._interactiveArea.width !== 1 ||
                this._interactiveArea.height !== 1) {
                const elRect = this._domElement.getBoundingClientRect();
                const left = event.clientX / elRect.width;
                const top = event.clientY / elRect.height;
                // check if the interactiveArea contains the drag start position.
                if (left < this._interactiveArea.left ||
                    left > this._interactiveArea.right ||
                    top < this._interactiveArea.top ||
                    top > this._interactiveArea.bottom)
                    return;
            }
            event.preventDefault();
            if (this.dollyToCursor ||
                this.mouseButtons.wheel === ACTION.ROTATE ||
                this.mouseButtons.wheel === ACTION.TRUCK) {
                const now = performance.now();
                // only need to fire this at scroll start.
                if (lastScrollTimeStamp - now < 1000)
                    this._getClientRect(this._elementRect);
                lastScrollTimeStamp = now;
            }
            // Ref: https://github.com/cedricpinson/osgjs/blob/00e5a7e9d9206c06fdde0436e1d62ab7cb5ce853/sources/osgViewer/input/source/InputSourceMouse.js#L89-L103
            const deltaYFactor = isMac ? -1 : -3;
            const delta = (event.deltaMode === 1) ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
            const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
            const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
            switch (this.mouseButtons.wheel) {
                case ACTION.ROTATE: {
                    this._rotateInternal(event.deltaX, event.deltaY);
                    this._isUserControllingRotate = true;
                    break;
                }
                case ACTION.TRUCK: {
                    this._truckInternal(event.deltaX, event.deltaY, false, false);
                    this._isUserControllingTruck = true;
                    break;
                }
                case ACTION.SCREEN_PAN: {
                    this._truckInternal(event.deltaX, event.deltaY, false, true);
                    this._isUserControllingTruck = true;
                    break;
                }
                case ACTION.OFFSET: {
                    this._truckInternal(event.deltaX, event.deltaY, true, false);
                    this._isUserControllingOffset = true;
                    break;
                }
                case ACTION.DOLLY: {
                    this._dollyInternal(-delta, x, y);
                    this._isUserControllingDolly = true;
                    break;
                }
                case ACTION.ZOOM: {
                    this._zoomInternal(-delta, x, y);
                    this._isUserControllingZoom = true;
                    break;
                }
            }
            this.dispatchEvent({ type: 'control' });
        };
        const onContextMenu = (event) => {
            if (!this._domElement || !this._enabled)
                return;
            // contextmenu event is fired right after pointerdown
            // remove attached handlers and active pointer, if interrupted by contextmenu.
            if (this.mouseButtons.right === CameraControls.ACTION.NONE) {
                const pointerId = event instanceof PointerEvent ? event.pointerId : 0;
                const pointer = this._findPointerById(pointerId);
                pointer && this._disposePointer(pointer);
                // eslint-disable-next-line no-undef
                this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });
                this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
                return;
            }
            event.preventDefault();
        };
        const startDragging = (event) => {
            if (!this._enabled)
                return;
            extractClientCoordFromEvent(this._activePointers, _v2);
            this._getClientRect(this._elementRect);
            dragStartPosition.copy(_v2);
            lastDragPosition.copy(_v2);
            const isMultiTouch = this._activePointers.length >= 2;
            if (isMultiTouch) {
                // 2 finger pinch
                const dx = _v2.x - this._activePointers[1].clientX;
                const dy = _v2.y - this._activePointers[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                dollyStart.set(0, distance);
                // center coords of 2 finger truck
                const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
                const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
                lastDragPosition.set(x, y);
            }
            this._state = 0;
            if (!event) {
                if (this._lockedPointer)
                    this._state = this._state | this.mouseButtons.left;
            }
            else if ('pointerType' in event && event.pointerType === 'touch') {
                switch (this._activePointers.length) {
                    case 1:
                        this._state = this.touches.one;
                        break;
                    case 2:
                        this._state = this.touches.two;
                        break;
                    case 3:
                        this._state = this.touches.three;
                        break;
                }
            }
            else {
                if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
                    this._state = this._state | this.mouseButtons.left;
                }
                if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
                    this._state = this._state | this.mouseButtons.middle;
                }
                if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
                    this._state = this._state | this.mouseButtons.right;
                }
            }
            // stop current movement on drag start
            // - rotate
            if ((this._state & ACTION.ROTATE) === ACTION.ROTATE ||
                (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE ||
                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||
                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
                this._sphericalEnd.theta = this._spherical.theta;
                this._sphericalEnd.phi = this._spherical.phi;
                this._thetaVelocity.value = 0;
                this._phiVelocity.value = 0;
            }
            // - truck and screen-pan
            if ((this._state & ACTION.TRUCK) === ACTION.TRUCK ||
                (this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN ||
                (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK ||
                (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN ||
                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||
                (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN ||
                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK ||
                (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN) {
                this._targetEnd.copy(this._target);
                this._targetVelocity.set(0, 0, 0);
            }
            // - dolly
            if ((this._state & ACTION.DOLLY) === ACTION.DOLLY ||
                (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY ||
                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||
                (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN ||
                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||
                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {
                this._sphericalEnd.radius = this._spherical.radius;
                this._radiusVelocity.value = 0;
            }
            // - zoom
            if ((this._state & ACTION.ZOOM) === ACTION.ZOOM ||
                (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM ||
                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK ||
                (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN ||
                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET ||
                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
                this._zoomEnd = this._zoom;
                this._zoomVelocity.value = 0;
            }
            // - offset
            if ((this._state & ACTION.OFFSET) === ACTION.OFFSET ||
                (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET ||
                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||
                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
                this._focalOffsetEnd.copy(this._focalOffset);
                this._focalOffsetVelocity.set(0, 0, 0);
            }
            this.dispatchEvent({ type: 'controlstart' });
        };
        const dragging = () => {
            if (!this._enabled || !this._dragNeedsUpdate)
                return;
            this._dragNeedsUpdate = false;
            extractClientCoordFromEvent(this._activePointers, _v2);
            // When pointer lock is enabled clientX, clientY, screenX, and screenY remain 0.
            // If pointer lock is enabled, use the Delta directory, and assume active-pointer is not multiple.
            const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
            const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;
            const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v2.x;
            const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v2.y;
            lastDragPosition.copy(_v2);
            // rotate
            if ((this._state & ACTION.ROTATE) === ACTION.ROTATE ||
                (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE ||
                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||
                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
                this._rotateInternal(deltaX, deltaY);
                this._isUserControllingRotate = true;
            }
            // mouse dolly or zoom
            if ((this._state & ACTION.DOLLY) === ACTION.DOLLY ||
                (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
                const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
                const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
                const dollyDirection = this.dollyDragInverted ? -1 : 1;
                if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {
                    this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
                    this._isUserControllingDolly = true;
                }
                else {
                    this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
                    this._isUserControllingZoom = true;
                }
            }
            // touch dolly or zoom
            if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY ||
                (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM ||
                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||
                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK ||
                (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN ||
                (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN ||
                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||
                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET ||
                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||
                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
                const dx = _v2.x - this._activePointers[1].clientX;
                const dy = _v2.y - this._activePointers[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const dollyDelta = dollyStart.y - distance;
                dollyStart.set(0, distance);
                const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
                const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
                if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY ||
                    (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||
                    (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||
                    (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN ||
                    (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {
                    this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
                    this._isUserControllingDolly = true;
                }
                else {
                    this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
                    this._isUserControllingZoom = true;
                }
            }
            // truck
            if ((this._state & ACTION.TRUCK) === ACTION.TRUCK ||
                (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK ||
                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||
                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
                this._truckInternal(deltaX, deltaY, false, false);
                this._isUserControllingTruck = true;
            }
            // screen-pan
            if ((this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN ||
                (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN ||
                (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN ||
                (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN) {
                this._truckInternal(deltaX, deltaY, false, true);
                this._isUserControllingTruck = true;
            }
            // offset
            if ((this._state & ACTION.OFFSET) === ACTION.OFFSET ||
                (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET ||
                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||
                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
                this._truckInternal(deltaX, deltaY, true, false);
                this._isUserControllingOffset = true;
            }
            this.dispatchEvent({ type: 'control' });
        };
        const endDragging = () => {
            extractClientCoordFromEvent(this._activePointers, _v2);
            lastDragPosition.copy(_v2);
            this._dragNeedsUpdate = false;
            if (this._activePointers.length === 0 ||
                (this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer)) {
                this._isDragging = false;
            }
            if (this._activePointers.length === 0 && this._domElement) {
                // eslint-disable-next-line no-undef
                this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });
                this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
                this.dispatchEvent({ type: 'controlend' });
            }
        };
        this.lockPointer = () => {
            if (!this._enabled || !this._domElement)
                return;
            this.cancel();
            // Element.requestPointerLock is allowed to happen without any pointer active - create a faux one for compatibility with controls
            this._lockedPointer = {
                pointerId: -1,
                clientX: 0,
                clientY: 0,
                deltaX: 0,
                deltaY: 0,
                mouseButton: null,
            };
            this._activePointers.push(this._lockedPointer);
            // eslint-disable-next-line no-undef
            this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });
            this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
            this._domElement.requestPointerLock();
            this._domElement.ownerDocument.addEventListener('pointerlockchange', onPointerLockChange);
            this._domElement.ownerDocument.addEventListener('pointerlockerror', onPointerLockError);
            this._domElement.ownerDocument.addEventListener('pointermove', onPointerMove, { passive: false });
            this._domElement.ownerDocument.addEventListener('pointerup', onPointerUp);
            startDragging();
        };
        this.unlockPointer = () => {
            var _a, _b, _c;
            if (this._lockedPointer !== null) {
                this._disposePointer(this._lockedPointer);
                this._lockedPointer = null;
            }
            (_a = this._domElement) === null || _a === void 0 ? void 0 : _a.ownerDocument.exitPointerLock();
            (_b = this._domElement) === null || _b === void 0 ? void 0 : _b.ownerDocument.removeEventListener('pointerlockchange', onPointerLockChange);
            (_c = this._domElement) === null || _c === void 0 ? void 0 : _c.ownerDocument.removeEventListener('pointerlockerror', onPointerLockError);
            this.cancel();
        };
        const onPointerLockChange = () => {
            const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
            if (!isPointerLockActive)
                this.unlockPointer();
        };
        const onPointerLockError = () => {
            this.unlockPointer();
        };
        this._addAllEventListeners = (domElement) => {
            this._domElement = domElement;
            this._domElement.style.touchAction = 'none';
            this._domElement.style.userSelect = 'none';
            this._domElement.style.webkitUserSelect = 'none';
            this._domElement.addEventListener('pointerdown', onPointerDown);
            this._domElement.addEventListener('pointercancel', onPointerUp);
            this._domElement.addEventListener('wheel', onMouseWheel, { passive: false });
            this._domElement.addEventListener('contextmenu', onContextMenu);
        };
        this._removeAllEventListeners = () => {
            if (!this._domElement)
                return;
            this._domElement.style.touchAction = '';
            this._domElement.style.userSelect = '';
            this._domElement.style.webkitUserSelect = '';
            this._domElement.removeEventListener('pointerdown', onPointerDown);
            this._domElement.removeEventListener('pointercancel', onPointerUp);
            // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener#matching_event_listeners_for_removal
            // > it's probably wise to use the same values used for the call to `addEventListener()` when calling `removeEventListener()`
            // see https://github.com/microsoft/TypeScript/issues/32912#issuecomment-522142969
            // eslint-disable-next-line no-undef
            this._domElement.removeEventListener('wheel', onMouseWheel, { passive: false });
            this._domElement.removeEventListener('contextmenu', onContextMenu);
            // eslint-disable-next-line no-undef
            this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });
            this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
            this._domElement.ownerDocument.removeEventListener('pointerlockchange', onPointerLockChange);
            this._domElement.ownerDocument.removeEventListener('pointerlockerror', onPointerLockError);
        };
        this.cancel = () => {
            if (this._state === ACTION.NONE)
                return;
            this._state = ACTION.NONE;
            this._activePointers.length = 0;
            endDragging();
        };
        if (domElement)
            this.connect(domElement);
        this.update(0);
    }
    /**
     * The camera to be controlled
     * @category Properties
     */
    get camera() {
        return this._camera;
    }
    set camera(camera) {
        this._camera = camera;
        this.updateCameraUp();
        this._camera.updateProjectionMatrix();
        this._updateNearPlaneCorners();
        this._needsUpdate = true;
    }
    /**
     * Whether or not the controls are enabled.
     * `false` to disable user dragging/touch-move, but all methods works.
     * @category Properties
     */
    get enabled() {
        return this._enabled;
    }
    set enabled(enabled) {
        this._enabled = enabled;
        if (!this._domElement)
            return;
        if (enabled) {
            this._domElement.style.touchAction = 'none';
            this._domElement.style.userSelect = 'none';
            this._domElement.style.webkitUserSelect = 'none';
        }
        else {
            this.cancel();
            this._domElement.style.touchAction = '';
            this._domElement.style.userSelect = '';
            this._domElement.style.webkitUserSelect = '';
        }
    }
    /**
     * Returns `true` if the controls are active updating.
     * readonly value.
     * @category Properties
     */
    get active() {
        return !this._hasRested;
    }
    /**
     * Getter for the current `ACTION`.
     * readonly value.
     * @category Properties
     */
    get currentAction() {
        return this._state;
    }
    /**
     * get/set Current distance.
     * @category Properties
     */
    get distance() {
        return this._spherical.radius;
    }
    set distance(distance) {
        if (this._spherical.radius === distance &&
            this._sphericalEnd.radius === distance)
            return;
        this._spherical.radius = distance;
        this._sphericalEnd.radius = distance;
        this._needsUpdate = true;
    }
    // horizontal angle
    /**
     * get/set the azimuth angle (horizontal) in radians.
     * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
     * @category Properties
     */
    get azimuthAngle() {
        return this._spherical.theta;
    }
    set azimuthAngle(azimuthAngle) {
        if (this._spherical.theta === azimuthAngle &&
            this._sphericalEnd.theta === azimuthAngle)
            return;
        this._spherical.theta = azimuthAngle;
        this._sphericalEnd.theta = azimuthAngle;
        this._needsUpdate = true;
    }
    // vertical angle
    /**
     * get/set the polar angle (vertical) in radians.
     * @category Properties
     */
    get polarAngle() {
        return this._spherical.phi;
    }
    set polarAngle(polarAngle) {
        if (this._spherical.phi === polarAngle &&
            this._sphericalEnd.phi === polarAngle)
            return;
        this._spherical.phi = polarAngle;
        this._sphericalEnd.phi = polarAngle;
        this._needsUpdate = true;
    }
    /**
     * Whether camera position should be enclosed in the boundary or not.
     * @category Properties
     */
    get boundaryEnclosesCamera() {
        return this._boundaryEnclosesCamera;
    }
    set boundaryEnclosesCamera(boundaryEnclosesCamera) {
        this._boundaryEnclosesCamera = boundaryEnclosesCamera;
        this._needsUpdate = true;
    }
    /**
     * Set drag-start, touches and wheel enable area in the domElement.
     * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
     * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
     * @category Properties
     */
    set interactiveArea(interactiveArea) {
        this._interactiveArea.width = clamp(interactiveArea.width, 0, 1);
        this._interactiveArea.height = clamp(interactiveArea.height, 0, 1);
        this._interactiveArea.x = clamp(interactiveArea.x, 0, 1 - this._interactiveArea.width);
        this._interactiveArea.y = clamp(interactiveArea.y, 0, 1 - this._interactiveArea.height);
    }
    /**
     * Adds the specified event listener.
     * Applicable event types (which is `K`) are:
     * | Event name          | Timing |
     * | ------------------- | ------ |
     * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
     * | `'control'`         | When the user controls the camera (dragging). |
     * | `'controlend'`      | When the user ends to control the camera. ¹ |
     * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
     * | `'update'`          | When the camera position is updated. |
     * | `'wake'`            | When the camera starts moving. |
     * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
     * | `'sleep'`           | When the camera end moving. |
     *
     * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
     * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
     *
     * e.g.
     * ```
     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
     * ```
     * @param type event name
     * @param listener handler function
     * @category Methods
     */
    addEventListener(type, listener) {
        super.addEventListener(type, listener);
    }
    /**
     * Removes the specified event listener
     * e.g.
     * ```
     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
     * ```
     * @param type event name
     * @param listener handler function
     * @category Methods
     */
    removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
    }
    /**
     * Rotate azimuthal angle(horizontal) and polar angle(vertical).
     * Every value is added to the current value.
     * @param azimuthAngle Azimuth rotate angle. In radian.
     * @param polarAngle Polar rotate angle. In radian.
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    rotate(azimuthAngle, polarAngle, enableTransition = false) {
        return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
    }
    /**
     * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
     *
     * e.g.
     * ```
     * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
     * ```
     * @param azimuthAngle Azimuth rotate angle. In radian.
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    rotateAzimuthTo(azimuthAngle, enableTransition = false) {
        return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
    }
    /**
     * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
     *
     * e.g.
     * ```
     * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
     * ```
     * @param polarAngle Polar rotate angle. In radian.
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    rotatePolarTo(polarAngle, enableTransition = false) {
        return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
    }
    /**
     * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
     * Camera view will rotate over the orbit pivot absolutely:
     *
     * azimuthAngle
     * ```
     *       0º
     *         \
     * 90º -----+----- -90º
     *           \
     *           180º
     * ```
     * | direction | angle                  |
     * | --------- | ---------------------- |
     * | front     | 0º                     |
     * | left      | 90º (`Math.PI / 2`)    |
     * | right     | -90º (`- Math.PI / 2`) |
     * | back      | 180º (`Math.PI`)       |
     *
     * polarAngle
     * ```
     *     180º
     *      |
     *      90º
     *      |
     *      0º
     * ```
     * | direction            | angle                  |
     * | -------------------- | ---------------------- |
     * | top/sky              | 180º (`Math.PI`)       |
     * | horizontal from view | 90º (`Math.PI / 2`)    |
     * | bottom/floor         | 0º                     |
     *
     * @param azimuthAngle Azimuth rotate angle to. In radian.
     * @param polarAngle Polar rotate angle to. In radian.
     * @param enableTransition  Whether to move smoothly or immediately
     * @category Methods
     */
    rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
        this._isUserControllingRotate = false;
        const theta = clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
        const phi = clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);
        this._sphericalEnd.theta = theta;
        this._sphericalEnd.phi = phi;
        this._sphericalEnd.makeSafe();
        this._needsUpdate = true;
        if (!enableTransition) {
            this._spherical.theta = this._sphericalEnd.theta;
            this._spherical.phi = this._sphericalEnd.phi;
        }
        const resolveImmediately = !enableTransition ||
            approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&
                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
    }
    /**
     * Dolly in/out camera position.
     * @param distance Distance of dollyIn. Negative number for dollyOut.
     * @param enableTransition Whether to move smoothly or immediately.
     * @category Methods
     */
    dolly(distance, enableTransition = false) {
        return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
    }
    /**
     * Dolly in/out camera position to given distance.
     * @param distance Distance of dolly.
     * @param enableTransition Whether to move smoothly or immediately.
     * @category Methods
     */
    dollyTo(distance, enableTransition = false) {
        this._isUserControllingDolly = false;
        this._lastDollyDirection = DOLLY_DIRECTION.NONE;
        this._changedDolly = 0;
        return this._dollyToNoClamp(clamp(distance, this.minDistance, this.maxDistance), enableTransition);
    }
    _dollyToNoClamp(distance, enableTransition = false) {
        const lastRadius = this._sphericalEnd.radius;
        const hasCollider = this.colliderMeshes.length >= 1;
        if (hasCollider) {
            const maxDistanceByCollisionTest = this._collisionTest();
            const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
            const isDollyIn = lastRadius > distance;
            if (!isDollyIn && isCollided)
                return Promise.resolve();
            this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);
        }
        else {
            this._sphericalEnd.radius = distance;
        }
        this._needsUpdate = true;
        if (!enableTransition) {
            this._spherical.radius = this._sphericalEnd.radius;
        }
        const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
    }
    /**
     * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
     * Specify a negative value for dolly out.
     * @param distance Distance of dolly.
     * @param enableTransition Whether to move smoothly or immediately.
     * @category Methods
     */
    dollyInFixed(distance, enableTransition = false) {
        this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));
        if (!enableTransition) {
            this._target.copy(this._targetEnd);
        }
        const resolveImmediately = !enableTransition ||
            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&
                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&
                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
    }
    /**
     * Zoom in/out camera. The value is added to camera zoom.
     * Limits set with `.minZoom` and `.maxZoom`
     * @param zoomStep zoom scale
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    zoom(zoomStep, enableTransition = false) {
        return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
    }
    /**
     * Zoom in/out camera to given scale. The value overwrites camera zoom.
     * Limits set with .minZoom and .maxZoom
     * @param zoom
     * @param enableTransition
     * @category Methods
     */
    zoomTo(zoom, enableTransition = false) {
        this._isUserControllingZoom = false;
        this._zoomEnd = clamp(zoom, this.minZoom, this.maxZoom);
        this._needsUpdate = true;
        if (!enableTransition) {
            this._zoom = this._zoomEnd;
        }
        const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
        this._changedZoom = 0;
        return this._createOnRestPromise(resolveImmediately);
    }
    /**
     * @deprecated `pan()` has been renamed to `truck()`
     * @category Methods
     */
    pan(x, y, enableTransition = false) {
        console.warn('`pan` has been renamed to `truck`');
        return this.truck(x, y, enableTransition);
    }
    /**
     * Truck and pedestal camera using current azimuthal angle
     * @param x Horizontal translate amount
     * @param y Vertical translate amount
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    truck(x, y, enableTransition = false) {
        this._camera.updateMatrix();
        _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
        _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
        _xColumn.multiplyScalar(x);
        _yColumn.multiplyScalar(-y);
        const offset = _v3A.copy(_xColumn).add(_yColumn);
        const to = _v3B.copy(this._targetEnd).add(offset);
        return this.moveTo(to.x, to.y, to.z, enableTransition);
    }
    /**
     * Move forward / backward.
     * @param distance Amount to move forward / backward. Negative value to move backward
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    forward(distance, enableTransition = false) {
        _v3A.setFromMatrixColumn(this._camera.matrix, 0);
        _v3A.crossVectors(this._camera.up, _v3A);
        _v3A.multiplyScalar(distance);
        const to = _v3B.copy(this._targetEnd).add(_v3A);
        return this.moveTo(to.x, to.y, to.z, enableTransition);
    }
    /**
     * Move up / down.
     * @param height Amount to move up / down. Negative value to move down
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    elevate(height, enableTransition = false) {
        _v3A.copy(this._camera.up).multiplyScalar(height);
        return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);
    }
    /**
     * Move target position to given point.
     * @param x x coord to move center position
     * @param y y coord to move center position
     * @param z z coord to move center position
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    moveTo(x, y, z, enableTransition = false) {
        this._isUserControllingTruck = false;
        const offset = _v3A.set(x, y, z).sub(this._targetEnd);
        this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
        this._needsUpdate = true;
        if (!enableTransition) {
            this._target.copy(this._targetEnd);
        }
        const resolveImmediately = !enableTransition ||
            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&
                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&
                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
    }
    /**
     * Look in the given point direction.
     * @param x point x.
     * @param y point y.
     * @param z point z.
     * @param enableTransition Whether to move smoothly or immediately.
     * @returns Transition end promise
     * @category Methods
     */
    lookInDirectionOf(x, y, z, enableTransition = false) {
        const point = _v3A.set(x, y, z);
        const direction = point.sub(this._targetEnd).normalize();
        const position = direction.multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
        return this.setPosition(position.x, position.y, position.z, enableTransition);
    }
    /**
     * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
     * set `cover: true` to fill enter screen.
     * e.g.
     * ```
     * cameraControls.fitToBox( myMesh );
     * ```
     * @param box3OrObject Axis aligned bounding box to fit the view.
     * @param enableTransition Whether to move smoothly or immediately.
     * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
     * @returns Transition end promise
     * @category Methods
     */
    fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
        const promises = [];
        const aabb = box3OrObject.isBox3
            ? _box3A.copy(box3OrObject)
            : _box3A.setFromObject(box3OrObject);
        if (aabb.isEmpty()) {
            console.warn('camera-controls: fitTo() cannot be used with an empty box. Aborting');
            Promise.resolve();
        }
        // round to closest axis ( forward | backward | right | left | top | bottom )
        const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
        const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
        promises.push(this.rotateTo(theta, phi, enableTransition));
        const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
        const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
        const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
        if (viewFromPolar) {
            rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
        }
        rotation.multiply(this._yAxisUpSpaceInverse);
        // make oriented bounding box
        const bb = _box3B.makeEmpty();
        // left bottom back corner
        _v3B.copy(aabb.min).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        // right bottom back corner
        _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        // left top back corner
        _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        // right top back corner
        _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        // left bottom front corner
        _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        // right bottom front corner
        _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        // left top front corner
        _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        // right top front corner
        _v3B.copy(aabb.max).applyQuaternion(rotation);
        bb.expandByPoint(_v3B);
        // add padding
        bb.min.x -= paddingLeft;
        bb.min.y -= paddingBottom;
        bb.max.x += paddingRight;
        bb.max.y += paddingTop;
        rotation.setFromUnitVectors(_AXIS_Z, normal);
        if (viewFromPolar) {
            rotation.premultiply(_quaternionB.invert());
        }
        rotation.premultiply(this._yAxisUpSpace);
        const bbSize = bb.getSize(_v3A);
        const center = bb.getCenter(_v3B).applyQuaternion(rotation);
        if (isPerspectiveCamera(this._camera)) {
            const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);
            promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
            promises.push(this.dollyTo(distance, enableTransition));
            promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
        }
        else if (isOrthographicCamera(this._camera)) {
            const camera = this._camera;
            const width = camera.right - camera.left;
            const height = camera.top - camera.bottom;
            const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);
            promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
            promises.push(this.zoomTo(zoom, enableTransition));
            promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
        }
        return Promise.all(promises);
    }
    /**
     * Fit the viewport to the sphere or the bounding sphere of the object.
     * @param sphereOrMesh
     * @param enableTransition
     * @category Methods
     */
    fitToSphere(sphereOrMesh, enableTransition) {
        const promises = [];
        const isObject3D = 'isObject3D' in sphereOrMesh;
        const boundingSphere = isObject3D ?
            CameraControls.createBoundingSphere(sphereOrMesh, _sphere$1) :
            _sphere$1.copy(sphereOrMesh);
        promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
        if (isPerspectiveCamera(this._camera)) {
            const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
            promises.push(this.dollyTo(distanceToFit, enableTransition));
        }
        else if (isOrthographicCamera(this._camera)) {
            const width = this._camera.right - this._camera.left;
            const height = this._camera.top - this._camera.bottom;
            const diameter = 2 * boundingSphere.radius;
            const zoom = Math.min(width / diameter, height / diameter);
            promises.push(this.zoomTo(zoom, enableTransition));
        }
        promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
        return Promise.all(promises);
    }
    /**
     * Look at the `target` from the `position`.
     * @param positionX
     * @param positionY
     * @param positionZ
     * @param targetX
     * @param targetY
     * @param targetZ
     * @param enableTransition
     * @category Methods
     */
    setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
        this._isUserControllingRotate = false;
        this._isUserControllingDolly = false;
        this._isUserControllingTruck = false;
        this._lastDollyDirection = DOLLY_DIRECTION.NONE;
        this._changedDolly = 0;
        const target = _v3B.set(targetX, targetY, targetZ);
        const position = _v3A.set(positionX, positionY, positionZ);
        this._targetEnd.copy(target);
        this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));
        this.normalizeRotations();
        this._needsUpdate = true;
        if (!enableTransition) {
            this._target.copy(this._targetEnd);
            this._spherical.copy(this._sphericalEnd);
        }
        const resolveImmediately = !enableTransition ||
            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&
                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&
                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) &&
                approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&
                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&
                approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
    }
    /**
     * Similar to setLookAt, but it interpolates between two states.
     * @param positionAX
     * @param positionAY
     * @param positionAZ
     * @param targetAX
     * @param targetAY
     * @param targetAZ
     * @param positionBX
     * @param positionBY
     * @param positionBZ
     * @param targetBX
     * @param targetBY
     * @param targetBZ
     * @param t
     * @param enableTransition
     * @category Methods
     */
    lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {
        this._isUserControllingRotate = false;
        this._isUserControllingDolly = false;
        this._isUserControllingTruck = false;
        this._lastDollyDirection = DOLLY_DIRECTION.NONE;
        this._changedDolly = 0;
        const targetA = _v3A.set(targetAX, targetAY, targetAZ);
        const positionA = _v3B.set(positionAX, positionAY, positionAZ);
        _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
        const targetB = _v3C.set(targetBX, targetBY, targetBZ);
        const positionB = _v3B.set(positionBX, positionBY, positionBZ);
        _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
        this._targetEnd.copy(targetA.lerp(targetB, t)); // tricky
        const deltaTheta = _sphericalB.theta - _sphericalA.theta;
        const deltaPhi = _sphericalB.phi - _sphericalA.phi;
        const deltaRadius = _sphericalB.radius - _sphericalA.radius;
        this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);
        this.normalizeRotations();
        this._needsUpdate = true;
        if (!enableTransition) {
            this._target.copy(this._targetEnd);
            this._spherical.copy(this._sphericalEnd);
        }
        const resolveImmediately = !enableTransition ||
            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&
                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&
                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) &&
                approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&
                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&
                approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
    }
    /**
     * Set angle and distance by given position.
     * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
     * @param positionX
     * @param positionY
     * @param positionZ
     * @param enableTransition
     * @category Methods
     */
    setPosition(positionX, positionY, positionZ, enableTransition = false) {
        return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
    }
    /**
     * Set the target position where gaze at.
     * An alias of `setLookAt()`, without position change. Thus keep the same position.
     * @param targetX
     * @param targetY
     * @param targetZ
     * @param enableTransition
     * @category Methods
     */
    setTarget(targetX, targetY, targetZ, enableTransition = false) {
        const pos = this.getPosition(_v3A);
        const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
        // see https://github.com/yomotsu/camera-controls/issues/335
        this._sphericalEnd.phi = clamp(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);
        return promise;
    }
    /**
     * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
     * @param x
     * @param y
     * @param z
     * @param enableTransition
     * @category Methods
     */
    setFocalOffset(x, y, z, enableTransition = false) {
        this._isUserControllingOffset = false;
        this._focalOffsetEnd.set(x, y, z);
        this._needsUpdate = true;
        if (!enableTransition)
            this._focalOffset.copy(this._focalOffsetEnd);
        const resolveImmediately = !enableTransition ||
            approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) &&
                approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) &&
                approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
        return this._createOnRestPromise(resolveImmediately);
    }
    /**
     * Set orbit point without moving the camera.
     * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
     * @param targetX
     * @param targetY
     * @param targetZ
     * @category Methods
     */
    setOrbitPoint(targetX, targetY, targetZ) {
        this._camera.updateMatrixWorld();
        _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
        _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
        _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
        const position = _v3A.set(targetX, targetY, targetZ);
        const distance = position.distanceTo(this._camera.position);
        const cameraToPoint = position.sub(this._camera.position);
        _xColumn.multiplyScalar(cameraToPoint.x);
        _yColumn.multiplyScalar(cameraToPoint.y);
        _zColumn.multiplyScalar(cameraToPoint.z);
        _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
        _v3A.z = _v3A.z + distance;
        this.dollyTo(distance, false);
        this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
        this.moveTo(targetX, targetY, targetZ, false);
    }
    /**
     * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
     * @param box3
     * @category Methods
     */
    setBoundary(box3) {
        if (!box3) {
            this._boundary.min.set(-Infinity, -Infinity, -Infinity);
            this._boundary.max.set(Infinity, Infinity, Infinity);
            this._needsUpdate = true;
            return;
        }
        this._boundary.copy(box3);
        this._boundary.clampPoint(this._targetEnd, this._targetEnd);
        this._needsUpdate = true;
    }
    /**
     * Set (or unset) the current viewport.
     * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
     * @param viewportOrX
     * @param y
     * @param width
     * @param height
     * @category Methods
     */
    setViewport(viewportOrX, y, width, height) {
        if (viewportOrX === null) { // null
            this._viewport = null;
            return;
        }
        this._viewport = this._viewport || new THREE$1.Vector4();
        if (typeof viewportOrX === 'number') { // number
            this._viewport.set(viewportOrX, y, width, height);
        }
        else { // Vector4
            this._viewport.copy(viewportOrX);
        }
    }
    /**
     * Calculate the distance to fit the box.
     * @param width box width
     * @param height box height
     * @param depth box depth
     * @returns distance
     * @category Methods
     */
    getDistanceToFitBox(width, height, depth, cover = false) {
        if (notSupportedInOrthographicCamera(this._camera, 'getDistanceToFitBox'))
            return this._spherical.radius;
        const boundingRectAspect = width / height;
        const fov = this._camera.getEffectiveFOV() * DEG2RAD;
        const aspect = this._camera.aspect;
        const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;
        return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
    }
    /**
     * Calculate the distance to fit the sphere.
     * @param radius sphere radius
     * @returns distance
     * @category Methods
     */
    getDistanceToFitSphere(radius) {
        if (notSupportedInOrthographicCamera(this._camera, 'getDistanceToFitSphere'))
            return this._spherical.radius;
        // https://stackoverflow.com/a/44849975
        const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;
        const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
        const fov = 1 < this._camera.aspect ? vFOV : hFOV;
        return radius / (Math.sin(fov * 0.5));
    }
    /**
     * Returns the orbit center position, where the camera looking at.
     * @param out The receiving Vector3 instance to copy the result
     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
     * @category Methods
     */
    getTarget(out, receiveEndValue = true) {
        const _out = !!out && out.isVector3 ? out : new THREE$1.Vector3();
        return _out.copy(receiveEndValue ? this._targetEnd : this._target);
    }
    /**
     * Returns the camera position.
     * @param out The receiving Vector3 instance to copy the result
     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
     * @category Methods
     */
    getPosition(out, receiveEndValue = true) {
        const _out = !!out && out.isVector3 ? out : new THREE$1.Vector3();
        return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);
    }
    /**
     * Returns the spherical coordinates of the orbit.
     * @param out The receiving Spherical instance to copy the result
     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
     * @category Methods
     */
    getSpherical(out, receiveEndValue = true) {
        const _out = out || new THREE$1.Spherical();
        return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);
    }
    /**
     * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
     * @param out The receiving Vector3 instance to copy the result
     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
     * @category Methods
     */
    getFocalOffset(out, receiveEndValue = true) {
        const _out = !!out && out.isVector3 ? out : new THREE$1.Vector3();
        return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);
    }
    /**
     * Normalize camera azimuth angle rotation between 0 and 360 degrees.
     * @category Methods
     */
    normalizeRotations() {
        this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
        if (this._sphericalEnd.theta < 0)
            this._sphericalEnd.theta += PI_2;
        this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
    }
    /**
     * stop all transitions.
     */
    stop() {
        this._focalOffset.copy(this._focalOffsetEnd);
        this._target.copy(this._targetEnd);
        this._spherical.copy(this._sphericalEnd);
        this._zoom = this._zoomEnd;
    }
    /**
     * Reset all rotation and position to defaults.
     * @param enableTransition
     * @category Methods
     */
    reset(enableTransition = false) {
        if (!approxEquals(this._camera.up.x, this._cameraUp0.x) ||
            !approxEquals(this._camera.up.y, this._cameraUp0.y) ||
            !approxEquals(this._camera.up.z, this._cameraUp0.z)) {
            this._camera.up.copy(this._cameraUp0);
            const position = this.getPosition(_v3A);
            this.updateCameraUp();
            this.setPosition(position.x, position.y, position.z);
        }
        const promises = [
            this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
            this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
            this.zoomTo(this._zoom0, enableTransition),
        ];
        return Promise.all(promises);
    }
    /**
     * Set current camera position as the default position.
     * @category Methods
     */
    saveState() {
        this._cameraUp0.copy(this._camera.up);
        this.getTarget(this._target0);
        this.getPosition(this._position0);
        this._zoom0 = this._zoom;
        this._focalOffset0.copy(this._focalOffset);
    }
    /**
     * Sync camera-up direction.
     * When camera-up vector is changed, `.updateCameraUp()` must be called.
     * @category Methods
     */
    updateCameraUp() {
        this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
        this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
    }
    /**
     * Apply current camera-up direction to the camera.
     * The orbit system will be re-initialized with the current position.
     * @category Methods
     */
    applyCameraUp() {
        const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();
        // So first find the vector off to the side, orthogonal to both this.object.up and
        // the "view" vector.
        const side = _v3B.crossVectors(cameraDirection, this._camera.up);
        // Then find the vector orthogonal to both this "side" vector and the "view" vector.
        // This vector will be the new "up" vector.
        this._camera.up.crossVectors(side, cameraDirection).normalize();
        this._camera.updateMatrixWorld();
        const position = this.getPosition(_v3A);
        this.updateCameraUp();
        this.setPosition(position.x, position.y, position.z);
    }
    /**
     * Update camera position and directions.
     * This should be called in your tick loop every time, and returns true if re-rendering is needed.
     * @param delta
     * @returns updated
     * @category Methods
     */
    update(delta) {
        const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
        const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
        const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
        const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
        const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
        const deltaZoom = this._zoomEnd - this._zoom;
        // update theta
        if (approxZero(deltaTheta)) {
            this._thetaVelocity.value = 0;
            this._spherical.theta = this._sphericalEnd.theta;
        }
        else {
            const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
            this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);
            this._needsUpdate = true;
        }
        // update phi
        if (approxZero(deltaPhi)) {
            this._phiVelocity.value = 0;
            this._spherical.phi = this._sphericalEnd.phi;
        }
        else {
            const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
            this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);
            this._needsUpdate = true;
        }
        // update distance
        if (approxZero(deltaRadius)) {
            this._radiusVelocity.value = 0;
            this._spherical.radius = this._sphericalEnd.radius;
        }
        else {
            const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
            this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);
            this._needsUpdate = true;
        }
        // update target position
        if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {
            this._targetVelocity.set(0, 0, 0);
            this._target.copy(this._targetEnd);
        }
        else {
            const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
            smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);
            this._needsUpdate = true;
        }
        // update focalOffset
        if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {
            this._focalOffsetVelocity.set(0, 0, 0);
            this._focalOffset.copy(this._focalOffsetEnd);
        }
        else {
            const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
            smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);
            this._needsUpdate = true;
        }
        // update zoom
        if (approxZero(deltaZoom)) {
            this._zoomVelocity.value = 0;
            this._zoom = this._zoomEnd;
        }
        else {
            const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
            this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);
        }
        if (this.dollyToCursor) {
            if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {
                const dollyControlAmount = this._spherical.radius - this._lastDistance;
                const camera = this._camera;
                const cameraDirection = this._getCameraDirection(_cameraDirection);
                const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();
                if (planeX.lengthSq() === 0)
                    planeX.x = 1.0;
                const planeY = _v3B.crossVectors(planeX, cameraDirection);
                const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);
                const prevRadius = this._sphericalEnd.radius - dollyControlAmount;
                const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
                const cursor = _v3C.copy(this._targetEnd)
                    .add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect))
                    .add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
                const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
                const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;
                const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;
                if (this.infinityDolly && (isMin || isMax)) {
                    this._sphericalEnd.radius -= dollyControlAmount;
                    this._spherical.radius -= dollyControlAmount;
                    const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);
                    newTargetEnd.add(dollyAmount);
                }
                // target position may be moved beyond boundary.
                this._boundary.clampPoint(newTargetEnd, newTargetEnd);
                const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
                this._targetEnd.copy(newTargetEnd);
                this._target.add(targetEndDiff);
                this._changedDolly -= dollyControlAmount;
                if (approxZero(this._changedDolly))
                    this._changedDolly = 0;
            }
            else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {
                const dollyControlAmount = this._zoom - this._lastZoom;
                const camera = this._camera;
                const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
                const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
                const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
                const prevZoom = this._zoom - dollyControlAmount;
                const lerpRatio = -(prevZoom - this._zoom) / this._zoom;
                // find the "distance" (aka plane constant in three.js) of Plane
                // from a given position (this._targetEnd) and normal vector (cameraDirection)
                // https://www.maplesoft.com/support/help/maple/view.aspx?path=MathApps%2FEquationOfAPlaneNormal#bkmrk0
                const cameraDirection = this._getCameraDirection(_cameraDirection);
                const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
                const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
                const newPlaneConstant = newTargetEnd.dot(cameraDirection);
                // Pull back the camera depth that has moved, to be the camera stationary as zoom
                const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
                newTargetEnd.sub(pullBack);
                // target position may be moved beyond boundary.
                this._boundary.clampPoint(newTargetEnd, newTargetEnd);
                const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
                this._targetEnd.copy(newTargetEnd);
                this._target.add(targetEndDiff);
                // this._target.copy( this._targetEnd );
                this._changedZoom -= dollyControlAmount;
                if (approxZero(this._changedZoom))
                    this._changedZoom = 0;
            }
        }
        if (this._camera.zoom !== this._zoom) {
            this._camera.zoom = this._zoom;
            this._camera.updateProjectionMatrix();
            this._updateNearPlaneCorners();
            this._needsUpdate = true;
        }
        this._dragNeedsUpdate = true;
        // collision detection
        const maxDistance = this._collisionTest();
        this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
        // decompose spherical to the camera position
        this._spherical.makeSafe();
        this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
        this._camera.lookAt(this._target);
        // set offset after the orbit movement
        const affectOffset = !approxZero(this._focalOffset.x) ||
            !approxZero(this._focalOffset.y) ||
            !approxZero(this._focalOffset.z);
        if (affectOffset) {
            _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
            _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
            _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
            _xColumn.multiplyScalar(this._focalOffset.x);
            _yColumn.multiplyScalar(-this._focalOffset.y);
            _zColumn.multiplyScalar(this._focalOffset.z); // notice: z-offset will not affect in Orthographic.
            _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
            this._camera.position.add(_v3A);
            this._camera.updateMatrixWorld();
        }
        if (this._boundaryEnclosesCamera) {
            this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1.0);
        }
        const updated = this._needsUpdate;
        if (updated && !this._updatedLastTime) {
            this._hasRested = false;
            this.dispatchEvent({ type: 'wake' });
            this.dispatchEvent({ type: 'update' });
        }
        else if (updated) {
            this.dispatchEvent({ type: 'update' });
            if (approxZero(deltaTheta, this.restThreshold) &&
                approxZero(deltaPhi, this.restThreshold) &&
                approxZero(deltaRadius, this.restThreshold) &&
                approxZero(deltaTarget.x, this.restThreshold) &&
                approxZero(deltaTarget.y, this.restThreshold) &&
                approxZero(deltaTarget.z, this.restThreshold) &&
                approxZero(deltaOffset.x, this.restThreshold) &&
                approxZero(deltaOffset.y, this.restThreshold) &&
                approxZero(deltaOffset.z, this.restThreshold) &&
                approxZero(deltaZoom, this.restThreshold) &&
                !this._hasRested) {
                this._hasRested = true;
                this.dispatchEvent({ type: 'rest' });
            }
        }
        else if (!updated && this._updatedLastTime) {
            this.dispatchEvent({ type: 'sleep' });
        }
        this._lastDistance = this._spherical.radius;
        this._lastZoom = this._zoom;
        this._updatedLastTime = updated;
        this._needsUpdate = false;
        return updated;
    }
    /**
     * Get all state in JSON string
     * @category Methods
     */
    toJSON() {
        return JSON.stringify({
            enabled: this._enabled,
            minDistance: this.minDistance,
            maxDistance: infinityToMaxNumber(this.maxDistance),
            minZoom: this.minZoom,
            maxZoom: infinityToMaxNumber(this.maxZoom),
            minPolarAngle: this.minPolarAngle,
            maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
            minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
            maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
            smoothTime: this.smoothTime,
            draggingSmoothTime: this.draggingSmoothTime,
            dollySpeed: this.dollySpeed,
            truckSpeed: this.truckSpeed,
            dollyToCursor: this.dollyToCursor,
            target: this._targetEnd.toArray(),
            position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
            zoom: this._zoomEnd,
            focalOffset: this._focalOffsetEnd.toArray(),
            target0: this._target0.toArray(),
            position0: this._position0.toArray(),
            zoom0: this._zoom0,
            focalOffset0: this._focalOffset0.toArray(),
        });
    }
    /**
     * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
     * @param json
     * @param enableTransition
     * @category Methods
     */
    fromJSON(json, enableTransition = false) {
        const obj = JSON.parse(json);
        this.enabled = obj.enabled;
        this.minDistance = obj.minDistance;
        this.maxDistance = maxNumberToInfinity(obj.maxDistance);
        this.minZoom = obj.minZoom;
        this.maxZoom = maxNumberToInfinity(obj.maxZoom);
        this.minPolarAngle = obj.minPolarAngle;
        this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
        this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
        this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
        this.smoothTime = obj.smoothTime;
        this.draggingSmoothTime = obj.draggingSmoothTime;
        this.dollySpeed = obj.dollySpeed;
        this.truckSpeed = obj.truckSpeed;
        this.dollyToCursor = obj.dollyToCursor;
        this._target0.fromArray(obj.target0);
        this._position0.fromArray(obj.position0);
        this._zoom0 = obj.zoom0;
        this._focalOffset0.fromArray(obj.focalOffset0);
        this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
        _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
        this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
        this.dollyTo(_sphericalA.radius, enableTransition);
        this.zoomTo(obj.zoom, enableTransition);
        this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
        this._needsUpdate = true;
    }
    /**
     * Attach all internal event handlers to enable drag control.
     * @category Methods
     */
    connect(domElement) {
        if (this._domElement) {
            console.warn('camera-controls is already connected.');
            return;
        }
        domElement.setAttribute('data-camera-controls-version', VERSION);
        this._addAllEventListeners(domElement);
        this._getClientRect(this._elementRect);
    }
    /**
     * Detach all internal event handlers to disable drag control.
     */
    disconnect() {
        this.cancel();
        this._removeAllEventListeners();
        if (this._domElement) {
            this._domElement.removeAttribute('data-camera-controls-version');
            this._domElement = undefined;
        }
    }
    /**
     * Dispose the cameraControls instance itself, remove all eventListeners.
     * @category Methods
     */
    dispose() {
        // remove all user event listeners
        this.removeAllEventListeners();
        // remove all internal event listeners
        this.disconnect();
    }
    // it's okay to expose public though
    _getTargetDirection(out) {
        // divide by distance to normalize, lighter than `Vector3.prototype.normalize()`
        return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
    }
    // it's okay to expose public though
    _getCameraDirection(out) {
        return this._getTargetDirection(out).negate();
    }
    _findPointerById(pointerId) {
        return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);
    }
    _findPointerByMouseButton(mouseButton) {
        return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);
    }
    _disposePointer(pointer) {
        this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
    }
    _encloseToBoundary(position, offset, friction) {
        const offsetLength2 = offset.lengthSq();
        if (offsetLength2 === 0.0) { // sanity check
            return position;
        }
        // See: https://twitter.com/FMS_Cat/status/1106508958640988161
        const newTarget = _v3B.copy(offset).add(position); // target
        const clampedTarget = this._boundary.clampPoint(newTarget, _v3C); // clamped target
        const deltaClampedTarget = clampedTarget.sub(newTarget); // newTarget -> clampedTarget
        const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq(); // squared length of deltaClampedTarget
        if (deltaClampedTargetLength2 === 0.0) { // when the position doesn't have to be clamped
            return position.add(offset);
        }
        else if (deltaClampedTargetLength2 === offsetLength2) { // when the position is completely stuck
            return position;
        }
        else if (friction === 0.0) {
            return position.add(offset).add(deltaClampedTarget);
        }
        else {
            const offsetFactor = 1.0 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
            return position
                .add(_v3B.copy(offset).multiplyScalar(offsetFactor))
                .add(deltaClampedTarget.multiplyScalar(1.0 - friction));
        }
    }
    _updateNearPlaneCorners() {
        if (isPerspectiveCamera(this._camera)) {
            const camera = this._camera;
            const near = camera.near;
            const fov = camera.getEffectiveFOV() * DEG2RAD;
            const heightHalf = Math.tan(fov * 0.5) * near; // near plain half height
            const widthHalf = heightHalf * camera.aspect; // near plain half width
            this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
            this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
            this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
            this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
        }
        else if (isOrthographicCamera(this._camera)) {
            const camera = this._camera;
            const zoomInv = 1 / camera.zoom;
            const left = camera.left * zoomInv;
            const right = camera.right * zoomInv;
            const top = camera.top * zoomInv;
            const bottom = camera.bottom * zoomInv;
            this._nearPlaneCorners[0].set(left, top, 0);
            this._nearPlaneCorners[1].set(right, top, 0);
            this._nearPlaneCorners[2].set(right, bottom, 0);
            this._nearPlaneCorners[3].set(left, bottom, 0);
        }
    }
    // lateUpdate
    _collisionTest() {
        let distance = Infinity;
        const hasCollider = this.colliderMeshes.length >= 1;
        if (!hasCollider)
            return distance;
        if (notSupportedInOrthographicCamera(this._camera, '_collisionTest'))
            return distance;
        const rayDirection = this._getTargetDirection(_cameraDirection);
        _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);
        for (let i = 0; i < 4; i++) {
            const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);
            nearPlaneCorner.applyMatrix4(_rotationMatrix);
            const origin = _v3C.addVectors(this._target, nearPlaneCorner);
            _raycaster.set(origin, rayDirection);
            _raycaster.far = this._spherical.radius + 1;
            const intersects = _raycaster.intersectObjects(this.colliderMeshes);
            if (intersects.length !== 0 && intersects[0].distance < distance) {
                distance = intersects[0].distance;
            }
        }
        return distance;
    }
    /**
     * Get its client rect and package into given `DOMRect` .
     */
    _getClientRect(target) {
        if (!this._domElement)
            return;
        const rect = this._domElement.getBoundingClientRect();
        target.x = rect.left;
        target.y = rect.top;
        if (this._viewport) {
            target.x += this._viewport.x;
            target.y += rect.height - this._viewport.w - this._viewport.y;
            target.width = this._viewport.z;
            target.height = this._viewport.w;
        }
        else {
            target.width = rect.width;
            target.height = rect.height;
        }
        return target;
    }
    _createOnRestPromise(resolveImmediately) {
        if (resolveImmediately)
            return Promise.resolve();
        this._hasRested = false;
        this.dispatchEvent({ type: 'transitionstart' });
        return new Promise((resolve) => {
            const onResolve = () => {
                this.removeEventListener('rest', onResolve);
                resolve();
            };
            this.addEventListener('rest', onResolve);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _addAllEventListeners(_domElement) { }
    _removeAllEventListeners() { }
    /**
     * backward compatible
     * @deprecated use smoothTime (in seconds) instead
     * @category Properties
     */
    get dampingFactor() {
        console.warn('.dampingFactor has been deprecated. use smoothTime (in seconds) instead.');
        return 0;
    }
    /**
     * backward compatible
     * @deprecated use smoothTime (in seconds) instead
     * @category Properties
     */
    set dampingFactor(_) {
        console.warn('.dampingFactor has been deprecated. use smoothTime (in seconds) instead.');
    }
    /**
     * backward compatible
     * @deprecated use draggingSmoothTime (in seconds) instead
     * @category Properties
     */
    get draggingDampingFactor() {
        console.warn('.draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.');
        return 0;
    }
    /**
     * backward compatible
     * @deprecated use draggingSmoothTime (in seconds) instead
     * @category Properties
     */
    set draggingDampingFactor(_) {
        console.warn('.draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.');
    }
    static createBoundingSphere(object3d, out = new THREE$1.Sphere()) {
        const boundingSphere = out;
        const center = boundingSphere.center;
        _box3A.makeEmpty();
        // find the center
        object3d.traverseVisible((object) => {
            if (!object.isMesh)
                return;
            _box3A.expandByObject(object);
        });
        _box3A.getCenter(center);
        // find the radius
        let maxRadiusSq = 0;
        object3d.traverseVisible((object) => {
            if (!object.isMesh)
                return;
            const mesh = object;
            if (!mesh.geometry)
                return;
            const geometry = mesh.geometry.clone();
            geometry.applyMatrix4(mesh.matrixWorld);
            const bufferGeometry = geometry;
            const position = bufferGeometry.attributes.position;
            for (let i = 0, l = position.count; i < l; i++) {
                _v3A.fromBufferAttribute(position, i);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
            }
        });
        boundingSphere.radius = Math.sqrt(maxRadiusSq);
        return boundingSphere;
    }
}

var __defProp$t = Object.defineProperty;
var __defNormalProp$t = (obj, key, value) => key in obj ? __defProp$t(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$t = (obj, key, value) => __defNormalProp$t(obj, typeof key !== "symbol" ? key + "" : key, value);
CameraControls.install({ THREE: THREE$2 });
var ECameraViewType = /* @__PURE__ */ ((ECameraViewType2) => {
  ECameraViewType2["PerspectiveView"] = "PerspectiveView";
  ECameraViewType2["Top"] = "top";
  ECameraViewType2["Bottom"] = "bottom";
  ECameraViewType2["Left"] = "left";
  ECameraViewType2["Right"] = "right";
  ECameraViewType2["Back"] = "back";
  ECameraViewType2["Front"] = "front";
  return ECameraViewType2;
})(ECameraViewType || {});
var ECameraType = /* @__PURE__ */ ((ECameraType2) => {
  ECameraType2["PerspectiveCamera"] = "PerspectiveCamera";
  ECameraType2["OrthographicCamera"] = "OrthographicCamera";
  return ECameraType2;
})(ECameraType || {});
const DEG90 = Math.PI * 0.5;
const DEG180 = Math.PI;
class CameraManager {
  /**
   * 构造函数初始化cameraManager实例。
   * @param options - 包含viewer实例的选项对象。
   */
  constructor(options) {
    __publicField$t(this, "options");
    __publicField$t(this, "viewer");
    __publicField$t(this, "cameraType", "PerspectiveCamera" /* PerspectiveCamera */);
    __publicField$t(this, "perspectiveCamera");
    __publicField$t(this, "orthographicCamera");
    __publicField$t(this, "perspectiveCameraControls");
    __publicField$t(this, "orthographicCameraControls");
    __publicField$t(this, "width");
    __publicField$t(this, "height");
    this.options = deepMergeRetain$1(options, {});
    this.viewer = this.options.viewer;
    let defaultWebGLRenderer = this.viewer.renderManager.defaultWebGLRenderer;
    let { width, height } = this.viewer.getSize();
    this.width = width;
    this.height = height;
    this.perspectiveCamera = new THREE$2.PerspectiveCamera(60, width / height, 0.01, 18e3);
    this.perspectiveCameraControls = new CameraControls(this.perspectiveCamera, defaultWebGLRenderer.domElement);
    this.orthographicCamera = new OrthographicCamera(
      width / -2,
      width / 2,
      height / 2,
      height / -2,
      0.01,
      18e3
    );
    this.orthographicCameraControls = new CameraControls(this.orthographicCamera, defaultWebGLRenderer.domElement);
    this.cameraControls.maxDistance = 99999;
    this.cameraControls.minDistance = -99999;
    window.test11 = () => {
      this.toJSON();
    };
    this.cameraControls.setPosition(5, 5, 5).then();
    this.cameraControls.setTarget(0, 0, 0).then();
  }
  toJSON() {
    const perspectiveCameraControlsJson = JSON.parse(this.perspectiveCameraControls.toJSON());
    const perspectiveCameraJson = this.perspectiveCamera.toJSON();
    console.log(perspectiveCameraControlsJson);
    console.log(perspectiveCameraJson);
    return {
      perspectiveCameraControls: perspectiveCameraControlsJson,
      perspectiveCamera: perspectiveCameraJson
    };
  }
  /**
   * 还原控制器
   */
  async fromJSON(json) {
    const asset = new Asset({
      result: json.perspectiveCamera,
      extension: "object"
    });
    const object = await this.viewer.assetManager.loadObject(asset);
    this.perspectiveCameraControls.camera.copy(object);
    this.perspectiveCameraControls.fromJSON(JSON.stringify(json.perspectiveCameraControls), false);
  }
  test() {
    console.log(JSON.parse(this.cameraControls.toJSON()));
    console.log("azimuthAngle", THREE$2.MathUtils.radToDeg(this.cameraControls.azimuthAngle));
    console.log("polarAngle", THREE$2.MathUtils.radToDeg(this.cameraControls.polarAngle));
  }
  get cameraControls() {
    return this.cameraType === "PerspectiveCamera" /* PerspectiveCamera */ ? this.perspectiveCameraControls : this.orthographicCameraControls;
  }
  get target() {
    return this.cameraControls.getTarget(new THREE$2.Vector3());
  }
  get position() {
    return this.cameraControls.getPosition(new THREE$2.Vector3());
  }
  get camera() {
    return this.cameraType === "PerspectiveCamera" /* PerspectiveCamera */ ? this.perspectiveCamera : this.orthographicCamera;
  }
  /**
   * 设置视图尺寸，并相应地调整摄像机的方面比例。
   * @param width - 视图宽度。
   * @param height - 视图高度。
   * @param updateStyle - 是否更新DOM元素的样式（可选）。
   */
  setSize(width, height, updateStyle) {
    this.width = width;
    this.height = height;
    this.perspectiveCamera.aspect = width / height;
    this.perspectiveCamera.updateProjectionMatrix();
    this.orthographicCamera.left = -width / 2;
    this.orthographicCamera.right = width / 2;
    this.orthographicCamera.top = height / 2;
    this.orthographicCamera.bottom = -height / 2;
    this.orthographicCamera.updateProjectionMatrix();
  }
  /**
   * 设置不同的视图模式
   * @param cameraViewType
   */
  setCameraViewType(cameraViewType) {
    switch (cameraViewType) {
      case "PerspectiveView" /* PerspectiveView */:
        this.setPerspectiveView();
        break;
      case "top" /* Top */:
        this.resetViewLimits();
        this.setTopView();
        break;
      case "bottom" /* Bottom */:
        this.resetViewLimits();
        this.setBottomView();
        break;
      case "left" /* Left */:
        this.resetViewLimits();
        this.setLeftView();
        break;
      case "right" /* Right */:
        this.resetViewLimits();
        this.setRightView();
        break;
      case "back" /* Back */:
        this.resetViewLimits();
        this.setBackView();
        break;
      case "front" /* Front */:
        this.resetViewLimits();
        this.setFrontView();
        break;
      default:
        throw new Error(`\u672A\u77E5\u7684\u89C6\u56FE\u7C7B\u578B: ${cameraViewType}`);
    }
  }
  /**
   * 重置视图限制
   */
  resetViewLimits() {
    this.cameraControls.minAzimuthAngle = -Infinity;
    this.cameraControls.maxAzimuthAngle = Infinity;
    this.cameraControls.minPolarAngle = -Infinity;
    this.cameraControls.maxPolarAngle = Infinity;
  }
  /**
   * 设置透视视图
   */
  setPerspectiveView() {
    this.resetViewLimits();
  }
  /**
   * 设置顶视图
   */
  setTopView() {
    this.cameraControls.rotateTo(0, 0, false).then();
    this.cameraControls.minAzimuthAngle = 0;
    this.cameraControls.maxAzimuthAngle = 0;
    this.cameraControls.minPolarAngle = 0;
    this.cameraControls.maxPolarAngle = 0;
  }
  /**
   * 设置底视图
   */
  setBottomView() {
    this.cameraControls.rotateTo(0, DEG180, false).then();
    this.cameraControls.minAzimuthAngle = 0;
    this.cameraControls.maxAzimuthAngle = 0;
    this.cameraControls.minPolarAngle = DEG180;
    this.cameraControls.maxPolarAngle = DEG180;
  }
  /**
   * 设置左视图
   */
  setLeftView() {
    this.cameraControls.rotateTo(-DEG90, DEG90, false).then();
    this.cameraControls.minAzimuthAngle = -DEG90;
    this.cameraControls.maxAzimuthAngle = -DEG90;
    this.cameraControls.minPolarAngle = DEG90;
    this.cameraControls.maxPolarAngle = DEG90;
  }
  /**
   * 设置右视图
   */
  setRightView() {
    this.cameraControls.rotateTo(DEG90, DEG90, false).then();
    this.cameraControls.minAzimuthAngle = DEG90;
    this.cameraControls.maxAzimuthAngle = DEG90;
    this.cameraControls.minPolarAngle = DEG90;
    this.cameraControls.maxPolarAngle = DEG90;
  }
  /**
   * 设置后视图
   */
  setBackView() {
    this.cameraControls.rotateTo(DEG180, DEG90, false).then();
    this.cameraControls.minAzimuthAngle = DEG180;
    this.cameraControls.maxAzimuthAngle = DEG180;
    this.cameraControls.minPolarAngle = DEG90;
    this.cameraControls.maxPolarAngle = DEG90;
  }
  /**
   * 设置前视图
   */
  setFrontView() {
    this.cameraControls.rotateTo(0, DEG90, false).then();
    this.cameraControls.minAzimuthAngle = 0;
    this.cameraControls.maxAzimuthAngle = 0;
    this.cameraControls.minPolarAngle = DEG90;
    this.cameraControls.maxPolarAngle = DEG90;
  }
  /**
   * 同步控制器属性
   */
  syncView() {
    const targetControls = this.cameraType === "PerspectiveCamera" /* PerspectiveCamera */ ? this.orthographicCameraControls : this.perspectiveCameraControls;
    targetControls.minAzimuthAngle = this.cameraControls.minAzimuthAngle;
    targetControls.maxAzimuthAngle = this.cameraControls.maxAzimuthAngle;
    targetControls.minPolarAngle = this.cameraControls.minPolarAngle;
    targetControls.maxPolarAngle = this.cameraControls.maxPolarAngle;
  }
  /**
   * 设置视图类型
   * @param type
   */
  setCameraType(type = "PerspectiveCamera" /* PerspectiveCamera */) {
    if (this.cameraType === type) return this;
    const target = this.target;
    const position = this.position;
    this.syncView();
    if (type === "PerspectiveCamera" /* PerspectiveCamera */) {
      this.perspectiveCameraControls.setLookAt(position.x, position.y, position.z, target.x, target.y, target.z, false).then();
    } else if (type === "OrthographicCamera" /* OrthographicCamera */) {
      const fov = this.perspectiveCamera.fov;
      this.perspectiveCamera.far;
      const depth = Math.tan(fov / 2 * DEG180 / 180) * 2;
      const z = position.distanceTo(target);
      const y = depth * z;
      const x = y * this.perspectiveCamera.aspect;
      this.orthographicCamera.left = -x / 2;
      this.orthographicCamera.right = x / 2;
      this.orthographicCamera.top = y / 2;
      this.orthographicCamera.bottom = -y / 2;
      this.orthographicCamera.zoom = 1;
      this.orthographicCameraControls.setLookAt(
        position.x,
        position.y,
        position.z,
        target.x,
        target.y,
        target.z,
        false
      ).then();
    }
    this.cameraType = type;
  }
  //--------------------- 聚焦相关-----------------------
  // 聚焦到场景
  async fitToSceneByBox(enableTransition = true) {
    const boundingBox = Tool$1.getSceneBox(this.viewer.scene);
    await this.cameraControls.fitToBox(boundingBox, enableTransition);
  }
  // 聚焦到场景
  async fitToSceneBySphere(enableTransition = true) {
    const sphere = Tool$1.getSceneSphere(this.viewer.scene);
    await this.cameraControls.fitToSphere(sphere, enableTransition);
  }
  async fitToMeshBySphere(objects, enableTransition = true) {
    const sphere = Tool$1.getSphereByObject3ds(objects);
    await this.cameraControls.fitToSphere(sphere, enableTransition);
  }
  async fitToMeshByBox3(objects, enableTransition = true) {
    const box3 = Tool$1.getBox3ByObject3ds(objects);
    await this.cameraControls.fitToBox(box3, enableTransition);
  }
  async fitToMeshByBox(box3OrObject, enableTransition) {
    await this.cameraControls.fitToBox(box3OrObject, enableTransition);
  }
}

class Measure extends Component {
  constructor(options) {
    super(options);
  }
  onAddPointEvent(value) {
  }
  onMoveEvent(value) {
  }
  onEndEvent(value) {
  }
}

UniformsLib.line = {

	worldUnits: { value: 1 },
	linewidth: { value: 1 },
	resolution: { value: new Vector2( 1, 1 ) },
	dashOffset: { value: 0 },
	dashScale: { value: 1 },
	dashSize: { value: 1 },
	gapSize: { value: 1 } // todo FIX - maybe change to totalSize

};

ShaderLib[ 'line' ] = {

	uniforms: UniformsUtils.merge( [
		UniformsLib.common,
		UniformsLib.fog,
		UniformsLib.line
	] ),

	vertexShader:
	/* glsl */`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,

	fragmentShader:
	/* glsl */`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};

class LineMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super( {

			type: 'LineMaterial',
			uniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),

			vertexShader: ShaderLib[ 'line' ].vertexShader,
			fragmentShader: ShaderLib[ 'line' ].fragmentShader,

			clipping: true // required for clipping support

		} );

		this.isLineMaterial = true;

		this.setValues( parameters );

	}

	get color() {

		return this.uniforms.diffuse.value;

	}

	set color( value ) {

		this.uniforms.diffuse.value = value;

	}

	get worldUnits() {

		return 'WORLD_UNITS' in this.defines;

	}

	set worldUnits( value ) {

		if ( value === true ) {

			this.defines.WORLD_UNITS = '';

		} else {

			delete this.defines.WORLD_UNITS;

		}

	}

	get linewidth() {

		return this.uniforms.linewidth.value;

	}

	set linewidth( value ) {

		if ( ! this.uniforms.linewidth ) return;
		this.uniforms.linewidth.value = value;

	}

	get dashed() {

		return 'USE_DASH' in this.defines;

	}

	set dashed( value ) {

		if ( ( value === true ) !== this.dashed ) {

			this.needsUpdate = true;

		}

		if ( value === true ) {

			this.defines.USE_DASH = '';

		} else {

			delete this.defines.USE_DASH;

		}

	}

	get dashScale() {

		return this.uniforms.dashScale.value;

	}

	set dashScale( value ) {

		this.uniforms.dashScale.value = value;

	}

	get dashSize() {

		return this.uniforms.dashSize.value;

	}

	set dashSize( value ) {

		this.uniforms.dashSize.value = value;

	}

	get dashOffset() {

		return this.uniforms.dashOffset.value;

	}

	set dashOffset( value ) {

		this.uniforms.dashOffset.value = value;

	}

	get gapSize() {

		return this.uniforms.gapSize.value;

	}

	set gapSize( value ) {

		this.uniforms.gapSize.value = value;

	}

	get opacity() {

		return this.uniforms.opacity.value;

	}

	set opacity( value ) {

		if ( ! this.uniforms ) return;
		this.uniforms.opacity.value = value;

	}

	get resolution() {

		return this.uniforms.resolution.value;

	}

	set resolution( value ) {

		this.uniforms.resolution.value.copy( value );

	}

	get alphaToCoverage() {

		return 'USE_ALPHA_TO_COVERAGE' in this.defines;

	}

	set alphaToCoverage( value ) {

		if ( ! this.defines ) return;

		if ( ( value === true ) !== this.alphaToCoverage ) {

			this.needsUpdate = true;

		}

		if ( value === true ) {

			this.defines.USE_ALPHA_TO_COVERAGE = '';

		} else {

			delete this.defines.USE_ALPHA_TO_COVERAGE;

		}

	}

}

const _box$1 = new Box3();
const _vector = new Vector3();

class LineSegmentsGeometry extends InstancedBufferGeometry {

	constructor() {

		super();

		this.isLineSegmentsGeometry = true;

		this.type = 'LineSegmentsGeometry';

		const positions = [ -1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0 ];
		const uvs = [ -1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2 ];
		const index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];

		this.setIndex( index );
		this.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	applyMatrix4( matrix ) {

		const start = this.attributes.instanceStart;
		const end = this.attributes.instanceEnd;

		if ( start !== undefined ) {

			start.applyMatrix4( matrix );

			end.applyMatrix4( matrix );

			start.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	setPositions( array ) {

		let lineSegments;

		if ( array instanceof Float32Array ) {

			lineSegments = array;

		} else if ( Array.isArray( array ) ) {

			lineSegments = new Float32Array( array );

		}

		const instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz

		this.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz
		this.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz

		this.instanceCount = this.attributes.instanceStart.count;

		//

		this.computeBoundingBox();
		this.computeBoundingSphere();

		return this;

	}

	setColors( array ) {

		let colors;

		if ( array instanceof Float32Array ) {

			colors = array;

		} else if ( Array.isArray( array ) ) {

			colors = new Float32Array( array );

		}

		const instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb

		this.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb
		this.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb

		return this;

	}

	fromWireframeGeometry( geometry ) {

		this.setPositions( geometry.attributes.position.array );

		return this;

	}

	fromEdgesGeometry( geometry ) {

		this.setPositions( geometry.attributes.position.array );

		return this;

	}

	fromMesh( mesh ) {

		this.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );

		// set colors, maybe

		return this;

	}

	fromLineSegments( lineSegments ) {

		const geometry = lineSegments.geometry;

		this.setPositions( geometry.attributes.position.array ); // assumes non-indexed

		// set colors, maybe

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const start = this.attributes.instanceStart;
		const end = this.attributes.instanceEnd;

		if ( start !== undefined && end !== undefined ) {

			this.boundingBox.setFromBufferAttribute( start );

			_box$1.setFromBufferAttribute( end );

			this.boundingBox.union( _box$1 );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		if ( this.boundingBox === null ) {

			this.computeBoundingBox();

		}

		const start = this.attributes.instanceStart;
		const end = this.attributes.instanceEnd;

		if ( start !== undefined && end !== undefined ) {

			const center = this.boundingSphere.center;

			this.boundingBox.getCenter( center );

			let maxRadiusSq = 0;

			for ( let i = 0, il = start.count; i < il; i ++ ) {

				_vector.fromBufferAttribute( start, i );
				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );

				_vector.fromBufferAttribute( end, i );
				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );

			}

		}

	}

	toJSON() {

		// todo

	}

	applyMatrix( matrix ) {

		console.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );

		return this.applyMatrix4( matrix );

	}

}

const _viewport = new Vector4();

const _start = new Vector3();
const _end = new Vector3();

const _start4 = new Vector4();
const _end4 = new Vector4();

const _ssOrigin = new Vector4();
const _ssOrigin3 = new Vector3();
const _mvMatrix = new Matrix4();
const _line = new Line3();
const _closestPoint = new Vector3();

const _box = new Box3();
const _sphere = new Sphere();
const _clipToWorldVector = new Vector4();

let _ray, _lineWidth;

// Returns the margin required to expand by in world space given the distance from the camera,
// line width, resolution, and camera projection
function getWorldSpaceHalfWidth( camera, distance, resolution ) {

	// transform into clip space, adjust the x and y values by the pixel width offset, then
	// transform back into world space to get world offset. Note clip space is [-1, 1] so full
	// width does not need to be halved.
	_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );
	_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );
	_clipToWorldVector.x = _lineWidth / resolution.width;
	_clipToWorldVector.y = _lineWidth / resolution.height;
	_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );
	_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );

	return Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );

}

function raycastWorldUnits( lineSegments, intersects ) {

	const matrixWorld = lineSegments.matrixWorld;
	const geometry = lineSegments.geometry;
	const instanceStart = geometry.attributes.instanceStart;
	const instanceEnd = geometry.attributes.instanceEnd;
	const segmentCount = Math.min( geometry.instanceCount, instanceStart.count );

	for ( let i = 0, l = segmentCount; i < l; i ++ ) {

		_line.start.fromBufferAttribute( instanceStart, i );
		_line.end.fromBufferAttribute( instanceEnd, i );

		_line.applyMatrix4( matrixWorld );

		const pointOnLine = new Vector3();
		const point = new Vector3();

		_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );
		const isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;

		if ( isInside ) {

			intersects.push( {
				point,
				pointOnLine,
				distance: _ray.origin.distanceTo( point ),
				object: lineSegments,
				face: null,
				faceIndex: i,
				uv: null,
				uv1: null,
			} );

		}

	}

}

function raycastScreenSpace( lineSegments, camera, intersects ) {

	const projectionMatrix = camera.projectionMatrix;
	const material = lineSegments.material;
	const resolution = material.resolution;
	const matrixWorld = lineSegments.matrixWorld;

	const geometry = lineSegments.geometry;
	const instanceStart = geometry.attributes.instanceStart;
	const instanceEnd = geometry.attributes.instanceEnd;
	const segmentCount = Math.min( geometry.instanceCount, instanceStart.count );

	const near = - camera.near;

	//

	// pick a point 1 unit out along the ray to avoid the ray origin
	// sitting at the camera origin which will cause "w" to be 0 when
	// applying the projection matrix.
	_ray.at( 1, _ssOrigin );

	// ndc space [ - 1.0, 1.0 ]
	_ssOrigin.w = 1;
	_ssOrigin.applyMatrix4( camera.matrixWorldInverse );
	_ssOrigin.applyMatrix4( projectionMatrix );
	_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );

	// screen space
	_ssOrigin.x *= resolution.x / 2;
	_ssOrigin.y *= resolution.y / 2;
	_ssOrigin.z = 0;

	_ssOrigin3.copy( _ssOrigin );

	_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );

	for ( let i = 0, l = segmentCount; i < l; i ++ ) {

		_start4.fromBufferAttribute( instanceStart, i );
		_end4.fromBufferAttribute( instanceEnd, i );

		_start4.w = 1;
		_end4.w = 1;

		// camera space
		_start4.applyMatrix4( _mvMatrix );
		_end4.applyMatrix4( _mvMatrix );

		// skip the segment if it's entirely behind the camera
		const isBehindCameraNear = _start4.z > near && _end4.z > near;
		if ( isBehindCameraNear ) {

			continue;

		}

		// trim the segment if it extends behind camera near
		if ( _start4.z > near ) {

			const deltaDist = _start4.z - _end4.z;
			const t = ( _start4.z - near ) / deltaDist;
			_start4.lerp( _end4, t );

		} else if ( _end4.z > near ) {

			const deltaDist = _end4.z - _start4.z;
			const t = ( _end4.z - near ) / deltaDist;
			_end4.lerp( _start4, t );

		}

		// clip space
		_start4.applyMatrix4( projectionMatrix );
		_end4.applyMatrix4( projectionMatrix );

		// ndc space [ - 1.0, 1.0 ]
		_start4.multiplyScalar( 1 / _start4.w );
		_end4.multiplyScalar( 1 / _end4.w );

		// screen space
		_start4.x *= resolution.x / 2;
		_start4.y *= resolution.y / 2;

		_end4.x *= resolution.x / 2;
		_end4.y *= resolution.y / 2;

		// create 2d segment
		_line.start.copy( _start4 );
		_line.start.z = 0;

		_line.end.copy( _end4 );
		_line.end.z = 0;

		// get closest point on ray to segment
		const param = _line.closestPointToPointParameter( _ssOrigin3, true );
		_line.at( param, _closestPoint );

		// check if the intersection point is within clip space
		const zPos = MathUtils.lerp( _start4.z, _end4.z, param );
		const isInClipSpace = zPos >= -1 && zPos <= 1;

		const isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;

		if ( isInClipSpace && isInside ) {

			_line.start.fromBufferAttribute( instanceStart, i );
			_line.end.fromBufferAttribute( instanceEnd, i );

			_line.start.applyMatrix4( matrixWorld );
			_line.end.applyMatrix4( matrixWorld );

			const pointOnLine = new Vector3();
			const point = new Vector3();

			_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );

			intersects.push( {
				point: point,
				pointOnLine: pointOnLine,
				distance: _ray.origin.distanceTo( point ),
				object: lineSegments,
				face: null,
				faceIndex: i,
				uv: null,
				uv1: null,
			} );

		}

	}

}

class LineSegments2 extends Mesh {

	constructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {

		super( geometry, material );

		this.isLineSegments2 = true;

		this.type = 'LineSegments2';

	}

	// for backwards-compatibility, but could be a method of LineSegmentsGeometry...

	computeLineDistances() {

		const geometry = this.geometry;

		const instanceStart = geometry.attributes.instanceStart;
		const instanceEnd = geometry.attributes.instanceEnd;
		const lineDistances = new Float32Array( 2 * instanceStart.count );

		for ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {

			_start.fromBufferAttribute( instanceStart, i );
			_end.fromBufferAttribute( instanceEnd, i );

			lineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];
			lineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );

		}

		const instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1

		geometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0
		geometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1

		return this;

	}

	raycast( raycaster, intersects ) {

		const worldUnits = this.material.worldUnits;
		const camera = raycaster.camera;

		if ( camera === null && ! worldUnits ) {

			console.error( 'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );

		}

		const threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;

		_ray = raycaster.ray;

		const matrixWorld = this.matrixWorld;
		const geometry = this.geometry;
		const material = this.material;

		_lineWidth = material.linewidth + threshold;

		// check if we intersect the sphere bounds
		if ( geometry.boundingSphere === null ) {

			geometry.computeBoundingSphere();

		}

		_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );

		// increase the sphere bounds by the worst case line screen space width
		let sphereMargin;
		if ( worldUnits ) {

			sphereMargin = _lineWidth * 0.5;

		} else {

			const distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );
			sphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );

		}

		_sphere.radius += sphereMargin;

		if ( _ray.intersectsSphere( _sphere ) === false ) {

			return;

		}

		// check if we intersect the box bounds
		if ( geometry.boundingBox === null ) {

			geometry.computeBoundingBox();

		}

		_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );

		// increase the box bounds by the worst case line width
		let boxMargin;
		if ( worldUnits ) {

			boxMargin = _lineWidth * 0.5;

		} else {

			const distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );
			boxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );

		}

		_box.expandByScalar( boxMargin );

		if ( _ray.intersectsBox( _box ) === false ) {

			return;

		}

		if ( worldUnits ) {

			raycastWorldUnits( this, intersects );

		} else {

			raycastScreenSpace( this, camera, intersects );

		}

	}

	onBeforeRender( renderer ) {

		const uniforms = this.material.uniforms;

		if ( uniforms && uniforms.resolution ) {

			renderer.getViewport( _viewport );
			this.material.uniforms.resolution.value.set( _viewport.z, _viewport.w );

		}

	}

}

class LineGeometry extends LineSegmentsGeometry {

	constructor() {

		super();

		this.isLineGeometry = true;

		this.type = 'LineGeometry';

	}

	setPositions( array ) {

		// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format

		const length = array.length - 3;
		const points = new Float32Array( 2 * length );

		for ( let i = 0; i < length; i += 3 ) {

			points[ 2 * i ] = array[ i ];
			points[ 2 * i + 1 ] = array[ i + 1 ];
			points[ 2 * i + 2 ] = array[ i + 2 ];

			points[ 2 * i + 3 ] = array[ i + 3 ];
			points[ 2 * i + 4 ] = array[ i + 4 ];
			points[ 2 * i + 5 ] = array[ i + 5 ];

		}

		super.setPositions( points );

		return this;

	}

	setColors( array ) {

		// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format

		const length = array.length - 3;
		const colors = new Float32Array( 2 * length );

		for ( let i = 0; i < length; i += 3 ) {

			colors[ 2 * i ] = array[ i ];
			colors[ 2 * i + 1 ] = array[ i + 1 ];
			colors[ 2 * i + 2 ] = array[ i + 2 ];

			colors[ 2 * i + 3 ] = array[ i + 3 ];
			colors[ 2 * i + 4 ] = array[ i + 4 ];
			colors[ 2 * i + 5 ] = array[ i + 5 ];

		}

		super.setColors( colors );

		return this;

	}

	setFromPoints( points ) {

		// converts a vector3 or vector2 array to pairs format

		const length = points.length - 1;
		const positions = new Float32Array( 6 * length );

		for ( let i = 0; i < length; i ++ ) {

			positions[ 6 * i ] = points[ i ].x;
			positions[ 6 * i + 1 ] = points[ i ].y;
			positions[ 6 * i + 2 ] = points[ i ].z || 0;

			positions[ 6 * i + 3 ] = points[ i + 1 ].x;
			positions[ 6 * i + 4 ] = points[ i + 1 ].y;
			positions[ 6 * i + 5 ] = points[ i + 1 ].z || 0;

		}

		super.setPositions( positions );

		return this;

	}

	fromLine( line ) {

		const geometry = line.geometry;

		this.setPositions( geometry.attributes.position.array ); // assumes non-indexed

		// set colors, maybe

		return this;

	}

}

let Line2$1 = class Line2 extends LineSegments2 {

	constructor( geometry = new LineGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {

		super( geometry, material );

		this.isLine2 = true;

		this.type = 'Line2';

	}

};

var __defProp$s = Object.defineProperty;
var __defNormalProp$s = (obj, key, value) => key in obj ? __defProp$s(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$s = (obj, key, value) => __defNormalProp$s(obj, typeof key !== "symbol" ? key + "" : key, value);
var Line2Type = /* @__PURE__ */ ((Line2Type2) => {
  Line2Type2["Line2"] = "Line2";
  Line2Type2["LineSegments2"] = "LineSegments2";
  Line2Type2["Wireframe"] = "Wireframe";
  return Line2Type2;
})(Line2Type || {});
const Line2DefaultsOptions = {
  points: [],
  vertexColors: [],
  lineType: "Line2" /* Line2 */,
  materialParams: {
    // alphaToCoverage: true,
    // color: "red",
    // dashed: false,
    // worldUnits: false,
    // linewidth: 1,
    // resolution: new THREE.Vector2(1, 1),
    // dashOffset: 0,
    // dashScale: 1,
    // dashSize: 1,
    // gapSize: 1,
  },
  isDelayInit: false
};
const GeometryMap = {
  "LineGeometry": LineGeometry,
  "LineSegmentsGeometry": LineSegmentsGeometry
};
class Line2 extends Object3D {
  constructor(_options) {
    super();
    __publicField$s(this, "line");
    __publicField$s(this, "material");
    __publicField$s(this, "options", Line2DefaultsOptions);
    __publicField$s(this, "points", []);
    this.options = deepMergeRetain$1(this.options, _options);
    this.init();
    if (!this.options.isDelayInit) {
      this.update(this.options);
    }
  }
  createLine(_options) {
    const { lineType, points, materialParams } = _options;
    switch (lineType) {
      case "Line2" /* Line2 */:
        this.line = new Line2$1();
        break;
      case "LineSegments2" /* LineSegments2 */:
        this.line = new LineSegments2();
        break;
      case "Wireframe" /* Wireframe */:
        this.line = new Wireframe();
        break;
    }
  }
  update(_options) {
    const { lineType, points, materialParams } = _options;
    if (isNil(this.line) || lineType !== this.options.lineType) {
      this.clear();
      Reflect.set(this, "line", null);
      this.createLine(_options);
      this.add(this.line);
    }
    if (isNil(this.material)) {
      this.material = new LineMaterial(materialParams);
    } else {
      !isNil(materialParams) && this.material.setValues(materialParams);
    }
    this.line.material = this.material;
    this.options = deepMergeRetain$1(this.options, _options);
    this.points = Tool$1.v3ArrayToVector3Array(this.options.points);
    this.setPoints();
  }
  updateGeometry() {
    this.line.geometry.dispose();
    const geo = new GeometryMap[this.line.geometry.type]();
    this.line.geometry = geo;
  }
  addPoint(point) {
    this.points.push(point);
    this.setPoints(this.points);
  }
  init() {
  }
  setPoints(points = this.getLinePoints()) {
    this.updateGeometry();
    let pointArray = Tool$1.v3ArrayToNum3Array(points).flat();
    this.line.geometry?.setPositions(pointArray);
    this.line.computeLineDistances();
  }
  setColors() {
    let colors = this.options.vertexColors.map((color) => {
      return isColor(color) ? color.toArray() : color;
    });
    this.options.vertexColors?.[0]?.length === 4 ? 4 : 3;
    if (colors.length > 2) {
      this.line.geometry.setColors(colors.flat());
    }
  }
  getLinePoints() {
    return this.points;
  }
}

var __defProp$r = Object.defineProperty;
var __defNormalProp$r = (obj, key, value) => key in obj ? __defProp$r(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$r = (obj, key, value) => __defNormalProp$r(obj, typeof key !== "symbol" ? key + "" : key, value);
class TextSprite extends THREE$2.Object3D {
  constructor(text) {
    super();
    __publicField$r(this, "texture");
    __publicField$r(this, "material");
    __publicField$r(this, "sprite");
    __publicField$r(this, "borderThickness", 4);
    __publicField$r(this, "fontface", "Arial");
    __publicField$r(this, "fontsize", 28);
    __publicField$r(this, "borderColor", { r: 0, g: 0, b: 0, a: 1 });
    __publicField$r(this, "backgroundColor", { r: 255, g: 255, b: 255, a: 1 });
    __publicField$r(this, "textColor", { r: 255, g: 255, b: 255, a: 1 });
    __publicField$r(this, "text", "");
    const texture = new THREE$2.Texture();
    texture.minFilter = THREE$2.LinearFilter;
    texture.magFilter = THREE$2.LinearFilter;
    this.material = new THREE$2.SpriteMaterial({
      map: texture,
      depthTest: false,
      depthWrite: false
    });
    this.texture = texture;
    this.sprite = new THREE$2.Sprite(this.material);
    this.add(this.sprite);
    this.setText(text);
  }
  setText(text) {
    if (this.text !== text) {
      this.text = text;
      this.update();
    }
  }
  setTextColor(color) {
    this.textColor = color;
    this.update();
  }
  setBorderColor(color) {
    this.borderColor = color;
    this.update();
  }
  setBackgroundColor(color) {
    this.backgroundColor = color;
    this.update();
  }
  update() {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    if (!context) return;
    context.font = "Bold " + this.fontsize + "px " + this.fontface;
    const metrics = context.measureText(this.text);
    const textWidth = metrics.width;
    const margin = 5;
    const spriteWidth = 2 * margin + textWidth + 2 * this.borderThickness;
    const spriteHeight = this.fontsize * 1.4 + 2 * this.borderThickness;
    context.canvas.width = spriteWidth;
    context.canvas.height = spriteHeight;
    context.font = "Bold " + this.fontsize + "px " + this.fontface;
    context.fillStyle = `rgba(${this.backgroundColor.r}, ${this.backgroundColor.g}, ${this.backgroundColor.b}, ${this.backgroundColor.a})`;
    context.strokeStyle = `rgba(${this.borderColor.r}, ${this.borderColor.g}, ${this.borderColor.b}, ${this.borderColor.a})`;
    context.lineWidth = this.borderThickness;
    this.roundRect(
      context,
      this.borderThickness / 2,
      this.borderThickness / 2,
      textWidth + this.borderThickness + 2 * margin,
      this.fontsize * 1.4 + this.borderThickness,
      6
    );
    context.strokeStyle = "rgba(0, 0, 0, 1.0)";
    context.strokeText(this.text, this.borderThickness + margin, this.fontsize + this.borderThickness);
    context.fillStyle = `rgba(${this.textColor.r}, ${this.textColor.g}, ${this.textColor.b}, ${this.textColor.a})`;
    context.fillText(this.text, this.borderThickness + margin, this.fontsize + this.borderThickness);
    const texture = new THREE$2.Texture(canvas);
    texture.minFilter = THREE$2.LinearFilter;
    texture.magFilter = THREE$2.LinearFilter;
    texture.needsUpdate = true;
    this.sprite.material.map = texture;
    this.texture = texture;
    this.sprite.scale.set(spriteWidth * 0.01, spriteHeight * 0.01, 1);
  }
  roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

var __defProp$q = Object.defineProperty;
var __defNormalProp$q = (obj, key, value) => key in obj ? __defProp$q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$q = (obj, key, value) => __defNormalProp$q(obj, typeof key !== "symbol" ? key + "" : key, value);
var EDistanceMeasureTextModel = /* @__PURE__ */ ((EDistanceMeasureTextModel2) => {
  EDistanceMeasureTextModel2[EDistanceMeasureTextModel2["Segment"] = 0] = "Segment";
  EDistanceMeasureTextModel2[EDistanceMeasureTextModel2["Total"] = 1] = "Total";
  return EDistanceMeasureTextModel2;
})(EDistanceMeasureTextModel || {});
class DistanceMeasure extends Measure {
  constructor(options) {
    super(options);
    __publicField$q(this, "pointGroup", new THREE$2.Group());
    __publicField$q(this, "lineGroup", new THREE$2.Group());
    __publicField$q(this, "textSprite", new THREE$2.Group());
    __publicField$q(this, "points", []);
    __publicField$q(this, "lines", []);
    __publicField$q(this, "line");
    __publicField$q(this, "isEnd", false);
    this.scene.add(this.pointGroup);
    this.pointGroup.userData.isVisibleGraph = false;
    this.pointGroup.userData.tag = ["DistanceMeasurePointGroup"];
    this.scene.add(this.lineGroup);
    this.lineGroup.userData.isVisibleGraph = false;
    this.lineGroup.userData.tag = ["DistanceMeasureLineGroup"];
    this.scene.add(this.textSprite);
    this.textSprite.userData.isVisibleGraph = false;
    this.textSprite.userData.tag = ["DistanceMeasureLineGroup"];
  }
  isFinish() {
    const { pointStopNum, textModel } = this.options;
    if (this.isEnd) {
      return true;
    }
    if (pointStopNum === -1) {
      return false;
    }
    return this.points.length === pointStopNum;
  }
  createSphereMaterial() {
    let meshLambertMaterial = new THREE$2.MeshLambertMaterial(
      {
        //shading: THREE.SmoothShading,
        color: new THREE$2.Color("#ff0000"),
        depthTest: false,
        depthWrite: false
      }
    );
    return meshLambertMaterial;
  }
  onAddPointEvent(value) {
    const { position } = value;
    if (this.isFinish()) {
      return;
    }
    this.points.push(position);
    this.addPoint(position);
    this.addLine(position);
    this.addText();
  }
  addPoint(position) {
    const sphereGeometry = new THREE$2.SphereGeometry(0.4, 10, 10);
    let sphere = new THREE$2.Mesh(sphereGeometry, this.createSphereMaterial());
    sphere.position.copy(position);
    this.pointGroup.add(sphere);
  }
  onMoveEvent(value) {
    const { position } = value;
    if (isNil(this.line)) return;
    if (this.isFinish()) {
      return;
    }
    const { pointStopNum, textModel } = this.options;
    const points = [...this.points, position];
    this.line.setPoints(points);
  }
  addLine(position) {
    if (isNil(this.line)) {
      this.line = new Line2({
        points: [position, position],
        // points: cc,
        materialParams: {
          color: 65280,
          linewidth: 10
        }
      });
      this.lineGroup.add(this.line);
    } else {
      this.line.setPoints(this.points);
    }
  }
  addText() {
    const { pointStopNum, textModel } = this.options;
    let len = this.points.length;
    if (len >= 2) {
      const startIndex = len - 2;
      const { text, distance, center } = this.getLabelSegmentInfo(startIndex);
      const textSprite = new TextSprite(text);
      textSprite.material.depthTest = false;
      textSprite.material.depthWrite = false;
      textSprite.position.copy(center);
      this.textSprite.add(textSprite);
    }
  }
  getLabelSegmentInfo(startIndex) {
    const { pointStopNum, textModel } = this.options;
    let distance = 0;
    if (textModel === 0 /* Segment */) {
      distance = this.points[startIndex].distanceTo(this.points[startIndex + 1]);
    } else {
      distance = Tool$1.calculateTotalLength(this.points);
    }
    const center = Tool$1.calculateCenter(this.points[startIndex], this.points[startIndex + 1]);
    const text = `${round(distance, 2)} \u7C73`;
    return {
      text,
      distance,
      center
    };
  }
  getLabelTotalInfo() {
    const distance = Tool$1.calculateTotalLength(this.points);
    const center = Tool$1.getBox3ByV3Array(this.points).getCenter(new THREE$2.Vector3());
    const text = `${round(distance, 2)} \u7C73`;
    return {
      text,
      distance,
      center
    };
  }
  onEndEvent(value) {
    this.isEnd = true;
  }
}

var __defProp$p = Object.defineProperty;
var __defNormalProp$p = (obj, key, value) => key in obj ? __defProp$p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$p = (obj, key, value) => __defNormalProp$p(obj, typeof key !== "symbol" ? key + "" : key, value);
var MeasureMode = /* @__PURE__ */ ((MeasureMode2) => {
  MeasureMode2[MeasureMode2["Distance"] = 0] = "Distance";
  MeasureMode2[MeasureMode2["Area"] = 1] = "Area";
  MeasureMode2[MeasureMode2["Angle"] = 2] = "Angle";
  return MeasureMode2;
})(MeasureMode || {});
class MeasureTool extends Component {
  constructor(options) {
    super(options);
    __publicField$p(this, "currentMeasure");
    __publicField$p(this, "leftClickSubscription", null);
    __publicField$p(this, "rightClickSubscription", null);
    __publicField$p(this, "pointerMoveSubscription", null);
    __publicField$p(this, "isAddEvent", false);
    __publicField$p(this, "dblClickSubscription", null);
  }
  addEvent() {
    if (this.isAddEvent) {
      return;
    }
    this.leftClickSubscription = this.eventManager.leftClickPickSubject.subscribe((value) => {
      const { position } = value;
      this.currentMeasure?.onAddPointEvent(value);
    });
    this.rightClickSubscription = this.eventManager.rightClickPickSubject.subscribe((value) => {
      const { position } = value;
      this.currentMeasure?.onAddPointEvent(value);
    });
    this.pointerMoveSubscription = this.eventManager.pointerMovePickSubject.subscribe((value) => {
      const { position } = value;
      this.currentMeasure?.onMoveEvent(value);
    });
    this.dblClickSubscription = this.eventManager.dblClickPickSubject.subscribe((value) => {
      const { position } = value;
      this.currentMeasure?.onEndEvent(value);
    });
    this.isAddEvent = true;
  }
  removeEvent() {
    this.leftClickSubscription?.unsubscribe();
    this.leftClickSubscription = null;
    this.rightClickSubscription?.unsubscribe();
    this.rightClickSubscription = null;
    this.pointerMoveSubscription?.unsubscribe();
    this.pointerMoveSubscription = null;
    this.isAddEvent = false;
  }
  startDistanceMeasure(options) {
    this.currentMeasure = new DistanceMeasure({
      viewer: this.viewer,
      ...deepMergeRetain(
        {
          pointStopNum: 2,
          textModel: EDistanceMeasureTextModel.Segment
        },
        options
      )
    });
    this.addEvent();
  }
  start(model) {
    this.addEvent();
  }
  end() {
    this.removeEvent();
  }
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var aliyunOssSdk = {exports: {}};

var hasRequiredAliyunOssSdk;

function requireAliyunOssSdk () {
	if (hasRequiredAliyunOssSdk) return aliyunOssSdk.exports;
	hasRequiredAliyunOssSdk = 1;
	(function (module, exports) {
		// Aliyun OSS SDK for JavaScript v6.22.0
		// Copyright Aliyun.com, Inc. or its affiliates. All Rights Reserved.
		// License at https://github.com/ali-sdk/ali-oss/blob/master/LICENSE
		(function(global){(function(f){{module.exports=f();}})(function(){return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof commonjsRequire&&commonjsRequire;if(!f&&c)return c(i,true);if(u)return u(i,true);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t);}return n[i].exports}for(var u="function"==typeof commonjsRequire&&commonjsRequire,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

		var OSS = require('./browser/client');
		OSS.Buffer = require('buffer').Buffer;
		OSS.urllib = require('../shims/xhr');
		OSS.version = require('./browser/version').version;
		module.exports = OSS;

		},{"../shims/xhr":546,"./browser/client":3,"./browser/version":6,"buffer":103}],2:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.array.slice.js");
		var assert = require('assert');
		var _require = require('../common/utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var proto = exports;
		function isArray(arr) {
		  if (Array.isArray) return Array.isArray(arr);
		  return Object.prototype.toString.call(arr) === '[object Array]';
		}
		function toArray(obj) {
		  if (!obj) return [];
		  if (isArray(obj)) return obj;
		  return [obj];
		}

		/**
		 * Bucket opertaions
		 */

		// TODO: OSS server currently do not support CORS requests for bucket operations
		// proto.listBuckets = function* listBuckets(query, options) {
		//   // prefix, marker, max-keys
		//   var result = yield this.request({
		//     method: 'GET',
		//     query: query,
		//     timeout: options && options.timeout,
		//     ctx: options && options.ctx,
		//   });
		//
		//   if (result.status === 200) {
		//     var data = yield this.parseXML(result.data);
		//     var buckets = data.Buckets || null;
		//     if (buckets) {
		//       if (buckets.Bucket) {
		//         buckets = buckets.Bucket;
		//       }
		//       if (!isArray(buckets)) {
		//         buckets = [buckets];
		//       }
		//       buckets = buckets.map(function (item) {
		//         return {
		//           name: item.Name,
		//           region: item.Location,
		//           creationDate: item.CreationDate,
		//         };
		//       });
		//     }
		//     return {
		//       buckets: buckets,
		//       owner: {
		//         id: data.Owner.ID,
		//         displayName: data.Owner.DisplayName,
		//       },
		//       isTruncated: data.IsTruncated === 'true',
		//       nextMarker: data.NextMarker || null,
		//       res: result.res
		//     };
		//   }
		//
		//   throw yield this.requestError(result);
		// };

		proto.useBucket = function useBucket(name) {
		  _checkBucketName(name);
		  this.options.bucket = name;
		  return this;
		};
		proto.setBucket = function useBucket(name) {
		  _checkBucketName(name);
		  this.options.bucket = name;
		  return this;
		};
		proto.getBucket = function getBucket() {
		  return this.options.bucket;
		};
		proto.deleteBucket = /*#__PURE__*/function () {
		  var _deleteBucket = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          params = this._bucketRequestParams('DELETE', name, '', options);
		          _context.next = 3;
		          return this.request(params);
		        case 3:
		          result = _context.sent;
		          if (!(result.status === 200 || result.status === 204)) {
		            _context.next = 6;
		            break;
		          }
		          return _context.abrupt("return", {
		            res: result.res
		          });
		        case 6:
		          _context.next = 8;
		          return this.requestError(result);
		        case 8:
		          throw _context.sent;
		        case 9:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function deleteBucket(_x, _x2) {
		    return _deleteBucket.apply(this, arguments);
		  }
		  return deleteBucket;
		}();

		// acl

		proto.putBucketACL = /*#__PURE__*/function () {
		  var _putBucketACL = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(name, acl, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee2$(_context2) {
		      while (1) switch (_context2.prev = _context2.next) {
		        case 0:
		          params = this._bucketRequestParams('PUT', name, 'acl', options);
		          params.headers = {
		            'x-oss-acl': acl
		          };
		          params.successStatuses = [200];
		          _context2.next = 5;
		          return this.request(params);
		        case 5:
		          result = _context2.sent;
		          return _context2.abrupt("return", {
		            bucket: result.headers.location && result.headers.location.substring(1) || null,
		            res: result.res
		          });
		        case 7:
		        case "end":
		          return _context2.stop();
		      }
		    }, _callee2, this);
		  }));
		  function putBucketACL(_x3, _x4, _x5) {
		    return _putBucketACL.apply(this, arguments);
		  }
		  return putBucketACL;
		}();
		proto.getBucketACL = /*#__PURE__*/function () {
		  var _getBucketACL = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(name, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee3$(_context3) {
		      while (1) switch (_context3.prev = _context3.next) {
		        case 0:
		          params = this._bucketRequestParams('GET', name, 'acl', options);
		          params.successStatuses = [200];
		          params.xmlResponse = true;
		          _context3.next = 5;
		          return this.request(params);
		        case 5:
		          result = _context3.sent;
		          return _context3.abrupt("return", {
		            acl: result.data.AccessControlList.Grant,
		            owner: {
		              id: result.data.Owner.ID,
		              displayName: result.data.Owner.DisplayName
		            },
		            res: result.res
		          });
		        case 7:
		        case "end":
		          return _context3.stop();
		      }
		    }, _callee3, this);
		  }));
		  function getBucketACL(_x6, _x7) {
		    return _getBucketACL.apply(this, arguments);
		  }
		  return getBucketACL;
		}();

		// logging

		proto.putBucketLogging = /*#__PURE__*/function () {
		  var _putBucketLogging = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(name, prefix, options) {
		    var params, xml, result;
		    return _regenerator.default.wrap(function _callee4$(_context4) {
		      while (1) switch (_context4.prev = _context4.next) {
		        case 0:
		          params = this._bucketRequestParams('PUT', name, 'logging', options);
		          xml = '<?xml version="1.0" encoding="UTF-8"?>\n<BucketLoggingStatus>\n<LoggingEnabled>\n<TargetBucket>'.concat(name, "</TargetBucket>\n");
		          if (prefix) {
		            xml += "<TargetPrefix>".concat(prefix, "</TargetPrefix>\n");
		          }
		          xml += '</LoggingEnabled>\n</BucketLoggingStatus>';
		          params.content = xml;
		          params.mime = 'xml';
		          params.successStatuses = [200];
		          _context4.next = 9;
		          return this.request(params);
		        case 9:
		          result = _context4.sent;
		          return _context4.abrupt("return", {
		            res: result.res
		          });
		        case 11:
		        case "end":
		          return _context4.stop();
		      }
		    }, _callee4, this);
		  }));
		  function putBucketLogging(_x8, _x9, _x10) {
		    return _putBucketLogging.apply(this, arguments);
		  }
		  return putBucketLogging;
		}();
		proto.getBucketLogging = /*#__PURE__*/function () {
		  var _getBucketLogging = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(name, options) {
		    var params, result, enable;
		    return _regenerator.default.wrap(function _callee5$(_context5) {
		      while (1) switch (_context5.prev = _context5.next) {
		        case 0:
		          params = this._bucketRequestParams('GET', name, 'logging', options);
		          params.successStatuses = [200];
		          params.xmlResponse = true;
		          _context5.next = 5;
		          return this.request(params);
		        case 5:
		          result = _context5.sent;
		          enable = result.data.LoggingEnabled;
		          return _context5.abrupt("return", {
		            enable: !!enable,
		            prefix: enable && enable.TargetPrefix || null,
		            res: result.res
		          });
		        case 8:
		        case "end":
		          return _context5.stop();
		      }
		    }, _callee5, this);
		  }));
		  function getBucketLogging(_x11, _x12) {
		    return _getBucketLogging.apply(this, arguments);
		  }
		  return getBucketLogging;
		}();
		proto.deleteBucketLogging = /*#__PURE__*/function () {
		  var _deleteBucketLogging = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(name, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee6$(_context6) {
		      while (1) switch (_context6.prev = _context6.next) {
		        case 0:
		          params = this._bucketRequestParams('DELETE', name, 'logging', options);
		          params.successStatuses = [204, 200];
		          _context6.next = 4;
		          return this.request(params);
		        case 4:
		          result = _context6.sent;
		          return _context6.abrupt("return", {
		            res: result.res
		          });
		        case 6:
		        case "end":
		          return _context6.stop();
		      }
		    }, _callee6, this);
		  }));
		  function deleteBucketLogging(_x13, _x14) {
		    return _deleteBucketLogging.apply(this, arguments);
		  }
		  return deleteBucketLogging;
		}();
		proto.putBucketCORS = /*#__PURE__*/function () {
		  var _putBucketCORS = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(name, rules, options) {
		    var params, xml, parseOrigin, parseMethod, parseHeader, parseExposeHeader, i, l, rule, result;
		    return _regenerator.default.wrap(function _callee7$(_context7) {
		      while (1) switch (_context7.prev = _context7.next) {
		        case 0:
		          rules = rules || [];
		          assert(rules.length, 'rules is required');
		          rules.forEach(function (rule) {
		            assert(rule.allowedOrigin, 'allowedOrigin is required');
		            assert(rule.allowedMethod, 'allowedMethod is required');
		          });
		          params = this._bucketRequestParams('PUT', name, 'cors', options);
		          xml = '<?xml version="1.0" encoding="UTF-8"?>\n<CORSConfiguration>';
		          parseOrigin = function parseOrigin(val) {
		            xml += "<AllowedOrigin>".concat(val, "</AllowedOrigin>");
		          };
		          parseMethod = function parseMethod(val) {
		            xml += "<AllowedMethod>".concat(val, "</AllowedMethod>");
		          };
		          parseHeader = function parseHeader(val) {
		            xml += "<AllowedHeader>".concat(val, "</AllowedHeader>");
		          };
		          parseExposeHeader = function parseExposeHeader(val) {
		            xml += "<ExposeHeader>".concat(val, "</ExposeHeader>");
		          };
		          for (i = 0, l = rules.length; i < l; i++) {
		            rule = rules[i];
		            xml += '<CORSRule>';
		            toArray(rule.allowedOrigin).forEach(parseOrigin);
		            toArray(rule.allowedMethod).forEach(parseMethod);
		            toArray(rule.allowedHeader).forEach(parseHeader);
		            toArray(rule.exposeHeader).forEach(parseExposeHeader);
		            if (rule.maxAgeSeconds) {
		              xml += "<MaxAgeSeconds>".concat(rule.maxAgeSeconds, "</MaxAgeSeconds>");
		            }
		            xml += '</CORSRule>';
		          }
		          xml += '</CORSConfiguration>';
		          params.content = xml;
		          params.mime = 'xml';
		          params.successStatuses = [200];
		          _context7.next = 16;
		          return this.request(params);
		        case 16:
		          result = _context7.sent;
		          return _context7.abrupt("return", {
		            res: result.res
		          });
		        case 18:
		        case "end":
		          return _context7.stop();
		      }
		    }, _callee7, this);
		  }));
		  function putBucketCORS(_x15, _x16, _x17) {
		    return _putBucketCORS.apply(this, arguments);
		  }
		  return putBucketCORS;
		}();
		proto.getBucketCORS = /*#__PURE__*/function () {
		  var _getBucketCORS = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(name, options) {
		    var params, result, rules, CORSRule;
		    return _regenerator.default.wrap(function _callee8$(_context8) {
		      while (1) switch (_context8.prev = _context8.next) {
		        case 0:
		          params = this._bucketRequestParams('GET', name, 'cors', options);
		          params.successStatuses = [200];
		          params.xmlResponse = true;
		          _context8.next = 5;
		          return this.request(params);
		        case 5:
		          result = _context8.sent;
		          rules = [];
		          if (result.data && result.data.CORSRule) {
		            CORSRule = result.data.CORSRule;
		            if (!isArray(CORSRule)) CORSRule = [CORSRule];
		            CORSRule.forEach(function (rule) {
		              var r = {};
		              Object.keys(rule).forEach(function (key) {
		                r[key.slice(0, 1).toLowerCase() + key.slice(1, key.length)] = rule[key];
		              });
		              rules.push(r);
		            });
		          }
		          return _context8.abrupt("return", {
		            rules: rules,
		            res: result.res
		          });
		        case 9:
		        case "end":
		          return _context8.stop();
		      }
		    }, _callee8, this);
		  }));
		  function getBucketCORS(_x18, _x19) {
		    return _getBucketCORS.apply(this, arguments);
		  }
		  return getBucketCORS;
		}();
		proto.deleteBucketCORS = /*#__PURE__*/function () {
		  var _deleteBucketCORS = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9(name, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee9$(_context9) {
		      while (1) switch (_context9.prev = _context9.next) {
		        case 0:
		          params = this._bucketRequestParams('DELETE', name, 'cors', options);
		          params.successStatuses = [204];
		          _context9.next = 4;
		          return this.request(params);
		        case 4:
		          result = _context9.sent;
		          return _context9.abrupt("return", {
		            res: result.res
		          });
		        case 6:
		        case "end":
		          return _context9.stop();
		      }
		    }, _callee9, this);
		  }));
		  function deleteBucketCORS(_x20, _x21) {
		    return _deleteBucketCORS.apply(this, arguments);
		  }
		  return deleteBucketCORS;
		}();

		// referer

		proto.putBucketReferer = /*#__PURE__*/function () {
		  var _putBucketReferer = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10(name, allowEmpty, referers, options) {
		    var params, xml, i, result;
		    return _regenerator.default.wrap(function _callee10$(_context10) {
		      while (1) switch (_context10.prev = _context10.next) {
		        case 0:
		          params = this._bucketRequestParams('PUT', name, 'referer', options);
		          xml = '<?xml version="1.0" encoding="UTF-8"?>\n<RefererConfiguration>\n';
		          xml += "  <AllowEmptyReferer>".concat(allowEmpty ? 'true' : 'false', "</AllowEmptyReferer>\n");
		          if (referers && referers.length > 0) {
		            xml += '  <RefererList>\n';
		            for (i = 0; i < referers.length; i++) {
		              xml += "    <Referer>".concat(referers[i], "</Referer>\n");
		            }
		            xml += '  </RefererList>\n';
		          } else {
		            xml += '  <RefererList />\n';
		          }
		          xml += '</RefererConfiguration>';
		          params.content = xml;
		          params.mime = 'xml';
		          params.successStatuses = [200];
		          _context10.next = 10;
		          return this.request(params);
		        case 10:
		          result = _context10.sent;
		          return _context10.abrupt("return", {
		            res: result.res
		          });
		        case 12:
		        case "end":
		          return _context10.stop();
		      }
		    }, _callee10, this);
		  }));
		  function putBucketReferer(_x22, _x23, _x24, _x25) {
		    return _putBucketReferer.apply(this, arguments);
		  }
		  return putBucketReferer;
		}();
		proto.getBucketReferer = /*#__PURE__*/function () {
		  var _getBucketReferer = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11(name, options) {
		    var params, result, referers;
		    return _regenerator.default.wrap(function _callee11$(_context11) {
		      while (1) switch (_context11.prev = _context11.next) {
		        case 0:
		          params = this._bucketRequestParams('GET', name, 'referer', options);
		          params.successStatuses = [200];
		          params.xmlResponse = true;
		          _context11.next = 5;
		          return this.request(params);
		        case 5:
		          result = _context11.sent;
		          referers = result.data.RefererList.Referer || null;
		          if (referers) {
		            if (!isArray(referers)) {
		              referers = [referers];
		            }
		          }
		          return _context11.abrupt("return", {
		            allowEmpty: result.data.AllowEmptyReferer === 'true',
		            referers: referers,
		            res: result.res
		          });
		        case 9:
		        case "end":
		          return _context11.stop();
		      }
		    }, _callee11, this);
		  }));
		  function getBucketReferer(_x26, _x27) {
		    return _getBucketReferer.apply(this, arguments);
		  }
		  return getBucketReferer;
		}();
		proto.deleteBucketReferer = /*#__PURE__*/function () {
		  var _deleteBucketReferer = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12(name, options) {
		    return _regenerator.default.wrap(function _callee12$(_context12) {
		      while (1) switch (_context12.prev = _context12.next) {
		        case 0:
		          _context12.next = 2;
		          return this.putBucketReferer(name, true, null, options);
		        case 2:
		          return _context12.abrupt("return", _context12.sent);
		        case 3:
		        case "end":
		          return _context12.stop();
		      }
		    }, _callee12, this);
		  }));
		  function deleteBucketReferer(_x28, _x29) {
		    return _deleteBucketReferer.apply(this, arguments);
		  }
		  return deleteBucketReferer;
		}();

		// private apis

		proto._bucketRequestParams = function _bucketRequestParams(method, bucket, subres, options) {
		  return {
		    method: method,
		    bucket: bucket,
		    subres: subres,
		    additionalHeaders: options && options.additionalHeaders,
		    timeout: options && options.timeout,
		    ctx: options && options.ctx
		  };
		};

		},{"../common/utils/checkBucketName":53,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"assert":95,"core-js/modules/es.array.slice.js":319,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/web.dom-collections.for-each.js":380}],3:[function(require,module,exports){
		(function (Buffer,process){(function (){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		require("core-js/modules/es.function.name.js");
		require("core-js/modules/es.object.assign.js");
		require("core-js/modules/es.array.includes.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.symbol.js");
		require("core-js/modules/es.symbol.description.js");
		require("core-js/modules/es.array.slice.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.promise.js");
		require("core-js/modules/es.regexp.to-string.js");
		var debug = require('debug')('ali-oss');
		var xml = require('xml2js');
		var AgentKeepalive = require('agentkeepalive');
		var merge = require('merge-descriptors');
		var platform = require('platform');
		var utility = require('utility');
		var urllib = require('urllib');
		var pkg = require('./version');
		var bowser = require('bowser');
		var signUtils = require('../common/signUtils');
		var _initOptions = require('../common/client/initOptions');
		var _require = require('../common/utils/createRequest'),
		  createRequest = _require.createRequest;
		var _require2 = require('../common/utils/encoder'),
		  encoder = _require2.encoder;
		var _require3 = require('../common/client/getReqUrl'),
		  getReqUrl = _require3.getReqUrl;
		var _require4 = require('../common/utils/setSTSToken'),
		  setSTSToken = _require4.setSTSToken;
		var _require5 = require('../common/utils/retry'),
		  retry = _require5.retry;
		var _require6 = require('../common/utils/isFunction'),
		  isFunction = _require6.isFunction;
		var _require7 = require('../common/utils/getStandardRegion'),
		  getStandardRegion = _require7.getStandardRegion;
		var globalHttpAgent = new AgentKeepalive();
		function _unSupportBrowserTip() {
		  var name = platform.name,
		    version = platform.version;
		  if (name && name.toLowerCase && name.toLowerCase() === 'ie' && version.split('.')[0] < 10) {
		    // eslint-disable-next-line no-console
		    console.warn('ali-oss does not support the current browser');
		  }
		}
		// check local web protocol,if https secure default set true , if http secure default set false
		function isHttpsWebProtocol() {
		  // for web worker not use window.location.
		  // eslint-disable-next-line no-restricted-globals
		  return location && location.protocol === 'https:';
		}
		function Client(options, ctx) {
		  _unSupportBrowserTip();
		  if (!(this instanceof Client)) {
		    return new Client(options, ctx);
		  }
		  if (options && options.inited) {
		    this.options = options;
		  } else {
		    this.options = Client.initOptions(options);
		  }
		  this.options.cancelFlag = false; // cancel flag: if true need to be cancelled, default false

		  // support custom agent and urllib client
		  if (this.options.urllib) {
		    this.urllib = this.options.urllib;
		  } else {
		    this.urllib = urllib;
		    this.agent = this.options.agent || globalHttpAgent;
		  }
		  this.ctx = ctx;
		  this.userAgent = this._getUserAgent();
		  this.stsTokenFreshTime = new Date();

		  // record the time difference between client and server
		  this.options.amendTimeSkewed = 0;
		}

		/**
		 * Expose `Client`
		 */

		module.exports = Client;
		Client.initOptions = function initOptions(options) {
		  if (!options.stsToken) {
		    console.warn('Please use STS Token for safety, see more details at https://help.aliyun.com/document_detail/32077.html');
		  }
		  var opts = Object.assign({
		    secure: isHttpsWebProtocol(),
		    // for browser compatibility disable fetch.
		    useFetch: false
		  }, options);
		  return _initOptions(opts);
		};

		/**
		 * prototype
		 */

		var proto = Client.prototype;

		// mount debug on proto
		proto.debug = debug;

		/**
		 * Object operations
		 */
		merge(proto, require('./object'));
		/**
		 * Bucket operations
		 */
		merge(proto, require('./bucket'));
		merge(proto, require('../common/bucket/getBucketWebsite'));
		merge(proto, require('../common/bucket/putBucketWebsite'));
		merge(proto, require('../common/bucket/deleteBucketWebsite'));

		// lifecycle
		merge(proto, require('../common/bucket/getBucketLifecycle'));
		merge(proto, require('../common/bucket/putBucketLifecycle'));
		merge(proto, require('../common/bucket/deleteBucketLifecycle'));

		// multiversion
		merge(proto, require('../common/bucket/putBucketVersioning'));
		merge(proto, require('../common/bucket/getBucketVersioning'));

		// inventory
		merge(proto, require('../common/bucket/getBucketInventory'));
		merge(proto, require('../common/bucket/deleteBucketInventory'));
		merge(proto, require('../common/bucket/listBucketInventory'));
		merge(proto, require('../common/bucket/putBucketInventory'));

		// worm
		merge(proto, require('../common/bucket/abortBucketWorm'));
		merge(proto, require('../common/bucket/completeBucketWorm'));
		merge(proto, require('../common/bucket/extendBucketWorm'));
		merge(proto, require('../common/bucket/getBucketWorm'));
		merge(proto, require('../common/bucket/initiateBucketWorm'));

		// multipart upload
		merge(proto, require('./managed-upload'));
		/**
		 * common multipart-copy support node and browser
		 */
		merge(proto, require('../common/multipart-copy'));
		/**
		 * Multipart operations
		 */
		merge(proto, require('../common/multipart'));

		/**
		 * Common module parallel
		 */
		merge(proto, require('../common/parallel'));

		/**
		 * get OSS signature
		 * @param {String} stringToSign
		 * @return {String} the signature
		 */
		proto.signature = function signature(stringToSign) {
		  this.debug('authorization stringToSign: %s', stringToSign, 'info');
		  return signUtils.computeSignature(this.options.accessKeySecret, stringToSign, this.options.headerEncoding);
		};
		proto._getReqUrl = getReqUrl;

		/**
		 * get author header
		 *
		 * "Authorization: OSS " + Access Key Id + ":" + Signature
		 *
		 * Signature = base64(hmac-sha1(Access Key Secret + "\n"
		 *  + VERB + "\n"
		 *  + CONTENT-MD5 + "\n"
		 *  + CONTENT-TYPE + "\n"
		 *  + DATE + "\n"
		 *  + CanonicalizedOSSHeaders
		 *  + CanonicalizedResource))
		 *
		 * @param {String} method
		 * @param {String} resource
		 * @param {Object} header
		 * @return {String}
		 *
		 * @api private
		 */

		proto.authorization = function authorization(method, resource, subres, headers) {
		  var stringToSign = signUtils.buildCanonicalString(method.toUpperCase(), resource, {
		    headers: headers,
		    parameters: subres
		  });
		  return signUtils.authorization(this.options.accessKeyId, this.options.accessKeySecret, stringToSign, this.options.headerEncoding);
		};

		/**
		 * get authorization header v4
		 *
		 * @param {string} method
		 * @param {Object} requestParams
		 * @param {Object} requestParams.headers
		 * @param {(string|string[]|Object)} [requestParams.queries]
		 * @param {string} [bucketName]
		 * @param {string} [objectName]
		 * @param {string[]} [additionalHeaders]
		 * @return {string}
		 *
		 * @api private
		 */
		proto.authorizationV4 = function authorizationV4(method, requestParams, bucketName, objectName, additionalHeaders) {
		  return signUtils.authorizationV4(this.options.accessKeyId, this.options.accessKeySecret, getStandardRegion(this.options.region), method, requestParams, bucketName, objectName, additionalHeaders, this.options.headerEncoding);
		};

		/**
		 * request oss server
		 * @param {Object} params
		 *   - {String} object
		 *   - {String} bucket
		 *   - {Object} [headers]
		 *   - {Object} [query]
		 *   - {Buffer} [content]
		 *   - {Stream} [stream]
		 *   - {Stream} [writeStream]
		 *   - {String} [mime]
		 *   - {Boolean} [xmlResponse]
		 *   - {Boolean} [customResponse]
		 *   - {Number} [timeout]
		 *   - {Object} [ctx] request context, default is `this.ctx`
		 *
		 * @api private
		 */

		proto.request = /*#__PURE__*/function () {
		  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(params) {
		    var _this = this;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          if (!this.options.retryMax) {
		            _context.next = 6;
		            break;
		          }
		          _context.next = 3;
		          return retry(request.bind(this), this.options.retryMax, {
		            errorHandler: function errorHandler(err) {
		              var _errHandle = function _errHandle(_err) {
		                if (params.stream) return false;
		                var statusErr = [-1, -2].includes(_err.status);
		                var requestErrorRetryHandle = _this.options.requestErrorRetryHandle || function () {
		                  return true;
		                };
		                return statusErr && requestErrorRetryHandle(_err);
		              };
		              if (_errHandle(err)) return true;
		              return false;
		            }
		          })(params);
		        case 3:
		          return _context.abrupt("return", _context.sent);
		        case 6:
		          return _context.abrupt("return", request.call(this, params));
		        case 7:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return function (_x) {
		    return _ref.apply(this, arguments);
		  };
		}();
		function request(_x2) {
		  return _request.apply(this, arguments);
		}
		function _request() {
		  _request = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(params) {
		    var reqParams, result, reqErr, useStream, err, parseData;
		    return _regenerator.default.wrap(function _callee4$(_context4) {
		      while (1) switch (_context4.prev = _context4.next) {
		        case 0:
		          if (!(this.options.stsToken && isFunction(this.options.refreshSTSToken))) {
		            _context4.next = 3;
		            break;
		          }
		          _context4.next = 3;
		          return setSTSToken.call(this);
		        case 3:
		          reqParams = createRequest.call(this, params);
		          if (!this.options.useFetch) {
		            reqParams.params.mode = 'disable-fetch';
		          }
		          useStream = !!params.stream;
		          _context4.prev = 6;
		          _context4.next = 9;
		          return this.urllib.request(reqParams.url, reqParams.params);
		        case 9:
		          result = _context4.sent;
		          this.debug('response %s %s, got %s, headers: %j', params.method, reqParams.url, result.status, result.headers, 'info');
		          _context4.next = 16;
		          break;
		        case 13:
		          _context4.prev = 13;
		          _context4.t0 = _context4["catch"](6);
		          reqErr = _context4.t0;
		        case 16:
		          if (!(result && params.successStatuses && params.successStatuses.indexOf(result.status) === -1)) {
		            _context4.next = 28;
		            break;
		          }
		          _context4.next = 19;
		          return this.requestError(result);
		        case 19:
		          err = _context4.sent;
		          if (!(err.code === 'RequestTimeTooSkewed' && !useStream)) {
		            _context4.next = 25;
		            break;
		          }
		          this.options.amendTimeSkewed = +new Date(err.serverTime) - new Date();
		          _context4.next = 24;
		          return this.request(params);
		        case 24:
		          return _context4.abrupt("return", _context4.sent);
		        case 25:
		          err.params = params;
		          _context4.next = 32;
		          break;
		        case 28:
		          if (!reqErr) {
		            _context4.next = 32;
		            break;
		          }
		          _context4.next = 31;
		          return this.requestError(reqErr);
		        case 31:
		          err = _context4.sent;
		        case 32:
		          if (!err) {
		            _context4.next = 34;
		            break;
		          }
		          throw err;
		        case 34:
		          if (!params.xmlResponse) {
		            _context4.next = 39;
		            break;
		          }
		          _context4.next = 37;
		          return this.parseXML(result.data);
		        case 37:
		          parseData = _context4.sent;
		          result.data = parseData;
		        case 39:
		          return _context4.abrupt("return", result);
		        case 40:
		        case "end":
		          return _context4.stop();
		      }
		    }, _callee4, this, [[6, 13]]);
		  }));
		  return _request.apply(this, arguments);
		}
		proto._getResource = function _getResource(params) {
		  var resource = '/';
		  if (params.bucket) resource += "".concat(params.bucket, "/");
		  if (params.object) resource += encoder(params.object, this.options.headerEncoding);
		  return resource;
		};
		proto._escape = function _escape(name) {
		  return utility.encodeURIComponent(name).replace(/%2F/g, '/');
		};

		/*
		 * Get User-Agent for browser & node.js
		 * @example
		 *   aliyun-sdk-nodejs/4.1.2 Node.js 5.3.0 on Darwin 64-bit
		 *   aliyun-sdk-js/4.1.2 Safari 9.0 on Apple iPhone(iOS 9.2.1)
		 *   aliyun-sdk-js/4.1.2 Chrome 43.0.2357.134 32-bit on Windows Server 2008 R2 / 7 64-bit
		 */

		proto._getUserAgent = function _getUserAgent() {
		  var agent = process && process.browser ? 'js' : 'nodejs';
		  var sdk = "aliyun-sdk-".concat(agent, "/").concat(pkg.version);
		  var plat = platform.description;
		  if (!plat && process) {
		    plat = "Node.js ".concat(process.version.slice(1), " on ").concat(process.platform, " ").concat(process.arch);
		  }
		  return this._checkUserAgent("".concat(sdk, " ").concat(plat));
		};
		proto._checkUserAgent = function _checkUserAgent(ua) {
		  var userAgent = ua.replace(/\u03b1/, 'alpha').replace(/\u03b2/, 'beta');
		  return userAgent;
		};

		/*
		 * Check Browser And Version
		 * @param {String} [name] browser name: like IE, Chrome, Firefox
		 * @param {String} [version] browser major version: like 10(IE 10.x), 55(Chrome 55.x), 50(Firefox 50.x)
		 * @return {Bool} true or false
		 * @api private
		 */

		proto.checkBrowserAndVersion = function checkBrowserAndVersion(name, version) {
		  return bowser.name === name && bowser.version.split('.')[0] === version;
		};

		/**
		 * thunkify xml.parseString
		 * @param {String|Buffer} str
		 *
		 * @api private
		 */

		proto.parseXML = function parseXMLThunk(str) {
		  return new Promise(function (resolve, reject) {
		    if (Buffer.isBuffer(str)) {
		      str = str.toString();
		    }
		    xml.parseString(str, {
		      explicitRoot: false,
		      explicitArray: false
		    }, function (err, result) {
		      if (err) {
		        reject(err);
		      } else {
		        resolve(result);
		      }
		    });
		  });
		};

		/**
		 * generater a request error with request response
		 * @param {Object} result
		 *
		 * @api private
		 */

		proto.requestError = /*#__PURE__*/function () {
		  var _requestError = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(result) {
		    var _this2 = this;
		    var err, setError, ossErr, message, _message;
		    return _regenerator.default.wrap(function _callee3$(_context3) {
		      while (1) switch (_context3.prev = _context3.next) {
		        case 0:
		          err = null;
		          setError = /*#__PURE__*/function () {
		            var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(message) {
		              var info, msg;
		              return _regenerator.default.wrap(function _callee2$(_context2) {
		                while (1) switch (_context2.prev = _context2.next) {
		                  case 0:
		                    _context2.prev = 0;
		                    _context2.next = 3;
		                    return _this2.parseXML(message);
		                  case 3:
		                    _context2.t0 = _context2.sent;
		                    if (_context2.t0) {
		                      _context2.next = 6;
		                      break;
		                    }
		                    _context2.t0 = {};
		                  case 6:
		                    info = _context2.t0;
		                    _context2.next = 16;
		                    break;
		                  case 9:
		                    _context2.prev = 9;
		                    _context2.t1 = _context2["catch"](0);
		                    _this2.debug(message, 'error');
		                    _context2.t1.message += "\nraw xml: ".concat(message);
		                    _context2.t1.status = result.status;
		                    _context2.t1.requestId = result.headers && result.headers['x-oss-request-id'];
		                    return _context2.abrupt("return", _context2.t1);
		                  case 16:
		                    msg = info.Message || "unknow request error, status: ".concat(result.status);
		                    if (info.Condition) {
		                      msg += " (condition: ".concat(info.Condition, ")");
		                    }
		                    err = new Error(msg);
		                    err.name = info.Code ? "".concat(info.Code, "Error") : 'UnknownError';
		                    err.status = result.status;
		                    err.code = info.Code;
		                    err.ecCode = info.EC;
		                    err.requestId = info.RequestId;
		                    err.hostId = info.HostId;
		                    err.serverTime = info.ServerTime;
		                    return _context2.abrupt("return", err);
		                  case 27:
		                  case "end":
		                    return _context2.stop();
		                }
		              }, _callee2, null, [[0, 9]]);
		            }));
		            return function setError(_x4) {
		              return _ref2.apply(this, arguments);
		            };
		          }();
		          if (!(!result.data || !result.data.length)) {
		            _context3.next = 38;
		            break;
		          }
		          if (!(result.status === -1 || result.status === -2)) {
		            _context3.next = 10;
		            break;
		          }
		          // -1 is net error , -2 is timeout
		          err = new Error(result.message);
		          err.name = result.name;
		          err.status = result.status;
		          err.code = result.name;
		          _context3.next = 36;
		          break;
		        case 10:
		          if (!(result.status === 404)) {
		            _context3.next = 17;
		            break;
		          }
		          err = new Error('Object not exists');
		          err.name = 'NoSuchKeyError';
		          err.status = 404;
		          err.code = 'NoSuchKey';
		          _context3.next = 34;
		          break;
		        case 17:
		          if (!(result.status === 412)) {
		            _context3.next = 24;
		            break;
		          }
		          err = new Error('Pre condition failed');
		          err.name = 'PreconditionFailedError';
		          err.status = 412;
		          err.code = 'PreconditionFailed';
		          _context3.next = 34;
		          break;
		        case 24:
		          err = new Error("Unknow error, status: ".concat(result.status));
		          err.name = 'UnknownError';
		          err.status = result.status;
		          err.res = result;
		          ossErr = result.headers && result.headers['x-oss-err'];
		          if (!ossErr) {
		            _context3.next = 34;
		            break;
		          }
		          message = atob(ossErr);
		          _context3.next = 33;
		          return setError(message);
		        case 33:
		          err = _context3.sent;
		        case 34:
		          err.requestId = result.headers && result.headers['x-oss-request-id'];
		          err.host = '';
		        case 36:
		          _context3.next = 43;
		          break;
		        case 38:
		          _message = String(result.data);
		          this.debug('request response error data: %s', _message, 'error');
		          _context3.next = 42;
		          return setError(_message);
		        case 42:
		          err = _context3.sent;
		        case 43:
		          this.debug('generate error %j', err, 'error');
		          return _context3.abrupt("return", err);
		        case 45:
		        case "end":
		          return _context3.stop();
		      }
		    }, _callee3, this);
		  }));
		  function requestError(_x3) {
		    return _requestError.apply(this, arguments);
		  }
		  return requestError;
		}();

		}).call(this);}).call(this,{"isBuffer":require("../../node_modules/is-buffer/index.js")},require('_process'));
		},{"../../node_modules/is-buffer/index.js":409,"../common/bucket/abortBucketWorm":7,"../common/bucket/completeBucketWorm":8,"../common/bucket/deleteBucketInventory":9,"../common/bucket/deleteBucketLifecycle":10,"../common/bucket/deleteBucketWebsite":11,"../common/bucket/extendBucketWorm":12,"../common/bucket/getBucketInventory":13,"../common/bucket/getBucketLifecycle":14,"../common/bucket/getBucketVersioning":15,"../common/bucket/getBucketWebsite":16,"../common/bucket/getBucketWorm":17,"../common/bucket/initiateBucketWorm":18,"../common/bucket/listBucketInventory":19,"../common/bucket/putBucketInventory":20,"../common/bucket/putBucketLifecycle":21,"../common/bucket/putBucketVersioning":22,"../common/bucket/putBucketWebsite":23,"../common/client/getReqUrl":25,"../common/client/initOptions":26,"../common/multipart":30,"../common/multipart-copy":29,"../common/parallel":51,"../common/signUtils":52,"../common/utils/createRequest":58,"../common/utils/encoder":62,"../common/utils/getStandardRegion":65,"../common/utils/isFunction":72,"../common/utils/retry":80,"../common/utils/setSTSToken":82,"./bucket":2,"./managed-upload":4,"./object":5,"./version":6,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"_process":538,"agentkeepalive":94,"bowser":101,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.includes.js":315,"core-js/modules/es.array.slice.js":319,"core-js/modules/es.function.name.js":322,"core-js/modules/es.object.assign.js":325,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.promise.js":333,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/es.string.replace.js":345,"core-js/modules/es.symbol.description.js":351,"core-js/modules/es.symbol.js":354,"debug":536,"merge-descriptors":428,"platform":440,"urllib":546,"utility":545,"xml2js":496}],4:[function(require,module,exports){
		(function (Buffer){(function (){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.function.name.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.promise.js");
		require("core-js/modules/es.array.from.js");
		require("core-js/modules/es.string.iterator.js");
		require("core-js/modules/es.array.map.js");
		require("core-js/modules/es.array.filter.js");
		require("core-js/modules/es.array.find.js");
		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.regexp.to-string.js");
		require("core-js/modules/es.array.slice.js");
		require("core-js/modules/es.array.iterator.js");
		require("core-js/modules/es.array-buffer.slice.js");
		require("core-js/modules/es.typed-array.uint8-array.js");
		require("core-js/modules/es.typed-array.copy-within.js");
		require("core-js/modules/es.typed-array.every.js");
		require("core-js/modules/es.typed-array.fill.js");
		require("core-js/modules/es.typed-array.filter.js");
		require("core-js/modules/es.typed-array.find.js");
		require("core-js/modules/es.typed-array.find-index.js");
		require("core-js/modules/es.typed-array.for-each.js");
		require("core-js/modules/es.typed-array.includes.js");
		require("core-js/modules/es.typed-array.index-of.js");
		require("core-js/modules/es.typed-array.iterator.js");
		require("core-js/modules/es.typed-array.join.js");
		require("core-js/modules/es.typed-array.last-index-of.js");
		require("core-js/modules/es.typed-array.map.js");
		require("core-js/modules/es.typed-array.reduce.js");
		require("core-js/modules/es.typed-array.reduce-right.js");
		require("core-js/modules/es.typed-array.reverse.js");
		require("core-js/modules/es.typed-array.set.js");
		require("core-js/modules/es.typed-array.slice.js");
		require("core-js/modules/es.typed-array.some.js");
		require("core-js/modules/es.typed-array.sort.js");
		require("core-js/modules/es.typed-array.subarray.js");
		require("core-js/modules/es.typed-array.to-locale-string.js");
		require("core-js/modules/es.typed-array.to-string.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		// var debug = require('debug')('ali-oss:multipart');
		var util = require('util');
		var path = require('path');
		var mime = require('mime');
		var copy = require('copy-to');
		var _require = require('../common/utils/isBlob'),
		  isBlob = _require.isBlob;
		var _require2 = require('../common/utils/isFile'),
		  isFile = _require2.isFile;
		var _require3 = require('../common/utils/isBuffer'),
		  isBuffer = _require3.isBuffer;
		var proto = exports;

		/**
		 * Multipart operations
		 */

		/**
		 * Upload a file to OSS using multipart uploads
		 * @param {String} name
		 * @param {String|File|Buffer} file
		 * @param {Object} options
		 *        {Object} [options.callback] The callback parameter is composed of a JSON string encoded in Base64
		 *        {String} options.callback.url the OSS sends a callback request to this URL
		 *        {String} [options.callback.host] The host header value for initiating callback requests
		 *        {String} options.callback.body The value of the request body when a callback is initiated
		 *        {String} [options.callback.contentType] The Content-Type of the callback requests initiated
		 *        {Boolean} [options.callback.callbackSNI] Whether OSS sends SNI to the origin address specified by callbackUrl when a callback request is initiated from the client
		 *        {Object} [options.callback.customValue] Custom parameters are a map of key-values, e.g:
		 *                  customValue = {
		 *                    key1: 'value1',
		 *                    key2: 'value2'
		 *                  }
		 */
		proto.multipartUpload = /*#__PURE__*/function () {
		  var _multipartUpload = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, file) {
		    var options,
		      minPartSize,
		      fileSize,
		      result,
		      ret,
		      initResult,
		      uploadId,
		      partSize,
		      checkpoint,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
		          this.resetCancelFlag();
		          options.disabledMD5 = options.disabledMD5 === undefined ? true : !!options.disabledMD5;
		          if (!(options.checkpoint && options.checkpoint.uploadId)) {
		            _context.next = 8;
		            break;
		          }
		          if (file && isFile(file)) options.checkpoint.file = file;
		          _context.next = 7;
		          return this._resumeMultipart(options.checkpoint, options);
		        case 7:
		          return _context.abrupt("return", _context.sent);
		        case 8:
		          minPartSize = 100 * 1024;
		          if (!options.mime) {
		            if (isFile(file)) {
		              options.mime = mime.getType(path.extname(file.name));
		            } else if (isBlob(file)) {
		              options.mime = file.type;
		            } else if (isBuffer(file)) {
		              options.mime = '';
		            } else {
		              options.mime = mime.getType(path.extname(file));
		            }
		          }
		          options.headers = options.headers || {};
		          this._convertMetaToHeaders(options.meta, options.headers);
		          _context.next = 14;
		          return this._getFileSize(file);
		        case 14:
		          fileSize = _context.sent;
		          if (!(fileSize < minPartSize)) {
		            _context.next = 26;
		            break;
		          }
		          options.contentLength = fileSize;
		          _context.next = 19;
		          return this.put(name, file, options);
		        case 19:
		          result = _context.sent;
		          if (!(options && options.progress)) {
		            _context.next = 23;
		            break;
		          }
		          _context.next = 23;
		          return options.progress(1);
		        case 23:
		          ret = {
		            res: result.res,
		            bucket: this.options.bucket,
		            name: name,
		            etag: result.res.headers.etag
		          };
		          if (options.headers && options.headers['x-oss-callback'] || options.callback) {
		            ret.data = result.data;
		          }
		          return _context.abrupt("return", ret);
		        case 26:
		          if (!(options.partSize && !(parseInt(options.partSize, 10) === options.partSize))) {
		            _context.next = 28;
		            break;
		          }
		          throw new Error('partSize must be int number');
		        case 28:
		          if (!(options.partSize && options.partSize < minPartSize)) {
		            _context.next = 30;
		            break;
		          }
		          throw new Error("partSize must not be smaller than ".concat(minPartSize));
		        case 30:
		          _context.next = 32;
		          return this.initMultipartUpload(name, options);
		        case 32:
		          initResult = _context.sent;
		          uploadId = initResult.uploadId;
		          partSize = this._getPartSize(fileSize, options.partSize);
		          checkpoint = {
		            file: file,
		            name: name,
		            fileSize: fileSize,
		            partSize: partSize,
		            uploadId: uploadId,
		            doneParts: []
		          };
		          if (!(options && options.progress)) {
		            _context.next = 39;
		            break;
		          }
		          _context.next = 39;
		          return options.progress(0, checkpoint, initResult.res);
		        case 39:
		          _context.next = 41;
		          return this._resumeMultipart(checkpoint, options);
		        case 41:
		          return _context.abrupt("return", _context.sent);
		        case 42:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function multipartUpload(_x, _x2) {
		    return _multipartUpload.apply(this, arguments);
		  }
		  return multipartUpload;
		}();

		/*
		 * Resume multipart upload from checkpoint. The checkpoint will be
		 * updated after each successful part upload.
		 * @param {Object} checkpoint the checkpoint
		 * @param {Object} options
		 */
		proto._resumeMultipart = /*#__PURE__*/function () {
		  var _resumeMultipart2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(checkpoint, options) {
		    var that, file, fileSize, partSize, uploadId, doneParts, name, internalDoneParts, partOffs, numParts, multipartFinish, uploadPartJob, all, done, todo, defaultParallel, parallel, jobErr, abortEvent;
		    return _regenerator.default.wrap(function _callee3$(_context3) {
		      while (1) switch (_context3.prev = _context3.next) {
		        case 0:
		          that = this;
		          if (!this.isCancel()) {
		            _context3.next = 3;
		            break;
		          }
		          throw this._makeCancelEvent();
		        case 3:
		          file = checkpoint.file, fileSize = checkpoint.fileSize, partSize = checkpoint.partSize, uploadId = checkpoint.uploadId, doneParts = checkpoint.doneParts, name = checkpoint.name;
		          internalDoneParts = [];
		          if (doneParts.length > 0) {
		            copy(doneParts).to(internalDoneParts);
		          }
		          partOffs = this._divideParts(fileSize, partSize);
		          numParts = partOffs.length;
		          multipartFinish = false;
		          uploadPartJob = function uploadPartJob(self, partNo) {
		            // eslint-disable-next-line no-async-promise-executor
		            return new Promise( /*#__PURE__*/function () {
		              var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(resolve, reject) {
		                var pi, content, data, result, tempErr;
		                return _regenerator.default.wrap(function _callee2$(_context2) {
		                  while (1) switch (_context2.prev = _context2.next) {
		                    case 0:
		                      _context2.prev = 0;
		                      if (self.isCancel()) {
		                        _context2.next = 29;
		                        break;
		                      }
		                      pi = partOffs[partNo - 1];
		                      _context2.next = 5;
		                      return self._createBuffer(file, pi.start, pi.end);
		                    case 5:
		                      content = _context2.sent;
		                      data = {
		                        content: content,
		                        size: pi.end - pi.start
		                      };
		                      _context2.prev = 7;
		                      _context2.next = 10;
		                      return self._uploadPart(name, uploadId, partNo, data, options);
		                    case 10:
		                      result = _context2.sent;
		                      _context2.next = 18;
		                      break;
		                    case 13:
		                      _context2.prev = 13;
		                      _context2.t0 = _context2["catch"](7);
		                      if (!(_context2.t0.status === 404)) {
		                        _context2.next = 17;
		                        break;
		                      }
		                      throw self._makeAbortEvent();
		                    case 17:
		                      throw _context2.t0;
		                    case 18:
		                      if (!(!self.isCancel() && !multipartFinish)) {
		                        _context2.next = 26;
		                        break;
		                      }
		                      checkpoint.doneParts.push({
		                        number: partNo,
		                        etag: result.res.headers.etag
		                      });
		                      if (!options.progress) {
		                        _context2.next = 23;
		                        break;
		                      }
		                      _context2.next = 23;
		                      return options.progress(doneParts.length / (numParts + 1), checkpoint, result.res);
		                    case 23:
		                      resolve({
		                        number: partNo,
		                        etag: result.res.headers.etag
		                      });
		                      _context2.next = 27;
		                      break;
		                    case 26:
		                      resolve();
		                    case 27:
		                      _context2.next = 30;
		                      break;
		                    case 29:
		                      resolve();
		                    case 30:
		                      _context2.next = 41;
		                      break;
		                    case 32:
		                      _context2.prev = 32;
		                      _context2.t1 = _context2["catch"](0);
		                      tempErr = new Error();
		                      tempErr.name = _context2.t1.name;
		                      tempErr.message = _context2.t1.message;
		                      tempErr.stack = _context2.t1.stack;
		                      tempErr.partNum = partNo;
		                      copy(_context2.t1).to(tempErr);
		                      reject(tempErr);
		                    case 41:
		                    case "end":
		                      return _context2.stop();
		                  }
		                }, _callee2, null, [[0, 32], [7, 13]]);
		              }));
		              return function (_x5, _x6) {
		                return _ref.apply(this, arguments);
		              };
		            }());
		          };
		          all = Array.from(new Array(numParts), function (x, i) {
		            return i + 1;
		          });
		          done = internalDoneParts.map(function (p) {
		            return p.number;
		          });
		          todo = all.filter(function (p) {
		            return done.indexOf(p) < 0;
		          });
		          defaultParallel = 5;
		          parallel = options.parallel || defaultParallel; // upload in parallel
		          _context3.next = 17;
		          return this._parallel(todo, parallel, function (value) {
		            return new Promise(function (resolve, reject) {
		              uploadPartJob(that, value).then(function (result) {
		                if (result) {
		                  internalDoneParts.push(result);
		                }
		                resolve();
		              }).catch(function (err) {
		                reject(err);
		              });
		            });
		          });
		        case 17:
		          jobErr = _context3.sent;
		          multipartFinish = true;
		          abortEvent = jobErr.find(function (err) {
		            return err.name === 'abort';
		          });
		          if (!abortEvent) {
		            _context3.next = 22;
		            break;
		          }
		          throw abortEvent;
		        case 22:
		          if (!this.isCancel()) {
		            _context3.next = 25;
		            break;
		          }
		          uploadPartJob = null;
		          throw this._makeCancelEvent();
		        case 25:
		          if (!(jobErr && jobErr.length > 0)) {
		            _context3.next = 28;
		            break;
		          }
		          jobErr[0].message = "Failed to upload some parts with error: ".concat(jobErr[0].toString(), " part_num: ").concat(jobErr[0].partNum);
		          throw jobErr[0];
		        case 28:
		          _context3.next = 30;
		          return this.completeMultipartUpload(name, uploadId, internalDoneParts, options);
		        case 30:
		          return _context3.abrupt("return", _context3.sent);
		        case 31:
		        case "end":
		          return _context3.stop();
		      }
		    }, _callee3, this);
		  }));
		  function _resumeMultipart(_x3, _x4) {
		    return _resumeMultipart2.apply(this, arguments);
		  }
		  return _resumeMultipart;
		}();

		/**
		 * Get file size
		 */
		proto._getFileSize = /*#__PURE__*/function () {
		  var _getFileSize2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(file) {
		    return _regenerator.default.wrap(function _callee4$(_context4) {
		      while (1) switch (_context4.prev = _context4.next) {
		        case 0:
		          if (!isBuffer(file)) {
		            _context4.next = 4;
		            break;
		          }
		          return _context4.abrupt("return", file.length);
		        case 4:
		          if (!(isBlob(file) || isFile(file))) {
		            _context4.next = 6;
		            break;
		          }
		          return _context4.abrupt("return", file.size);
		        case 6:
		          throw new Error('_getFileSize requires Buffer/File/Blob.');
		        case 7:
		        case "end":
		          return _context4.stop();
		      }
		    }, _callee4);
		  }));
		  function _getFileSize(_x7) {
		    return _getFileSize2.apply(this, arguments);
		  }
		  return _getFileSize;
		}();

		/*
		 * Readable stream for Web File
		 */
		var _require4 = require('stream'),
		  Readable = _require4.Readable;
		function WebFileReadStream(file, options) {
		  if (!(this instanceof WebFileReadStream)) {
		    return new WebFileReadStream(file, options);
		  }
		  Readable.call(this, options);
		  this.file = file;
		  this.reader = new FileReader();
		  this.start = 0;
		  this.finish = false;
		  this.fileBuffer = null;
		}
		util.inherits(WebFileReadStream, Readable);
		WebFileReadStream.prototype.readFileAndPush = function readFileAndPush(size) {
		  if (this.fileBuffer) {
		    var pushRet = true;
		    while (pushRet && this.fileBuffer && this.start < this.fileBuffer.length) {
		      var start = this.start;
		      var end = start + size;
		      end = end > this.fileBuffer.length ? this.fileBuffer.length : end;
		      this.start = end;
		      pushRet = this.push(this.fileBuffer.slice(start, end));
		    }
		  }
		};
		WebFileReadStream.prototype._read = function _read(size) {
		  if (this.file && this.start >= this.file.size || this.fileBuffer && this.start >= this.fileBuffer.length || this.finish || this.start === 0 && !this.file) {
		    if (!this.finish) {
		      this.fileBuffer = null;
		      this.finish = true;
		    }
		    this.push(null);
		    return;
		  }
		  var defaultReadSize = 16 * 1024;
		  size = size || defaultReadSize;
		  var that = this;
		  this.reader.onload = function onload(e) {
		    that.fileBuffer = Buffer.from(new Uint8Array(e.target.result));
		    that.file = null;
		    that.readFileAndPush(size);
		  };
		  if (this.start === 0) {
		    this.reader.readAsArrayBuffer(this.file);
		  } else {
		    this.readFileAndPush(size);
		  }
		};
		function getBuffer(file) {
		  // Some browsers do not support Blob.prototype.arrayBuffer, such as IE
		  if (file.arrayBuffer) return file.arrayBuffer();
		  return new Promise(function (resolve, reject) {
		    var reader = new FileReader();
		    reader.onload = function (e) {
		      resolve(e.target.result);
		    };
		    reader.onerror = function (e) {
		      reject(e);
		    };
		    reader.readAsArrayBuffer(file);
		  });
		}
		proto._createBuffer = /*#__PURE__*/function () {
		  var _createBuffer2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(file, start, end) {
		    var _file, fileContent;
		    return _regenerator.default.wrap(function _callee5$(_context5) {
		      while (1) switch (_context5.prev = _context5.next) {
		        case 0:
		          if (!(isBlob(file) || isFile(file))) {
		            _context5.next = 8;
		            break;
		          }
		          _file = file.slice(start, end);
		          _context5.next = 4;
		          return getBuffer(_file);
		        case 4:
		          fileContent = _context5.sent;
		          return _context5.abrupt("return", Buffer.from(fileContent));
		        case 8:
		          if (!isBuffer(file)) {
		            _context5.next = 12;
		            break;
		          }
		          return _context5.abrupt("return", file.subarray(start, end));
		        case 12:
		          throw new Error('_createBuffer requires File/Blob/Buffer.');
		        case 13:
		        case "end":
		          return _context5.stop();
		      }
		    }, _callee5);
		  }));
		  function _createBuffer(_x8, _x9, _x10) {
		    return _createBuffer2.apply(this, arguments);
		  }
		  return _createBuffer;
		}();
		proto._getPartSize = function _getPartSize(fileSize, partSize) {
		  var maxNumParts = 10 * 1000;
		  var defaultPartSize = 1 * 1024 * 1024;
		  if (!partSize) partSize = defaultPartSize;
		  var safeSize = Math.ceil(fileSize / maxNumParts);
		  if (partSize < safeSize) {
		    partSize = safeSize;
		    console.warn("partSize has been set to ".concat(partSize, ", because the partSize you provided causes partNumber to be greater than 10,000"));
		  }
		  return partSize;
		};
		proto._divideParts = function _divideParts(fileSize, partSize) {
		  var numParts = Math.ceil(fileSize / partSize);
		  var partOffs = [];
		  for (var i = 0; i < numParts; i++) {
		    var start = partSize * i;
		    var end = Math.min(start + partSize, fileSize);
		    partOffs.push({
		      start: start,
		      end: end
		    });
		  }
		  return partOffs;
		};

		}).call(this);}).call(this,require("buffer").Buffer);
		},{"../common/utils/isBlob":68,"../common/utils/isBuffer":69,"../common/utils/isFile":71,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"buffer":103,"copy-to":107,"core-js/modules/es.array-buffer.slice.js":309,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.filter.js":312,"core-js/modules/es.array.find.js":313,"core-js/modules/es.array.from.js":314,"core-js/modules/es.array.iterator.js":316,"core-js/modules/es.array.map.js":318,"core-js/modules/es.array.slice.js":319,"core-js/modules/es.function.name.js":322,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.promise.js":333,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/es.string.iterator.js":343,"core-js/modules/es.typed-array.copy-within.js":356,"core-js/modules/es.typed-array.every.js":357,"core-js/modules/es.typed-array.fill.js":358,"core-js/modules/es.typed-array.filter.js":359,"core-js/modules/es.typed-array.find-index.js":360,"core-js/modules/es.typed-array.find.js":361,"core-js/modules/es.typed-array.for-each.js":362,"core-js/modules/es.typed-array.includes.js":363,"core-js/modules/es.typed-array.index-of.js":364,"core-js/modules/es.typed-array.iterator.js":365,"core-js/modules/es.typed-array.join.js":366,"core-js/modules/es.typed-array.last-index-of.js":367,"core-js/modules/es.typed-array.map.js":368,"core-js/modules/es.typed-array.reduce-right.js":369,"core-js/modules/es.typed-array.reduce.js":370,"core-js/modules/es.typed-array.reverse.js":371,"core-js/modules/es.typed-array.set.js":372,"core-js/modules/es.typed-array.slice.js":373,"core-js/modules/es.typed-array.some.js":374,"core-js/modules/es.typed-array.sort.js":375,"core-js/modules/es.typed-array.subarray.js":376,"core-js/modules/es.typed-array.to-locale-string.js":377,"core-js/modules/es.typed-array.to-string.js":378,"core-js/modules/es.typed-array.uint8-array.js":379,"mime":430,"path":439,"stream":468,"util":489}],5:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		require("core-js/modules/es.function.name.js");
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		require("core-js/modules/es.array.map.js");
		require("core-js/modules/es.number.constructor.js");
		require("core-js/modules/es.object.assign.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.promise.js");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		// const debug = require('debug')('ali-oss:object');
		var fs = require('fs');
		var copy = require('copy-to');
		var path = require('path');
		var mime = require('mime');
		var callback = require('../common/callback');
		var merge = require('merge-descriptors');
		var _require = require('../common/utils/isBlob'),
		  isBlob = _require.isBlob;
		var _require2 = require('../common/utils/isFile'),
		  isFile = _require2.isFile;
		var _require3 = require('../common/utils/isBuffer'),
		  isBuffer = _require3.isBuffer;
		var _require4 = require('../common/utils/obj2xml'),
		  obj2xml = _require4.obj2xml;
		var _require5 = require('../common/utils/parseRestoreInfo'),
		  parseRestoreInfo = _require5.parseRestoreInfo;

		// var assert = require('assert');

		var proto = exports;

		/**
		 * Object operations
		 */

		/**
		 * append an object from String(file path)/Buffer/ReadableStream
		 * @param {String} name the object key
		 * @param {Mixed} file String(file path)/Buffer/ReadableStream
		 * @param {Object} options
		 * @return {Object}
		 */
		proto.append = /*#__PURE__*/function () {
		  var _append = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, file, options) {
		    var result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = options || {};
		          if (options.position === undefined) options.position = '0';
		          options.subres = {
		            append: '',
		            position: options.position
		          };
		          options.method = 'POST';
		          _context.next = 6;
		          return this.put(name, file, options);
		        case 6:
		          result = _context.sent;
		          result.nextAppendPosition = result.res.headers['x-oss-next-append-position'];
		          return _context.abrupt("return", result);
		        case 9:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function append(_x, _x2, _x3) {
		    return _append.apply(this, arguments);
		  }
		  return append;
		}();

		/**
		 * put an object from String(file path)/Buffer/ReadableStream
		 * @param {String} name the object key
		 * @param {Mixed} file String(file path)/Buffer/ReadableStream
		 * @param {Object} options
		 *        {Object} [options.callback] The callback parameter is composed of a JSON string encoded in Base64
		 *        {String} options.callback.url  the OSS sends a callback request to this URL
		 *        {String} [options.callback.host]  The host header value for initiating callback requests
		 *        {String} options.callback.body  The value of the request body when a callback is initiated
		 *        {String} [options.callback.contentType]  The Content-Type of the callback requests initiated
		 *        {Boolean} [options.callback.callbackSNI] Whether OSS sends SNI to the origin address specified by callbackUrl when a callback request is initiated from the client
		 *        {Object} [options.callback.customValue]  Custom parameters are a map of key-values, e.g:
		 *                  customValue = {
		 *                    key1: 'value1',
		 *                    key2: 'value2'
		 *                  }
		 * @return {Object}
		 */
		proto.put = /*#__PURE__*/function () {
		  var _put = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(name, file, options) {
		    var content, method, params, result, ret;
		    return _regenerator.default.wrap(function _callee2$(_context2) {
		      while (1) switch (_context2.prev = _context2.next) {
		        case 0:
		          options = options || {};
		          options.disabledMD5 = options.disabledMD5 === undefined ? true : !!options.disabledMD5;
		          options.headers = options.headers || {};
		          name = this._objectName(name);
		          if (!isBuffer(file)) {
		            _context2.next = 8;
		            break;
		          }
		          content = file;
		          _context2.next = 19;
		          break;
		        case 8:
		          if (!(isBlob(file) || isFile(file))) {
		            _context2.next = 18;
		            break;
		          }
		          if (!options.mime) {
		            if (isFile(file)) {
		              options.mime = mime.getType(path.extname(file.name));
		            } else {
		              options.mime = file.type;
		            }
		          }
		          _context2.next = 12;
		          return this._createBuffer(file, 0, file.size);
		        case 12:
		          content = _context2.sent;
		          _context2.next = 15;
		          return this._getFileSize(file);
		        case 15:
		          options.contentLength = _context2.sent;
		          _context2.next = 19;
		          break;
		        case 18:
		          throw new TypeError('Must provide Buffer/Blob/File for put.');
		        case 19:
		          this._convertMetaToHeaders(options.meta, options.headers);
		          method = options.method || 'PUT';
		          params = this._objectRequestParams(method, name, options);
		          callback.encodeCallback(params, options);
		          params.mime = options.mime;
		          params.disabledMD5 = options.disabledMD5;
		          params.content = content;
		          params.successStatuses = [200];
		          _context2.next = 29;
		          return this.request(params);
		        case 29:
		          result = _context2.sent;
		          ret = {
		            name: name,
		            url: this._objectUrl(name),
		            res: result.res
		          };
		          if (params.headers && params.headers['x-oss-callback']) {
		            ret.data = JSON.parse(result.data.toString());
		          }
		          return _context2.abrupt("return", ret);
		        case 33:
		        case "end":
		          return _context2.stop();
		      }
		    }, _callee2, this);
		  }));
		  function put(_x4, _x5, _x6) {
		    return _put.apply(this, arguments);
		  }
		  return put;
		}();

		/**
		 * put an object from ReadableStream. If `options.contentLength` is
		 * not provided, chunked encoding is used.
		 * @param {String} name the object key
		 * @param {Readable} stream the ReadableStream
		 * @param {Object} options
		 * @return {Object}
		 */
		proto.putStream = /*#__PURE__*/function () {
		  var _putStream = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(name, stream, options) {
		    var method, params, result, ret;
		    return _regenerator.default.wrap(function _callee3$(_context3) {
		      while (1) switch (_context3.prev = _context3.next) {
		        case 0:
		          options = options || {};
		          options.headers = options.headers || {};
		          name = this._objectName(name);
		          if (options.contentLength) {
		            options.headers['Content-Length'] = options.contentLength;
		          } else {
		            options.headers['Transfer-Encoding'] = 'chunked';
		          }
		          this._convertMetaToHeaders(options.meta, options.headers);
		          method = options.method || 'PUT';
		          params = this._objectRequestParams(method, name, options);
		          callback.encodeCallback(params, options);
		          params.mime = options.mime;
		          params.stream = stream;
		          params.successStatuses = [200];
		          _context3.next = 13;
		          return this.request(params);
		        case 13:
		          result = _context3.sent;
		          ret = {
		            name: name,
		            url: this._objectUrl(name),
		            res: result.res
		          };
		          if (params.headers && params.headers['x-oss-callback']) {
		            ret.data = JSON.parse(result.data.toString());
		          }
		          return _context3.abrupt("return", ret);
		        case 17:
		        case "end":
		          return _context3.stop();
		      }
		    }, _callee3, this);
		  }));
		  function putStream(_x7, _x8, _x9) {
		    return _putStream.apply(this, arguments);
		  }
		  return putStream;
		}();
		merge(proto, require('../common/object/copyObject'));
		merge(proto, require('../common/object/getObjectTagging'));
		merge(proto, require('../common/object/putObjectTagging'));
		merge(proto, require('../common/object/deleteObjectTagging'));
		merge(proto, require('../common/image'));
		merge(proto, require('../common/object/getBucketVersions'));
		merge(proto, require('../common/object/getACL'));
		merge(proto, require('../common/object/putACL'));
		merge(proto, require('../common/object/head'));
		merge(proto, require('../common/object/delete'));
		merge(proto, require('../common/object/get'));
		merge(proto, require('../common/object/putSymlink'));
		merge(proto, require('../common/object/getSymlink'));
		merge(proto, require('../common/object/deleteMulti'));
		merge(proto, require('../common/object/getObjectMeta'));
		merge(proto, require('../common/object/getObjectUrl'));
		merge(proto, require('../common/object/generateObjectUrl'));
		merge(proto, require('../common/object/signatureUrl'));
		merge(proto, require('../common/object/asyncSignatureUrl'));
		merge(proto, require('../common/object/signatureUrlV4'));
		merge(proto, require('../common/object/signPostObjectPolicyV4'));
		proto.putMeta = /*#__PURE__*/function () {
		  var _putMeta = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(name, meta, options) {
		    var copyResult;
		    return _regenerator.default.wrap(function _callee4$(_context4) {
		      while (1) switch (_context4.prev = _context4.next) {
		        case 0:
		          _context4.next = 2;
		          return this.copy(name, name, {
		            meta: meta || {},
		            timeout: options && options.timeout,
		            ctx: options && options.ctx
		          });
		        case 2:
		          copyResult = _context4.sent;
		          return _context4.abrupt("return", copyResult);
		        case 4:
		        case "end":
		          return _context4.stop();
		      }
		    }, _callee4, this);
		  }));
		  function putMeta(_x10, _x11, _x12) {
		    return _putMeta.apply(this, arguments);
		  }
		  return putMeta;
		}();
		proto.list = /*#__PURE__*/function () {
		  var _list = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(query, options) {
		    var params, result, objects, that, prefixes;
		    return _regenerator.default.wrap(function _callee5$(_context5) {
		      while (1) switch (_context5.prev = _context5.next) {
		        case 0:
		          // prefix, marker, max-keys, delimiter
		          params = this._objectRequestParams('GET', '', options);
		          params.query = query;
		          params.xmlResponse = true;
		          params.successStatuses = [200];
		          _context5.next = 6;
		          return this.request(params);
		        case 6:
		          result = _context5.sent;
		          objects = result.data.Contents || [];
		          that = this;
		          if (objects) {
		            if (!Array.isArray(objects)) {
		              objects = [objects];
		            }
		            objects = objects.map(function (obj) {
		              return {
		                name: obj.Key,
		                url: that._objectUrl(obj.Key),
		                lastModified: obj.LastModified,
		                etag: obj.ETag,
		                type: obj.Type,
		                size: Number(obj.Size),
		                storageClass: obj.StorageClass,
		                owner: {
		                  id: obj.Owner.ID,
		                  displayName: obj.Owner.DisplayName
		                },
		                restoreInfo: parseRestoreInfo(obj.RestoreInfo)
		              };
		            });
		          }
		          prefixes = result.data.CommonPrefixes || null;
		          if (prefixes) {
		            if (!Array.isArray(prefixes)) {
		              prefixes = [prefixes];
		            }
		            prefixes = prefixes.map(function (item) {
		              return item.Prefix;
		            });
		          }
		          return _context5.abrupt("return", {
		            res: result.res,
		            objects: objects,
		            prefixes: prefixes,
		            nextMarker: result.data.NextMarker || null,
		            isTruncated: result.data.IsTruncated === 'true'
		          });
		        case 13:
		        case "end":
		          return _context5.stop();
		      }
		    }, _callee5, this);
		  }));
		  function list(_x13, _x14) {
		    return _list.apply(this, arguments);
		  }
		  return list;
		}();
		proto.listV2 = /*#__PURE__*/function () {
		  var _listV = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(query) {
		    var options,
		      continuation_token,
		      params,
		      result,
		      objects,
		      that,
		      prefixes,
		      _args6 = arguments;
		    return _regenerator.default.wrap(function _callee6$(_context6) {
		      while (1) switch (_context6.prev = _context6.next) {
		        case 0:
		          options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
		          continuation_token = query['continuation-token'] || query.continuationToken;
		          if (continuation_token) {
		            options.subres = Object.assign({
		              'continuation-token': continuation_token
		            }, options.subres);
		          }
		          params = this._objectRequestParams('GET', '', options);
		          params.query = Object.assign({
		            'list-type': 2
		          }, query);
		          delete params.query['continuation-token'];
		          delete params.query.continuationToken;
		          params.xmlResponse = true;
		          params.successStatuses = [200];
		          _context6.next = 11;
		          return this.request(params);
		        case 11:
		          result = _context6.sent;
		          objects = result.data.Contents || [];
		          that = this;
		          if (objects) {
		            if (!Array.isArray(objects)) {
		              objects = [objects];
		            }
		            objects = objects.map(function (obj) {
		              var owner = null;
		              if (obj.Owner) {
		                owner = {
		                  id: obj.Owner.ID,
		                  displayName: obj.Owner.DisplayName
		                };
		              }
		              return {
		                name: obj.Key,
		                url: that._objectUrl(obj.Key),
		                lastModified: obj.LastModified,
		                etag: obj.ETag,
		                type: obj.Type,
		                size: Number(obj.Size),
		                storageClass: obj.StorageClass,
		                owner: owner,
		                restoreInfo: parseRestoreInfo(obj.RestoreInfo)
		              };
		            });
		          }
		          prefixes = result.data.CommonPrefixes || null;
		          if (prefixes) {
		            if (!Array.isArray(prefixes)) {
		              prefixes = [prefixes];
		            }
		            prefixes = prefixes.map(function (item) {
		              return item.Prefix;
		            });
		          }
		          return _context6.abrupt("return", {
		            res: result.res,
		            objects: objects,
		            prefixes: prefixes,
		            isTruncated: result.data.IsTruncated === 'true',
		            keyCount: +result.data.KeyCount,
		            continuationToken: result.data.ContinuationToken || null,
		            nextContinuationToken: result.data.NextContinuationToken || null
		          });
		        case 18:
		        case "end":
		          return _context6.stop();
		      }
		    }, _callee6, this);
		  }));
		  function listV2(_x15) {
		    return _listV.apply(this, arguments);
		  }
		  return listV2;
		}();

		/**
		 * Restore Object
		 * @param {String} name the object key
		 * @param {Object} options
		 * @returns {{res}}
		 */
		proto.restore = /*#__PURE__*/function () {
		  var _restore = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(name) {
		    var options,
		      params,
		      paramsXMLObj,
		      result,
		      _args7 = arguments;
		    return _regenerator.default.wrap(function _callee7$(_context7) {
		      while (1) switch (_context7.prev = _context7.next) {
		        case 0:
		          options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {
		            type: 'Archive'
		          };
		          options = options || {};
		          options.subres = Object.assign({
		            restore: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          params = this._objectRequestParams('POST', name, options);
		          paramsXMLObj = {
		            RestoreRequest: {
		              Days: options.Days ? options.Days : 2
		            }
		          };
		          if (options.type === 'ColdArchive' || options.type === 'DeepColdArchive') {
		            paramsXMLObj.RestoreRequest.JobParameters = {
		              Tier: options.JobParameters ? options.JobParameters : 'Standard'
		            };
		          }
		          params.content = obj2xml(paramsXMLObj, {
		            headers: true
		          });
		          params.mime = 'xml';
		          params.successStatuses = [202];
		          _context7.next = 12;
		          return this.request(params);
		        case 12:
		          result = _context7.sent;
		          return _context7.abrupt("return", {
		            res: result.res
		          });
		        case 14:
		        case "end":
		          return _context7.stop();
		      }
		    }, _callee7, this);
		  }));
		  function restore(_x16) {
		    return _restore.apply(this, arguments);
		  }
		  return restore;
		}();
		proto._objectUrl = function _objectUrl(name) {
		  return this._getReqUrl({
		    bucket: this.options.bucket,
		    object: name
		  });
		};

		/**
		 * generator request params
		 * @return {Object} params
		 *
		 * @api private
		 */

		proto._objectRequestParams = function _objectRequestParams(method, name, options) {
		  if (!this.options.bucket && !this.options.cname) {
		    throw new Error('Please create a bucket first');
		  }
		  options = options || {};
		  name = this._objectName(name);
		  var params = {
		    object: name,
		    bucket: this.options.bucket,
		    method: method,
		    subres: options && options.subres,
		    additionalHeaders: options && options.additionalHeaders,
		    timeout: options && options.timeout,
		    ctx: options && options.ctx
		  };
		  if (options.headers) {
		    params.headers = {};
		    copy(options.headers).to(params.headers);
		  }
		  return params;
		};
		proto._objectName = function _objectName(name) {
		  return name.replace(/^\/+/, '');
		};
		proto._convertMetaToHeaders = function _convertMetaToHeaders(meta, headers) {
		  if (!meta) {
		    return;
		  }
		  Object.keys(meta).forEach(function (k) {
		    headers["x-oss-meta-".concat(k)] = meta[k];
		  });
		};
		proto._deleteFileSafe = function _deleteFileSafe(filepath) {
		  var _this = this;
		  return new Promise(function (resolve) {
		    fs.exists(filepath, function (exists) {
		      if (!exists) {
		        resolve();
		      } else {
		        fs.unlink(filepath, function (err) {
		          if (err) {
		            _this.debug('unlink %j error: %s', filepath, err, 'error');
		          }
		          resolve();
		        });
		      }
		    });
		  });
		};

		},{"../common/callback":24,"../common/image":27,"../common/object/asyncSignatureUrl":31,"../common/object/copyObject":32,"../common/object/delete":33,"../common/object/deleteMulti":34,"../common/object/deleteObjectTagging":35,"../common/object/generateObjectUrl":36,"../common/object/get":37,"../common/object/getACL":38,"../common/object/getBucketVersions":39,"../common/object/getObjectMeta":40,"../common/object/getObjectTagging":41,"../common/object/getObjectUrl":42,"../common/object/getSymlink":43,"../common/object/head":44,"../common/object/putACL":45,"../common/object/putObjectTagging":46,"../common/object/putSymlink":47,"../common/object/signPostObjectPolicyV4":48,"../common/object/signatureUrl":49,"../common/object/signatureUrlV4":50,"../common/utils/isBlob":68,"../common/utils/isBuffer":69,"../common/utils/isFile":71,"../common/utils/obj2xml":76,"../common/utils/parseRestoreInfo":78,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"copy-to":107,"core-js/modules/es.array.map.js":318,"core-js/modules/es.function.name.js":322,"core-js/modules/es.number.constructor.js":324,"core-js/modules/es.object.assign.js":325,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.promise.js":333,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/es.string.replace.js":345,"core-js/modules/web.dom-collections.for-each.js":380,"fs":102,"merge-descriptors":428,"mime":430,"path":439}],6:[function(require,module,exports){

		exports.version = '6.22.0';

		},{}],7:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.abortBucketWorm = void 0;
		var checkBucketName_1 = require("../utils/checkBucketName");
		function abortBucketWorm(_x, _x2) {
		  return _abortBucketWorm.apply(this, arguments);
		}
		function _abortBucketWorm() {
		  _abortBucketWorm = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          checkBucketName_1.checkBucketName(name);
		          params = this._bucketRequestParams('DELETE', name, 'worm', options);
		          _context.next = 4;
		          return this.request(params);
		        case 4:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res,
		            status: result.status
		          });
		        case 6:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _abortBucketWorm.apply(this, arguments);
		}
		exports.abortBucketWorm = abortBucketWorm;

		},{"../utils/checkBucketName":53,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93}],8:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.completeBucketWorm = void 0;
		var checkBucketName_1 = require("../utils/checkBucketName");
		function completeBucketWorm(_x, _x2, _x3) {
		  return _completeBucketWorm.apply(this, arguments);
		}
		function _completeBucketWorm() {
		  _completeBucketWorm = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, wormId, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          checkBucketName_1.checkBucketName(name);
		          params = this._bucketRequestParams('POST', name, {
		            wormId: wormId
		          }, options);
		          _context.next = 4;
		          return this.request(params);
		        case 4:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res,
		            status: result.status
		          });
		        case 6:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _completeBucketWorm.apply(this, arguments);
		}
		exports.completeBucketWorm = completeBucketWorm;

		},{"../utils/checkBucketName":53,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93}],9:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.deleteBucketInventory = void 0;
		var checkBucketName_1 = require("../utils/checkBucketName");
		/**
		 * deleteBucketInventory
		 * @param {String} bucketName - bucket name
		 * @param {String} inventoryId
		 * @param {Object} options
		 */
		function deleteBucketInventory(_x, _x2) {
		  return _deleteBucketInventory.apply(this, arguments);
		}
		function _deleteBucketInventory() {
		  _deleteBucketInventory = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(bucketName, inventoryId) {
		    var options,
		      subres,
		      params,
		      result,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
		          subres = Object.assign({
		            inventory: '',
		            inventoryId: inventoryId
		          }, options.subres);
		          checkBucketName_1.checkBucketName(bucketName);
		          params = this._bucketRequestParams('DELETE', bucketName, subres, options);
		          params.successStatuses = [204];
		          _context.next = 7;
		          return this.request(params);
		        case 7:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            status: result.status,
		            res: result.res
		          });
		        case 9:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _deleteBucketInventory.apply(this, arguments);
		}
		exports.deleteBucketInventory = deleteBucketInventory;

		},{"../utils/checkBucketName":53,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],10:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var proto = exports;
		proto.deleteBucketLifecycle = /*#__PURE__*/function () {
		  var _deleteBucketLifecycle = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          _checkBucketName(name);
		          params = this._bucketRequestParams('DELETE', name, 'lifecycle', options);
		          params.successStatuses = [204];
		          _context.next = 5;
		          return this.request(params);
		        case 5:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res
		          });
		        case 7:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function deleteBucketLifecycle(_x, _x2) {
		    return _deleteBucketLifecycle.apply(this, arguments);
		  }
		  return deleteBucketLifecycle;
		}();

		},{"../utils/checkBucketName":53,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93}],11:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var proto = exports;
		proto.deleteBucketWebsite = /*#__PURE__*/function () {
		  var _deleteBucketWebsite = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          _checkBucketName(name);
		          params = this._bucketRequestParams('DELETE', name, 'website', options);
		          params.successStatuses = [204];
		          _context.next = 5;
		          return this.request(params);
		        case 5:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res
		          });
		        case 7:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function deleteBucketWebsite(_x, _x2) {
		    return _deleteBucketWebsite.apply(this, arguments);
		  }
		  return deleteBucketWebsite;
		}();

		},{"../utils/checkBucketName":53,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93}],12:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.extendBucketWorm = void 0;
		var checkBucketName_1 = require("../utils/checkBucketName");
		var obj2xml_1 = require("../utils/obj2xml");
		function extendBucketWorm(_x, _x2, _x3, _x4) {
		  return _extendBucketWorm.apply(this, arguments);
		}
		function _extendBucketWorm() {
		  _extendBucketWorm = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, wormId, days, options) {
		    var params, paramlXMLObJ, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          checkBucketName_1.checkBucketName(name);
		          params = this._bucketRequestParams('POST', name, {
		            wormExtend: '',
		            wormId: wormId
		          }, options);
		          paramlXMLObJ = {
		            ExtendWormConfiguration: {
		              RetentionPeriodInDays: days
		            }
		          };
		          params.mime = 'xml';
		          params.content = obj2xml_1.obj2xml(paramlXMLObJ, {
		            headers: true
		          });
		          params.successStatuses = [200];
		          _context.next = 8;
		          return this.request(params);
		        case 8:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res,
		            status: result.status
		          });
		        case 10:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _extendBucketWorm.apply(this, arguments);
		}
		exports.extendBucketWorm = extendBucketWorm;

		},{"../utils/checkBucketName":53,"../utils/obj2xml":76,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93}],13:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.getBucketInventory = void 0;
		var checkBucketName_1 = require("../utils/checkBucketName");
		var formatInventoryConfig_1 = require("../utils/formatInventoryConfig");
		/**
		 * getBucketInventory
		 * @param {String} bucketName - bucket name
		 * @param {String} inventoryId
		 * @param {Object} options
		 */
		function getBucketInventory(_x, _x2) {
		  return _getBucketInventory.apply(this, arguments);
		}
		function _getBucketInventory() {
		  _getBucketInventory = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(bucketName, inventoryId) {
		    var options,
		      subres,
		      params,
		      result,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
		          subres = Object.assign({
		            inventory: '',
		            inventoryId: inventoryId
		          }, options.subres);
		          checkBucketName_1.checkBucketName(bucketName);
		          params = this._bucketRequestParams('GET', bucketName, subres, options);
		          params.successStatuses = [200];
		          params.xmlResponse = true;
		          _context.next = 8;
		          return this.request(params);
		        case 8:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            status: result.status,
		            res: result.res,
		            inventory: formatInventoryConfig_1.formatInventoryConfig(result.data)
		          });
		        case 10:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _getBucketInventory.apply(this, arguments);
		}
		exports.getBucketInventory = getBucketInventory;

		},{"../utils/checkBucketName":53,"../utils/formatInventoryConfig":63,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],14:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.array.map.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var _require2 = require('../utils/isArray'),
		  isArray = _require2.isArray;
		var _require3 = require('../utils/formatObjKey'),
		  formatObjKey = _require3.formatObjKey;
		var proto = exports;
		proto.getBucketLifecycle = /*#__PURE__*/function () {
		  var _getBucketLifecycle = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, options) {
		    var params, result, rules;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          _checkBucketName(name);
		          params = this._bucketRequestParams('GET', name, 'lifecycle', options);
		          params.successStatuses = [200];
		          params.xmlResponse = true;
		          _context.next = 6;
		          return this.request(params);
		        case 6:
		          result = _context.sent;
		          rules = result.data.Rule || null;
		          if (rules) {
		            if (!isArray(rules)) {
		              rules = [rules];
		            }
		            rules = rules.map(function (_) {
		              if (_.ID) {
		                _.id = _.ID;
		                delete _.ID;
		              }
		              if (_.Tag && !isArray(_.Tag)) {
		                _.Tag = [_.Tag];
		              }
		              return formatObjKey(_, 'firstLowerCase');
		            });
		          }
		          return _context.abrupt("return", {
		            rules: rules,
		            res: result.res
		          });
		        case 10:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function getBucketLifecycle(_x, _x2) {
		    return _getBucketLifecycle.apply(this, arguments);
		  }
		  return getBucketLifecycle;
		}();

		},{"../utils/checkBucketName":53,"../utils/formatObjKey":64,"../utils/isArray":67,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.array.map.js":318}],15:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var proto = exports;
		/**
		 * getBucketVersioning
		 * @param {String} bucketName - bucket name
		 */

		proto.getBucketVersioning = /*#__PURE__*/function () {
		  var _getBucketVersioning = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(bucketName, options) {
		    var params, result, versionStatus;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          _checkBucketName(bucketName);
		          params = this._bucketRequestParams('GET', bucketName, 'versioning', options);
		          params.xmlResponse = true;
		          params.successStatuses = [200];
		          _context.next = 6;
		          return this.request(params);
		        case 6:
		          result = _context.sent;
		          versionStatus = result.data.Status;
		          return _context.abrupt("return", {
		            status: result.status,
		            versionStatus: versionStatus,
		            res: result.res
		          });
		        case 9:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function getBucketVersioning(_x, _x2) {
		    return _getBucketVersioning.apply(this, arguments);
		  }
		  return getBucketVersioning;
		}();

		},{"../utils/checkBucketName":53,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93}],16:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var _require2 = require('../utils/isObject'),
		  isObject = _require2.isObject;
		var proto = exports;
		proto.getBucketWebsite = /*#__PURE__*/function () {
		  var _getBucketWebsite = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, options) {
		    var params, result, routingRules;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          _checkBucketName(name);
		          params = this._bucketRequestParams('GET', name, 'website', options);
		          params.successStatuses = [200];
		          params.xmlResponse = true;
		          _context.next = 6;
		          return this.request(params);
		        case 6:
		          result = _context.sent;
		          routingRules = [];
		          if (result.data.RoutingRules && result.data.RoutingRules.RoutingRule) {
		            if (isObject(result.data.RoutingRules.RoutingRule)) {
		              routingRules = [result.data.RoutingRules.RoutingRule];
		            } else {
		              routingRules = result.data.RoutingRules.RoutingRule;
		            }
		          }
		          return _context.abrupt("return", {
		            index: result.data.IndexDocument && result.data.IndexDocument.Suffix || '',
		            supportSubDir: result.data.IndexDocument && result.data.IndexDocument.SupportSubDir || 'false',
		            type: result.data.IndexDocument && result.data.IndexDocument.Type,
		            routingRules: routingRules,
		            error: result.data.ErrorDocument && result.data.ErrorDocument.Key || null,
		            res: result.res
		          });
		        case 10:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function getBucketWebsite(_x, _x2) {
		    return _getBucketWebsite.apply(this, arguments);
		  }
		  return getBucketWebsite;
		}();

		},{"../utils/checkBucketName":53,"../utils/isObject":74,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93}],17:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.getBucketWorm = void 0;
		var checkBucketName_1 = require("../utils/checkBucketName");
		var dataFix_1 = require("../utils/dataFix");
		function getBucketWorm(_x, _x2) {
		  return _getBucketWorm.apply(this, arguments);
		}
		function _getBucketWorm() {
		  _getBucketWorm = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          checkBucketName_1.checkBucketName(name);
		          params = this._bucketRequestParams('GET', name, 'worm', options);
		          params.successStatuses = [200];
		          params.xmlResponse = true;
		          _context.next = 6;
		          return this.request(params);
		        case 6:
		          result = _context.sent;
		          dataFix_1.dataFix(result.data, {
		            lowerFirst: true,
		            rename: {
		              RetentionPeriodInDays: 'days'
		            }
		          });
		          return _context.abrupt("return", Object.assign(Object.assign({}, result.data), {
		            res: result.res,
		            status: result.status
		          }));
		        case 9:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _getBucketWorm.apply(this, arguments);
		}
		exports.getBucketWorm = getBucketWorm;

		},{"../utils/checkBucketName":53,"../utils/dataFix":59,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],18:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.initiateBucketWorm = void 0;
		var obj2xml_1 = require("../utils/obj2xml");
		var checkBucketName_1 = require("../utils/checkBucketName");
		function initiateBucketWorm(_x, _x2, _x3) {
		  return _initiateBucketWorm.apply(this, arguments);
		}
		function _initiateBucketWorm() {
		  _initiateBucketWorm = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, days, options) {
		    var params, paramlXMLObJ, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          checkBucketName_1.checkBucketName(name);
		          params = this._bucketRequestParams('POST', name, 'worm', options);
		          paramlXMLObJ = {
		            InitiateWormConfiguration: {
		              RetentionPeriodInDays: days
		            }
		          };
		          params.mime = 'xml';
		          params.content = obj2xml_1.obj2xml(paramlXMLObJ, {
		            headers: true
		          });
		          params.successStatuses = [200];
		          _context.next = 8;
		          return this.request(params);
		        case 8:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res,
		            wormId: result.res.headers['x-oss-worm-id'],
		            status: result.status
		          });
		        case 10:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _initiateBucketWorm.apply(this, arguments);
		}
		exports.initiateBucketWorm = initiateBucketWorm;

		},{"../utils/checkBucketName":53,"../utils/obj2xml":76,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93}],19:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.listBucketInventory = void 0;
		var checkBucketName_1 = require("../utils/checkBucketName");
		var formatInventoryConfig_1 = require("../utils/formatInventoryConfig");
		/**
		 * listBucketInventory
		 * @param {String} bucketName - bucket name
		 * @param {String} inventoryId
		 * @param {Object} options
		 */
		function listBucketInventory(_x) {
		  return _listBucketInventory.apply(this, arguments);
		}
		function _listBucketInventory() {
		  _listBucketInventory = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(bucketName) {
		    var options,
		      continuationToken,
		      subres,
		      params,
		      result,
		      data,
		      res,
		      status,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
		          continuationToken = options.continuationToken;
		          subres = Object.assign({
		            inventory: ''
		          }, continuationToken && {
		            'continuation-token': continuationToken
		          }, options.subres);
		          checkBucketName_1.checkBucketName(bucketName);
		          params = this._bucketRequestParams('GET', bucketName, subres, options);
		          params.successStatuses = [200];
		          params.xmlResponse = true;
		          _context.next = 9;
		          return this.request(params);
		        case 9:
		          result = _context.sent;
		          data = result.data, res = result.res, status = result.status;
		          return _context.abrupt("return", {
		            isTruncated: data.IsTruncated === 'true',
		            nextContinuationToken: data.NextContinuationToken,
		            inventoryList: formatInventoryConfig_1.formatInventoryConfig(data.InventoryConfiguration, true),
		            status: status,
		            res: res
		          });
		        case 12:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _listBucketInventory.apply(this, arguments);
		}
		exports.listBucketInventory = listBucketInventory;

		},{"../utils/checkBucketName":53,"../utils/formatInventoryConfig":63,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],20:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		require("core-js/modules/es.array.concat.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.putBucketInventory = void 0;
		var checkBucketName_1 = require("../utils/checkBucketName");
		var obj2xml_1 = require("../utils/obj2xml");
		/**
		 * putBucketInventory
		 * @param {String} bucketName - bucket name
		 * @param {Inventory} inventory
		 * @param {Object} options
		 */
		function putBucketInventory(_x, _x2) {
		  return _putBucketInventory.apply(this, arguments);
		}
		function _putBucketInventory() {
		  _putBucketInventory = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(bucketName, inventory) {
		    var options,
		      subres,
		      OSSBucketDestination,
		      optionalFields,
		      includedObjectVersions,
		      destinationBucketPrefix,
		      rolePrefix,
		      paramXMLObj,
		      paramXML,
		      params,
		      result,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
		          subres = Object.assign({
		            inventory: '',
		            inventoryId: inventory.id
		          }, options.subres);
		          checkBucketName_1.checkBucketName(bucketName);
		          OSSBucketDestination = inventory.OSSBucketDestination, optionalFields = inventory.optionalFields, includedObjectVersions = inventory.includedObjectVersions;
		          destinationBucketPrefix = 'acs:oss:::';
		          rolePrefix = "acs:ram::".concat(OSSBucketDestination.accountId, ":role/");
		          paramXMLObj = {
		            InventoryConfiguration: {
		              Id: inventory.id,
		              IsEnabled: inventory.isEnabled,
		              Filter: {
		                Prefix: inventory.prefix || ''
		              },
		              Destination: {
		                OSSBucketDestination: {
		                  Format: OSSBucketDestination.format,
		                  AccountId: OSSBucketDestination.accountId,
		                  RoleArn: "".concat(rolePrefix).concat(OSSBucketDestination.rolename),
		                  Bucket: "".concat(destinationBucketPrefix).concat(OSSBucketDestination.bucket),
		                  Prefix: OSSBucketDestination.prefix || '',
		                  Encryption: OSSBucketDestination.encryption || ''
		                }
		              },
		              Schedule: {
		                Frequency: inventory.frequency
		              },
		              IncludedObjectVersions: includedObjectVersions,
		              OptionalFields: {
		                Field: (optionalFields === null || optionalFields === void 0 ? void 0 : optionalFields.field) || []
		              }
		            }
		          };
		          paramXML = obj2xml_1.obj2xml(paramXMLObj, {
		            headers: true,
		            firstUpperCase: true
		          });
		          params = this._bucketRequestParams('PUT', bucketName, subres, options);
		          params.successStatuses = [200];
		          params.mime = 'xml';
		          params.content = paramXML;
		          _context.next = 14;
		          return this.request(params);
		        case 14:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            status: result.status,
		            res: result.res
		          });
		        case 16:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _putBucketInventory.apply(this, arguments);
		}
		exports.putBucketInventory = putBucketInventory;

		},{"../utils/checkBucketName":53,"../utils/obj2xml":76,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.object.assign.js":325}],21:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.array.includes.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		/* eslint-disable no-use-before-define */
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var _require2 = require('../utils/isArray'),
		  isArray = _require2.isArray;
		var _require3 = require('../utils/deepCopy'),
		  deepCopy = _require3.deepCopy;
		var _require4 = require('../utils/isObject'),
		  isObject = _require4.isObject;
		var _require5 = require('../utils/obj2xml'),
		  obj2xml = _require5.obj2xml;
		var _require6 = require('../utils/checkObjectTag'),
		  checkObjectTag = _require6.checkObjectTag;
		var _require7 = require('../utils/getStrBytesCount'),
		  getStrBytesCount = _require7.getStrBytesCount;
		var proto = exports;
		proto.putBucketLifecycle = /*#__PURE__*/function () {
		  var _putBucketLifecycle = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, rules, options) {
		    var params, Rule, paramXMLObj, paramXML, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          _checkBucketName(name);
		          if (isArray(rules)) {
		            _context.next = 3;
		            break;
		          }
		          throw new Error('rules must be Array');
		        case 3:
		          params = this._bucketRequestParams('PUT', name, 'lifecycle', options);
		          Rule = [];
		          paramXMLObj = {
		            LifecycleConfiguration: {
		              Rule: Rule
		            }
		          };
		          rules.forEach(function (_) {
		            defaultDaysAndDate2Expiration(_); // todo delete, 兼容旧版本
		            checkRule(_);
		            if (_.id) {
		              _.ID = _.id;
		              delete _.id;
		            }
		            Rule.push(_);
		          });
		          paramXML = obj2xml(paramXMLObj, {
		            headers: true,
		            firstUpperCase: true
		          });
		          params.content = paramXML;
		          params.mime = 'xml';
		          params.successStatuses = [200];
		          _context.next = 13;
		          return this.request(params);
		        case 13:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res
		          });
		        case 15:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function putBucketLifecycle(_x, _x2, _x3) {
		    return _putBucketLifecycle.apply(this, arguments);
		  }
		  return putBucketLifecycle;
		}();

		// todo delete, 兼容旧版本
		function defaultDaysAndDate2Expiration(obj) {
		  if (obj.days) {
		    obj.expiration = {
		      days: obj.days
		    };
		  }
		  if (obj.date) {
		    obj.expiration = {
		      createdBeforeDate: obj.date
		    };
		  }
		}
		function checkDaysAndDate(obj, key) {
		  var days = obj.days,
		    createdBeforeDate = obj.createdBeforeDate;
		  if (!days && !createdBeforeDate) {
		    throw new Error("".concat(key, " must includes days or createdBeforeDate"));
		  } else if (days && (isArray(days) || !/^[1-9][0-9]*$/.test(days))) {
		    throw new Error('days must be a positive integer');
		  } else if (createdBeforeDate && !/\d{4}-\d{2}-\d{2}T00:00:00.000Z/.test(createdBeforeDate)) {
		    throw new Error('createdBeforeDate must be date and conform to iso8601 format');
		  }
		}
		function checkNoncurrentDays(obj, key) {
		  var noncurrentDays = obj.noncurrentDays;
		  if (!noncurrentDays) {
		    throw new Error("".concat(key, " must includes noncurrentDays"));
		  } else if (noncurrentDays && (isArray(noncurrentDays) || !/^[1-9][0-9]*$/.test(noncurrentDays))) {
		    throw new Error('noncurrentDays must be a positive integer');
		  }
		}
		function handleCheckTag(tag) {
		  if (!isArray(tag) && !isObject(tag)) {
		    throw new Error('tag must be Object or Array');
		  }
		  tag = isObject(tag) ? [tag] : tag;
		  var tagObj = {};
		  var tagClone = deepCopy(tag);
		  tagClone.forEach(function (v) {
		    tagObj[v.key] = v.value;
		  });
		  checkObjectTag(tagObj);
		}
		function checkStorageClass(storageClass) {
		  if (!['IA', 'Archive', 'ColdArchive', 'DeepColdArchive'].includes(storageClass)) throw new Error("StorageClass must be IA or Archive or ColdArchive or DeepColdArchive");
		}
		function checkRule(rule) {
		  if (rule.id && getStrBytesCount(rule.id) > 255) throw new Error('ID is composed of 255 bytes at most');
		  if (rule.prefix === undefined) throw new Error('Rule must includes prefix');
		  if (!['Enabled', 'Disabled'].includes(rule.status)) throw new Error('Status must be Enabled or Disabled');
		  if (!rule.expiration && !rule.noncurrentVersionExpiration && !rule.abortMultipartUpload && !rule.transition && !rule.noncurrentVersionTransition) {
		    throw new Error('Rule must includes expiration or noncurrentVersionExpiration or abortMultipartUpload or transition or noncurrentVersionTransition');
		  }
		  if (rule.transition) {
		    checkStorageClass(rule.transition.storageClass);
		    checkDaysAndDate(rule.transition, 'Transition');
		  }
		  if (rule.expiration) {
		    if (!rule.expiration.expiredObjectDeleteMarker) {
		      checkDaysAndDate(rule.expiration, 'Expiration');
		    } else if (rule.expiration.days || rule.expiration.createdBeforeDate) {
		      throw new Error('expiredObjectDeleteMarker cannot be used with days or createdBeforeDate');
		    }
		  }
		  if (rule.abortMultipartUpload) {
		    checkDaysAndDate(rule.abortMultipartUpload, 'AbortMultipartUpload');
		  }
		  if (rule.noncurrentVersionTransition) {
		    checkStorageClass(rule.noncurrentVersionTransition.storageClass);
		    checkNoncurrentDays(rule.noncurrentVersionTransition, 'NoncurrentVersionTransition');
		  }
		  if (rule.noncurrentVersionExpiration) {
		    checkNoncurrentDays(rule.noncurrentVersionExpiration, 'NoncurrentVersionExpiration');
		  }
		  if (rule.tag) {
		    if (rule.abortMultipartUpload) {
		      throw new Error('Tag cannot be used with abortMultipartUpload');
		    }
		    handleCheckTag(rule.tag);
		  }
		}

		},{"../utils/checkBucketName":53,"../utils/checkObjectTag":56,"../utils/deepCopy":60,"../utils/getStrBytesCount":66,"../utils/isArray":67,"../utils/isObject":74,"../utils/obj2xml":76,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.array.includes.js":315,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/web.dom-collections.for-each.js":380}],22:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.array.includes.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var _require2 = require('../utils/obj2xml'),
		  obj2xml = _require2.obj2xml;
		var proto = exports;
		/**
		 * putBucketVersioning
		 * @param {String} name - bucket name
		 * @param {String} status
		 * @param {Object} options
		 */

		proto.putBucketVersioning = /*#__PURE__*/function () {
		  var _putBucketVersioning = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, status) {
		    var options,
		      params,
		      paramXMLObj,
		      result,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
		          _checkBucketName(name);
		          if (['Enabled', 'Suspended'].includes(status)) {
		            _context.next = 4;
		            break;
		          }
		          throw new Error('status must be Enabled or Suspended');
		        case 4:
		          params = this._bucketRequestParams('PUT', name, 'versioning', options);
		          paramXMLObj = {
		            VersioningConfiguration: {
		              Status: status
		            }
		          };
		          params.mime = 'xml';
		          params.content = obj2xml(paramXMLObj, {
		            headers: true
		          });
		          _context.next = 10;
		          return this.request(params);
		        case 10:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res,
		            status: result.status
		          });
		        case 12:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function putBucketVersioning(_x, _x2) {
		    return _putBucketVersioning.apply(this, arguments);
		  }
		  return putBucketVersioning;
		}();

		},{"../utils/checkBucketName":53,"../utils/obj2xml":76,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.array.includes.js":315}],23:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var _require2 = require('../utils/obj2xml'),
		  obj2xml = _require2.obj2xml;
		var _require3 = require('../utils/isArray'),
		  isArray = _require3.isArray;
		var proto = exports;
		proto.putBucketWebsite = /*#__PURE__*/function () {
		  var _putBucketWebsite = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name) {
		    var config,
		      options,
		      params,
		      IndexDocument,
		      WebsiteConfiguration,
		      website,
		      result,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          config = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
		          options = _args.length > 2 ? _args[2] : undefined;
		          _checkBucketName(name);
		          params = this._bucketRequestParams('PUT', name, 'website', options);
		          IndexDocument = {
		            Suffix: config.index || 'index.html'
		          };
		          WebsiteConfiguration = {
		            IndexDocument: IndexDocument
		          };
		          website = {
		            WebsiteConfiguration: WebsiteConfiguration
		          };
		          if (config.supportSubDir) {
		            IndexDocument.SupportSubDir = config.supportSubDir;
		          }
		          if (config.type) {
		            IndexDocument.Type = config.type;
		          }
		          if (config.error) {
		            WebsiteConfiguration.ErrorDocument = {
		              Key: config.error
		            };
		          }
		          if (!(config.routingRules !== undefined)) {
		            _context.next = 14;
		            break;
		          }
		          if (isArray(config.routingRules)) {
		            _context.next = 13;
		            break;
		          }
		          throw new Error('RoutingRules must be Array');
		        case 13:
		          WebsiteConfiguration.RoutingRules = {
		            RoutingRule: config.routingRules
		          };
		        case 14:
		          website = obj2xml(website);
		          params.content = website;
		          params.mime = 'xml';
		          params.successStatuses = [200];
		          _context.next = 20;
		          return this.request(params);
		        case 20:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res
		          });
		        case 22:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function putBucketWebsite(_x) {
		    return _putBucketWebsite.apply(this, arguments);
		  }
		  return putBucketWebsite;
		}();

		},{"../utils/checkBucketName":53,"../utils/isArray":67,"../utils/obj2xml":76,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93}],24:[function(require,module,exports){
		(function (Buffer){(function (){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		exports.encodeCallback = function encodeCallback(reqParams, options) {
		  reqParams.headers = reqParams.headers || {};
		  if (!Object.prototype.hasOwnProperty.call(reqParams.headers, 'x-oss-callback')) {
		    if (options.callback) {
		      var json = {
		        callbackUrl: encodeURI(options.callback.url),
		        callbackBody: options.callback.body
		      };
		      if (options.callback.host) {
		        json.callbackHost = options.callback.host;
		      }
		      if (options.callback.contentType) {
		        json.callbackBodyType = options.callback.contentType;
		      }
		      if (options.callback.callbackSNI) {
		        json.callbackSNI = options.callback.callbackSNI;
		      }
		      var callback = Buffer.from(JSON.stringify(json)).toString('base64');
		      reqParams.headers['x-oss-callback'] = callback;
		      if (options.callback.customValue) {
		        var callbackVar = {};
		        Object.keys(options.callback.customValue).forEach(function (key) {
		          callbackVar["x:".concat(key)] = options.callback.customValue[key].toString();
		        });
		        reqParams.headers['x-oss-callback-var'] = Buffer.from(JSON.stringify(callbackVar)).toString('base64');
		      }
		    }
		  }
		};

		}).call(this);}).call(this,require("buffer").Buffer);
		},{"buffer":103,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/web.dom-collections.for-each.js":380}],25:[function(require,module,exports){

		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		var __importDefault = function (mod) {
		  return mod && mod.__esModule ? mod : {
		    "default": mod
		  };
		};
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.getReqUrl = void 0;
		var copy_to_1 = __importDefault(require("copy-to"));
		var url_1 = __importDefault(require("url"));
		var merge_descriptors_1 = __importDefault(require("merge-descriptors"));
		var is_type_of_1 = __importDefault(require("is-type-of"));
		var isIP_1 = require("../utils/isIP");
		var checkConfigValid_1 = require("../utils/checkConfigValid");
		function getReqUrl(params) {
		  var ep = {};
		  var isCname = this.options.cname;
		  checkConfigValid_1.checkConfigValid(this.options.endpoint, 'endpoint');
		  copy_to_1.default(this.options.endpoint, false).to(ep);
		  if (params.bucket && !isCname && !isIP_1.isIP(ep.hostname) && !this.options.sldEnable) {
		    ep.host = "".concat(params.bucket, ".").concat(ep.host);
		  }
		  var resourcePath = '/';
		  if (params.bucket && this.options.sldEnable) {
		    resourcePath += "".concat(params.bucket, "/");
		  }
		  if (params.object) {
		    // Preserve '/' in result url
		    resourcePath += this._escape(params.object).replace(/\+/g, '%2B');
		  }
		  ep.pathname = resourcePath;
		  var query = {};
		  if (params.query) {
		    merge_descriptors_1.default(query, params.query);
		  }
		  if (params.subres) {
		    var subresAsQuery = {};
		    if (is_type_of_1.default.string(params.subres)) {
		      subresAsQuery[params.subres] = '';
		    } else if (is_type_of_1.default.array(params.subres)) {
		      params.subres.forEach(function (k) {
		        subresAsQuery[k] = '';
		      });
		    } else {
		      subresAsQuery = params.subres;
		    }
		    merge_descriptors_1.default(query, subresAsQuery);
		  }
		  ep.query = query;
		  return url_1.default.format(ep);
		}
		exports.getReqUrl = getReqUrl;

		},{"../utils/checkConfigValid":54,"../utils/isIP":73,"copy-to":107,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.replace.js":345,"core-js/modules/web.dom-collections.for-each.js":380,"is-type-of":537,"merge-descriptors":428,"url":543}],26:[function(require,module,exports){

		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.object.assign.js");
		require("core-js/modules/es.string.trim.js");
		var ms = require('humanize-ms');
		var urlutil = require('url');
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var _require2 = require('../utils/setRegion'),
		  setRegion = _require2.setRegion;
		var _require3 = require('../utils/checkConfigValid'),
		  checkConfigValid = _require3.checkConfigValid;
		function setEndpoint(endpoint, secure) {
		  checkConfigValid(endpoint, 'endpoint');
		  var url = urlutil.parse(endpoint);
		  if (!url.protocol) {
		    url = urlutil.parse("http".concat(secure ? 's' : '', "://").concat(endpoint));
		  }
		  if (url.protocol !== 'http:' && url.protocol !== 'https:') {
		    throw new Error('Endpoint protocol must be http or https.');
		  }
		  return url;
		}
		module.exports = function (options) {
		  if (!options || !options.accessKeyId || !options.accessKeySecret) {
		    throw new Error('require accessKeyId, accessKeySecret');
		  }
		  if (options.stsToken && !options.refreshSTSToken && !options.refreshSTSTokenInterval) {
		    console.warn("It's recommended to set 'refreshSTSToken' and 'refreshSTSTokenInterval' to refresh" + ' stsToken、accessKeyId、accessKeySecret automatically when sts token has expired');
		  }
		  if (options.bucket) {
		    _checkBucketName(options.bucket);
		  }
		  var opts = Object.assign({
		    region: 'oss-cn-hangzhou',
		    internal: false,
		    secure: false,
		    timeout: 60000,
		    bucket: null,
		    endpoint: null,
		    cname: false,
		    isRequestPay: false,
		    sldEnable: false,
		    headerEncoding: 'utf-8',
		    refreshSTSToken: null,
		    refreshSTSTokenInterval: 60000 * 5,
		    retryMax: 0,
		    authorizationV4: false // 启用v4签名，默认关闭
		  }, options);
		  opts.accessKeyId = opts.accessKeyId.trim();
		  opts.accessKeySecret = opts.accessKeySecret.trim();
		  if (opts.timeout) {
		    opts.timeout = ms(opts.timeout);
		  }
		  if (opts.endpoint) {
		    opts.endpoint = setEndpoint(opts.endpoint, opts.secure);
		  } else if (opts.region) {
		    opts.endpoint = setRegion(opts.region, opts.internal, opts.secure);
		  } else {
		    throw new Error('require options.endpoint or options.region');
		  }
		  opts.inited = true;
		  return opts;
		};

		},{"../utils/checkBucketName":53,"../utils/checkConfigValid":54,"../utils/setRegion":81,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.object.assign.js":325,"core-js/modules/es.string.trim.js":349,"humanize-ms":399,"url":543}],27:[function(require,module,exports){

		var merge = require('merge-descriptors');
		var proto = exports;
		merge(proto, require('./processObjectSave'));

		},{"./processObjectSave":28,"merge-descriptors":428}],28:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.array.concat.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		/* eslint-disable no-use-before-define */
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var querystring = require('querystring');
		var _require2 = require('js-base64'),
		  str2Base64 = _require2.Base64.encode;
		var proto = exports;
		proto.processObjectSave = /*#__PURE__*/function () {
		  var _processObjectSave = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(sourceObject, targetObject, process, targetBucket) {
		    var params, bucketParam, content, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          checkArgs(sourceObject, 'sourceObject');
		          checkArgs(targetObject, 'targetObject');
		          checkArgs(process, 'process');
		          targetObject = this._objectName(targetObject);
		          if (targetBucket) {
		            _checkBucketName(targetBucket);
		          }
		          params = this._objectRequestParams('POST', sourceObject, {
		            subres: 'x-oss-process'
		          });
		          bucketParam = targetBucket ? ",b_".concat(str2Base64(targetBucket)) : '';
		          targetObject = str2Base64(targetObject);
		          content = {
		            'x-oss-process': "".concat(process, "|sys/saveas,o_").concat(targetObject).concat(bucketParam)
		          };
		          params.content = querystring.stringify(content);
		          _context.next = 12;
		          return this.request(params);
		        case 12:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res,
		            status: result.res.status
		          });
		        case 14:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function processObjectSave(_x, _x2, _x3, _x4) {
		    return _processObjectSave.apply(this, arguments);
		  }
		  return processObjectSave;
		}();
		function checkArgs(name, key) {
		  if (!name) {
		    throw new Error("".concat(key, " is required"));
		  }
		  if (typeof name !== 'string') {
		    throw new Error("".concat(key, " must be String"));
		  }
		}

		},{"../utils/checkBucketName":53,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.array.concat.js":310,"js-base64":413,"querystring":451}],29:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.function.name.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.promise.js");
		require("core-js/modules/es.array.from.js");
		require("core-js/modules/es.string.iterator.js");
		require("core-js/modules/es.array.map.js");
		require("core-js/modules/es.array.filter.js");
		require("core-js/modules/es.array.find.js");
		require("core-js/modules/es.regexp.to-string.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		/* eslint-disable no-async-promise-executor */

		var debug = require('debug')('ali-oss:multipart-copy');
		var copy = require('copy-to');
		var proto = exports;

		/**
		 * Upload a part copy in a multipart from the source bucket/object
		 * used with initMultipartUpload and completeMultipartUpload.
		 * @param {String} name copy object name
		 * @param {String} uploadId the upload id
		 * @param {Number} partNo the part number
		 * @param {String} range  like 0-102400  part size need to copy
		 * @param {Object} sourceData
		 *        {String} sourceData.sourceKey  the source object name
		 *        {String} sourceData.sourceBucketName  the source bucket name
		 * @param {Object} options
		 */
		/* eslint max-len: [0] */
		proto.uploadPartCopy = /*#__PURE__*/function () {
		  var _uploadPartCopy = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, uploadId, partNo, range, sourceData) {
		    var options,
		      versionId,
		      copySource,
		      params,
		      result,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 5 && _args[5] !== undefined ? _args[5] : {};
		          options.headers = options.headers || {};
		          versionId = options.versionId || options.subres && options.subres.versionId || null;
		          if (versionId) {
		            copySource = "/".concat(sourceData.sourceBucketName, "/").concat(encodeURIComponent(sourceData.sourceKey), "?versionId=").concat(versionId);
		          } else {
		            copySource = "/".concat(sourceData.sourceBucketName, "/").concat(encodeURIComponent(sourceData.sourceKey));
		          }
		          options.headers['x-oss-copy-source'] = copySource;
		          if (range) {
		            options.headers['x-oss-copy-source-range'] = "bytes=".concat(range);
		          }
		          options.subres = {
		            partNumber: partNo,
		            uploadId: uploadId
		          };
		          params = this._objectRequestParams('PUT', name, options);
		          params.mime = options.mime;
		          params.successStatuses = [200];
		          _context.next = 12;
		          return this.request(params);
		        case 12:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            name: name,
		            etag: result.res.headers.etag,
		            res: result.res
		          });
		        case 14:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function uploadPartCopy(_x, _x2, _x3, _x4, _x5) {
		    return _uploadPartCopy.apply(this, arguments);
		  }
		  return uploadPartCopy;
		}();

		/**
		 * @param {String} name copy object name
		 * @param {Object} sourceData
		 *        {String} sourceData.sourceKey  the source object name
		 *        {String} sourceData.sourceBucketName  the source bucket name
		 *        {Number} sourceData.startOffset  data copy start byte offset, e.g: 0
		 *        {Number} sourceData.endOffset  data copy end byte offset, e.g: 102400
		 * @param {Object} options
		 *        {Number} options.partSize
		 */
		proto.multipartUploadCopy = /*#__PURE__*/function () {
		  var _multipartUploadCopy = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(name, sourceData) {
		    var options,
		      _options$versionId,
		      versionId,
		      metaOpt,
		      objectMeta,
		      fileSize,
		      minPartSize,
		      copySize,
		      init,
		      uploadId,
		      partSize,
		      checkpoint,
		      _args2 = arguments;
		    return _regenerator.default.wrap(function _callee2$(_context2) {
		      while (1) switch (_context2.prev = _context2.next) {
		        case 0:
		          options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};
		          this.resetCancelFlag();
		          _options$versionId = options.versionId, versionId = _options$versionId === void 0 ? null : _options$versionId;
		          metaOpt = {
		            versionId: versionId
		          };
		          _context2.next = 6;
		          return this._getObjectMeta(sourceData.sourceBucketName, sourceData.sourceKey, metaOpt);
		        case 6:
		          objectMeta = _context2.sent;
		          fileSize = objectMeta.res.headers['content-length'];
		          sourceData.startOffset = sourceData.startOffset || 0;
		          sourceData.endOffset = sourceData.endOffset || fileSize;
		          if (!(options.checkpoint && options.checkpoint.uploadId)) {
		            _context2.next = 14;
		            break;
		          }
		          _context2.next = 13;
		          return this._resumeMultipartCopy(options.checkpoint, sourceData, options);
		        case 13:
		          return _context2.abrupt("return", _context2.sent);
		        case 14:
		          minPartSize = 100 * 1024;
		          copySize = sourceData.endOffset - sourceData.startOffset;
		          if (!(copySize < minPartSize)) {
		            _context2.next = 18;
		            break;
		          }
		          throw new Error("copySize must not be smaller than ".concat(minPartSize));
		        case 18:
		          if (!(options.partSize && options.partSize < minPartSize)) {
		            _context2.next = 20;
		            break;
		          }
		          throw new Error("partSize must not be smaller than ".concat(minPartSize));
		        case 20:
		          _context2.next = 22;
		          return this.initMultipartUpload(name, options);
		        case 22:
		          init = _context2.sent;
		          uploadId = init.uploadId;
		          partSize = this._getPartSize(copySize, options.partSize);
		          checkpoint = {
		            name: name,
		            copySize: copySize,
		            partSize: partSize,
		            uploadId: uploadId,
		            doneParts: []
		          };
		          if (!(options && options.progress)) {
		            _context2.next = 29;
		            break;
		          }
		          _context2.next = 29;
		          return options.progress(0, checkpoint, init.res);
		        case 29:
		          _context2.next = 31;
		          return this._resumeMultipartCopy(checkpoint, sourceData, options);
		        case 31:
		          return _context2.abrupt("return", _context2.sent);
		        case 32:
		        case "end":
		          return _context2.stop();
		      }
		    }, _callee2, this);
		  }));
		  function multipartUploadCopy(_x6, _x7) {
		    return _multipartUploadCopy.apply(this, arguments);
		  }
		  return multipartUploadCopy;
		}();

		/*
		 * Resume multipart copy from checkpoint. The checkpoint will be
		 * updated after each successful part copy.
		 * @param {Object} checkpoint the checkpoint
		 * @param {Object} options
		 */
		proto._resumeMultipartCopy = /*#__PURE__*/function () {
		  var _resumeMultipartCopy2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(checkpoint, sourceData, options) {
		    var _options$versionId2, versionId, metaOpt, copySize, partSize, uploadId, doneParts, name, partOffs, numParts, uploadPartCopyOptions, uploadPartJob, all, done, todo, defaultParallel, parallel, i, errors, abortEvent, err;
		    return _regenerator.default.wrap(function _callee4$(_context4) {
		      while (1) switch (_context4.prev = _context4.next) {
		        case 0:
		          if (!this.isCancel()) {
		            _context4.next = 2;
		            break;
		          }
		          throw this._makeCancelEvent();
		        case 2:
		          _options$versionId2 = options.versionId, versionId = _options$versionId2 === void 0 ? null : _options$versionId2;
		          metaOpt = {
		            versionId: versionId
		          };
		          copySize = checkpoint.copySize, partSize = checkpoint.partSize, uploadId = checkpoint.uploadId, doneParts = checkpoint.doneParts, name = checkpoint.name;
		          partOffs = this._divideMultipartCopyParts(copySize, partSize, sourceData.startOffset);
		          numParts = partOffs.length;
		          uploadPartCopyOptions = {
		            headers: {}
		          };
		          if (options.copyheaders) {
		            copy(options.copyheaders).to(uploadPartCopyOptions.headers);
		          }
		          if (versionId) {
		            copy(metaOpt).to(uploadPartCopyOptions);
		          }
		          uploadPartJob = function uploadPartJob(self, partNo, source) {
		            return new Promise( /*#__PURE__*/function () {
		              var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(resolve, reject) {
		                var pi, range, result;
		                return _regenerator.default.wrap(function _callee3$(_context3) {
		                  while (1) switch (_context3.prev = _context3.next) {
		                    case 0:
		                      _context3.prev = 0;
		                      if (self.isCancel()) {
		                        _context3.next = 22;
		                        break;
		                      }
		                      pi = partOffs[partNo - 1];
		                      range = "".concat(pi.start, "-").concat(pi.end - 1);
		                      _context3.prev = 4;
		                      _context3.next = 7;
		                      return self.uploadPartCopy(name, uploadId, partNo, range, source, uploadPartCopyOptions);
		                    case 7:
		                      result = _context3.sent;
		                      _context3.next = 15;
		                      break;
		                    case 10:
		                      _context3.prev = 10;
		                      _context3.t0 = _context3["catch"](4);
		                      if (!(_context3.t0.status === 404)) {
		                        _context3.next = 14;
		                        break;
		                      }
		                      throw self._makeAbortEvent();
		                    case 14:
		                      throw _context3.t0;
		                    case 15:
		                      if (self.isCancel()) {
		                        _context3.next = 22;
		                        break;
		                      }
		                      debug("content-range ".concat(result.res.headers['content-range']));
		                      doneParts.push({
		                        number: partNo,
		                        etag: result.res.headers.etag
		                      });
		                      checkpoint.doneParts = doneParts;
		                      if (!(options && options.progress)) {
		                        _context3.next = 22;
		                        break;
		                      }
		                      _context3.next = 22;
		                      return options.progress(doneParts.length / numParts, checkpoint, result.res);
		                    case 22:
		                      resolve();
		                      _context3.next = 29;
		                      break;
		                    case 25:
		                      _context3.prev = 25;
		                      _context3.t1 = _context3["catch"](0);
		                      _context3.t1.partNum = partNo;
		                      reject(_context3.t1);
		                    case 29:
		                    case "end":
		                      return _context3.stop();
		                  }
		                }, _callee3, null, [[0, 25], [4, 10]]);
		              }));
		              return function (_x11, _x12) {
		                return _ref.apply(this, arguments);
		              };
		            }());
		          };
		          all = Array.from(new Array(numParts), function (x, i) {
		            return i + 1;
		          });
		          done = doneParts.map(function (p) {
		            return p.number;
		          });
		          todo = all.filter(function (p) {
		            return done.indexOf(p) < 0;
		          });
		          defaultParallel = 5;
		          parallel = options.parallel || defaultParallel;
		          if (!(this.checkBrowserAndVersion('Internet Explorer', '10') || parallel === 1)) {
		            _context4.next = 28;
		            break;
		          }
		          i = 0;
		        case 18:
		          if (!(i < todo.length)) {
		            _context4.next = 26;
		            break;
		          }
		          if (!this.isCancel()) {
		            _context4.next = 21;
		            break;
		          }
		          throw this._makeCancelEvent();
		        case 21:
		          _context4.next = 23;
		          return uploadPartJob(this, todo[i], sourceData);
		        case 23:
		          i++;
		          _context4.next = 18;
		          break;
		        case 26:
		          _context4.next = 40;
		          break;
		        case 28:
		          _context4.next = 30;
		          return this._parallelNode(todo, parallel, uploadPartJob, sourceData);
		        case 30:
		          errors = _context4.sent;
		          abortEvent = errors.find(function (err) {
		            return err.name === 'abort';
		          });
		          if (!abortEvent) {
		            _context4.next = 34;
		            break;
		          }
		          throw abortEvent;
		        case 34:
		          if (!this.isCancel()) {
		            _context4.next = 36;
		            break;
		          }
		          throw this._makeCancelEvent();
		        case 36:
		          if (!(errors && errors.length > 0)) {
		            _context4.next = 40;
		            break;
		          }
		          err = errors[0];
		          err.message = "Failed to copy some parts with error: ".concat(err.toString(), " part_num: ").concat(err.partNum);
		          throw err;
		        case 40:
		          _context4.next = 42;
		          return this.completeMultipartUpload(name, uploadId, doneParts, options);
		        case 42:
		          return _context4.abrupt("return", _context4.sent);
		        case 43:
		        case "end":
		          return _context4.stop();
		      }
		    }, _callee4, this);
		  }));
		  function _resumeMultipartCopy(_x8, _x9, _x10) {
		    return _resumeMultipartCopy2.apply(this, arguments);
		  }
		  return _resumeMultipartCopy;
		}();
		proto._divideMultipartCopyParts = function _divideMultipartCopyParts(fileSize, partSize, startOffset) {
		  var numParts = Math.ceil(fileSize / partSize);
		  var partOffs = [];
		  for (var i = 0; i < numParts; i++) {
		    var start = partSize * i + startOffset;
		    var end = Math.min(start + partSize, fileSize + startOffset);
		    partOffs.push({
		      start: start,
		      end: end
		    });
		  }
		  return partOffs;
		};

		/**
		 * Get Object Meta
		 * @param {String} bucket  bucket name
		 * @param {String} name   object name
		 * @param {Object} options
		 */
		proto._getObjectMeta = /*#__PURE__*/function () {
		  var _getObjectMeta2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(bucket, name, options) {
		    var currentBucket, data;
		    return _regenerator.default.wrap(function _callee5$(_context5) {
		      while (1) switch (_context5.prev = _context5.next) {
		        case 0:
		          currentBucket = this.getBucket();
		          this.setBucket(bucket);
		          _context5.next = 4;
		          return this.head(name, options);
		        case 4:
		          data = _context5.sent;
		          this.setBucket(currentBucket);
		          return _context5.abrupt("return", data);
		        case 7:
		        case "end":
		          return _context5.stop();
		      }
		    }, _callee5, this);
		  }));
		  function _getObjectMeta(_x13, _x14, _x15) {
		    return _getObjectMeta2.apply(this, arguments);
		  }
		  return _getObjectMeta;
		}();

		},{"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"copy-to":107,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.filter.js":312,"core-js/modules/es.array.find.js":313,"core-js/modules/es.array.from.js":314,"core-js/modules/es.array.map.js":318,"core-js/modules/es.function.name.js":322,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.promise.js":333,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/es.string.iterator.js":343,"debug":536}],30:[function(require,module,exports){
		(function (process){(function (){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.array.map.js");
		require("core-js/modules/es.array.filter.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.array.sort.js");
		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.regexp.to-string.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var copy = require('copy-to');
		var callback = require('./callback');
		var _require = require('./utils/deepCopy'),
		  deepCopyWith = _require.deepCopyWith;
		var _require2 = require('./utils/isBuffer'),
		  isBuffer = _require2.isBuffer;
		var _require3 = require('./utils/omit'),
		  omit = _require3.omit;
		var proto = exports;

		/**
		 * List the on-going multipart uploads
		 * https://help.aliyun.com/document_detail/31997.html
		 * @param {Object} options
		 * @return {Array} the multipart uploads
		 */
		proto.listUploads = /*#__PURE__*/function () {
		  var _listUploads = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(query, options) {
		    var opt, params, result, uploads;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = options || {};
		          opt = {};
		          copy(options).to(opt);
		          opt.subres = 'uploads';
		          params = this._objectRequestParams('GET', '', opt);
		          params.query = query;
		          params.xmlResponse = true;
		          params.successStatuses = [200];
		          _context.next = 10;
		          return this.request(params);
		        case 10:
		          result = _context.sent;
		          uploads = result.data.Upload || [];
		          if (!Array.isArray(uploads)) {
		            uploads = [uploads];
		          }
		          uploads = uploads.map(function (up) {
		            return {
		              name: up.Key,
		              uploadId: up.UploadId,
		              initiated: up.Initiated
		            };
		          });
		          return _context.abrupt("return", {
		            res: result.res,
		            uploads: uploads,
		            bucket: result.data.Bucket,
		            nextKeyMarker: result.data.NextKeyMarker,
		            nextUploadIdMarker: result.data.NextUploadIdMarker,
		            isTruncated: result.data.IsTruncated === 'true'
		          });
		        case 15:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function listUploads(_x, _x2) {
		    return _listUploads.apply(this, arguments);
		  }
		  return listUploads;
		}();

		/**
		 * List the done uploadPart parts
		 * @param {String} name object name
		 * @param {String} uploadId multipart upload id
		 * @param {Object} query
		 * {Number} query.max-parts The maximum part number in the response of the OSS. Default value: 1000
		 * {Number} query.part-number-marker Starting position of a specific list.
		 * {String} query.encoding-type Specify the encoding of the returned content and the encoding type.
		 * @param {Object} options
		 * @return {Object} result
		 */
		proto.listParts = /*#__PURE__*/function () {
		  var _listParts = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(name, uploadId, query, options) {
		    var opt, params, result;
		    return _regenerator.default.wrap(function _callee2$(_context2) {
		      while (1) switch (_context2.prev = _context2.next) {
		        case 0:
		          options = options || {};
		          opt = {};
		          copy(options).to(opt);
		          opt.subres = {
		            uploadId: uploadId
		          };
		          params = this._objectRequestParams('GET', name, opt);
		          params.query = query;
		          params.xmlResponse = true;
		          params.successStatuses = [200];
		          _context2.next = 10;
		          return this.request(params);
		        case 10:
		          result = _context2.sent;
		          return _context2.abrupt("return", {
		            res: result.res,
		            uploadId: result.data.UploadId,
		            bucket: result.data.Bucket,
		            name: result.data.Key,
		            partNumberMarker: result.data.PartNumberMarker,
		            nextPartNumberMarker: result.data.NextPartNumberMarker,
		            maxParts: result.data.MaxParts,
		            isTruncated: result.data.IsTruncated,
		            parts: result.data.Part || []
		          });
		        case 12:
		        case "end":
		          return _context2.stop();
		      }
		    }, _callee2, this);
		  }));
		  function listParts(_x3, _x4, _x5, _x6) {
		    return _listParts.apply(this, arguments);
		  }
		  return listParts;
		}();

		/**
		 * Abort a multipart upload transaction
		 * @param {String} name the object name
		 * @param {String} uploadId the upload id
		 * @param {Object} options
		 */
		proto.abortMultipartUpload = /*#__PURE__*/function () {
		  var _abortMultipartUpload = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(name, uploadId, options) {
		    var opt, params, result;
		    return _regenerator.default.wrap(function _callee3$(_context3) {
		      while (1) switch (_context3.prev = _context3.next) {
		        case 0:
		          this._stop();
		          options = options || {};
		          opt = {};
		          copy(options).to(opt);
		          opt.subres = {
		            uploadId: uploadId
		          };
		          params = this._objectRequestParams('DELETE', name, opt);
		          params.successStatuses = [204];
		          _context3.next = 9;
		          return this.request(params);
		        case 9:
		          result = _context3.sent;
		          return _context3.abrupt("return", {
		            res: result.res
		          });
		        case 11:
		        case "end":
		          return _context3.stop();
		      }
		    }, _callee3, this);
		  }));
		  function abortMultipartUpload(_x7, _x8, _x9) {
		    return _abortMultipartUpload.apply(this, arguments);
		  }
		  return abortMultipartUpload;
		}();

		/**
		 * Initiate a multipart upload transaction
		 * @param {String} name the object name
		 * @param {Object} options
		 * @return {String} upload id
		 */
		proto.initMultipartUpload = /*#__PURE__*/function () {
		  var _initMultipartUpload = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(name, options) {
		    var opt, params, result;
		    return _regenerator.default.wrap(function _callee4$(_context4) {
		      while (1) switch (_context4.prev = _context4.next) {
		        case 0:
		          options = options || {};
		          opt = {};
		          copy(options).to(opt);
		          opt.headers = opt.headers || {};
		          this._convertMetaToHeaders(options.meta, opt.headers);
		          opt.subres = 'uploads';
		          params = this._objectRequestParams('POST', name, opt);
		          params.mime = options.mime;
		          params.xmlResponse = true;
		          params.successStatuses = [200];
		          _context4.next = 12;
		          return this.request(params);
		        case 12:
		          result = _context4.sent;
		          return _context4.abrupt("return", {
		            res: result.res,
		            bucket: result.data.Bucket,
		            name: result.data.Key,
		            uploadId: result.data.UploadId
		          });
		        case 14:
		        case "end":
		          return _context4.stop();
		      }
		    }, _callee4, this);
		  }));
		  function initMultipartUpload(_x10, _x11) {
		    return _initMultipartUpload.apply(this, arguments);
		  }
		  return initMultipartUpload;
		}();

		/**
		 * Upload a part in a multipart upload transaction
		 * @param {String} name the object name
		 * @param {String} uploadId the upload id
		 * @param {Integer} partNo the part number
		 * @param {File} file upload File, whole File
		 * @param {Integer} start  part start bytes  e.g: 102400
		 * @param {Integer} end  part end bytes  e.g: 204800
		 * @param {Object} options
		 */
		proto.uploadPart = /*#__PURE__*/function () {
		  var _uploadPart2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(name, uploadId, partNo, file, start, end, options) {
		    var data, isBrowserEnv;
		    return _regenerator.default.wrap(function _callee5$(_context5) {
		      while (1) switch (_context5.prev = _context5.next) {
		        case 0:
		          data = {
		            size: end - start
		          };
		          isBrowserEnv = process && process.browser;
		          if (!isBrowserEnv) {
		            _context5.next = 8;
		            break;
		          }
		          _context5.next = 5;
		          return this._createBuffer(file, start, end);
		        case 5:
		          data.content = _context5.sent;
		          _context5.next = 11;
		          break;
		        case 8:
		          _context5.next = 10;
		          return this._createStream(file, start, end);
		        case 10:
		          data.stream = _context5.sent;
		        case 11:
		          _context5.next = 13;
		          return this._uploadPart(name, uploadId, partNo, data, options);
		        case 13:
		          return _context5.abrupt("return", _context5.sent);
		        case 14:
		        case "end":
		          return _context5.stop();
		      }
		    }, _callee5, this);
		  }));
		  function uploadPart(_x12, _x13, _x14, _x15, _x16, _x17, _x18) {
		    return _uploadPart2.apply(this, arguments);
		  }
		  return uploadPart;
		}();

		/**
		 * Complete a multipart upload transaction
		 * @param {String} name the object name
		 * @param {String} uploadId the upload id
		 * @param {Array} parts the uploaded parts, each in the structure:
		 *        {Integer} number partNo
		 *        {String} etag  part etag  uploadPartCopy result.res.header.etag
		 * @param {Object} options
		 *         {Object} [options.callback] The callback parameter is composed of a JSON string encoded in Base64
		 *         {String} options.callback.url  the OSS sends a callback request to this URL
		 *         {String} [options.callback.host]  The host header value for initiating callback requests
		 *         {String} options.callback.body  The value of the request body when a callback is initiated
		 *         {String} [options.callback.contentType]  The Content-Type of the callback requests initiated
		 *         {Boolean} [options.callback.callbackSNI] Whether OSS sends SNI to the origin address specified by callbackUrl when a callback request is initiated from the client
		 *         {Object} [options.callback.customValue]  Custom parameters are a map of key-values, e.g:
		 *                   customValue = {
		 *                     key1: 'value1',
		 *                     key2: 'value2'
		 *                   }
		 */
		proto.completeMultipartUpload = /*#__PURE__*/function () {
		  var _completeMultipartUpload = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(name, uploadId, parts, options) {
		    var completeParts, xml, i, p, opt, params, result, ret;
		    return _regenerator.default.wrap(function _callee6$(_context6) {
		      while (1) switch (_context6.prev = _context6.next) {
		        case 0:
		          completeParts = parts.concat().sort(function (a, b) {
		            return a.number - b.number;
		          }).filter(function (item, index, arr) {
		            return !index || item.number !== arr[index - 1].number;
		          });
		          xml = '<?xml version="1.0" encoding="UTF-8"?>\n<CompleteMultipartUpload>\n';
		          for (i = 0; i < completeParts.length; i++) {
		            p = completeParts[i];
		            xml += '<Part>\n';
		            xml += "<PartNumber>".concat(p.number, "</PartNumber>\n");
		            xml += "<ETag>".concat(p.etag, "</ETag>\n");
		            xml += '</Part>\n';
		          }
		          xml += '</CompleteMultipartUpload>';
		          options = options || {};
		          opt = {};
		          opt = deepCopyWith(options, function (_) {
		            if (isBuffer(_)) return null;
		          });
		          opt.subres = {
		            uploadId: uploadId
		          };
		          opt.headers = omit(opt.headers, ['x-oss-server-side-encryption', 'x-oss-storage-class']);
		          params = this._objectRequestParams('POST', name, opt);
		          callback.encodeCallback(params, opt);
		          params.mime = 'xml';
		          params.content = xml;
		          if (!(params.headers && params.headers['x-oss-callback'])) {
		            params.xmlResponse = true;
		          }
		          params.successStatuses = [200];
		          _context6.next = 17;
		          return this.request(params);
		        case 17:
		          result = _context6.sent;
		          if (!options.progress) {
		            _context6.next = 21;
		            break;
		          }
		          _context6.next = 21;
		          return options.progress(1, null, result.res);
		        case 21:
		          ret = {
		            res: result.res,
		            bucket: params.bucket,
		            name: name,
		            etag: result.res.headers.etag
		          };
		          if (params.headers && params.headers['x-oss-callback']) {
		            ret.data = JSON.parse(result.data.toString());
		          }
		          return _context6.abrupt("return", ret);
		        case 24:
		        case "end":
		          return _context6.stop();
		      }
		    }, _callee6, this);
		  }));
		  function completeMultipartUpload(_x19, _x20, _x21, _x22) {
		    return _completeMultipartUpload.apply(this, arguments);
		  }
		  return completeMultipartUpload;
		}();

		/**
		 * Upload a part in a multipart upload transaction
		 * @param {String} name the object name
		 * @param {String} uploadId the upload id
		 * @param {Integer} partNo the part number
		 * @param {Object} data the body data
		 * @param {Object} options
		 */
		proto._uploadPart = /*#__PURE__*/function () {
		  var _uploadPart3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(name, uploadId, partNo, data, options) {
		    var opt, params, isBrowserEnv, result;
		    return _regenerator.default.wrap(function _callee7$(_context7) {
		      while (1) switch (_context7.prev = _context7.next) {
		        case 0:
		          options = options || {};
		          opt = {};
		          copy(options).to(opt);
		          opt.headers = opt.headers || {};
		          opt.headers['Content-Length'] = data.size;

		          // Uploading shards does not require x-oss headers.
		          opt.headers = omit(opt.headers, ['x-oss-server-side-encryption', 'x-oss-storage-class']);
		          opt.subres = {
		            partNumber: partNo,
		            uploadId: uploadId
		          };
		          params = this._objectRequestParams('PUT', name, opt);
		          params.mime = opt.mime;
		          isBrowserEnv = process && process.browser;
		          isBrowserEnv ? params.content = data.content : params.stream = data.stream;
		          params.successStatuses = [200];
		          params.disabledMD5 = options.disabledMD5;
		          _context7.next = 15;
		          return this.request(params);
		        case 15:
		          result = _context7.sent;
		          if (result.res.headers.etag) {
		            _context7.next = 18;
		            break;
		          }
		          throw new Error('Please set the etag of expose-headers in OSS \n https://help.aliyun.com/document_detail/32069.html');
		        case 18:
		          if (data.stream) {
		            data.stream = null;
		            params.stream = null;
		          }
		          return _context7.abrupt("return", {
		            name: name,
		            etag: result.res.headers.etag,
		            res: result.res
		          });
		        case 20:
		        case "end":
		          return _context7.stop();
		      }
		    }, _callee7, this);
		  }));
		  function _uploadPart(_x23, _x24, _x25, _x26, _x27) {
		    return _uploadPart3.apply(this, arguments);
		  }
		  return _uploadPart;
		}();

		}).call(this);}).call(this,require('_process'));
		},{"./callback":24,"./utils/deepCopy":60,"./utils/isBuffer":69,"./utils/omit":77,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"_process":538,"copy-to":107,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.filter.js":312,"core-js/modules/es.array.map.js":318,"core-js/modules/es.array.sort.js":320,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.to-string.js":339}],31:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.regexp.exec.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var urlutil = require('url');
		var utility = require('utility');
		var copy = require('copy-to');
		var signHelper = require('../../common/signUtils');
		var _require = require('../utils/isIP'),
		  isIP = _require.isIP;
		var _require2 = require('../utils/setSTSToken'),
		  setSTSToken = _require2.setSTSToken;
		var _require3 = require('../utils/isFunction'),
		  isFunction = _require3.isFunction;
		var proto = exports;

		/**
		 * asyncSignatureUrl
		 * @param {String} name object name
		 * @param {Object} options options
		 * @param {boolean} [strictObjectNameValidation=true] the flag of verifying object name strictly
		 */
		proto.asyncSignatureUrl = /*#__PURE__*/function () {
		  var _asyncSignatureUrl = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, options) {
		    var strictObjectNameValidation,
		      expires,
		      params,
		      resource,
		      signRes,
		      url,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          strictObjectNameValidation = _args.length > 2 && _args[2] !== undefined ? _args[2] : true;
		          if (!isIP(this.options.endpoint.hostname)) {
		            _context.next = 3;
		            break;
		          }
		          throw new Error('can not get the object URL when endpoint is IP');
		        case 3:
		          if (!(strictObjectNameValidation && /^\?/.test(name))) {
		            _context.next = 5;
		            break;
		          }
		          throw new Error("Invalid object name ".concat(name));
		        case 5:
		          options = options || {};
		          name = this._objectName(name);
		          options.method = options.method || 'GET';
		          expires = utility.timestamp() + (options.expires || 1800);
		          params = {
		            bucket: this.options.bucket,
		            object: name
		          };
		          resource = this._getResource(params);
		          if (!(this.options.stsToken && isFunction(this.options.refreshSTSToken))) {
		            _context.next = 14;
		            break;
		          }
		          _context.next = 14;
		          return setSTSToken.call(this);
		        case 14:
		          if (this.options.stsToken) {
		            options['security-token'] = this.options.stsToken;
		          }
		          signRes = signHelper._signatureForURL(this.options.accessKeySecret, options, resource, expires);
		          url = urlutil.parse(this._getReqUrl(params));
		          url.query = {
		            OSSAccessKeyId: this.options.accessKeyId,
		            Expires: expires,
		            Signature: signRes.Signature
		          };
		          copy(signRes.subResource).to(url.query);
		          return _context.abrupt("return", url.format());
		        case 20:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function asyncSignatureUrl(_x, _x2) {
		    return _asyncSignatureUrl.apply(this, arguments);
		  }
		  return asyncSignatureUrl;
		}();

		},{"../../common/signUtils":52,"../utils/isFunction":72,"../utils/isIP":73,"../utils/setSTSToken":82,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"copy-to":107,"core-js/modules/es.regexp.exec.js":338,"url":543,"utility":545}],32:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.array.find.js");
		require("core-js/modules/es.array.includes.js");
		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('../utils/checkBucketName'),
		  _checkBucketName = _require.checkBucketName;
		var proto = exports;
		var REPLACE_HEDERS = ['content-type', 'content-encoding', 'content-language', 'content-disposition', 'cache-control', 'expires'];
		proto.copy = /*#__PURE__*/function () {
		  var _copy = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, sourceName, bucketName, options) {
		    var params, result, data;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          if ((0, _typeof2.default)(bucketName) === 'object') {
		            options = bucketName; // 兼容旧版本，旧版本第三个参数为options
		          }
		          options = options || {};
		          options.headers = options.headers || {};
		          Object.keys(options.headers).forEach(function (key) {
		            options.headers["x-oss-copy-source-".concat(key.toLowerCase())] = options.headers[key];
		          });
		          if (options.meta || Object.keys(options.headers).find(function (_) {
		            return REPLACE_HEDERS.includes(_.toLowerCase());
		          })) {
		            options.headers['x-oss-metadata-directive'] = 'REPLACE';
		          }
		          this._convertMetaToHeaders(options.meta, options.headers);
		          sourceName = this._getSourceName(sourceName, bucketName);
		          if (options.versionId) {
		            sourceName = "".concat(sourceName, "?versionId=").concat(options.versionId);
		          }
		          options.headers['x-oss-copy-source'] = sourceName;
		          params = this._objectRequestParams('PUT', name, options);
		          params.xmlResponse = true;
		          params.successStatuses = [200, 304];
		          _context.next = 14;
		          return this.request(params);
		        case 14:
		          result = _context.sent;
		          data = result.data;
		          if (data) {
		            data = {
		              etag: data.ETag,
		              lastModified: data.LastModified
		            };
		          }
		          return _context.abrupt("return", {
		            data: data,
		            res: result.res
		          });
		        case 18:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function copy(_x, _x2, _x3, _x4) {
		    return _copy.apply(this, arguments);
		  }
		  return copy;
		}();

		// todo delete
		proto._getSourceName = function _getSourceName(sourceName, bucketName) {
		  if (typeof bucketName === 'string') {
		    sourceName = this._objectName(sourceName);
		  } else if (sourceName[0] !== '/') {
		    bucketName = this.options.bucket;
		  } else {
		    bucketName = sourceName.replace(/\/(.+?)(\/.*)/, '$1');
		    sourceName = sourceName.replace(/(\/.+?\/)(.*)/, '$2');
		  }
		  _checkBucketName(bucketName);
		  sourceName = encodeURIComponent(sourceName);
		  sourceName = "/".concat(bucketName, "/").concat(sourceName);
		  return sourceName;
		};

		},{"../utils/checkBucketName":53,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/helpers/typeof":91,"@babel/runtime/regenerator":93,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.find.js":313,"core-js/modules/es.array.includes.js":315,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.replace.js":345,"core-js/modules/web.dom-collections.for-each.js":380}],33:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var proto = exports;
		/**
		 * delete
		 * @param {String} name - object name
		 * @param {Object} options
		 * @param {{res}}
		 */

		proto.delete = /*#__PURE__*/function () {
		  var _delete2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name) {
		    var options,
		      params,
		      result,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
		          options.subres = Object.assign({}, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          params = this._objectRequestParams('DELETE', name, options);
		          params.successStatuses = [204];
		          _context.next = 7;
		          return this.request(params);
		        case 7:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res
		          });
		        case 9:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function _delete(_x) {
		    return _delete2.apply(this, arguments);
		  }
		  return _delete;
		}();

		},{"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],34:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		/* eslint-disable object-curly-newline */
		var utility = require('utility');
		var _require = require('../utils/obj2xml'),
		  obj2xml = _require.obj2xml;
		var proto = exports;
		proto.deleteMulti = /*#__PURE__*/function () {
		  var _deleteMulti = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(names) {
		    var options,
		      objects,
		      i,
		      object,
		      _names$i,
		      key,
		      versionId,
		      paramXMLObj,
		      paramXML,
		      params,
		      result,
		      r,
		      deleted,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
		          objects = [];
		          if (!(!names || !names.length)) {
		            _context.next = 4;
		            break;
		          }
		          throw new Error('names is required');
		        case 4:
		          for (i = 0; i < names.length; i++) {
		            object = {};
		            if (typeof names[i] === 'string') {
		              object.Key = utility.escape(this._objectName(names[i]));
		            } else {
		              _names$i = names[i], key = _names$i.key, versionId = _names$i.versionId;
		              object.Key = utility.escape(this._objectName(key));
		              object.VersionId = versionId;
		            }
		            objects.push(object);
		          }
		          paramXMLObj = {
		            Delete: {
		              Quiet: !!options.quiet,
		              Object: objects
		            }
		          };
		          paramXML = obj2xml(paramXMLObj, {
		            headers: true
		          });
		          options.subres = Object.assign({
		            delete: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          params = this._objectRequestParams('POST', '', options);
		          params.mime = 'xml';
		          params.content = paramXML;
		          params.xmlResponse = true;
		          params.successStatuses = [200];
		          _context.next = 16;
		          return this.request(params);
		        case 16:
		          result = _context.sent;
		          r = result.data;
		          deleted = r && r.Deleted || null;
		          if (deleted) {
		            if (!Array.isArray(deleted)) {
		              deleted = [deleted];
		            }
		          }
		          return _context.abrupt("return", {
		            res: result.res,
		            deleted: deleted || []
		          });
		        case 21:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function deleteMulti(_x) {
		    return _deleteMulti.apply(this, arguments);
		  }
		  return deleteMulti;
		}();

		},{"../utils/obj2xml":76,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325,"utility":545}],35:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var proto = exports;
		/**
		 * deleteObjectTagging
		 * @param {String} name - object name
		 * @param {Object} options
		 */

		proto.deleteObjectTagging = /*#__PURE__*/function () {
		  var _deleteObjectTagging = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name) {
		    var options,
		      params,
		      result,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
		          options.subres = Object.assign({
		            tagging: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          name = this._objectName(name);
		          params = this._objectRequestParams('DELETE', name, options);
		          params.successStatuses = [204];
		          _context.next = 8;
		          return this.request(params);
		        case 8:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            status: result.status,
		            res: result.res
		          });
		        case 10:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function deleteObjectTagging(_x) {
		    return _deleteObjectTagging.apply(this, arguments);
		  }
		  return deleteObjectTagging;
		}();

		},{"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],36:[function(require,module,exports){

		require("core-js/modules/es.array.concat.js");
		var urlutil = require('url');
		var _require = require('../utils/isIP'),
		  isIP = _require.isIP;
		var proto = exports;

		/**
		 * Get Object url by name
		 * @param {String} name - object name
		 * @param {String} [baseUrl] - If provide `baseUrl`, will use `baseUrl` instead the default `endpoint and bucket`.
		 * @return {String} object url include bucket
		 */
		proto.generateObjectUrl = function generateObjectUrl(name, baseUrl) {
		  if (isIP(this.options.endpoint.hostname)) {
		    throw new Error('can not get the object URL when endpoint is IP');
		  }
		  if (!baseUrl) {
		    baseUrl = this.options.endpoint.format();
		    var copyUrl = urlutil.parse(baseUrl);
		    var bucket = this.options.bucket;
		    copyUrl.hostname = "".concat(bucket, ".").concat(copyUrl.hostname);
		    copyUrl.host = "".concat(bucket, ".").concat(copyUrl.host);
		    baseUrl = copyUrl.format();
		  } else if (baseUrl[baseUrl.length - 1] !== '/') {
		    baseUrl += '/';
		  }
		  return baseUrl + this._escape(this._objectName(name));
		};

		},{"../utils/isIP":73,"core-js/modules/es.array.concat.js":310,"url":543}],37:[function(require,module,exports){
		(function (process){(function (){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var fs = require('fs');
		var is = require('is-type-of');
		var _require = require('../utils/isObject'),
		  isObject = _require.isObject;
		var proto = exports;
		/**
		 * get
		 * @param {String} name - object name
		 * @param {String | Stream | Object} file - file path or file stream or options
		 * @param {Object} options
		 * @param {{res}}
		 */
		proto.get = /*#__PURE__*/function () {
		  var _get = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, file) {
		    var options,
		      writeStream,
		      needDestroy,
		      isBrowserEnv,
		      responseCacheControl,
		      defaultSubresOptions,
		      result,
		      params,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
		          writeStream = null;
		          needDestroy = false;
		          if (is.writableStream(file)) {
		            writeStream = file;
		          } else if (is.string(file)) {
		            writeStream = fs.createWriteStream(file);
		            needDestroy = true;
		          } else if (isObject(file)) {
		            // get(name, options)
		            options = file;
		          }
		          options = options || {};
		          isBrowserEnv = process && process.browser;
		          responseCacheControl = options.responseCacheControl === null ? '' : 'no-cache';
		          defaultSubresOptions = isBrowserEnv && responseCacheControl ? {
		            'response-cache-control': responseCacheControl
		          } : {};
		          options.subres = Object.assign(defaultSubresOptions, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          if (options.process) {
		            options.subres['x-oss-process'] = options.process;
		          }
		          _context.prev = 11;
		          params = this._objectRequestParams('GET', name, options);
		          params.writeStream = writeStream;
		          params.successStatuses = [200, 206, 304];
		          _context.next = 17;
		          return this.request(params);
		        case 17:
		          result = _context.sent;
		          if (needDestroy) {
		            writeStream.destroy();
		          }
		          _context.next = 28;
		          break;
		        case 21:
		          _context.prev = 21;
		          _context.t0 = _context["catch"](11);
		          if (!needDestroy) {
		            _context.next = 27;
		            break;
		          }
		          writeStream.destroy();
		          // should delete the exists file before throw error
		          _context.next = 27;
		          return this._deleteFileSafe(file);
		        case 27:
		          throw _context.t0;
		        case 28:
		          return _context.abrupt("return", {
		            res: result.res,
		            content: result.data
		          });
		        case 29:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this, [[11, 21]]);
		  }));
		  function get(_x, _x2) {
		    return _get.apply(this, arguments);
		  }
		  return get;
		}();

		}).call(this);}).call(this,require('_process'));
		},{"../utils/isObject":74,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"_process":538,"core-js/modules/es.object.assign.js":325,"fs":102,"is-type-of":537}],38:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var proto = exports;

		/*
		 * Get object's ACL
		 * @param {String} name the object key
		 * @param {Object} options
		 * @return {Object}
		 */
		proto.getACL = /*#__PURE__*/function () {
		  var _getACL = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name) {
		    var options,
		      params,
		      result,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
		          options.subres = Object.assign({
		            acl: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          name = this._objectName(name);
		          params = this._objectRequestParams('GET', name, options);
		          params.successStatuses = [200];
		          params.xmlResponse = true;
		          _context.next = 9;
		          return this.request(params);
		        case 9:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            acl: result.data.AccessControlList.Grant,
		            owner: {
		              id: result.data.Owner.ID,
		              displayName: result.data.Owner.DisplayName
		            },
		            res: result.res
		          });
		        case 11:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function getACL(_x) {
		    return _getACL.apply(this, arguments);
		  }
		  return getACL;
		}();

		},{"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],39:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.object.assign.js");
		require("core-js/modules/es.array.map.js");
		require("core-js/modules/es.number.constructor.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		/* eslint-disable no-use-before-define */
		var proto = exports;
		var _require = require('../utils/isObject'),
		  isObject = _require.isObject;
		var _require2 = require('../utils/isArray'),
		  isArray = _require2.isArray;
		var _require3 = require('../utils/parseRestoreInfo'),
		  parseRestoreInfo = _require3.parseRestoreInfo;
		proto.getBucketVersions = getBucketVersions;
		proto.listObjectVersions = getBucketVersions;
		function getBucketVersions() {
		  return _getBucketVersions.apply(this, arguments);
		}
		function _getBucketVersions() {
		  _getBucketVersions = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
		    var query,
		      options,
		      params,
		      result,
		      objects,
		      deleteMarker,
		      that,
		      prefixes,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          query = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
		          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
		          if (!(query.versionIdMarker && query.keyMarker === undefined)) {
		            _context.next = 4;
		            break;
		          }
		          throw new Error('A version-id marker cannot be specified without a key marker');
		        case 4:
		          options.subres = Object.assign({
		            versions: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          params = this._objectRequestParams('GET', '', options);
		          params.xmlResponse = true;
		          params.successStatuses = [200];
		          params.query = formatQuery(query);
		          _context.next = 12;
		          return this.request(params);
		        case 12:
		          result = _context.sent;
		          objects = result.data.Version || [];
		          deleteMarker = result.data.DeleteMarker || [];
		          that = this;
		          if (objects) {
		            if (!Array.isArray(objects)) {
		              objects = [objects];
		            }
		            objects = objects.map(function (obj) {
		              return {
		                name: obj.Key,
		                url: that._objectUrl(obj.Key),
		                lastModified: obj.LastModified,
		                isLatest: obj.IsLatest === 'true',
		                versionId: obj.VersionId,
		                etag: obj.ETag,
		                type: obj.Type,
		                size: Number(obj.Size),
		                storageClass: obj.StorageClass,
		                owner: {
		                  id: obj.Owner.ID,
		                  displayName: obj.Owner.DisplayName
		                },
		                restoreInfo: parseRestoreInfo(obj.RestoreInfo)
		              };
		            });
		          }
		          if (deleteMarker) {
		            if (!isArray(deleteMarker)) {
		              deleteMarker = [deleteMarker];
		            }
		            deleteMarker = deleteMarker.map(function (obj) {
		              return {
		                name: obj.Key,
		                lastModified: obj.LastModified,
		                versionId: obj.VersionId,
		                owner: {
		                  id: obj.Owner.ID,
		                  displayName: obj.Owner.DisplayName
		                }
		              };
		            });
		          }
		          prefixes = result.data.CommonPrefixes || null;
		          if (prefixes) {
		            if (!isArray(prefixes)) {
		              prefixes = [prefixes];
		            }
		            prefixes = prefixes.map(function (item) {
		              return item.Prefix;
		            });
		          }
		          return _context.abrupt("return", {
		            res: result.res,
		            objects: objects,
		            deleteMarker: deleteMarker,
		            prefixes: prefixes,
		            // attirbute of legacy error
		            nextMarker: result.data.NextKeyMarker || null,
		            // attirbute of legacy error
		            NextVersionIdMarker: result.data.NextVersionIdMarker || null,
		            nextKeyMarker: result.data.NextKeyMarker || null,
		            nextVersionIdMarker: result.data.NextVersionIdMarker || null,
		            isTruncated: result.data.IsTruncated === 'true'
		          });
		        case 21:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _getBucketVersions.apply(this, arguments);
		}
		function camel2Line(name) {
		  return name.replace(/([A-Z])/g, '-$1').toLowerCase();
		}
		function formatQuery() {
		  var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		  var obj = {};
		  if (isObject(query)) {
		    Object.keys(query).forEach(function (key) {
		      obj[camel2Line(key)] = query[key];
		    });
		  }
		  return obj;
		}

		},{"../utils/isArray":67,"../utils/isObject":74,"../utils/parseRestoreInfo":78,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.array.map.js":318,"core-js/modules/es.number.constructor.js":324,"core-js/modules/es.object.assign.js":325,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.replace.js":345,"core-js/modules/web.dom-collections.for-each.js":380}],40:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var proto = exports;
		/**
		 * getObjectMeta
		 * @param {String} name - object name
		 * @param {Object} options
		 * @param {{res}}
		 */

		proto.getObjectMeta = /*#__PURE__*/function () {
		  var _getObjectMeta = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = options || {};
		          name = this._objectName(name);
		          options.subres = Object.assign({
		            objectMeta: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          params = this._objectRequestParams('HEAD', name, options);
		          params.successStatuses = [200];
		          _context.next = 8;
		          return this.request(params);
		        case 8:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            status: result.status,
		            res: result.res
		          });
		        case 10:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function getObjectMeta(_x, _x2) {
		    return _getObjectMeta.apply(this, arguments);
		  }
		  return getObjectMeta;
		}();

		},{"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],41:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var proto = exports;
		var _require = require('../utils/isObject'),
		  isObject = _require.isObject;
		/**
		 * getObjectTagging
		 * @param {String} name - object name
		 * @param {Object} options
		 * @return {Object}
		 */

		proto.getObjectTagging = /*#__PURE__*/function () {
		  var _getObjectTagging = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name) {
		    var options,
		      params,
		      result,
		      Tagging,
		      Tag,
		      tag,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
		          options.subres = Object.assign({
		            tagging: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          name = this._objectName(name);
		          params = this._objectRequestParams('GET', name, options);
		          params.successStatuses = [200];
		          _context.next = 8;
		          return this.request(params);
		        case 8:
		          result = _context.sent;
		          _context.next = 11;
		          return this.parseXML(result.data);
		        case 11:
		          Tagging = _context.sent;
		          Tag = Tagging.TagSet.Tag;
		          Tag = Tag && isObject(Tag) ? [Tag] : Tag || [];
		          tag = {};
		          Tag.forEach(function (item) {
		            tag[item.Key] = item.Value;
		          });
		          return _context.abrupt("return", {
		            status: result.status,
		            res: result.res,
		            tag: tag
		          });
		        case 17:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function getObjectTagging(_x) {
		    return _getObjectTagging.apply(this, arguments);
		  }
		  return getObjectTagging;
		}();

		},{"../utils/isObject":74,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325,"core-js/modules/es.object.to-string.js":329,"core-js/modules/web.dom-collections.for-each.js":380}],42:[function(require,module,exports){

		var _require = require('../utils/isIP'),
		  isIP = _require.isIP;
		var proto = exports;
		/**
		 * Get Object url by name
		 * @param {String} name - object name
		 * @param {String} [baseUrl] - If provide `baseUrl`,
		 *        will use `baseUrl` instead the default `endpoint`.
		 * @return {String} object url
		 */
		proto.getObjectUrl = function getObjectUrl(name, baseUrl) {
		  if (isIP(this.options.endpoint.hostname)) {
		    throw new Error('can not get the object URL when endpoint is IP');
		  }
		  if (!baseUrl) {
		    baseUrl = this.options.endpoint.format();
		  } else if (baseUrl[baseUrl.length - 1] !== '/') {
		    baseUrl += '/';
		  }
		  return baseUrl + this._escape(this._objectName(name));
		};

		},{"../utils/isIP":73}],43:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var proto = exports;
		/**
		 * getSymlink
		 * @param {String} name - object name
		 * @param {Object} options
		 * @param {{res}}
		 */

		proto.getSymlink = /*#__PURE__*/function () {
		  var _getSymlink = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name) {
		    var options,
		      params,
		      result,
		      target,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
		          options.subres = Object.assign({
		            symlink: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          name = this._objectName(name);
		          params = this._objectRequestParams('GET', name, options);
		          params.successStatuses = [200];
		          _context.next = 8;
		          return this.request(params);
		        case 8:
		          result = _context.sent;
		          target = result.res.headers['x-oss-symlink-target'];
		          return _context.abrupt("return", {
		            targetName: decodeURIComponent(target),
		            res: result.res
		          });
		        case 11:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function getSymlink(_x) {
		    return _getSymlink.apply(this, arguments);
		  }
		  return getSymlink;
		}();

		},{"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],44:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('../utils/checkEnv'),
		  checkEnv = _require.checkEnv;
		var proto = exports;
		/**
		 * head
		 * @param {String} name - object name
		 * @param {Object} options
		 * @param {{res}}
		 */

		proto.head = /*#__PURE__*/function () {
		  var _head = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name) {
		    var options,
		      params,
		      result,
		      data,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
		          checkEnv('Because HeadObject has gzip enabled, head cannot get the file size correctly. If you need to get the file size, please use getObjectMeta');
		          options.subres = Object.assign({}, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          params = this._objectRequestParams('HEAD', name, options);
		          params.successStatuses = [200, 304];
		          _context.next = 8;
		          return this.request(params);
		        case 8:
		          result = _context.sent;
		          data = {
		            meta: null,
		            res: result.res,
		            status: result.status
		          };
		          if (result.status === 200) {
		            Object.keys(result.headers).forEach(function (k) {
		              if (k.indexOf('x-oss-meta-') === 0) {
		                if (!data.meta) {
		                  data.meta = {};
		                }
		                data.meta[k.substring(11)] = result.headers[k];
		              }
		            });
		          }
		          return _context.abrupt("return", data);
		        case 12:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function head(_x) {
		    return _head.apply(this, arguments);
		  }
		  return head;
		}();

		},{"../utils/checkEnv":55,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/web.dom-collections.for-each.js":380}],45:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var proto = exports;

		/*
		 * Set object's ACL
		 * @param {String} name the object key
		 * @param {String} acl the object ACL
		 * @param {Object} options
		 */
		proto.putACL = /*#__PURE__*/function () {
		  var _putACL = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, acl, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = options || {};
		          options.subres = Object.assign({
		            acl: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          options.headers = options.headers || {};
		          options.headers['x-oss-object-acl'] = acl;
		          name = this._objectName(name);
		          params = this._objectRequestParams('PUT', name, options);
		          params.successStatuses = [200];
		          _context.next = 10;
		          return this.request(params);
		        case 10:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res
		          });
		        case 12:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function putACL(_x, _x2, _x3) {
		    return _putACL.apply(this, arguments);
		  }
		  return putACL;
		}();

		},{"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],46:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		require("core-js/modules/es.array.map.js");
		require("core-js/modules/es.object.keys.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('../utils/obj2xml'),
		  obj2xml = _require.obj2xml;
		var _require2 = require('../utils/checkObjectTag'),
		  checkObjectTag = _require2.checkObjectTag;
		var proto = exports;
		/**
		 * putObjectTagging
		 * @param {String} name - object name
		 * @param {Object} tag -  object tag, eg: `{a: "1", b: "2"}`
		 * @param {Object} options
		 */

		proto.putObjectTagging = /*#__PURE__*/function () {
		  var _putObjectTagging = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, tag) {
		    var options,
		      params,
		      paramXMLObj,
		      result,
		      _args = arguments;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
		          checkObjectTag(tag);
		          options.subres = Object.assign({
		            tagging: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          name = this._objectName(name);
		          params = this._objectRequestParams('PUT', name, options);
		          params.successStatuses = [200];
		          tag = Object.keys(tag).map(function (key) {
		            return {
		              Key: key,
		              Value: tag[key]
		            };
		          });
		          paramXMLObj = {
		            Tagging: {
		              TagSet: {
		                Tag: tag
		              }
		            }
		          };
		          params.mime = 'xml';
		          params.content = obj2xml(paramXMLObj);
		          _context.next = 13;
		          return this.request(params);
		        case 13:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res,
		            status: result.status
		          });
		        case 15:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function putObjectTagging(_x, _x2) {
		    return _putObjectTagging.apply(this, arguments);
		  }
		  return putObjectTagging;
		}();

		},{"../utils/checkObjectTag":56,"../utils/obj2xml":76,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.array.map.js":318,"core-js/modules/es.object.assign.js":325,"core-js/modules/es.object.keys.js":328}],47:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var proto = exports;
		/**
		 * putSymlink
		 * @param {String} name - object name
		 * @param {String} targetName - target name
		 * @param {Object} options
		 * @param {{res}}
		 */

		proto.putSymlink = /*#__PURE__*/function () {
		  var _putSymlink = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name, targetName, options) {
		    var params, result;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          options = options || {};
		          options.headers = options.headers || {};
		          targetName = this._escape(this._objectName(targetName));
		          this._convertMetaToHeaders(options.meta, options.headers);
		          options.headers['x-oss-symlink-target'] = targetName;
		          options.subres = Object.assign({
		            symlink: ''
		          }, options.subres);
		          if (options.versionId) {
		            options.subres.versionId = options.versionId;
		          }
		          if (options.storageClass) {
		            options.headers['x-oss-storage-class'] = options.storageClass;
		          }
		          name = this._objectName(name);
		          params = this._objectRequestParams('PUT', name, options);
		          params.successStatuses = [200];
		          _context.next = 13;
		          return this.request(params);
		        case 13:
		          result = _context.sent;
		          return _context.abrupt("return", {
		            res: result.res
		          });
		        case 15:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function putSymlink(_x, _x2, _x3) {
		    return _putSymlink.apply(this, arguments);
		  }
		  return putSymlink;
		}();

		},{"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.object.assign.js":325}],48:[function(require,module,exports){
		(function (Buffer){(function (){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		var __importDefault = function (mod) {
		  return mod && mod.__esModule ? mod : {
		    "default": mod
		  };
		};
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.signPostObjectPolicyV4 = void 0;
		var dateformat_1 = __importDefault(require("dateformat"));
		var getStandardRegion_1 = require("../utils/getStandardRegion");
		var policy2Str_1 = require("../utils/policy2Str");
		var signUtils_1 = require("../signUtils");
		function signPostObjectPolicyV4(policy, date) {
		  var policyStr = Buffer.from(policy2Str_1.policy2Str(policy), 'utf8').toString('base64');
		  var formattedDate = dateformat_1.default(date, "UTC:yyyymmdd'T'HHMMss'Z'");
		  var onlyDate = formattedDate.split('T')[0];
		  var signature = signUtils_1.getSignatureV4(this.options.accessKeySecret, onlyDate, getStandardRegion_1.getStandardRegion(this.options.region), policyStr);
		  return signature;
		}
		exports.signPostObjectPolicyV4 = signPostObjectPolicyV4;

		}).call(this);}).call(this,require("buffer").Buffer);
		},{"../signUtils":52,"../utils/getStandardRegion":65,"../utils/policy2Str":79,"buffer":103,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.to-string.js":339,"dateformat":383}],49:[function(require,module,exports){

		require("core-js/modules/es.regexp.exec.js");
		var urlutil = require('url');
		var utility = require('utility');
		var copy = require('copy-to');
		var signHelper = require('../../common/signUtils');
		var _require = require('../utils/isIP'),
		  isIP = _require.isIP;
		var proto = exports;

		/**
		 *  signatureUrl
		 * @deprecated will be deprecated in 7.x
		 * @param {String} name object name
		 * @param {Object} options options
		 * @param {boolean} [strictObjectNameValidation=true] the flag of verifying object name strictly
		 */
		proto.signatureUrl = function signatureUrl(name, options) {
		  var strictObjectNameValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
		  if (isIP(this.options.endpoint.hostname)) {
		    throw new Error('can not get the object URL when endpoint is IP');
		  }
		  if (strictObjectNameValidation && /^\?/.test(name)) {
		    throw new Error("Invalid object name ".concat(name));
		  }
		  options = options || {};
		  name = this._objectName(name);
		  options.method = options.method || 'GET';
		  var expires = utility.timestamp() + (options.expires || 1800);
		  var params = {
		    bucket: this.options.bucket,
		    object: name
		  };
		  var resource = this._getResource(params);
		  if (this.options.stsToken) {
		    options['security-token'] = this.options.stsToken;
		  }
		  var signRes = signHelper._signatureForURL(this.options.accessKeySecret, options, resource, expires);
		  var url = urlutil.parse(this._getReqUrl(params));
		  url.query = {
		    OSSAccessKeyId: this.options.accessKeyId,
		    Expires: expires,
		    Signature: signRes.Signature
		  };
		  copy(signRes.subResource).to(url.query);
		  return url.format();
		};

		},{"../../common/signUtils":52,"../utils/isIP":73,"copy-to":107,"core-js/modules/es.regexp.exec.js":338,"url":543,"utility":545}],50:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.assign.js");
		require("core-js/modules/es.array.join.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var dateFormat = require('dateformat');
		var urlUtil = require('url');
		var signHelper = require('../../common/signUtils');
		var _require = require('../utils/setSTSToken'),
		  setSTSToken = _require.setSTSToken;
		var _require2 = require('../utils/isFunction'),
		  isFunction = _require2.isFunction;
		var _require3 = require('../utils/getStandardRegion'),
		  getStandardRegion = _require3.getStandardRegion;
		var proto = exports;

		/**
		 * signatureUrlV4
		 *
		 * @param {string} method
		 * @param {number} expires
		 * @param {Object} [request]
		 * @param {Object} [request.headers]
		 * @param {Object} [request.queries]
		 * @param {string} [objectName]
		 * @param {string[]} [additionalHeaders]
		 */
		proto.signatureUrlV4 = /*#__PURE__*/function () {
		  var _signatureUrlV = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(method, expires, request, objectName, additionalHeaders) {
		    var headers, queries, date, formattedDate, onlyDate, fixedAdditionalHeaders, region, canonicalRequest, stringToSign, signedUrl;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          headers = request && request.headers || {};
		          queries = Object.assign({}, request && request.queries || {});
		          date = new Date();
		          formattedDate = dateFormat(date, "UTC:yyyymmdd'T'HHMMss'Z'");
		          onlyDate = formattedDate.split('T')[0];
		          fixedAdditionalHeaders = signHelper.fixAdditionalHeaders(additionalHeaders);
		          region = getStandardRegion(this.options.region);
		          if (fixedAdditionalHeaders.length > 0) {
		            queries['x-oss-additional-headers'] = fixedAdditionalHeaders.join(';');
		          }
		          queries['x-oss-credential'] = signHelper.getCredential(onlyDate, region, this.options.accessKeyId);
		          queries['x-oss-date'] = formattedDate;
		          queries['x-oss-expires'] = expires;
		          queries['x-oss-signature-version'] = 'OSS4-HMAC-SHA256';
		          if (!(this.options.stsToken && isFunction(this.options.refreshSTSToken))) {
		            _context.next = 15;
		            break;
		          }
		          _context.next = 15;
		          return setSTSToken.call(this);
		        case 15:
		          if (this.options.stsToken) {
		            queries['x-oss-security-token'] = this.options.stsToken;
		          }
		          canonicalRequest = signHelper.getCanonicalRequest(method, {
		            headers: headers,
		            queries: queries
		          }, this.options.bucket, objectName, fixedAdditionalHeaders);
		          stringToSign = signHelper.getStringToSign(region, formattedDate, canonicalRequest);
		          queries['x-oss-signature'] = signHelper.getSignatureV4(this.options.accessKeySecret, onlyDate, region, stringToSign);
		          signedUrl = urlUtil.parse(this._getReqUrl({
		            bucket: this.options.bucket,
		            object: objectName
		          }));
		          signedUrl.query = Object.assign({}, queries);
		          return _context.abrupt("return", signedUrl.format());
		        case 22:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  function signatureUrlV4(_x, _x2, _x3, _x4, _x5) {
		    return _signatureUrlV.apply(this, arguments);
		  }
		  return signatureUrlV4;
		}();

		},{"../../common/signUtils":52,"../utils/getStandardRegion":65,"../utils/isFunction":72,"../utils/setSTSToken":82,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.array.join.js":317,"core-js/modules/es.object.assign.js":325,"dateformat":383,"url":543}],51:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.array.iterator.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.promise.js");
		require("core-js/modules/es.string.iterator.js");
		require("core-js/modules/web.dom-collections.iterator.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.function.name.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		var _require = require('./utils/isArray'),
		  isArray = _require.isArray;
		var proto = exports;
		proto._parallelNode = /*#__PURE__*/function () {
		  var _parallelNode2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(todo, parallel, fn, sourceData) {
		    var that, jobErr, jobs, tempBatch, remainder, batch, taskIndex, i;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          that = this; // upload in parallel
		          jobErr = [];
		          jobs = [];
		          tempBatch = todo.length / parallel;
		          remainder = todo.length % parallel;
		          batch = remainder === 0 ? tempBatch : (todo.length - remainder) / parallel + 1;
		          taskIndex = 1;
		          i = 0;
		        case 8:
		          if (!(i < todo.length)) {
		            _context.next = 26;
		            break;
		          }
		          if (!that.isCancel()) {
		            _context.next = 11;
		            break;
		          }
		          return _context.abrupt("break", 26);
		        case 11:
		          if (sourceData) {
		            jobs.push(fn(that, todo[i], sourceData));
		          } else {
		            jobs.push(fn(that, todo[i]));
		          }
		          if (!(jobs.length === parallel || taskIndex === batch && i === todo.length - 1)) {
		            _context.next = 23;
		            break;
		          }
		          _context.prev = 13;
		          taskIndex += 1;
		          /* eslint no-await-in-loop: [0] */
		          _context.next = 17;
		          return Promise.all(jobs);
		        case 17:
		          _context.next = 22;
		          break;
		        case 19:
		          _context.prev = 19;
		          _context.t0 = _context["catch"](13);
		          jobErr.push(_context.t0);
		        case 22:
		          jobs = [];
		        case 23:
		          i++;
		          _context.next = 8;
		          break;
		        case 26:
		          return _context.abrupt("return", jobErr);
		        case 27:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this, [[13, 19]]);
		  }));
		  function _parallelNode(_x, _x2, _x3, _x4) {
		    return _parallelNode2.apply(this, arguments);
		  }
		  return _parallelNode;
		}();
		proto._parallel = function _parallel(todo, parallel, jobPromise) {
		  var that = this;
		  return new Promise(function (resolve) {
		    var _jobErr = [];
		    if (parallel <= 0 || !todo) {
		      resolve(_jobErr);
		      return;
		    }
		    function onlyOnce(fn) {
		      return function () {
		        if (fn === null) throw new Error('Callback was already called.');
		        var callFn = fn;
		        fn = null;
		        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
		          args[_key] = arguments[_key];
		        }
		        callFn.apply(this, args);
		      };
		    }
		    function createArrayIterator(coll) {
		      var i = -1;
		      var len = coll.length;
		      return function next() {
		        return ++i < len && !that.isCancel() ? {
		          value: coll[i],
		          key: i
		        } : null;
		      };
		    }
		    var nextElem = createArrayIterator(todo);
		    var done = false;
		    var running = 0;
		    var looping = false;
		    function iterateeCallback(err) {
		      running -= 1;
		      if (err) {
		        done = true;
		        _jobErr.push(err);
		        resolve(_jobErr);
		      } else if (done && running <= 0) {
		        done = true;
		        resolve(_jobErr);
		      } else if (!looping) {
		        /* eslint no-use-before-define: [0] */
		        if (that.isCancel()) {
		          resolve(_jobErr);
		        } else {
		          replenish();
		        }
		      }
		    }
		    function iteratee(value, callback) {
		      jobPromise(value).then(function (result) {
		        callback(null, result);
		      }).catch(function (err) {
		        callback(err);
		      });
		    }
		    function replenish() {
		      looping = true;
		      while (running < parallel && !done && !that.isCancel()) {
		        var elem = nextElem();
		        if (elem === null || _jobErr.length > 0) {
		          done = true;
		          if (running <= 0) {
		            resolve(_jobErr);
		          }
		          return;
		        }
		        running += 1;
		        iteratee(elem.value, onlyOnce(iterateeCallback));
		      }
		      looping = false;
		    }
		    replenish();
		  });
		};

		/**
		 * cancel operation, now can use with multipartUpload
		 * @param {Object} abort
		 *        {String} anort.name object key
		 *        {String} anort.uploadId upload id
		 *        {String} anort.options timeout
		 */
		proto.cancel = function cancel(abort) {
		  this.options.cancelFlag = true;
		  if (isArray(this.multipartUploadStreams)) {
		    this.multipartUploadStreams.forEach(function (_) {
		      if (_.destroyed === false) {
		        var err = {
		          name: 'cancel',
		          message: 'cancel'
		        };
		        _.destroy(err);
		      }
		    });
		  }
		  this.multipartUploadStreams = [];
		  if (abort) {
		    this.abortMultipartUpload(abort.name, abort.uploadId, abort.options);
		  }
		};
		proto.isCancel = function isCancel() {
		  return this.options.cancelFlag;
		};
		proto.resetCancelFlag = function resetCancelFlag() {
		  this.options.cancelFlag = false;
		};
		proto._stop = function _stop() {
		  this.options.cancelFlag = true;
		};

		// cancel is not error , so create an object
		proto._makeCancelEvent = function _makeCancelEvent() {
		  var cancelEvent = {
		    status: 0,
		    name: 'cancel'
		  };
		  return cancelEvent;
		};

		// abort is not error , so create an object
		proto._makeAbortEvent = function _makeAbortEvent() {
		  var abortEvent = {
		    status: 0,
		    name: 'abort',
		    message: 'upload task has been abort'
		  };
		  return abortEvent;
		};

		},{"./utils/isArray":67,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.array.iterator.js":316,"core-js/modules/es.function.name.js":322,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.promise.js":333,"core-js/modules/es.string.iterator.js":343,"core-js/modules/web.dom-collections.for-each.js":380,"core-js/modules/web.dom-collections.iterator.js":381}],52:[function(require,module,exports){
		(function (Buffer){(function (){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
		require("core-js/modules/es.string.trim.js");
		require("core-js/modules/es.array.sort.js");
		require("core-js/modules/es.array.join.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.array.filter.js");
		require("core-js/modules/es.array.iterator.js");
		require("core-js/modules/es.set.js");
		require("core-js/modules/es.string.iterator.js");
		require("core-js/modules/web.dom-collections.iterator.js");
		require("core-js/modules/es.array.map.js");
		require("core-js/modules/es.string.starts-with.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		require("core-js/modules/es.object.entries.js");
		require("core-js/modules/es.regexp.to-string.js");
		var crypto = require('./../../shims/crypto/crypto.js');
		var is = require('is-type-of');
		var qs = require('qs');
		var _require = require('./utils/lowercaseKeyHeader'),
		  lowercaseKeyHeader = _require.lowercaseKeyHeader;
		var _require2 = require('./utils/encodeString'),
		  encodeString = _require2.encodeString;

		/**
		 *
		 * @param {String} resourcePath
		 * @param {Object} parameters
		 * @return
		 */
		exports.buildCanonicalizedResource = function buildCanonicalizedResource(resourcePath, parameters) {
		  var canonicalizedResource = "".concat(resourcePath);
		  var separatorString = '?';
		  if (is.string(parameters) && parameters.trim() !== '') {
		    canonicalizedResource += separatorString + parameters;
		  } else if (is.array(parameters)) {
		    parameters.sort();
		    canonicalizedResource += separatorString + parameters.join('&');
		  } else if (parameters) {
		    var processFunc = function processFunc(key) {
		      canonicalizedResource += separatorString + key;
		      if (parameters[key] || parameters[key] === 0) {
		        canonicalizedResource += "=".concat(parameters[key]);
		      }
		      separatorString = '&';
		    };
		    Object.keys(parameters).sort().forEach(processFunc);
		  }
		  return canonicalizedResource;
		};

		/**
		 * @param {String} method
		 * @param {String} resourcePath
		 * @param {Object} request
		 * @param {String} expires
		 * @return {String} canonicalString
		 */
		exports.buildCanonicalString = function canonicalString(method, resourcePath, request, expires) {
		  request = request || {};
		  var headers = lowercaseKeyHeader(request.headers);
		  var OSS_PREFIX = 'x-oss-';
		  var ossHeaders = [];
		  var headersToSign = {};
		  var signContent = [method.toUpperCase(), headers['content-md5'] || '', headers['content-type'], expires || headers['x-oss-date']];
		  Object.keys(headers).forEach(function (key) {
		    var lowerKey = key.toLowerCase();
		    if (lowerKey.indexOf(OSS_PREFIX) === 0) {
		      headersToSign[lowerKey] = String(headers[key]).trim();
		    }
		  });
		  Object.keys(headersToSign).sort().forEach(function (key) {
		    ossHeaders.push("".concat(key, ":").concat(headersToSign[key]));
		  });
		  signContent = signContent.concat(ossHeaders);
		  signContent.push(this.buildCanonicalizedResource(resourcePath, request.parameters));
		  return signContent.join('\n');
		};

		/**
		 * @param {String} accessKeySecret
		 * @param {String} canonicalString
		 */
		exports.computeSignature = function computeSignature(accessKeySecret, canonicalString) {
		  var headerEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf-8';
		  var signature = crypto.createHmac('sha1', accessKeySecret);
		  return signature.update(Buffer.from(canonicalString, headerEncoding)).digest('base64');
		};

		/**
		 * @param {String} accessKeyId
		 * @param {String} accessKeySecret
		 * @param {String} canonicalString
		 */
		exports.authorization = function authorization(accessKeyId, accessKeySecret, canonicalString, headerEncoding) {
		  return "OSS ".concat(accessKeyId, ":").concat(this.computeSignature(accessKeySecret, canonicalString, headerEncoding));
		};

		/**
		 * @param {string[]} [additionalHeaders]
		 * @returns {string[]}
		 */
		exports.fixAdditionalHeaders = function (additionalHeaders) {
		  if (!additionalHeaders) {
		    return [];
		  }
		  var OSS_PREFIX = 'x-oss-';
		  return (0, _toConsumableArray2.default)(new Set(additionalHeaders.map(function (v) {
		    return v.toLowerCase();
		  }))).filter(function (v) {
		    return v !== 'content-type' && v !== 'content-md5' && !v.startsWith(OSS_PREFIX);
		  }).sort();
		};

		/**
		 * @param {string} method
		 * @param {Object} request
		 * @param {Object} request.headers
		 * @param {Object} [request.queries]
		 * @param {string} [bucketName]
		 * @param {string} [objectName]
		 * @param {string[]} [additionalHeaders] additional headers after deduplication, lowercase and sorting
		 * @returns {string}
		 */
		exports.getCanonicalRequest = function getCanonicalRequest(method, request, bucketName, objectName, additionalHeaders) {
		  var headers = lowercaseKeyHeader(request.headers);
		  var queries = request.queries || {};
		  var OSS_PREFIX = 'x-oss-';
		  if (objectName && !bucketName) {
		    throw Error('Please ensure that bucketName is passed into getCanonicalRequest.');
		  }
		  var signContent = [method.toUpperCase(),
		  // HTTP Verb
		  encodeString("/".concat(bucketName ? "".concat(bucketName, "/") : '').concat(objectName || '')).replace(/%2F/g, '/') // Canonical URI
		  ];

		  // Canonical Query String
		  signContent.push(qs.stringify(queries, {
		    encoder: encodeString,
		    sort: function sort(a, b) {
		      return a.localeCompare(b);
		    },
		    strictNullHandling: true
		  }));

		  // Canonical Headers
		  if (additionalHeaders) {
		    additionalHeaders.forEach(function (v) {
		      if (!Object.prototype.hasOwnProperty.call(headers, v)) {
		        throw Error("Can't find additional header ".concat(v, " in request headers."));
		      }
		    });
		  }
		  var tempHeaders = new Set(additionalHeaders);
		  Object.keys(headers).forEach(function (v) {
		    if (v === 'content-type' || v === 'content-md5' || v.startsWith(OSS_PREFIX)) {
		      tempHeaders.add(v);
		    }
		  });
		  var canonicalHeaders = "".concat((0, _toConsumableArray2.default)(tempHeaders).sort().map(function (v) {
		    return "".concat(v, ":").concat(is.string(headers[v]) ? headers[v].trim() : headers[v], "\n");
		  }).join(''));
		  signContent.push(canonicalHeaders);

		  // Additional Headers
		  if (additionalHeaders && additionalHeaders.length > 0) {
		    signContent.push(additionalHeaders.join(';'));
		  } else {
		    signContent.push('');
		  }

		  // Hashed Payload
		  signContent.push(headers['x-oss-content-sha256'] || 'UNSIGNED-PAYLOAD');
		  return signContent.join('\n');
		};

		/**
		 * @param {string} date yyyymmdd
		 * @param {string} region Standard region, e.g. cn-hangzhou
		 * @param {string} [accessKeyId] Access Key ID
		 * @param {string} [product] Product name, default is oss
		 * @returns {string}
		 */
		exports.getCredential = function getCredential(date, region, accessKeyId) {
		  var product = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'oss';
		  var tempCredential = "".concat(date, "/").concat(region, "/").concat(product, "/aliyun_v4_request");
		  if (accessKeyId) {
		    return "".concat(accessKeyId, "/").concat(tempCredential);
		  }
		  return tempCredential;
		};

		/**
		 * @param {string} region Standard region, e.g. cn-hangzhou
		 * @param {string} date ISO8601 UTC:yyyymmdd'T'HHMMss'Z'
		 * @param {string} canonicalRequest
		 * @returns {string}
		 */
		exports.getStringToSign = function getStringToSign(region, date, canonicalRequest) {
		  var stringToSign = ['OSS4-HMAC-SHA256', date,
		  // TimeStamp
		  this.getCredential(date.split('T')[0], region),
		  // Scope
		  crypto.createHash('sha256').update(canonicalRequest).digest('hex') // Hashed Canonical Request
		  ];
		  return stringToSign.join('\n');
		};

		/**
		 * @param {String} accessKeySecret
		 * @param {string} date yyyymmdd
		 * @param {string} region Standard region, e.g. cn-hangzhou
		 * @param {string} stringToSign
		 * @returns {string}
		 */
		exports.getSignatureV4 = function getSignatureV4(accessKeySecret, date, region, stringToSign) {
		  var signingDate = crypto.createHmac('sha256', "aliyun_v4".concat(accessKeySecret)).update(date).digest();
		  var signingRegion = crypto.createHmac('sha256', signingDate).update(region).digest();
		  var signingOss = crypto.createHmac('sha256', signingRegion).update('oss').digest();
		  var signingKey = crypto.createHmac('sha256', signingOss).update('aliyun_v4_request').digest();
		  var signatureValue = crypto.createHmac('sha256', signingKey).update(stringToSign).digest('hex');
		  return signatureValue;
		};

		/**
		 * @param {String} accessKeyId
		 * @param {String} accessKeySecret
		 * @param {string} region Standard region, e.g. cn-hangzhou
		 * @param {string} method
		 * @param {Object} request
		 * @param {Object} request.headers
		 * @param {Object} [request.queries]
		 * @param {string} [bucketName]
		 * @param {string} [objectName]
		 * @param {string[]} [additionalHeaders]
		 * @param {string} [headerEncoding='utf-8']
		 * @returns {string}
		 */
		exports.authorizationV4 = function authorizationV4(accessKeyId, accessKeySecret, region, method, request, bucketName, objectName, additionalHeaders) {
		  var headerEncoding = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 'utf-8';
		  var fixedAdditionalHeaders = this.fixAdditionalHeaders(additionalHeaders);
		  var fixedHeaders = {};
		  Object.entries(request.headers).forEach(function (v) {
		    fixedHeaders[v[0]] = is.string(v[1]) ? Buffer.from(v[1], headerEncoding).toString() : v[1];
		  });
		  var date = fixedHeaders['x-oss-date'] || request.queries && request.queries['x-oss-date'];
		  var canonicalRequest = this.getCanonicalRequest(method, {
		    headers: fixedHeaders,
		    queries: request.queries
		  }, bucketName, objectName, fixedAdditionalHeaders);
		  var stringToSign = this.getStringToSign(region, date, canonicalRequest);
		  var onlyDate = date.split('T')[0];
		  var signatureValue = this.getSignatureV4(accessKeySecret, onlyDate, region, stringToSign);
		  var additionalHeadersValue = fixedAdditionalHeaders.length > 0 ? "AdditionalHeaders=".concat(fixedAdditionalHeaders.join(';'), ",") : '';
		  return "OSS4-HMAC-SHA256 Credential=".concat(this.getCredential(onlyDate, region, accessKeyId), ",").concat(additionalHeadersValue, "Signature=").concat(signatureValue);
		};

		/**
		 *
		 * @param {String} accessKeySecret
		 * @param {Object} options
		 * @param {String} resource
		 * @param {Number} expires
		 */
		exports._signatureForURL = function _signatureForURL(accessKeySecret) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		  var resource = arguments.length > 2 ? arguments[2] : undefined;
		  var expires = arguments.length > 3 ? arguments[3] : undefined;
		  var headerEncoding = arguments.length > 4 ? arguments[4] : undefined;
		  var headers = {};
		  var _options$subResource = options.subResource,
		    subResource = _options$subResource === void 0 ? {} : _options$subResource;
		  if (options.process) {
		    var processKeyword = 'x-oss-process';
		    subResource[processKeyword] = options.process;
		  }
		  if (options.trafficLimit) {
		    var trafficLimitKey = 'x-oss-traffic-limit';
		    subResource[trafficLimitKey] = options.trafficLimit;
		  }
		  if (options.response) {
		    Object.keys(options.response).forEach(function (k) {
		      var key = "response-".concat(k.toLowerCase());
		      subResource[key] = options.response[k];
		    });
		  }
		  Object.keys(options).forEach(function (key) {
		    var lowerKey = key.toLowerCase();
		    var value = options[key];
		    if (lowerKey.indexOf('x-oss-') === 0) {
		      headers[lowerKey] = value;
		    } else if (lowerKey.indexOf('content-md5') === 0) {
		      headers[key] = value;
		    } else if (lowerKey.indexOf('content-type') === 0) {
		      headers[key] = value;
		    }
		  });
		  if (Object.prototype.hasOwnProperty.call(options, 'security-token')) {
		    subResource['security-token'] = options['security-token'];
		  }
		  if (Object.prototype.hasOwnProperty.call(options, 'callback')) {
		    var json = {
		      callbackUrl: encodeURI(options.callback.url),
		      callbackBody: options.callback.body
		    };
		    if (options.callback.host) {
		      json.callbackHost = options.callback.host;
		    }
		    if (options.callback.contentType) {
		      json.callbackBodyType = options.callback.contentType;
		    }
		    if (options.callback.callbackSNI) {
		      json.callbackSNI = options.callback.callbackSNI;
		    }
		    subResource.callback = Buffer.from(JSON.stringify(json)).toString('base64');
		    if (options.callback.customValue) {
		      var callbackVar = {};
		      Object.keys(options.callback.customValue).forEach(function (key) {
		        callbackVar["x:".concat(key)] = options.callback.customValue[key];
		      });
		      subResource['callback-var'] = Buffer.from(JSON.stringify(callbackVar)).toString('base64');
		    }
		  }
		  var canonicalString = this.buildCanonicalString(options.method, resource, {
		    headers: headers,
		    parameters: subResource
		  }, expires.toString());
		  return {
		    Signature: this.computeSignature(accessKeySecret, canonicalString, headerEncoding),
		    subResource: subResource
		  };
		};

		}).call(this);}).call(this,require("buffer").Buffer);
		},{"./../../shims/crypto/crypto.js":531,"./utils/encodeString":61,"./utils/lowercaseKeyHeader":75,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/helpers/toConsumableArray":90,"buffer":103,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.filter.js":312,"core-js/modules/es.array.iterator.js":316,"core-js/modules/es.array.join.js":317,"core-js/modules/es.array.map.js":318,"core-js/modules/es.array.sort.js":320,"core-js/modules/es.object.entries.js":326,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/es.set.js":341,"core-js/modules/es.string.iterator.js":343,"core-js/modules/es.string.replace.js":345,"core-js/modules/es.string.starts-with.js":348,"core-js/modules/es.string.trim.js":349,"core-js/modules/web.dom-collections.for-each.js":380,"core-js/modules/web.dom-collections.iterator.js":381,"is-type-of":537,"qs":445}],53:[function(require,module,exports){

		require("core-js/modules/es.regexp.exec.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.checkBucketName = void 0;
		exports.checkBucketName = function (name) {
		  var createBucket = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
		  var bucketRegex = createBucket ? /^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$/ : /^[a-z0-9_][a-z0-9-_]{1,61}[a-z0-9_]$/;
		  if (!bucketRegex.test(name)) {
		    throw new Error('The bucket must be conform to the specifications');
		  }
		};

		},{"core-js/modules/es.regexp.exec.js":338}],54:[function(require,module,exports){

		require("core-js/modules/es.regexp.exec.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.checkConfigValid = void 0;
		var checkConfigMap = {
		  endpoint: checkEndpoint,
		  region: /^[a-zA-Z0-9\-_]+$/
		};
		function checkEndpoint(endpoint) {
		  if (typeof endpoint === 'string') {
		    return /^[a-zA-Z0-9._:/-]+$/.test(endpoint);
		  } else if (endpoint.host) {
		    return /^[a-zA-Z0-9._:/-]+$/.test(endpoint.host);
		  }
		  return false;
		}
		exports.checkConfigValid = function (conf, key) {
		  if (checkConfigMap[key]) {
		    var isConfigValid = true;
		    if (checkConfigMap[key] instanceof Function) {
		      isConfigValid = checkConfigMap[key](conf);
		    } else {
		      isConfigValid = checkConfigMap[key].test(conf);
		    }
		    if (!isConfigValid) {
		      throw new Error("The ".concat(key, " must be conform to the specifications"));
		    }
		  }
		};

		},{"core-js/modules/es.regexp.exec.js":338}],55:[function(require,module,exports){
		(function (process){(function (){

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.checkEnv = void 0;
		function checkEnv(msg) {
		  if (process.browser) {
		    console.warn(msg);
		  }
		}
		exports.checkEnv = checkEnv;

		}).call(this);}).call(this,require('_process'));
		},{"_process":538}],56:[function(require,module,exports){

		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.object.entries.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.checkObjectTag = void 0;
		var _require = require('./checkValid'),
		  checkValid = _require.checkValid;
		var _require2 = require('./isObject'),
		  isObject = _require2.isObject;
		var commonRules = [{
		  validator: function validator(value) {
		    if (typeof value !== 'string') {
		      throw new Error('the key and value of the tag must be String');
		    }
		  }
		}, {
		  pattern: /^[a-zA-Z0-9 +-=._:/]+$/,
		  msg: 'tag can contain letters, numbers, spaces, and the following symbols: plus sign (+), hyphen (-), equal sign (=), period (.), underscore (_), colon (:), and forward slash (/)'
		}];
		var rules = {
		  key: [].concat(commonRules, [{
		    pattern: /^.{1,128}$/,
		    msg: 'tag key can be a maximum of 128 bytes in length'
		  }]),
		  value: [].concat(commonRules, [{
		    pattern: /^.{0,256}$/,
		    msg: 'tag value can be a maximum of 256 bytes in length'
		  }])
		};
		function checkObjectTag(tag) {
		  if (!isObject(tag)) {
		    throw new Error('tag must be Object');
		  }
		  var entries = Object.entries(tag);
		  if (entries.length > 10) {
		    throw new Error('maximum of 10 tags for a object');
		  }
		  var rulesIndexKey = ['key', 'value'];
		  entries.forEach(function (keyValue) {
		    keyValue.forEach(function (item, index) {
		      checkValid(item, rules[rulesIndexKey[index]]);
		    });
		  });
		}
		exports.checkObjectTag = checkObjectTag;

		},{"./checkValid":57,"./isObject":74,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.object.entries.js":326,"core-js/modules/es.object.to-string.js":329,"core-js/modules/web.dom-collections.for-each.js":380}],57:[function(require,module,exports){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.regexp.exec.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.checkValid = void 0;
		function checkValid(_value, _rules) {
		  _rules.forEach(function (rule) {
		    if (rule.validator) {
		      rule.validator(_value);
		    } else if (rule.pattern && !rule.pattern.test(_value)) {
		      throw new Error(rule.msg);
		    }
		  });
		}
		exports.checkValid = checkValid;

		},{"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/web.dom-collections.for-each.js":380}],58:[function(require,module,exports){
		(function (Buffer){(function (){

		require("core-js/modules/es.array.includes.js");
		require("core-js/modules/es.string.includes.js");
		require("core-js/modules/es.object.assign.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.entries.js");
		require("core-js/modules/es.array.concat.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.createRequest = void 0;
		var crypto = require('./../../../shims/crypto/crypto.js');
		var debug = require('debug')('ali-oss');
		var _isString = require('lodash/isString');
		var _isArray = require('lodash/isArray');
		var _isObject = require('lodash/isObject');
		var mime = require('mime');
		var dateFormat = require('dateformat');
		var copy = require('copy-to');
		var path = require('path');
		var _require = require('./encoder'),
		  encoder = _require.encoder;
		var _require2 = require('./isIP'),
		  isIP = _require2.isIP;
		var _require3 = require('./setRegion'),
		  setRegion = _require3.setRegion;
		var _require4 = require('../client/getReqUrl'),
		  getReqUrl = _require4.getReqUrl;
		var _require5 = require('./isDingTalk'),
		  isDingTalk = _require5.isDingTalk;
		function getHeader(headers, name) {
		  return headers[name] || headers[name.toLowerCase()];
		}
		function delHeader(headers, name) {
		  delete headers[name];
		  delete headers[name.toLowerCase()];
		}
		function createRequest(params) {
		  var date = new Date();
		  if (this.options.amendTimeSkewed) {
		    date = +new Date() + this.options.amendTimeSkewed;
		  }
		  var headers = {
		    'x-oss-date': dateFormat(date, this.options.authorizationV4 ? "UTC:yyyymmdd'T'HHMMss'Z'" : "UTC:ddd, dd mmm yyyy HH:MM:ss 'GMT'")
		  };
		  if (this.options.authorizationV4) {
		    headers['x-oss-content-sha256'] = 'UNSIGNED-PAYLOAD';
		  }
		  if (typeof window !== 'undefined') {
		    headers['x-oss-user-agent'] = this.userAgent;
		  }
		  if (this.userAgent.includes('nodejs')) {
		    headers['User-Agent'] = this.userAgent;
		  }
		  if (this.options.isRequestPay) {
		    Object.assign(headers, {
		      'x-oss-request-payer': 'requester'
		    });
		  }
		  if (this.options.stsToken) {
		    headers['x-oss-security-token'] = this.options.stsToken;
		  }
		  copy(params.headers).to(headers);
		  if (!getHeader(headers, 'Content-Type')) {
		    if (params.mime && params.mime.indexOf('/') > 0) {
		      headers['Content-Type'] = params.mime;
		    } else if (isDingTalk()) {
		      headers['Content-Type'] = 'application/octet-stream';
		    } else {
		      headers['Content-Type'] = mime.getType(params.mime || path.extname(params.object || ''));
		    }
		  }
		  if (!getHeader(headers, 'Content-Type')) {
		    delHeader(headers, 'Content-Type');
		  }
		  if (params.content) {
		    if (!params.disabledMD5) {
		      if (!params.headers || !params.headers['Content-MD5']) {
		        headers['Content-MD5'] = crypto.createHash('md5').update(Buffer.from(params.content, 'utf8')).digest('base64');
		      } else {
		        headers['Content-MD5'] = params.headers['Content-MD5'];
		      }
		    }
		    if (!headers['Content-Length']) {
		      headers['Content-Length'] = params.content.length;
		    }
		  }
		  var hasOwnProperty = Object.prototype.hasOwnProperty;
		  for (var k in headers) {
		    if (headers[k] && hasOwnProperty.call(headers, k)) {
		      headers[k] = encoder(String(headers[k]), this.options.headerEncoding);
		    }
		  }
		  var queries = {};
		  if (_isString(params.subres)) {
		    queries[params.subres] = null;
		  } else if (_isArray(params.subres)) {
		    params.subres.forEach(function (v) {
		      queries[v] = null;
		    });
		  } else if (_isObject(params.subres)) {
		    Object.entries(params.subres).forEach(function (v) {
		      queries[v[0]] = v[1] === '' ? null : v[1];
		    });
		  }
		  if (_isObject(params.query)) {
		    Object.entries(params.query).forEach(function (v) {
		      queries[v[0]] = v[1];
		    });
		  }
		  headers.authorization = this.options.authorizationV4 ? this.authorizationV4(params.method, {
		    headers: headers,
		    queries: queries
		  }, params.bucket, params.object, params.additionalHeaders) : this.authorization(params.method, this._getResource(params), params.subres, headers, this.options.headerEncoding);
		  // const url = this._getReqUrl(params);
		  if (isIP(this.options.endpoint.hostname)) {
		    var _this$options = this.options,
		      region = _this$options.region,
		      internal = _this$options.internal,
		      secure = _this$options.secure;
		    var hostInfo = setRegion(region, internal, secure);
		    headers.host = "".concat(params.bucket, ".").concat(hostInfo.host);
		  }
		  var url = getReqUrl.bind(this)(params);
		  debug('request %s %s, with headers %j, !!stream: %s', params.method, url, headers, !!params.stream);
		  var timeout = params.timeout || this.options.timeout;
		  var reqParams = {
		    method: params.method,
		    content: params.content,
		    stream: params.stream,
		    headers: headers,
		    timeout: timeout,
		    writeStream: params.writeStream,
		    customResponse: params.customResponse,
		    ctx: params.ctx || this.ctx
		  };
		  if (this.agent) {
		    reqParams.agent = this.agent;
		  }
		  if (this.httpsAgent) {
		    reqParams.httpsAgent = this.httpsAgent;
		  }
		  reqParams.enableProxy = !!this.options.enableProxy;
		  reqParams.proxy = this.options.proxy ? this.options.proxy : null;
		  return {
		    url: url,
		    params: reqParams
		  };
		}
		exports.createRequest = createRequest;

		}).call(this);}).call(this,require("buffer").Buffer);
		},{"../client/getReqUrl":25,"./../../../shims/crypto/crypto.js":531,"./encoder":62,"./isDingTalk":70,"./isIP":73,"./setRegion":81,"buffer":103,"copy-to":107,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.includes.js":315,"core-js/modules/es.object.assign.js":325,"core-js/modules/es.object.entries.js":326,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.string.includes.js":342,"core-js/modules/web.dom-collections.for-each.js":380,"dateformat":383,"debug":536,"lodash/isArray":422,"lodash/isObject":423,"lodash/isString":425,"mime":430,"path":439}],59:[function(require,module,exports){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.entries.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		require("core-js/modules/es.array.includes.js");
		require("core-js/modules/es.object.keys.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.dataFix = void 0;
		var isObject_1 = require("./isObject");
		var TRUE = ['true', 'TRUE', '1', 1];
		var FALSE = ['false', 'FALSE', '0', 0];
		function dataFix(o, conf, finalKill) {
		  if (!isObject_1.isObject(o)) return;
		  var _conf$remove = conf.remove,
		    remove = _conf$remove === void 0 ? [] : _conf$remove,
		    _conf$rename = conf.rename,
		    rename = _conf$rename === void 0 ? {} : _conf$rename,
		    _conf$camel = conf.camel,
		    camel = _conf$camel === void 0 ? [] : _conf$camel,
		    _conf$bool = conf.bool,
		    bool = _conf$bool === void 0 ? [] : _conf$bool,
		    _conf$lowerFirst = conf.lowerFirst,
		    lowerFirst = _conf$lowerFirst === void 0 ? false : _conf$lowerFirst;
		  // 删除不需要的数据
		  remove.forEach(function (v) {
		    return delete o[v];
		  });
		  // 重命名
		  Object.entries(rename).forEach(function (v) {
		    if (!o[v[0]]) return;
		    if (o[v[1]]) return;
		    o[v[1]] = o[v[0]];
		    delete o[v[0]];
		  });
		  // 驼峰化
		  camel.forEach(function (v) {
		    if (!o[v]) return;
		    var afterKey = v.replace(/^(.)/, function ($0) {
		      return $0.toLowerCase();
		    }).replace(/-(\w)/g, function (_, $1) {
		      return $1.toUpperCase();
		    });
		    if (o[afterKey]) return;
		    o[afterKey] = o[v];
		    // todo 暂时兼容以前数据，不做删除
		    // delete o[v];
		  });
		  // 转换值为布尔值
		  bool.forEach(function (v) {
		    o[v] = fixBool(o[v]);
		  });
		  // finalKill
		  if (typeof finalKill === 'function') {
		    finalKill(o);
		  }
		  // 首字母转小写
		  fixLowerFirst(o, lowerFirst);
		  return dataFix;
		}
		exports.dataFix = dataFix;
		function fixBool(value) {
		  if (!value) return false;
		  if (TRUE.includes(value)) return true;
		  return FALSE.includes(value) ? false : value;
		}
		function fixLowerFirst(o, lowerFirst) {
		  if (lowerFirst) {
		    Object.keys(o).forEach(function (key) {
		      var lowerK = key.replace(/^\w/, function (match) {
		        return match.toLowerCase();
		      });
		      if (typeof o[lowerK] === 'undefined') {
		        o[lowerK] = o[key];
		        delete o[key];
		      }
		    });
		  }
		}

		},{"./isObject":74,"core-js/modules/es.array.includes.js":315,"core-js/modules/es.object.entries.js":326,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.replace.js":345,"core-js/modules/web.dom-collections.for-each.js":380}],60:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		require("core-js/modules/es.array.slice.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.deepCopyWith = exports.deepCopy = void 0;
		var isBuffer_1 = require("./isBuffer");
		exports.deepCopy = function (obj) {
		  if (obj === null || (0, _typeof2.default)(obj) !== 'object') {
		    return obj;
		  }
		  if (isBuffer_1.isBuffer(obj)) {
		    return obj.slice();
		  }
		  var copy = Array.isArray(obj) ? [] : {};
		  Object.keys(obj).forEach(function (key) {
		    copy[key] = exports.deepCopy(obj[key]);
		  });
		  return copy;
		};
		exports.deepCopyWith = function (obj, customizer) {
		  function deepCopyWithHelper(value, innerKey, innerObject) {
		    var result = customizer(value, innerKey, innerObject);
		    if (result !== undefined) return result;
		    if (value === null || (0, _typeof2.default)(value) !== 'object') {
		      return value;
		    }
		    if (isBuffer_1.isBuffer(value)) {
		      return value.slice();
		    }
		    var copy = Array.isArray(value) ? [] : {};
		    Object.keys(value).forEach(function (k) {
		      copy[k] = deepCopyWithHelper(value[k], k, value);
		    });
		    return copy;
		  }
		  if (customizer) {
		    return deepCopyWithHelper(obj, '', null);
		  } else {
		    return exports.deepCopy(obj);
		  }
		};

		},{"./isBuffer":69,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/helpers/typeof":91,"core-js/modules/es.array.slice.js":319,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/web.dom-collections.for-each.js":380}],61:[function(require,module,exports){

		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		var __importDefault = function (mod) {
		  return mod && mod.__esModule ? mod : {
		    "default": mod
		  };
		};
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.encodeString = void 0;
		var toString_1 = __importDefault(require("lodash/toString"));
		function encodeString(str) {
		  var tempStr = toString_1.default(str);
		  return encodeURIComponent(tempStr).replace(/[!'()*]/g, function (c) {
		    return "%".concat(c.charCodeAt(0).toString(16).toUpperCase());
		  });
		}
		exports.encodeString = encodeString;

		},{"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/es.string.replace.js":345,"lodash/toString":427}],62:[function(require,module,exports){
		(function (Buffer){(function (){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.encoder = void 0;
		function encoder(str) {
		  var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf-8';
		  if (encoding === 'utf-8') return str;
		  return Buffer.from(str).toString('latin1');
		}
		exports.encoder = encoder;

		}).call(this);}).call(this,require("buffer").Buffer);
		},{"buffer":103,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.to-string.js":339}],63:[function(require,module,exports){

		require("core-js/modules/es.array.map.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.formatInventoryConfig = void 0;
		var dataFix_1 = require("../utils/dataFix");
		var isObject_1 = require("../utils/isObject");
		var isArray_1 = require("../utils/isArray");
		var formatObjKey_1 = require("../utils/formatObjKey");
		function formatInventoryConfig(inventoryConfig) {
		  var toArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
		  if (toArray && isObject_1.isObject(inventoryConfig)) inventoryConfig = [inventoryConfig];
		  if (isArray_1.isArray(inventoryConfig)) {
		    inventoryConfig = inventoryConfig.map(formatFn);
		  } else {
		    inventoryConfig = formatFn(inventoryConfig);
		  }
		  return inventoryConfig;
		}
		exports.formatInventoryConfig = formatInventoryConfig;
		function formatFn(_) {
		  dataFix_1.dataFix(_, {
		    bool: ['IsEnabled']
		  }, function (conf) {
		    var _a, _b;
		    // prefix
		    conf.prefix = conf.Filter.Prefix;
		    delete conf.Filter;
		    // OSSBucketDestination
		    conf.OSSBucketDestination = conf.Destination.OSSBucketDestination;
		    // OSSBucketDestination.rolename
		    conf.OSSBucketDestination.rolename = conf.OSSBucketDestination.RoleArn.replace(/.*\//, '');
		    delete conf.OSSBucketDestination.RoleArn;
		    // OSSBucketDestination.bucket
		    conf.OSSBucketDestination.bucket = conf.OSSBucketDestination.Bucket.replace(/.*:::/, '');
		    delete conf.OSSBucketDestination.Bucket;
		    delete conf.Destination;
		    // frequency
		    conf.frequency = conf.Schedule.Frequency;
		    delete conf.Schedule.Frequency;
		    // optionalFields
		    if (((_a = conf === null || conf === void 0 ? void 0 : conf.OptionalFields) === null || _a === void 0 ? void 0 : _a.Field) && !isArray_1.isArray((_b = conf.OptionalFields) === null || _b === void 0 ? void 0 : _b.Field)) conf.OptionalFields.Field = [conf.OptionalFields.Field];
		  });
		  // firstLowerCase
		  _ = formatObjKey_1.formatObjKey(_, 'firstLowerCase', {
		    exclude: ['OSSBucketDestination', 'SSE-OSS', 'SSE-KMS']
		  });
		  return _;
		}

		},{"../utils/dataFix":59,"../utils/formatObjKey":64,"../utils/isArray":67,"../utils/isObject":74,"core-js/modules/es.array.map.js":318,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.replace.js":345}],64:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.array.includes.js");
		require("core-js/modules/es.string.includes.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.formatObjKey = void 0;
		function formatObjKey(obj, type, options) {
		  if (obj === null || (0, _typeof2.default)(obj) !== 'object') {
		    return obj;
		  }
		  var o;
		  if (Array.isArray(obj)) {
		    o = [];
		    for (var i = 0; i < obj.length; i++) {
		      o.push(formatObjKey(obj[i], type, options));
		    }
		  } else {
		    o = {};
		    Object.keys(obj).forEach(function (key) {
		      o[handelFormat(key, type, options)] = formatObjKey(obj[key], type, options);
		    });
		  }
		  return o;
		}
		exports.formatObjKey = formatObjKey;
		function handelFormat(key, type, options) {
		  if (options && options.exclude && options.exclude.includes(key)) return key;
		  if (type === 'firstUpperCase') {
		    key = key.replace(/^./, function (_) {
		      return _.toUpperCase();
		    });
		  } else if (type === 'firstLowerCase') {
		    key = key.replace(/^./, function (_) {
		      return _.toLowerCase();
		    });
		  }
		  return key;
		}

		},{"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/helpers/typeof":91,"core-js/modules/es.array.includes.js":315,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.includes.js":342,"core-js/modules/es.string.replace.js":345,"core-js/modules/web.dom-collections.for-each.js":380}],65:[function(require,module,exports){

		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.getStandardRegion = void 0;
		function getStandardRegion(str) {
		  return str.replace(/^oss-/g, '');
		}
		exports.getStandardRegion = getStandardRegion;

		},{"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.replace.js":345}],66:[function(require,module,exports){

		require("core-js/modules/es.regexp.exec.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.getStrBytesCount = void 0;
		function getStrBytesCount(str) {
		  var bytesCount = 0;
		  for (var i = 0; i < str.length; i++) {
		    var c = str.charAt(i);
		    if (/^[\u00-\uff]$/.test(c)) {
		      bytesCount += 1;
		    } else {
		      bytesCount += 2;
		    }
		  }
		  return bytesCount;
		}
		exports.getStrBytesCount = getStrBytesCount;

		},{"core-js/modules/es.regexp.exec.js":338}],67:[function(require,module,exports){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.isArray = void 0;
		exports.isArray = function (obj) {
		  return Object.prototype.toString.call(obj) === '[object Array]';
		};

		},{"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.to-string.js":339}],68:[function(require,module,exports){

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.isBlob = void 0;
		function isBlob(blob) {
		  return typeof Blob !== 'undefined' && blob instanceof Blob;
		}
		exports.isBlob = isBlob;

		},{}],69:[function(require,module,exports){
		(function (Buffer){(function (){

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.isBuffer = void 0;
		function isBuffer(obj) {
		  return Buffer.isBuffer(obj);
		}
		exports.isBuffer = isBuffer;

		}).call(this);}).call(this,{"isBuffer":require("../../../node_modules/is-buffer/index.js")});
		},{"../../../node_modules/is-buffer/index.js":409}],70:[function(require,module,exports){
		(function (process){(function (){

		require("core-js/modules/es.array.includes.js");
		require("core-js/modules/es.string.includes.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.isDingTalk = void 0;
		function isDingTalk() {
		  if (process.browser && window.navigator.userAgent.toLowerCase().includes('aliapp(dingtalk')) {
		    return true;
		  }
		  return false;
		}
		exports.isDingTalk = isDingTalk;

		}).call(this);}).call(this,require('_process'));
		},{"_process":538,"core-js/modules/es.array.includes.js":315,"core-js/modules/es.string.includes.js":342}],71:[function(require,module,exports){

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.isFile = void 0;
		exports.isFile = function (obj) {
		  return typeof File !== 'undefined' && obj instanceof File;
		};

		},{}],72:[function(require,module,exports){

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.isFunction = void 0;
		exports.isFunction = function (v) {
		  return typeof v === 'function';
		};

		},{}],73:[function(require,module,exports){

		require("core-js/modules/es.regexp.exec.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.isIP = void 0;
		// it provide commont methods for node and browser , we will add more solutions later in this file
		/**
		 * Judge isIP include ipv4 or ipv6
		 * @param {String} options
		 * @return {Array} the multipart uploads
		 */
		exports.isIP = function (host) {
		  var ipv4Regex = /^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}$/;
		  var ipv6Regex = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
		  return ipv4Regex.test(host) || ipv6Regex.test(host);
		};

		},{"core-js/modules/es.regexp.exec.js":338}],74:[function(require,module,exports){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.isObject = void 0;
		exports.isObject = function (obj) {
		  return Object.prototype.toString.call(obj) === '[object Object]';
		};

		},{"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.to-string.js":339}],75:[function(require,module,exports){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.lowercaseKeyHeader = void 0;
		var isObject_1 = require("./isObject");
		function lowercaseKeyHeader(headers) {
		  var lowercaseHeader = {};
		  if (isObject_1.isObject(headers)) {
		    Object.keys(headers).forEach(function (key) {
		      lowercaseHeader[key.toLowerCase()] = headers[key];
		    });
		  }
		  return lowercaseHeader;
		}
		exports.lowercaseKeyHeader = lowercaseKeyHeader;

		},{"./isObject":74,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/web.dom-collections.for-each.js":380}],76:[function(require,module,exports){

		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.array.join.js");
		require("core-js/modules/es.array.map.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.obj2xml = void 0;
		var formatObjKey_1 = require("./formatObjKey");
		function type(params) {
		  return Object.prototype.toString.call(params).replace(/(.*? |])/g, '').toLowerCase();
		}
		function obj2xml(obj, options) {
		  var s = '';
		  if (options && options.headers) {
		    s = '<?xml version="1.0" encoding="UTF-8"?>\n';
		  }
		  if (options && options.firstUpperCase) {
		    obj = formatObjKey_1.formatObjKey(obj, 'firstUpperCase');
		  }
		  if (type(obj) === 'object') {
		    Object.keys(obj).forEach(function (key) {
		      // filter undefined or null
		      if (type(obj[key]) !== 'undefined' && type(obj[key]) !== 'null') {
		        if (type(obj[key]) === 'string' || type(obj[key]) === 'number') {
		          s += "<".concat(key, ">").concat(obj[key], "</").concat(key, ">");
		        } else if (type(obj[key]) === 'object') {
		          s += "<".concat(key, ">").concat(obj2xml(obj[key]), "</").concat(key, ">");
		        } else if (type(obj[key]) === 'array') {
		          s += obj[key].map(function (keyChild) {
		            return "<".concat(key, ">").concat(obj2xml(keyChild), "</").concat(key, ">");
		          }).join('');
		        } else {
		          s += "<".concat(key, ">").concat(obj[key].toString(), "</").concat(key, ">");
		        }
		      }
		    });
		  } else {
		    s += obj.toString();
		  }
		  return s;
		}
		exports.obj2xml = obj2xml;

		},{"./formatObjKey":64,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.join.js":317,"core-js/modules/es.array.map.js":318,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/es.string.replace.js":345,"core-js/modules/web.dom-collections.for-each.js":380}],77:[function(require,module,exports){

		require("core-js/modules/es.array.slice.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		require("core-js/modules/es.function.name.js");
		require("core-js/modules/es.array.from.js");
		require("core-js/modules/es.string.iterator.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.symbol.js");
		require("core-js/modules/es.symbol.description.js");
		require("core-js/modules/es.symbol.iterator.js");
		require("core-js/modules/es.array.iterator.js");
		require("core-js/modules/web.dom-collections.iterator.js");
		require("core-js/modules/es.object.assign.js");
		function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
		function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
		function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.omit = void 0;
		function omit(originalObject, keysToOmit) {
		  var cloneObject = Object.assign({}, originalObject);
		  var _iterator = _createForOfIteratorHelper(keysToOmit),
		    _step;
		  try {
		    for (_iterator.s(); !(_step = _iterator.n()).done;) {
		      var path = _step.value;
		      delete cloneObject[path];
		    }
		  } catch (err) {
		    _iterator.e(err);
		  } finally {
		    _iterator.f();
		  }
		  return cloneObject;
		}
		exports.omit = omit;

		},{"core-js/modules/es.array.from.js":314,"core-js/modules/es.array.iterator.js":316,"core-js/modules/es.array.slice.js":319,"core-js/modules/es.function.name.js":322,"core-js/modules/es.object.assign.js":325,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/es.string.iterator.js":343,"core-js/modules/es.symbol.description.js":351,"core-js/modules/es.symbol.iterator.js":353,"core-js/modules/es.symbol.js":354,"core-js/modules/web.dom-collections.iterator.js":381}],78:[function(require,module,exports){

		require("core-js/modules/es.array.includes.js");
		require("core-js/modules/es.string.includes.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.match.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.parseRestoreInfo = void 0;
		exports.parseRestoreInfo = function (originalRestoreInfo) {
		  var tempRestoreInfo;
		  if (originalRestoreInfo) {
		    tempRestoreInfo = {
		      ongoingRequest: originalRestoreInfo.includes('true')
		    };
		    if (!tempRestoreInfo.ongoingRequest) {
		      var matchArray = originalRestoreInfo.match(/expiry-date="(.*)"/);
		      if (matchArray && matchArray[1]) {
		        tempRestoreInfo.expiryDate = new Date(matchArray[1]);
		      }
		    }
		  }
		  return tempRestoreInfo;
		};

		},{"core-js/modules/es.array.includes.js":315,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.includes.js":342,"core-js/modules/es.string.match.js":344}],79:[function(require,module,exports){

		require("core-js/modules/es.object.keys.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.policy2Str = void 0;
		function policy2Str(policy) {
		  var policyStr;
		  if (policy) {
		    if (typeof policy === 'string') {
		      try {
		        policyStr = JSON.stringify(JSON.parse(policy));
		      } catch (err) {
		        throw new Error("Policy string is not a valid JSON: ".concat(err.message));
		      }
		    } else {
		      policyStr = JSON.stringify(policy);
		    }
		  }
		  return policyStr;
		}
		exports.policy2Str = policy2Str;

		},{"core-js/modules/es.object.keys.js":328}],80:[function(require,module,exports){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.promise.js");
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.retry = void 0;
		function retry(func, retryMax) {
		  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		  var retryNum = 0;
		  var _config$retryDelay = config.retryDelay,
		    retryDelay = _config$retryDelay === void 0 ? 500 : _config$retryDelay,
		    _config$errorHandler = config.errorHandler,
		    errorHandler = _config$errorHandler === void 0 ? function () {
		      return true;
		    } : _config$errorHandler;
		  var funcR = function funcR() {
		    for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
		      arg[_key] = arguments[_key];
		    }
		    return new Promise(function (resolve, reject) {
		      func.apply(void 0, arg).then(function (result) {
		        retryNum = 0;
		        resolve(result);
		      }).catch(function (err) {
		        if (retryNum < retryMax && errorHandler(err)) {
		          retryNum++;
		          setTimeout(function () {
		            resolve(funcR.apply(void 0, arg));
		          }, retryDelay);
		        } else {
		          retryNum = 0;
		          reject(err);
		        }
		      });
		    });
		  };
		  return funcR;
		}
		exports.retry = retry;

		},{"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.promise.js":333}],81:[function(require,module,exports){

		var __importDefault = function (mod) {
		  return mod && mod.__esModule ? mod : {
		    "default": mod
		  };
		};
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.setRegion = void 0;
		var url_1 = __importDefault(require("url"));
		var checkConfigValid_1 = require("./checkConfigValid");
		function setRegion(region) {
		  var internal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
		  var secure = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		  checkConfigValid_1.checkConfigValid(region, 'region');
		  var protocol = secure ? 'https://' : 'http://';
		  var suffix = internal ? '-internal.aliyuncs.com' : '.aliyuncs.com';
		  var prefix = 'vpc100-oss-cn-';
		  // aliyun VPC region: https://help.aliyun.com/knowledge_detail/38740.html
		  if (region.substr(0, prefix.length) === prefix) {
		    suffix = '.aliyuncs.com';
		  }
		  return url_1.default.parse(protocol + region + suffix);
		}
		exports.setRegion = setRegion;

		},{"./checkConfigValid":54,"url":543}],82:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.array.find.js");
		require("core-js/modules/es.object.assign.js");
		var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.checkCredentials = exports.setSTSToken = void 0;
		var formatObjKey_1 = require("./formatObjKey");
		function setSTSToken() {
		  return _setSTSToken.apply(this, arguments);
		}
		function _setSTSToken() {
		  _setSTSToken = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
		    var now, credentials;
		    return _regenerator.default.wrap(function _callee$(_context) {
		      while (1) switch (_context.prev = _context.next) {
		        case 0:
		          if (!this.options) this.options = {};
		          now = new Date();
		          if (!this.stsTokenFreshTime) {
		            _context.next = 14;
		            break;
		          }
		          if (!(+now - this.stsTokenFreshTime >= this.options.refreshSTSTokenInterval)) {
		            _context.next = 12;
		            break;
		          }
		          this.stsTokenFreshTime = now;
		          _context.next = 7;
		          return this.options.refreshSTSToken();
		        case 7:
		          credentials = _context.sent;
		          credentials = formatObjKey_1.formatObjKey(credentials, 'firstLowerCase');
		          if (credentials.securityToken) {
		            credentials.stsToken = credentials.securityToken;
		          }
		          checkCredentials(credentials);
		          Object.assign(this.options, credentials);
		        case 12:
		          _context.next = 15;
		          break;
		        case 14:
		          this.stsTokenFreshTime = now;
		        case 15:
		          return _context.abrupt("return", null);
		        case 16:
		        case "end":
		          return _context.stop();
		      }
		    }, _callee, this);
		  }));
		  return _setSTSToken.apply(this, arguments);
		}
		exports.setSTSToken = setSTSToken;
		function checkCredentials(obj) {
		  var stsTokenKey = ['accessKeySecret', 'accessKeyId', 'stsToken'];
		  var objKeys = Object.keys(obj);
		  stsTokenKey.forEach(function (_) {
		    if (!objKeys.find(function (key) {
		      return key === _;
		    })) {
		      throw Error("refreshSTSToken must return contains ".concat(_));
		    }
		  });
		}
		exports.checkCredentials = checkCredentials;

		},{"./formatObjKey":64,"@babel/runtime/helpers/asyncToGenerator":85,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/regenerator":93,"core-js/modules/es.array.find.js":313,"core-js/modules/es.object.assign.js":325,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329}],83:[function(require,module,exports){
		function _arrayLikeToArray(arr, len) {
		  if (len == null || len > arr.length) len = arr.length;
		  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
		  return arr2;
		}
		module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
		},{}],84:[function(require,module,exports){
		var arrayLikeToArray = require("./arrayLikeToArray.js");
		function _arrayWithoutHoles(arr) {
		  if (Array.isArray(arr)) return arrayLikeToArray(arr);
		}
		module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
		},{"./arrayLikeToArray.js":83}],85:[function(require,module,exports){
		function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
		  try {
		    var info = gen[key](arg);
		    var value = info.value;
		  } catch (error) {
		    reject(error);
		    return;
		  }
		  if (info.done) {
		    resolve(value);
		  } else {
		    Promise.resolve(value).then(_next, _throw);
		  }
		}
		function _asyncToGenerator(fn) {
		  return function () {
		    var self = this,
		      args = arguments;
		    return new Promise(function (resolve, reject) {
		      var gen = fn.apply(self, args);
		      function _next(value) {
		        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
		      }
		      function _throw(err) {
		        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
		      }
		      _next(undefined);
		    });
		  };
		}
		module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
		},{}],86:[function(require,module,exports){
		function _interopRequireDefault(obj) {
		  return obj && obj.__esModule ? obj : {
		    "default": obj
		  };
		}
		module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
		},{}],87:[function(require,module,exports){
		function _iterableToArray(iter) {
		  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
		}
		module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
		},{}],88:[function(require,module,exports){
		function _nonIterableSpread() {
		  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
		}
		module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
		},{}],89:[function(require,module,exports){
		var _typeof = require("./typeof.js")["default"];
		function _regeneratorRuntime() {
		  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
		    return e;
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
		  var t,
		    e = {},
		    r = Object.prototype,
		    n = r.hasOwnProperty,
		    o = Object.defineProperty || function (t, e, r) {
		      t[e] = r.value;
		    },
		    i = "function" == typeof Symbol ? Symbol : {},
		    a = i.iterator || "@@iterator",
		    c = i.asyncIterator || "@@asyncIterator",
		    u = i.toStringTag || "@@toStringTag";
		  function define(t, e, r) {
		    return Object.defineProperty(t, e, {
		      value: r,
		      enumerable: true,
		      configurable: true,
		      writable: true
		    }), t[e];
		  }
		  try {
		    define({}, "");
		  } catch (t) {
		    define = function define(t, e, r) {
		      return t[e] = r;
		    };
		  }
		  function wrap(t, e, r, n) {
		    var i = e && e.prototype instanceof Generator ? e : Generator,
		      a = Object.create(i.prototype),
		      c = new Context(n || []);
		    return o(a, "_invoke", {
		      value: makeInvokeMethod(t, r, c)
		    }), a;
		  }
		  function tryCatch(t, e, r) {
		    try {
		      return {
		        type: "normal",
		        arg: t.call(e, r)
		      };
		    } catch (t) {
		      return {
		        type: "throw",
		        arg: t
		      };
		    }
		  }
		  e.wrap = wrap;
		  var h = "suspendedStart",
		    l = "suspendedYield",
		    f = "executing",
		    s = "completed",
		    y = {};
		  function Generator() {}
		  function GeneratorFunction() {}
		  function GeneratorFunctionPrototype() {}
		  var p = {};
		  define(p, a, function () {
		    return this;
		  });
		  var d = Object.getPrototypeOf,
		    v = d && d(d(values([])));
		  v && v !== r && n.call(v, a) && (p = v);
		  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
		  function defineIteratorMethods(t) {
		    ["next", "throw", "return"].forEach(function (e) {
		      define(t, e, function (t) {
		        return this._invoke(e, t);
		      });
		    });
		  }
		  function AsyncIterator(t, e) {
		    function invoke(r, o, i, a) {
		      var c = tryCatch(t[r], t, o);
		      if ("throw" !== c.type) {
		        var u = c.arg,
		          h = u.value;
		        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
		          invoke("next", t, i, a);
		        }, function (t) {
		          invoke("throw", t, i, a);
		        }) : e.resolve(h).then(function (t) {
		          u.value = t, i(u);
		        }, function (t) {
		          return invoke("throw", t, i, a);
		        });
		      }
		      a(c.arg);
		    }
		    var r;
		    o(this, "_invoke", {
		      value: function value(t, n) {
		        function callInvokeWithMethodAndArg() {
		          return new e(function (e, r) {
		            invoke(t, n, e, r);
		          });
		        }
		        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
		      }
		    });
		  }
		  function makeInvokeMethod(e, r, n) {
		    var o = h;
		    return function (i, a) {
		      if (o === f) throw new Error("Generator is already running");
		      if (o === s) {
		        if ("throw" === i) throw a;
		        return {
		          value: t,
		          done: true
		        };
		      }
		      for (n.method = i, n.arg = a;;) {
		        var c = n.delegate;
		        if (c) {
		          var u = maybeInvokeDelegate(c, n);
		          if (u) {
		            if (u === y) continue;
		            return u;
		          }
		        }
		        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
		          if (o === h) throw o = s, n.arg;
		          n.dispatchException(n.arg);
		        } else "return" === n.method && n.abrupt("return", n.arg);
		        o = f;
		        var p = tryCatch(e, r, n);
		        if ("normal" === p.type) {
		          if (o = n.done ? s : l, p.arg === y) continue;
		          return {
		            value: p.arg,
		            done: n.done
		          };
		        }
		        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
		      }
		    };
		  }
		  function maybeInvokeDelegate(e, r) {
		    var n = r.method,
		      o = e.iterator[n];
		    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
		    var i = tryCatch(o, e.iterator, r.arg);
		    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
		    var a = i.arg;
		    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
		  }
		  function pushTryEntry(t) {
		    var e = {
		      tryLoc: t[0]
		    };
		    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
		  }
		  function resetTryEntry(t) {
		    var e = t.completion || {};
		    e.type = "normal", delete e.arg, t.completion = e;
		  }
		  function Context(t) {
		    this.tryEntries = [{
		      tryLoc: "root"
		    }], t.forEach(pushTryEntry, this), this.reset(true);
		  }
		  function values(e) {
		    if (e || "" === e) {
		      var r = e[a];
		      if (r) return r.call(e);
		      if ("function" == typeof e.next) return e;
		      if (!isNaN(e.length)) {
		        var o = -1,
		          i = function next() {
		            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = false, next;
		            return next.value = t, next.done = true, next;
		          };
		        return i.next = i;
		      }
		    }
		    throw new TypeError(_typeof(e) + " is not iterable");
		  }
		  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
		    value: GeneratorFunctionPrototype,
		    configurable: true
		  }), o(GeneratorFunctionPrototype, "constructor", {
		    value: GeneratorFunction,
		    configurable: true
		  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
		    var e = "function" == typeof t && t.constructor;
		    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
		  }, e.mark = function (t) {
		    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
		  }, e.awrap = function (t) {
		    return {
		      __await: t
		    };
		  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
		    return this;
		  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
		    void 0 === i && (i = Promise);
		    var a = new AsyncIterator(wrap(t, r, n, o), i);
		    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
		      return t.done ? t.value : a.next();
		    });
		  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
		    return this;
		  }), define(g, "toString", function () {
		    return "[object Generator]";
		  }), e.keys = function (t) {
		    var e = Object(t),
		      r = [];
		    for (var n in e) r.push(n);
		    return r.reverse(), function next() {
		      for (; r.length;) {
		        var t = r.pop();
		        if (t in e) return next.value = t, next.done = false, next;
		      }
		      return next.done = true, next;
		    };
		  }, e.values = values, Context.prototype = {
		    constructor: Context,
		    reset: function reset(e) {
		      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
		    },
		    stop: function stop() {
		      this.done = true;
		      var t = this.tryEntries[0].completion;
		      if ("throw" === t.type) throw t.arg;
		      return this.rval;
		    },
		    dispatchException: function dispatchException(e) {
		      if (this.done) throw e;
		      var r = this;
		      function handle(n, o) {
		        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
		      }
		      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
		        var i = this.tryEntries[o],
		          a = i.completion;
		        if ("root" === i.tryLoc) return handle("end");
		        if (i.tryLoc <= this.prev) {
		          var c = n.call(i, "catchLoc"),
		            u = n.call(i, "finallyLoc");
		          if (c && u) {
		            if (this.prev < i.catchLoc) return handle(i.catchLoc, true);
		            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
		          } else if (c) {
		            if (this.prev < i.catchLoc) return handle(i.catchLoc, true);
		          } else {
		            if (!u) throw new Error("try statement without catch or finally");
		            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
		          }
		        }
		      }
		    },
		    abrupt: function abrupt(t, e) {
		      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
		        var o = this.tryEntries[r];
		        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
		          var i = o;
		          break;
		        }
		      }
		      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
		      var a = i ? i.completion : {};
		      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
		    },
		    complete: function complete(t, e) {
		      if ("throw" === t.type) throw t.arg;
		      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
		    },
		    finish: function finish(t) {
		      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
		        var r = this.tryEntries[e];
		        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
		      }
		    },
		    "catch": function _catch(t) {
		      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
		        var r = this.tryEntries[e];
		        if (r.tryLoc === t) {
		          var n = r.completion;
		          if ("throw" === n.type) {
		            var o = n.arg;
		            resetTryEntry(r);
		          }
		          return o;
		        }
		      }
		      throw new Error("illegal catch attempt");
		    },
		    delegateYield: function delegateYield(e, r, n) {
		      return this.delegate = {
		        iterator: values(e),
		        resultName: r,
		        nextLoc: n
		      }, "next" === this.method && (this.arg = t), y;
		    }
		  }, e;
		}
		module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
		},{"./typeof.js":91}],90:[function(require,module,exports){
		var arrayWithoutHoles = require("./arrayWithoutHoles.js");
		var iterableToArray = require("./iterableToArray.js");
		var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");
		var nonIterableSpread = require("./nonIterableSpread.js");
		function _toConsumableArray(arr) {
		  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
		}
		module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
		},{"./arrayWithoutHoles.js":84,"./iterableToArray.js":87,"./nonIterableSpread.js":88,"./unsupportedIterableToArray.js":92}],91:[function(require,module,exports){
		function _typeof(o) {
		  "@babel/helpers - typeof";

		  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
		    return typeof o;
		  } : function (o) {
		    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
		}
		module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
		},{}],92:[function(require,module,exports){
		var arrayLikeToArray = require("./arrayLikeToArray.js");
		function _unsupportedIterableToArray(o, minLen) {
		  if (!o) return;
		  if (typeof o === "string") return arrayLikeToArray(o, minLen);
		  var n = Object.prototype.toString.call(o).slice(8, -1);
		  if (n === "Object" && o.constructor) n = o.constructor.name;
		  if (n === "Map" || n === "Set") return Array.from(o);
		  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
		}
		module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
		},{"./arrayLikeToArray.js":83}],93:[function(require,module,exports){
		// TODO(Babel 8): Remove this file.

		var runtime = require("../helpers/regeneratorRuntime")();
		module.exports = runtime;

		// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
		try {
		  regeneratorRuntime = runtime;
		} catch (accidentalStrictMode) {
		  if (typeof globalThis === "object") {
		    globalThis.regeneratorRuntime = runtime;
		  } else {
		    Function("r", "regeneratorRuntime = r")(runtime);
		  }
		}

		},{"../helpers/regeneratorRuntime":89}],94:[function(require,module,exports){
		module.exports = noop;
		module.exports.HttpsAgent = noop;

		// Noop function for browser since native api's don't use agents.
		function noop () {}

		},{}],95:[function(require,module,exports){
		(function (global){(function (){

		var objectAssign = require('object.assign/polyfill')();

		// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
		// original notice:

		/*!
		 * The buffer module from node.js, for the browser.
		 *
		 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
		 * @license  MIT
		 */
		function compare(a, b) {
		  if (a === b) {
		    return 0;
		  }

		  var x = a.length;
		  var y = b.length;

		  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
		    if (a[i] !== b[i]) {
		      x = a[i];
		      y = b[i];
		      break;
		    }
		  }

		  if (x < y) {
		    return -1;
		  }
		  if (y < x) {
		    return 1;
		  }
		  return 0;
		}
		function isBuffer(b) {
		  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
		    return global.Buffer.isBuffer(b);
		  }
		  return !!(b != null && b._isBuffer);
		}

		// based on node assert, original notice:
		// NB: The URL to the CommonJS spec is kept just for tradition.
		//     node-assert has evolved a lot since then, both in API and behavior.

		// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
		//
		// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
		//
		// Originally from narwhal.js (http://narwhaljs.org)
		// Copyright (c) 2009 Thomas Robinson <280north.com>
		//
		// Permission is hereby granted, free of charge, to any person obtaining a copy
		// of this software and associated documentation files (the 'Software'), to
		// deal in the Software without restriction, including without limitation the
		// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
		// sell copies of the Software, and to permit persons to whom the Software is
		// furnished to do so, subject to the following conditions:
		//
		// The above copyright notice and this permission notice shall be included in
		// all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
		// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
		// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

		var util = require('util/');
		var hasOwn = Object.prototype.hasOwnProperty;
		var pSlice = Array.prototype.slice;
		var functionsHaveNames = (function () {
		  return function foo() {}.name === 'foo';
		}());
		function pToString (obj) {
		  return Object.prototype.toString.call(obj);
		}
		function isView(arrbuf) {
		  if (isBuffer(arrbuf)) {
		    return false;
		  }
		  if (typeof global.ArrayBuffer !== 'function') {
		    return false;
		  }
		  if (typeof ArrayBuffer.isView === 'function') {
		    return ArrayBuffer.isView(arrbuf);
		  }
		  if (!arrbuf) {
		    return false;
		  }
		  if (arrbuf instanceof DataView) {
		    return true;
		  }
		  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
		    return true;
		  }
		  return false;
		}
		// 1. The assert module provides functions that throw
		// AssertionError's when particular conditions are not met. The
		// assert module must conform to the following interface.

		var assert = module.exports = ok;

		// 2. The AssertionError is defined in assert.
		// new assert.AssertionError({ message: message,
		//                             actual: actual,
		//                             expected: expected })

		var regex = /\s*function\s+([^\(\s]*)\s*/;
		// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
		function getName(func) {
		  if (!util.isFunction(func)) {
		    return;
		  }
		  if (functionsHaveNames) {
		    return func.name;
		  }
		  var str = func.toString();
		  var match = str.match(regex);
		  return match && match[1];
		}
		assert.AssertionError = function AssertionError(options) {
		  this.name = 'AssertionError';
		  this.actual = options.actual;
		  this.expected = options.expected;
		  this.operator = options.operator;
		  if (options.message) {
		    this.message = options.message;
		    this.generatedMessage = false;
		  } else {
		    this.message = getMessage(this);
		    this.generatedMessage = true;
		  }
		  var stackStartFunction = options.stackStartFunction || fail;
		  if (Error.captureStackTrace) {
		    Error.captureStackTrace(this, stackStartFunction);
		  } else {
		    // non v8 browsers so we can have a stacktrace
		    var err = new Error();
		    if (err.stack) {
		      var out = err.stack;

		      // try to strip useless frames
		      var fn_name = getName(stackStartFunction);
		      var idx = out.indexOf('\n' + fn_name);
		      if (idx >= 0) {
		        // once we have located the function frame
		        // we need to strip out everything before it (and its line)
		        var next_line = out.indexOf('\n', idx + 1);
		        out = out.substring(next_line + 1);
		      }

		      this.stack = out;
		    }
		  }
		};

		// assert.AssertionError instanceof Error
		util.inherits(assert.AssertionError, Error);

		function truncate(s, n) {
		  if (typeof s === 'string') {
		    return s.length < n ? s : s.slice(0, n);
		  } else {
		    return s;
		  }
		}
		function inspect(something) {
		  if (functionsHaveNames || !util.isFunction(something)) {
		    return util.inspect(something);
		  }
		  var rawname = getName(something);
		  var name = rawname ? ': ' + rawname : '';
		  return '[Function' +  name + ']';
		}
		function getMessage(self) {
		  return truncate(inspect(self.actual), 128) + ' ' +
		         self.operator + ' ' +
		         truncate(inspect(self.expected), 128);
		}

		// At present only the three keys mentioned above are used and
		// understood by the spec. Implementations or sub modules can pass
		// other keys to the AssertionError's constructor - they will be
		// ignored.

		// 3. All of the following functions must throw an AssertionError
		// when a corresponding condition is not met, with a message that
		// may be undefined if not provided.  All assertion methods provide
		// both the actual and expected values to the assertion error for
		// display purposes.

		function fail(actual, expected, message, operator, stackStartFunction) {
		  throw new assert.AssertionError({
		    message: message,
		    actual: actual,
		    expected: expected,
		    operator: operator,
		    stackStartFunction: stackStartFunction
		  });
		}

		// EXTENSION! allows for well behaved errors defined elsewhere.
		assert.fail = fail;

		// 4. Pure assertion tests whether a value is truthy, as determined
		// by !!guard.
		// assert.ok(guard, message_opt);
		// This statement is equivalent to assert.equal(true, !!guard,
		// message_opt);. To test strictly for the value true, use
		// assert.strictEqual(true, guard, message_opt);.

		function ok(value, message) {
		  if (!value) fail(value, true, message, '==', assert.ok);
		}
		assert.ok = ok;

		// 5. The equality assertion tests shallow, coercive equality with
		// ==.
		// assert.equal(actual, expected, message_opt);

		assert.equal = function equal(actual, expected, message) {
		  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
		};

		// 6. The non-equality assertion tests for whether two objects are not equal
		// with != assert.notEqual(actual, expected, message_opt);

		assert.notEqual = function notEqual(actual, expected, message) {
		  if (actual == expected) {
		    fail(actual, expected, message, '!=', assert.notEqual);
		  }
		};

		// 7. The equivalence assertion tests a deep equality relation.
		// assert.deepEqual(actual, expected, message_opt);

		assert.deepEqual = function deepEqual(actual, expected, message) {
		  if (!_deepEqual(actual, expected, false)) {
		    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
		  }
		};

		assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
		  if (!_deepEqual(actual, expected, true)) {
		    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
		  }
		};

		function _deepEqual(actual, expected, strict, memos) {
		  // 7.1. All identical values are equivalent, as determined by ===.
		  if (actual === expected) {
		    return true;
		  } else if (isBuffer(actual) && isBuffer(expected)) {
		    return compare(actual, expected) === 0;

		  // 7.2. If the expected value is a Date object, the actual value is
		  // equivalent if it is also a Date object that refers to the same time.
		  } else if (util.isDate(actual) && util.isDate(expected)) {
		    return actual.getTime() === expected.getTime();

		  // 7.3 If the expected value is a RegExp object, the actual value is
		  // equivalent if it is also a RegExp object with the same source and
		  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
		  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
		    return actual.source === expected.source &&
		           actual.global === expected.global &&
		           actual.multiline === expected.multiline &&
		           actual.lastIndex === expected.lastIndex &&
		           actual.ignoreCase === expected.ignoreCase;

		  // 7.4. Other pairs that do not both pass typeof value == 'object',
		  // equivalence is determined by ==.
		  } else if ((actual === null || typeof actual !== 'object') &&
		             (expected === null || typeof expected !== 'object')) {
		    return strict ? actual === expected : actual == expected;

		  // If both values are instances of typed arrays, wrap their underlying
		  // ArrayBuffers in a Buffer each to increase performance
		  // This optimization requires the arrays to have the same type as checked by
		  // Object.prototype.toString (aka pToString). Never perform binary
		  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
		  // bit patterns are not identical.
		  } else if (isView(actual) && isView(expected) &&
		             pToString(actual) === pToString(expected) &&
		             !(actual instanceof Float32Array ||
		               actual instanceof Float64Array)) {
		    return compare(new Uint8Array(actual.buffer),
		                   new Uint8Array(expected.buffer)) === 0;

		  // 7.5 For all other Object pairs, including Array objects, equivalence is
		  // determined by having the same number of owned properties (as verified
		  // with Object.prototype.hasOwnProperty.call), the same set of keys
		  // (although not necessarily the same order), equivalent values for every
		  // corresponding key, and an identical 'prototype' property. Note: this
		  // accounts for both named and indexed properties on Arrays.
		  } else if (isBuffer(actual) !== isBuffer(expected)) {
		    return false;
		  } else {
		    memos = memos || {actual: [], expected: []};

		    var actualIndex = memos.actual.indexOf(actual);
		    if (actualIndex !== -1) {
		      if (actualIndex === memos.expected.indexOf(expected)) {
		        return true;
		      }
		    }

		    memos.actual.push(actual);
		    memos.expected.push(expected);

		    return objEquiv(actual, expected, strict, memos);
		  }
		}

		function isArguments(object) {
		  return Object.prototype.toString.call(object) == '[object Arguments]';
		}

		function objEquiv(a, b, strict, actualVisitedObjects) {
		  if (a === null || a === undefined || b === null || b === undefined)
		    return false;
		  // if one is a primitive, the other must be same
		  if (util.isPrimitive(a) || util.isPrimitive(b))
		    return a === b;
		  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
		    return false;
		  var aIsArgs = isArguments(a);
		  var bIsArgs = isArguments(b);
		  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
		    return false;
		  if (aIsArgs) {
		    a = pSlice.call(a);
		    b = pSlice.call(b);
		    return _deepEqual(a, b, strict);
		  }
		  var ka = objectKeys(a);
		  var kb = objectKeys(b);
		  var key, i;
		  // having the same number of owned properties (keys incorporates
		  // hasOwnProperty)
		  if (ka.length !== kb.length)
		    return false;
		  //the same set of keys (although not necessarily the same order),
		  ka.sort();
		  kb.sort();
		  //~~~cheap key test
		  for (i = ka.length - 1; i >= 0; i--) {
		    if (ka[i] !== kb[i])
		      return false;
		  }
		  //equivalent values for every corresponding key, and
		  //~~~possibly expensive deep test
		  for (i = ka.length - 1; i >= 0; i--) {
		    key = ka[i];
		    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
		      return false;
		  }
		  return true;
		}

		// 8. The non-equivalence assertion tests for any deep inequality.
		// assert.notDeepEqual(actual, expected, message_opt);

		assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
		  if (_deepEqual(actual, expected, false)) {
		    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
		  }
		};

		assert.notDeepStrictEqual = notDeepStrictEqual;
		function notDeepStrictEqual(actual, expected, message) {
		  if (_deepEqual(actual, expected, true)) {
		    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
		  }
		}


		// 9. The strict equality assertion tests strict equality, as determined by ===.
		// assert.strictEqual(actual, expected, message_opt);

		assert.strictEqual = function strictEqual(actual, expected, message) {
		  if (actual !== expected) {
		    fail(actual, expected, message, '===', assert.strictEqual);
		  }
		};

		// 10. The strict non-equality assertion tests for strict inequality, as
		// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

		assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
		  if (actual === expected) {
		    fail(actual, expected, message, '!==', assert.notStrictEqual);
		  }
		};

		function expectedException(actual, expected) {
		  if (!actual || !expected) {
		    return false;
		  }

		  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
		    return expected.test(actual);
		  }

		  try {
		    if (actual instanceof expected) {
		      return true;
		    }
		  } catch (e) {
		    // Ignore.  The instanceof check doesn't work for arrow functions.
		  }

		  if (Error.isPrototypeOf(expected)) {
		    return false;
		  }

		  return expected.call({}, actual) === true;
		}

		function _tryBlock(block) {
		  var error;
		  try {
		    block();
		  } catch (e) {
		    error = e;
		  }
		  return error;
		}

		function _throws(shouldThrow, block, expected, message) {
		  var actual;

		  if (typeof block !== 'function') {
		    throw new TypeError('"block" argument must be a function');
		  }

		  if (typeof expected === 'string') {
		    message = expected;
		    expected = null;
		  }

		  actual = _tryBlock(block);

		  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
		            (message ? ' ' + message : '.');

		  if (shouldThrow && !actual) {
		    fail(actual, expected, 'Missing expected exception' + message);
		  }

		  var userProvidedMessage = typeof message === 'string';
		  var isUnwantedException = !shouldThrow && util.isError(actual);
		  var isUnexpectedException = !shouldThrow && actual && !expected;

		  if ((isUnwantedException &&
		      userProvidedMessage &&
		      expectedException(actual, expected)) ||
		      isUnexpectedException) {
		    fail(actual, expected, 'Got unwanted exception' + message);
		  }

		  if ((shouldThrow && actual && expected &&
		      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
		    throw actual;
		  }
		}

		// 11. Expected to throw an error:
		// assert.throws(block, Error_opt, message_opt);

		assert.throws = function(block, /*optional*/error, /*optional*/message) {
		  _throws(true, block, error, message);
		};

		// EXTENSION! This is annoying to write outside this module.
		assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
		  _throws(false, block, error, message);
		};

		assert.ifError = function(err) { if (err) throw err; };

		// Expose a strict only variant of assert
		function strict(value, message) {
		  if (!value) fail(value, true, message, '==', strict);
		}
		assert.strict = objectAssign(strict, assert, {
		  equal: assert.strictEqual,
		  deepEqual: assert.deepStrictEqual,
		  notEqual: assert.notStrictEqual,
		  notDeepEqual: assert.notDeepStrictEqual
		});
		assert.strict.strict = assert.strict;

		var objectKeys = Object.keys || function (obj) {
		  var keys = [];
		  for (var key in obj) {
		    if (hasOwn.call(obj, key)) keys.push(key);
		  }
		  return keys;
		};

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{"object.assign/polyfill":438,"util/":98}],96:[function(require,module,exports){
		if (typeof Object.create === 'function') {
		  // implementation from standard node.js 'util' module
		  module.exports = function inherits(ctor, superCtor) {
		    ctor.super_ = superCtor;
		    ctor.prototype = Object.create(superCtor.prototype, {
		      constructor: {
		        value: ctor,
		        enumerable: false,
		        writable: true,
		        configurable: true
		      }
		    });
		  };
		} else {
		  // old school shim for old browsers
		  module.exports = function inherits(ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  };
		}

		},{}],97:[function(require,module,exports){
		module.exports = function isBuffer(arg) {
		  return arg && typeof arg === 'object'
		    && typeof arg.copy === 'function'
		    && typeof arg.fill === 'function'
		    && typeof arg.readUInt8 === 'function';
		};
		},{}],98:[function(require,module,exports){
		(function (process,global){(function (){
		// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.

		var formatRegExp = /%[sdj%]/g;
		exports.format = function(f) {
		  if (!isString(f)) {
		    var objects = [];
		    for (var i = 0; i < arguments.length; i++) {
		      objects.push(inspect(arguments[i]));
		    }
		    return objects.join(' ');
		  }

		  var i = 1;
		  var args = arguments;
		  var len = args.length;
		  var str = String(f).replace(formatRegExp, function(x) {
		    if (x === '%%') return '%';
		    if (i >= len) return x;
		    switch (x) {
		      case '%s': return String(args[i++]);
		      case '%d': return Number(args[i++]);
		      case '%j':
		        try {
		          return JSON.stringify(args[i++]);
		        } catch (_) {
		          return '[Circular]';
		        }
		      default:
		        return x;
		    }
		  });
		  for (var x = args[i]; i < len; x = args[++i]) {
		    if (isNull(x) || !isObject(x)) {
		      str += ' ' + x;
		    } else {
		      str += ' ' + inspect(x);
		    }
		  }
		  return str;
		};


		// Mark that a method should not be used.
		// Returns a modified function which warns once by default.
		// If --no-deprecation is set, then it is a no-op.
		exports.deprecate = function(fn, msg) {
		  // Allow for deprecating things in the process of starting up.
		  if (isUndefined(global.process)) {
		    return function() {
		      return exports.deprecate(fn, msg).apply(this, arguments);
		    };
		  }

		  if (process.noDeprecation === true) {
		    return fn;
		  }

		  var warned = false;
		  function deprecated() {
		    if (!warned) {
		      if (process.throwDeprecation) {
		        throw new Error(msg);
		      } else if (process.traceDeprecation) {
		        console.trace(msg);
		      } else {
		        console.error(msg);
		      }
		      warned = true;
		    }
		    return fn.apply(this, arguments);
		  }

		  return deprecated;
		};


		var debugs = {};
		var debugEnviron;
		exports.debuglog = function(set) {
		  if (isUndefined(debugEnviron))
		    debugEnviron = process.env.NODE_DEBUG || '';
		  set = set.toUpperCase();
		  if (!debugs[set]) {
		    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
		      var pid = process.pid;
		      debugs[set] = function() {
		        var msg = exports.format.apply(exports, arguments);
		        console.error('%s %d: %s', set, pid, msg);
		      };
		    } else {
		      debugs[set] = function() {};
		    }
		  }
		  return debugs[set];
		};


		/**
		 * Echos the value of a value. Trys to print the value out
		 * in the best way possible given the different types.
		 *
		 * @param {Object} obj The object to print out.
		 * @param {Object} opts Optional options object that alters the output.
		 */
		/* legacy: obj, showHidden, depth, colors*/
		function inspect(obj, opts) {
		  // default options
		  var ctx = {
		    seen: [],
		    stylize: stylizeNoColor
		  };
		  // legacy...
		  if (arguments.length >= 3) ctx.depth = arguments[2];
		  if (arguments.length >= 4) ctx.colors = arguments[3];
		  if (isBoolean(opts)) {
		    // legacy...
		    ctx.showHidden = opts;
		  } else if (opts) {
		    // got an "options" object
		    exports._extend(ctx, opts);
		  }
		  // set default options
		  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
		  if (isUndefined(ctx.depth)) ctx.depth = 2;
		  if (isUndefined(ctx.colors)) ctx.colors = false;
		  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
		  if (ctx.colors) ctx.stylize = stylizeWithColor;
		  return formatValue(ctx, obj, ctx.depth);
		}
		exports.inspect = inspect;


		// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
		inspect.colors = {
		  'bold' : [1, 22],
		  'italic' : [3, 23],
		  'underline' : [4, 24],
		  'inverse' : [7, 27],
		  'white' : [37, 39],
		  'grey' : [90, 39],
		  'black' : [30, 39],
		  'blue' : [34, 39],
		  'cyan' : [36, 39],
		  'green' : [32, 39],
		  'magenta' : [35, 39],
		  'red' : [31, 39],
		  'yellow' : [33, 39]
		};

		// Don't use 'blue' not visible on cmd.exe
		inspect.styles = {
		  'special': 'cyan',
		  'number': 'yellow',
		  'boolean': 'yellow',
		  'undefined': 'grey',
		  'null': 'bold',
		  'string': 'green',
		  'date': 'magenta',
		  // "name": intentionally not styling
		  'regexp': 'red'
		};


		function stylizeWithColor(str, styleType) {
		  var style = inspect.styles[styleType];

		  if (style) {
		    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
		           '\u001b[' + inspect.colors[style][1] + 'm';
		  } else {
		    return str;
		  }
		}


		function stylizeNoColor(str, styleType) {
		  return str;
		}


		function arrayToHash(array) {
		  var hash = {};

		  array.forEach(function(val, idx) {
		    hash[val] = true;
		  });

		  return hash;
		}


		function formatValue(ctx, value, recurseTimes) {
		  // Provide a hook for user-specified inspect functions.
		  // Check that value is an object with an inspect function on it
		  if (ctx.customInspect &&
		      value &&
		      isFunction(value.inspect) &&
		      // Filter out the util module, it's inspect function is special
		      value.inspect !== exports.inspect &&
		      // Also filter out any prototype objects using the circular check.
		      !(value.constructor && value.constructor.prototype === value)) {
		    var ret = value.inspect(recurseTimes, ctx);
		    if (!isString(ret)) {
		      ret = formatValue(ctx, ret, recurseTimes);
		    }
		    return ret;
		  }

		  // Primitive types cannot have properties
		  var primitive = formatPrimitive(ctx, value);
		  if (primitive) {
		    return primitive;
		  }

		  // Look up the keys of the object.
		  var keys = Object.keys(value);
		  var visibleKeys = arrayToHash(keys);

		  if (ctx.showHidden) {
		    keys = Object.getOwnPropertyNames(value);
		  }

		  // IE doesn't make error fields non-enumerable
		  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
		  if (isError(value)
		      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
		    return formatError(value);
		  }

		  // Some type of object without properties can be shortcutted.
		  if (keys.length === 0) {
		    if (isFunction(value)) {
		      var name = value.name ? ': ' + value.name : '';
		      return ctx.stylize('[Function' + name + ']', 'special');
		    }
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    }
		    if (isDate(value)) {
		      return ctx.stylize(Date.prototype.toString.call(value), 'date');
		    }
		    if (isError(value)) {
		      return formatError(value);
		    }
		  }

		  var base = '', array = false, braces = ['{', '}'];

		  // Make Array say that they are Array
		  if (isArray(value)) {
		    array = true;
		    braces = ['[', ']'];
		  }

		  // Make functions say that they are functions
		  if (isFunction(value)) {
		    var n = value.name ? ': ' + value.name : '';
		    base = ' [Function' + n + ']';
		  }

		  // Make RegExps say that they are RegExps
		  if (isRegExp(value)) {
		    base = ' ' + RegExp.prototype.toString.call(value);
		  }

		  // Make dates with properties first say the date
		  if (isDate(value)) {
		    base = ' ' + Date.prototype.toUTCString.call(value);
		  }

		  // Make error with message first say the error
		  if (isError(value)) {
		    base = ' ' + formatError(value);
		  }

		  if (keys.length === 0 && (!array || value.length == 0)) {
		    return braces[0] + base + braces[1];
		  }

		  if (recurseTimes < 0) {
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    } else {
		      return ctx.stylize('[Object]', 'special');
		    }
		  }

		  ctx.seen.push(value);

		  var output;
		  if (array) {
		    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
		  } else {
		    output = keys.map(function(key) {
		      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
		    });
		  }

		  ctx.seen.pop();

		  return reduceToSingleString(output, base, braces);
		}


		function formatPrimitive(ctx, value) {
		  if (isUndefined(value))
		    return ctx.stylize('undefined', 'undefined');
		  if (isString(value)) {
		    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
		                                             .replace(/'/g, "\\'")
		                                             .replace(/\\"/g, '"') + '\'';
		    return ctx.stylize(simple, 'string');
		  }
		  if (isNumber(value))
		    return ctx.stylize('' + value, 'number');
		  if (isBoolean(value))
		    return ctx.stylize('' + value, 'boolean');
		  // For some reason typeof null is "object", so special case here.
		  if (isNull(value))
		    return ctx.stylize('null', 'null');
		}


		function formatError(value) {
		  return '[' + Error.prototype.toString.call(value) + ']';
		}


		function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
		  var output = [];
		  for (var i = 0, l = value.length; i < l; ++i) {
		    if (hasOwnProperty(value, String(i))) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          String(i), true));
		    } else {
		      output.push('');
		    }
		  }
		  keys.forEach(function(key) {
		    if (!key.match(/^\d+$/)) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          key, true));
		    }
		  });
		  return output;
		}


		function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
		  var name, str, desc;
		  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
		  if (desc.get) {
		    if (desc.set) {
		      str = ctx.stylize('[Getter/Setter]', 'special');
		    } else {
		      str = ctx.stylize('[Getter]', 'special');
		    }
		  } else {
		    if (desc.set) {
		      str = ctx.stylize('[Setter]', 'special');
		    }
		  }
		  if (!hasOwnProperty(visibleKeys, key)) {
		    name = '[' + key + ']';
		  }
		  if (!str) {
		    if (ctx.seen.indexOf(desc.value) < 0) {
		      if (isNull(recurseTimes)) {
		        str = formatValue(ctx, desc.value, null);
		      } else {
		        str = formatValue(ctx, desc.value, recurseTimes - 1);
		      }
		      if (str.indexOf('\n') > -1) {
		        if (array) {
		          str = str.split('\n').map(function(line) {
		            return '  ' + line;
		          }).join('\n').substr(2);
		        } else {
		          str = '\n' + str.split('\n').map(function(line) {
		            return '   ' + line;
		          }).join('\n');
		        }
		      }
		    } else {
		      str = ctx.stylize('[Circular]', 'special');
		    }
		  }
		  if (isUndefined(name)) {
		    if (array && key.match(/^\d+$/)) {
		      return str;
		    }
		    name = JSON.stringify('' + key);
		    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
		      name = name.substr(1, name.length - 2);
		      name = ctx.stylize(name, 'name');
		    } else {
		      name = name.replace(/'/g, "\\'")
		                 .replace(/\\"/g, '"')
		                 .replace(/(^"|"$)/g, "'");
		      name = ctx.stylize(name, 'string');
		    }
		  }

		  return name + ': ' + str;
		}


		function reduceToSingleString(output, base, braces) {
		  var length = output.reduce(function(prev, cur) {
		    if (cur.indexOf('\n') >= 0) ;
		    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
		  }, 0);

		  if (length > 60) {
		    return braces[0] +
		           (base === '' ? '' : base + '\n ') +
		           ' ' +
		           output.join(',\n  ') +
		           ' ' +
		           braces[1];
		  }

		  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
		}


		// NOTE: These type checking functions intentionally don't use `instanceof`
		// because it is fragile and can be easily faked with `Object.create()`.
		function isArray(ar) {
		  return Array.isArray(ar);
		}
		exports.isArray = isArray;

		function isBoolean(arg) {
		  return typeof arg === 'boolean';
		}
		exports.isBoolean = isBoolean;

		function isNull(arg) {
		  return arg === null;
		}
		exports.isNull = isNull;

		function isNullOrUndefined(arg) {
		  return arg == null;
		}
		exports.isNullOrUndefined = isNullOrUndefined;

		function isNumber(arg) {
		  return typeof arg === 'number';
		}
		exports.isNumber = isNumber;

		function isString(arg) {
		  return typeof arg === 'string';
		}
		exports.isString = isString;

		function isSymbol(arg) {
		  return typeof arg === 'symbol';
		}
		exports.isSymbol = isSymbol;

		function isUndefined(arg) {
		  return arg === void 0;
		}
		exports.isUndefined = isUndefined;

		function isRegExp(re) {
		  return isObject(re) && objectToString(re) === '[object RegExp]';
		}
		exports.isRegExp = isRegExp;

		function isObject(arg) {
		  return typeof arg === 'object' && arg !== null;
		}
		exports.isObject = isObject;

		function isDate(d) {
		  return isObject(d) && objectToString(d) === '[object Date]';
		}
		exports.isDate = isDate;

		function isError(e) {
		  return isObject(e) &&
		      (objectToString(e) === '[object Error]' || e instanceof Error);
		}
		exports.isError = isError;

		function isFunction(arg) {
		  return typeof arg === 'function';
		}
		exports.isFunction = isFunction;

		function isPrimitive(arg) {
		  return arg === null ||
		         typeof arg === 'boolean' ||
		         typeof arg === 'number' ||
		         typeof arg === 'string' ||
		         typeof arg === 'symbol' ||  // ES6 symbol
		         typeof arg === 'undefined';
		}
		exports.isPrimitive = isPrimitive;

		exports.isBuffer = require('./support/isBuffer');

		function objectToString(o) {
		  return Object.prototype.toString.call(o);
		}


		function pad(n) {
		  return n < 10 ? '0' + n.toString(10) : n.toString(10);
		}


		var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
		              'Oct', 'Nov', 'Dec'];

		// 26 Feb 16:19:34
		function timestamp() {
		  var d = new Date();
		  var time = [pad(d.getHours()),
		              pad(d.getMinutes()),
		              pad(d.getSeconds())].join(':');
		  return [d.getDate(), months[d.getMonth()], time].join(' ');
		}


		// log is just a thin wrapper to console.log that prepends a timestamp
		exports.log = function() {
		  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
		};


		/**
		 * Inherit the prototype methods from one constructor into another.
		 *
		 * The Function.prototype.inherits from lang.js rewritten as a standalone
		 * function (not on Function.prototype). NOTE: If this file is to be loaded
		 * during bootstrapping this function needs to be rewritten using some native
		 * functions as prototype setup using normal JavaScript does not work as
		 * expected during bootstrapping (see mirror.js in r114903).
		 *
		 * @param {function} ctor Constructor function which needs to inherit the
		 *     prototype.
		 * @param {function} superCtor Constructor function to inherit prototype from.
		 */
		exports.inherits = require('inherits');

		exports._extend = function(origin, add) {
		  // Don't do anything if add isn't an object
		  if (!add || !isObject(add)) return origin;

		  var keys = Object.keys(add);
		  var i = keys.length;
		  while (i--) {
		    origin[keys[i]] = add[keys[i]];
		  }
		  return origin;
		};

		function hasOwnProperty(obj, prop) {
		  return Object.prototype.hasOwnProperty.call(obj, prop);
		}

		}).call(this);}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{"./support/isBuffer":97,"_process":538,"inherits":96}],99:[function(require,module,exports){
		(function (global){(function (){

		var possibleNames = [
			'BigInt64Array',
			'BigUint64Array',
			'Float32Array',
			'Float64Array',
			'Int16Array',
			'Int32Array',
			'Int8Array',
			'Uint16Array',
			'Uint32Array',
			'Uint8Array',
			'Uint8ClampedArray'
		];

		var g = typeof globalThis === 'undefined' ? global : globalThis;

		module.exports = function availableTypedArrays() {
			var out = [];
			for (var i = 0; i < possibleNames.length; i++) {
				if (typeof g[possibleNames[i]] === 'function') {
					out[out.length] = possibleNames[i];
				}
			}
			return out;
		};

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],100:[function(require,module,exports){

		exports.byteLength = byteLength;
		exports.toByteArray = toByteArray;
		exports.fromByteArray = fromByteArray;

		var lookup = [];
		var revLookup = [];
		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

		var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		for (var i = 0, len = code.length; i < len; ++i) {
		  lookup[i] = code[i];
		  revLookup[code.charCodeAt(i)] = i;
		}

		// Support decoding URL-safe base64 strings, as Node.js does.
		// See: https://en.wikipedia.org/wiki/Base64#URL_applications
		revLookup['-'.charCodeAt(0)] = 62;
		revLookup['_'.charCodeAt(0)] = 63;

		function getLens (b64) {
		  var len = b64.length;

		  if (len % 4 > 0) {
		    throw new Error('Invalid string. Length must be a multiple of 4')
		  }

		  // Trim off extra bytes after placeholder bytes are found
		  // See: https://github.com/beatgammit/base64-js/issues/42
		  var validLen = b64.indexOf('=');
		  if (validLen === -1) validLen = len;

		  var placeHoldersLen = validLen === len
		    ? 0
		    : 4 - (validLen % 4);

		  return [validLen, placeHoldersLen]
		}

		// base64 is 4/3 + up to two characters of the original data
		function byteLength (b64) {
		  var lens = getLens(b64);
		  var validLen = lens[0];
		  var placeHoldersLen = lens[1];
		  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
		}

		function _byteLength (b64, validLen, placeHoldersLen) {
		  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
		}

		function toByteArray (b64) {
		  var tmp;
		  var lens = getLens(b64);
		  var validLen = lens[0];
		  var placeHoldersLen = lens[1];

		  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

		  var curByte = 0;

		  // if there are placeholders, only get up to the last complete 4 chars
		  var len = placeHoldersLen > 0
		    ? validLen - 4
		    : validLen;

		  var i;
		  for (i = 0; i < len; i += 4) {
		    tmp =
		      (revLookup[b64.charCodeAt(i)] << 18) |
		      (revLookup[b64.charCodeAt(i + 1)] << 12) |
		      (revLookup[b64.charCodeAt(i + 2)] << 6) |
		      revLookup[b64.charCodeAt(i + 3)];
		    arr[curByte++] = (tmp >> 16) & 0xFF;
		    arr[curByte++] = (tmp >> 8) & 0xFF;
		    arr[curByte++] = tmp & 0xFF;
		  }

		  if (placeHoldersLen === 2) {
		    tmp =
		      (revLookup[b64.charCodeAt(i)] << 2) |
		      (revLookup[b64.charCodeAt(i + 1)] >> 4);
		    arr[curByte++] = tmp & 0xFF;
		  }

		  if (placeHoldersLen === 1) {
		    tmp =
		      (revLookup[b64.charCodeAt(i)] << 10) |
		      (revLookup[b64.charCodeAt(i + 1)] << 4) |
		      (revLookup[b64.charCodeAt(i + 2)] >> 2);
		    arr[curByte++] = (tmp >> 8) & 0xFF;
		    arr[curByte++] = tmp & 0xFF;
		  }

		  return arr
		}

		function tripletToBase64 (num) {
		  return lookup[num >> 18 & 0x3F] +
		    lookup[num >> 12 & 0x3F] +
		    lookup[num >> 6 & 0x3F] +
		    lookup[num & 0x3F]
		}

		function encodeChunk (uint8, start, end) {
		  var tmp;
		  var output = [];
		  for (var i = start; i < end; i += 3) {
		    tmp =
		      ((uint8[i] << 16) & 0xFF0000) +
		      ((uint8[i + 1] << 8) & 0xFF00) +
		      (uint8[i + 2] & 0xFF);
		    output.push(tripletToBase64(tmp));
		  }
		  return output.join('')
		}

		function fromByteArray (uint8) {
		  var tmp;
		  var len = uint8.length;
		  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
		  var parts = [];
		  var maxChunkLength = 16383; // must be multiple of 3

		  // go through the array every three bytes, we'll deal with trailing stuff later
		  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
		    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
		  }

		  // pad the end with zeros, but make sure to not forget the extra bytes
		  if (extraBytes === 1) {
		    tmp = uint8[len - 1];
		    parts.push(
		      lookup[tmp >> 2] +
		      lookup[(tmp << 4) & 0x3F] +
		      '=='
		    );
		  } else if (extraBytes === 2) {
		    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
		    parts.push(
		      lookup[tmp >> 10] +
		      lookup[(tmp >> 4) & 0x3F] +
		      lookup[(tmp << 2) & 0x3F] +
		      '='
		    );
		  }

		  return parts.join('')
		}

		},{}],101:[function(require,module,exports){
		/*!
		 * Bowser - a browser detector
		 * https://github.com/ded/bowser
		 * MIT License | (c) Dustin Diaz 2015
		 */

		!function (root, name, definition) {
		  if (typeof module != 'undefined' && module.exports) module.exports = definition();
		  else root[name] = definition();
		}(this, 'bowser', function () {
		  /**
		    * See useragents.js for examples of navigator.userAgent
		    */

		  var t = true;

		  function detect(ua) {

		    function getFirstMatch(regex) {
		      var match = ua.match(regex);
		      return (match && match.length > 1 && match[1]) || '';
		    }

		    function getSecondMatch(regex) {
		      var match = ua.match(regex);
		      return (match && match.length > 1 && match[2]) || '';
		    }

		    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
		      , likeAndroid = /like android/i.test(ua)
		      , android = !likeAndroid && /android/i.test(ua)
		      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
		      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
		      , chromeos = /CrOS/.test(ua)
		      , silk = /silk/i.test(ua)
		      , sailfish = /sailfish/i.test(ua)
		      , tizen = /tizen/i.test(ua)
		      , webos = /(web|hpw)(o|0)s/i.test(ua)
		      , windowsphone = /windows phone/i.test(ua)
		      , windows = !windowsphone && /windows/i.test(ua)
		      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
		      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
		      , edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i)
		      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
		      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
		      , mobile = !tablet && /[^-]mobi/i.test(ua)
		      , xbox = /xbox/i.test(ua)
		      , result;

		    if (/opera/i.test(ua)) {
		      //  an old Opera
		      result = {
		        name: 'Opera'
		      , opera: t
		      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
		      };
		    } else if (/opr\/|opios/i.test(ua)) {
		      // a new Opera
		      result = {
		        name: 'Opera'
		        , opera: t
		        , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
		      };
		    }
		    else if (/SamsungBrowser/i.test(ua)) {
		      result = {
		        name: 'Samsung Internet for Android'
		        , samsungBrowser: t
		        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
		      };
		    }
		    else if (/Whale/i.test(ua)) {
		      result = {
		        name: 'NAVER Whale browser'
		        , whale: t
		        , version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
		      };
		    }
		    else if (/MZBrowser/i.test(ua)) {
		      result = {
		        name: 'MZ Browser'
		        , mzbrowser: t
		        , version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
		      };
		    }
		    else if (/coast/i.test(ua)) {
		      result = {
		        name: 'Opera Coast'
		        , coast: t
		        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
		      };
		    }
		    else if (/focus/i.test(ua)) {
		      result = {
		        name: 'Focus'
		        , focus: t
		        , version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
		      };
		    }
		    else if (/yabrowser/i.test(ua)) {
		      result = {
		        name: 'Yandex Browser'
		      , yandexbrowser: t
		      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
		      };
		    }
		    else if (/ucbrowser/i.test(ua)) {
		      result = {
		          name: 'UC Browser'
		        , ucbrowser: t
		        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
		      };
		    }
		    else if (/mxios/i.test(ua)) {
		      result = {
		        name: 'Maxthon'
		        , maxthon: t
		        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
		      };
		    }
		    else if (/epiphany/i.test(ua)) {
		      result = {
		        name: 'Epiphany'
		        , epiphany: t
		        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
		      };
		    }
		    else if (/puffin/i.test(ua)) {
		      result = {
		        name: 'Puffin'
		        , puffin: t
		        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
		      };
		    }
		    else if (/sleipnir/i.test(ua)) {
		      result = {
		        name: 'Sleipnir'
		        , sleipnir: t
		        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
		      };
		    }
		    else if (/k-meleon/i.test(ua)) {
		      result = {
		        name: 'K-Meleon'
		        , kMeleon: t
		        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
		      };
		    }
		    else if (windowsphone) {
		      result = {
		        name: 'Windows Phone'
		      , osname: 'Windows Phone'
		      , windowsphone: t
		      };
		      if (edgeVersion) {
		        result.msedge = t;
		        result.version = edgeVersion;
		      }
		      else {
		        result.msie = t;
		        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i);
		      }
		    }
		    else if (/msie|trident/i.test(ua)) {
		      result = {
		        name: 'Internet Explorer'
		      , msie: t
		      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
		      };
		    } else if (chromeos) {
		      result = {
		        name: 'Chrome'
		      , osname: 'Chrome OS'
		      , chromeos: t
		      , chromeBook: t
		      , chrome: t
		      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
		      };
		    } else if (/edg([ea]|ios)/i.test(ua)) {
		      result = {
		        name: 'Microsoft Edge'
		      , msedge: t
		      , version: edgeVersion
		      };
		    }
		    else if (/vivaldi/i.test(ua)) {
		      result = {
		        name: 'Vivaldi'
		        , vivaldi: t
		        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
		      };
		    }
		    else if (sailfish) {
		      result = {
		        name: 'Sailfish'
		      , osname: 'Sailfish OS'
		      , sailfish: t
		      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
		      };
		    }
		    else if (/seamonkey\//i.test(ua)) {
		      result = {
		        name: 'SeaMonkey'
		      , seamonkey: t
		      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
		      };
		    }
		    else if (/firefox|iceweasel|fxios/i.test(ua)) {
		      result = {
		        name: 'Firefox'
		      , firefox: t
		      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
		      };
		      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
		        result.firefoxos = t;
		        result.osname = 'Firefox OS';
		      }
		    }
		    else if (silk) {
		      result =  {
		        name: 'Amazon Silk'
		      , silk: t
		      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
		      };
		    }
		    else if (/phantom/i.test(ua)) {
		      result = {
		        name: 'PhantomJS'
		      , phantom: t
		      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
		      };
		    }
		    else if (/slimerjs/i.test(ua)) {
		      result = {
		        name: 'SlimerJS'
		        , slimer: t
		        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
		      };
		    }
		    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
		      result = {
		        name: 'BlackBerry'
		      , osname: 'BlackBerry OS'
		      , blackberry: t
		      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
		      };
		    }
		    else if (webos) {
		      result = {
		        name: 'WebOS'
		      , osname: 'WebOS'
		      , webos: t
		      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
		      };
		      /touchpad\//i.test(ua) && (result.touchpad = t);
		    }
		    else if (/bada/i.test(ua)) {
		      result = {
		        name: 'Bada'
		      , osname: 'Bada'
		      , bada: t
		      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
		      };
		    }
		    else if (tizen) {
		      result = {
		        name: 'Tizen'
		      , osname: 'Tizen'
		      , tizen: t
		      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
		      };
		    }
		    else if (/qupzilla/i.test(ua)) {
		      result = {
		        name: 'QupZilla'
		        , qupzilla: t
		        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
		      };
		    }
		    else if (/chromium/i.test(ua)) {
		      result = {
		        name: 'Chromium'
		        , chromium: t
		        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
		      };
		    }
		    else if (/chrome|crios|crmo/i.test(ua)) {
		      result = {
		        name: 'Chrome'
		        , chrome: t
		        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
		      };
		    }
		    else if (android) {
		      result = {
		        name: 'Android'
		        , version: versionIdentifier
		      };
		    }
		    else if (/safari|applewebkit/i.test(ua)) {
		      result = {
		        name: 'Safari'
		      , safari: t
		      };
		      if (versionIdentifier) {
		        result.version = versionIdentifier;
		      }
		    }
		    else if (iosdevice) {
		      result = {
		        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
		      };
		      // WTF: version is not part of user agent in web apps
		      if (versionIdentifier) {
		        result.version = versionIdentifier;
		      }
		    }
		    else if(/googlebot/i.test(ua)) {
		      result = {
		        name: 'Googlebot'
		      , googlebot: t
		      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
		      };
		    }
		    else {
		      result = {
		        name: getFirstMatch(/^(.*)\/(.*) /),
		        version: getSecondMatch(/^(.*)\/(.*) /)
		     };
		   }

		    // set webkit or gecko flag for browsers based on these engines
		    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
		      if (/(apple)?webkit\/537\.36/i.test(ua)) {
		        result.name = result.name || "Blink";
		        result.blink = t;
		      } else {
		        result.name = result.name || "Webkit";
		        result.webkit = t;
		      }
		      if (!result.version && versionIdentifier) {
		        result.version = versionIdentifier;
		      }
		    } else if (!result.opera && /gecko\//i.test(ua)) {
		      result.name = result.name || "Gecko";
		      result.gecko = t;
		      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i);
		    }

		    // set OS flags for platforms that have multiple browsers
		    if (!result.windowsphone && (android || result.silk)) {
		      result.android = t;
		      result.osname = 'Android';
		    } else if (!result.windowsphone && iosdevice) {
		      result[iosdevice] = t;
		      result.ios = t;
		      result.osname = 'iOS';
		    } else if (mac) {
		      result.mac = t;
		      result.osname = 'macOS';
		    } else if (xbox) {
		      result.xbox = t;
		      result.osname = 'Xbox';
		    } else if (windows) {
		      result.windows = t;
		      result.osname = 'Windows';
		    } else if (linux) {
		      result.linux = t;
		      result.osname = 'Linux';
		    }

		    function getWindowsVersion (s) {
		      switch (s) {
		        case 'NT': return 'NT'
		        case 'XP': return 'XP'
		        case 'NT 5.0': return '2000'
		        case 'NT 5.1': return 'XP'
		        case 'NT 5.2': return '2003'
		        case 'NT 6.0': return 'Vista'
		        case 'NT 6.1': return '7'
		        case 'NT 6.2': return '8'
		        case 'NT 6.3': return '8.1'
		        case 'NT 10.0': return '10'
		        default: return undefined
		      }
		    }

		    // OS version extraction
		    var osVersion = '';
		    if (result.windows) {
		      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i));
		    } else if (result.windowsphone) {
		      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
		    } else if (result.mac) {
		      osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
		      osVersion = osVersion.replace(/[_\s]/g, '.');
		    } else if (iosdevice) {
		      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
		      osVersion = osVersion.replace(/[_\s]/g, '.');
		    } else if (android) {
		      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
		    } else if (result.webos) {
		      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
		    } else if (result.blackberry) {
		      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
		    } else if (result.bada) {
		      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
		    } else if (result.tizen) {
		      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
		    }
		    if (osVersion) {
		      result.osversion = osVersion;
		    }

		    // device type extraction
		    var osMajorVersion = !result.windows && osVersion.split('.')[0];
		    if (
		         tablet
		      || nexusTablet
		      || iosdevice == 'ipad'
		      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
		      || result.silk
		    ) {
		      result.tablet = t;
		    } else if (
		         mobile
		      || iosdevice == 'iphone'
		      || iosdevice == 'ipod'
		      || android
		      || nexusMobile
		      || result.blackberry
		      || result.webos
		      || result.bada
		    ) {
		      result.mobile = t;
		    }

		    // Graded Browser Support
		    // http://developer.yahoo.com/yui/articles/gbs
		    if (result.msedge ||
		        (result.msie && result.version >= 10) ||
		        (result.yandexbrowser && result.version >= 15) ||
				    (result.vivaldi && result.version >= 1.0) ||
		        (result.chrome && result.version >= 20) ||
		        (result.samsungBrowser && result.version >= 4) ||
		        (result.whale && compareVersions([result.version, '1.0']) === 1) ||
		        (result.mzbrowser && compareVersions([result.version, '6.0']) === 1) ||
		        (result.focus && compareVersions([result.version, '1.0']) === 1) ||
		        (result.firefox && result.version >= 20.0) ||
		        (result.safari && result.version >= 6) ||
		        (result.opera && result.version >= 10.0) ||
		        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
		        (result.blackberry && result.version >= 10.1)
		        || (result.chromium && result.version >= 20)
		        ) {
		      result.a = t;
		    }
		    else if ((result.msie && result.version < 10) ||
		        (result.chrome && result.version < 20) ||
		        (result.firefox && result.version < 20.0) ||
		        (result.safari && result.version < 6) ||
		        (result.opera && result.version < 10.0) ||
		        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
		        || (result.chromium && result.version < 20)
		        ) {
		      result.c = t;
		    } else result.x = t;

		    return result
		  }

		  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '');

		  bowser.test = function (browserList) {
		    for (var i = 0; i < browserList.length; ++i) {
		      var browserItem = browserList[i];
		      if (typeof browserItem=== 'string') {
		        if (browserItem in bowser) {
		          return true;
		        }
		      }
		    }
		    return false;
		  };

		  /**
		   * Get version precisions count
		   *
		   * @example
		   *   getVersionPrecision("1.10.3") // 3
		   *
		   * @param  {string} version
		   * @return {number}
		   */
		  function getVersionPrecision(version) {
		    return version.split(".").length;
		  }

		  /**
		   * Array::map polyfill
		   *
		   * @param  {Array} arr
		   * @param  {Function} iterator
		   * @return {Array}
		   */
		  function map(arr, iterator) {
		    var result = [], i;
		    if (Array.prototype.map) {
		      return Array.prototype.map.call(arr, iterator);
		    }
		    for (i = 0; i < arr.length; i++) {
		      result.push(iterator(arr[i]));
		    }
		    return result;
		  }

		  /**
		   * Calculate browser version weight
		   *
		   * @example
		   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
		   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
		   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
		   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
		   *
		   * @param  {Array<String>} versions versions to compare
		   * @return {Number} comparison result
		   */
		  function compareVersions(versions) {
		    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
		    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
		    var chunks = map(versions, function (version) {
		      var delta = precision - getVersionPrecision(version);

		      // 2) "9" -> "9.0" (for precision = 2)
		      version = version + new Array(delta + 1).join(".0");

		      // 3) "9.0" -> ["000000000"", "000000009"]
		      return map(version.split("."), function (chunk) {
		        return new Array(20 - chunk.length).join("0") + chunk;
		      }).reverse();
		    });

		    // iterate in reverse order by reversed chunks array
		    while (--precision >= 0) {
		      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
		      if (chunks[0][precision] > chunks[1][precision]) {
		        return 1;
		      }
		      else if (chunks[0][precision] === chunks[1][precision]) {
		        if (precision === 0) {
		          // all version chunks are same
		          return 0;
		        }
		      }
		      else {
		        return -1;
		      }
		    }
		  }

		  /**
		   * Check if browser is unsupported
		   *
		   * @example
		   *   bowser.isUnsupportedBrowser({
		   *     msie: "10",
		   *     firefox: "23",
		   *     chrome: "29",
		   *     safari: "5.1",
		   *     opera: "16",
		   *     phantom: "534"
		   *   });
		   *
		   * @param  {Object}  minVersions map of minimal version to browser
		   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
		   * @param  {String}  [ua] user agent string
		   * @return {Boolean}
		   */
		  function isUnsupportedBrowser(minVersions, strictMode, ua) {
		    var _bowser = bowser;

		    // make strictMode param optional with ua param usage
		    if (typeof strictMode === 'string') {
		      ua = strictMode;
		      strictMode = void 0;
		    }

		    if (strictMode === void 0) {
		      strictMode = false;
		    }
		    if (ua) {
		      _bowser = detect(ua);
		    }

		    var version = "" + _bowser.version;
		    for (var browser in minVersions) {
		      if (minVersions.hasOwnProperty(browser)) {
		        if (_bowser[browser]) {
		          if (typeof minVersions[browser] !== 'string') {
		            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
		          }

		          // browser version and min supported version.
		          return compareVersions([version, minVersions[browser]]) < 0;
		        }
		      }
		    }

		    return strictMode; // not found
		  }

		  /**
		   * Check if browser is supported
		   *
		   * @param  {Object} minVersions map of minimal version to browser
		   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
		   * @param  {String}  [ua] user agent string
		   * @return {Boolean}
		   */
		  function check(minVersions, strictMode, ua) {
		    return !isUnsupportedBrowser(minVersions, strictMode, ua);
		  }

		  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
		  bowser.compareVersions = compareVersions;
		  bowser.check = check;

		  /*
		   * Set our detect method to the main bowser object so we can
		   * reuse it to test other user agents.
		   * This is needed to implement future tests.
		   */
		  bowser._detect = detect;

		  /*
		   * Set our detect public method to the main bowser object
		   * This is needed to implement bowser in server side
		   */
		  bowser.detect = detect;
		  return bowser
		});

		},{}],102:[function(require,module,exports){

		},{}],103:[function(require,module,exports){
		(function (Buffer){(function (){

		var base64 = require('base64-js');
		var ieee754 = require('ieee754');

		exports.Buffer = Buffer;
		exports.SlowBuffer = SlowBuffer;
		exports.INSPECT_MAX_BYTES = 50;

		var K_MAX_LENGTH = 0x7fffffff;
		exports.kMaxLength = K_MAX_LENGTH;

		/**
		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
		 *   === true    Use Uint8Array implementation (fastest)
		 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
		 *               implementation (most compatible, even IE6)
		 *
		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		 * Opera 11.6+, iOS 4.2+.
		 *
		 * We report that the browser does not support typed arrays if the are not subclassable
		 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
		 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
		 * for __proto__ and has a buggy typed array implementation.
		 */
		Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

		if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
		    typeof console.error === 'function') {
		  console.error(
		    'This browser lacks typed array (Uint8Array) support which is required by ' +
		    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
		  );
		}

		function typedArraySupport () {
		  // Can typed array instances can be augmented?
		  try {
		    var arr = new Uint8Array(1);
		    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } };
		    return arr.foo() === 42
		  } catch (e) {
		    return false
		  }
		}

		Object.defineProperty(Buffer.prototype, 'parent', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.buffer
		  }
		});

		Object.defineProperty(Buffer.prototype, 'offset', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.byteOffset
		  }
		});

		function createBuffer (length) {
		  if (length > K_MAX_LENGTH) {
		    throw new RangeError('The value "' + length + '" is invalid for option "size"')
		  }
		  // Return an augmented `Uint8Array` instance
		  var buf = new Uint8Array(length);
		  buf.__proto__ = Buffer.prototype;
		  return buf
		}

		/**
		 * The Buffer constructor returns instances of `Uint8Array` that have their
		 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
		 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
		 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
		 * returns a single octet.
		 *
		 * The `Uint8Array` prototype remains unmodified.
		 */

		function Buffer (arg, encodingOrOffset, length) {
		  // Common case.
		  if (typeof arg === 'number') {
		    if (typeof encodingOrOffset === 'string') {
		      throw new TypeError(
		        'The "string" argument must be of type string. Received type number'
		      )
		    }
		    return allocUnsafe(arg)
		  }
		  return from(arg, encodingOrOffset, length)
		}

		// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
		if (typeof Symbol !== 'undefined' && Symbol.species != null &&
		    Buffer[Symbol.species] === Buffer) {
		  Object.defineProperty(Buffer, Symbol.species, {
		    value: null,
		    configurable: true,
		    enumerable: false,
		    writable: false
		  });
		}

		Buffer.poolSize = 8192; // not used by this implementation

		function from (value, encodingOrOffset, length) {
		  if (typeof value === 'string') {
		    return fromString(value, encodingOrOffset)
		  }

		  if (ArrayBuffer.isView(value)) {
		    return fromArrayLike(value)
		  }

		  if (value == null) {
		    throw TypeError(
		      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		      'or Array-like Object. Received type ' + (typeof value)
		    )
		  }

		  if (isInstance(value, ArrayBuffer) ||
		      (value && isInstance(value.buffer, ArrayBuffer))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof value === 'number') {
		    throw new TypeError(
		      'The "value" argument must not be of type number. Received type number'
		    )
		  }

		  var valueOf = value.valueOf && value.valueOf();
		  if (valueOf != null && valueOf !== value) {
		    return Buffer.from(valueOf, encodingOrOffset, length)
		  }

		  var b = fromObject(value);
		  if (b) return b

		  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
		      typeof value[Symbol.toPrimitive] === 'function') {
		    return Buffer.from(
		      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
		    )
		  }

		  throw new TypeError(
		    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		    'or Array-like Object. Received type ' + (typeof value)
		  )
		}

		/**
		 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
		 * if value is a number.
		 * Buffer.from(str[, encoding])
		 * Buffer.from(array)
		 * Buffer.from(buffer)
		 * Buffer.from(arrayBuffer[, byteOffset[, length]])
		 **/
		Buffer.from = function (value, encodingOrOffset, length) {
		  return from(value, encodingOrOffset, length)
		};

		// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
		// https://github.com/feross/buffer/pull/148
		Buffer.prototype.__proto__ = Uint8Array.prototype;
		Buffer.__proto__ = Uint8Array;

		function assertSize (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('"size" argument must be of type number')
		  } else if (size < 0) {
		    throw new RangeError('The value "' + size + '" is invalid for option "size"')
		  }
		}

		function alloc (size, fill, encoding) {
		  assertSize(size);
		  if (size <= 0) {
		    return createBuffer(size)
		  }
		  if (fill !== undefined) {
		    // Only pay attention to encoding if it's a string. This
		    // prevents accidentally sending in a number that would
		    // be interpretted as a start offset.
		    return typeof encoding === 'string'
		      ? createBuffer(size).fill(fill, encoding)
		      : createBuffer(size).fill(fill)
		  }
		  return createBuffer(size)
		}

		/**
		 * Creates a new filled Buffer instance.
		 * alloc(size[, fill[, encoding]])
		 **/
		Buffer.alloc = function (size, fill, encoding) {
		  return alloc(size, fill, encoding)
		};

		function allocUnsafe (size) {
		  assertSize(size);
		  return createBuffer(size < 0 ? 0 : checked(size) | 0)
		}

		/**
		 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
		 * */
		Buffer.allocUnsafe = function (size) {
		  return allocUnsafe(size)
		};
		/**
		 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
		 */
		Buffer.allocUnsafeSlow = function (size) {
		  return allocUnsafe(size)
		};

		function fromString (string, encoding) {
		  if (typeof encoding !== 'string' || encoding === '') {
		    encoding = 'utf8';
		  }

		  if (!Buffer.isEncoding(encoding)) {
		    throw new TypeError('Unknown encoding: ' + encoding)
		  }

		  var length = byteLength(string, encoding) | 0;
		  var buf = createBuffer(length);

		  var actual = buf.write(string, encoding);

		  if (actual !== length) {
		    // Writing a hex string, for example, that contains invalid characters will
		    // cause everything after the first invalid character to be ignored. (e.g.
		    // 'abxxcd' will be treated as 'ab')
		    buf = buf.slice(0, actual);
		  }

		  return buf
		}

		function fromArrayLike (array) {
		  var length = array.length < 0 ? 0 : checked(array.length) | 0;
		  var buf = createBuffer(length);
		  for (var i = 0; i < length; i += 1) {
		    buf[i] = array[i] & 255;
		  }
		  return buf
		}

		function fromArrayBuffer (array, byteOffset, length) {
		  if (byteOffset < 0 || array.byteLength < byteOffset) {
		    throw new RangeError('"offset" is outside of buffer bounds')
		  }

		  if (array.byteLength < byteOffset + (length || 0)) {
		    throw new RangeError('"length" is outside of buffer bounds')
		  }

		  var buf;
		  if (byteOffset === undefined && length === undefined) {
		    buf = new Uint8Array(array);
		  } else if (length === undefined) {
		    buf = new Uint8Array(array, byteOffset);
		  } else {
		    buf = new Uint8Array(array, byteOffset, length);
		  }

		  // Return an augmented `Uint8Array` instance
		  buf.__proto__ = Buffer.prototype;
		  return buf
		}

		function fromObject (obj) {
		  if (Buffer.isBuffer(obj)) {
		    var len = checked(obj.length) | 0;
		    var buf = createBuffer(len);

		    if (buf.length === 0) {
		      return buf
		    }

		    obj.copy(buf, 0, 0, len);
		    return buf
		  }

		  if (obj.length !== undefined) {
		    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
		      return createBuffer(0)
		    }
		    return fromArrayLike(obj)
		  }

		  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
		    return fromArrayLike(obj.data)
		  }
		}

		function checked (length) {
		  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
		  // length is NaN (which is otherwise coerced to zero.)
		  if (length >= K_MAX_LENGTH) {
		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
		                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
		  }
		  return length | 0
		}

		function SlowBuffer (length) {
		  if (+length != length) { // eslint-disable-line eqeqeq
		    length = 0;
		  }
		  return Buffer.alloc(+length)
		}

		Buffer.isBuffer = function isBuffer (b) {
		  return b != null && b._isBuffer === true &&
		    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
		};

		Buffer.compare = function compare (a, b) {
		  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
		  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
		    throw new TypeError(
		      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
		    )
		  }

		  if (a === b) return 0

		  var x = a.length;
		  var y = b.length;

		  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
		    if (a[i] !== b[i]) {
		      x = a[i];
		      y = b[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		Buffer.isEncoding = function isEncoding (encoding) {
		  switch (String(encoding).toLowerCase()) {
		    case 'hex':
		    case 'utf8':
		    case 'utf-8':
		    case 'ascii':
		    case 'latin1':
		    case 'binary':
		    case 'base64':
		    case 'ucs2':
		    case 'ucs-2':
		    case 'utf16le':
		    case 'utf-16le':
		      return true
		    default:
		      return false
		  }
		};

		Buffer.concat = function concat (list, length) {
		  if (!Array.isArray(list)) {
		    throw new TypeError('"list" argument must be an Array of Buffers')
		  }

		  if (list.length === 0) {
		    return Buffer.alloc(0)
		  }

		  var i;
		  if (length === undefined) {
		    length = 0;
		    for (i = 0; i < list.length; ++i) {
		      length += list[i].length;
		    }
		  }

		  var buffer = Buffer.allocUnsafe(length);
		  var pos = 0;
		  for (i = 0; i < list.length; ++i) {
		    var buf = list[i];
		    if (isInstance(buf, Uint8Array)) {
		      buf = Buffer.from(buf);
		    }
		    if (!Buffer.isBuffer(buf)) {
		      throw new TypeError('"list" argument must be an Array of Buffers')
		    }
		    buf.copy(buffer, pos);
		    pos += buf.length;
		  }
		  return buffer
		};

		function byteLength (string, encoding) {
		  if (Buffer.isBuffer(string)) {
		    return string.length
		  }
		  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
		    return string.byteLength
		  }
		  if (typeof string !== 'string') {
		    throw new TypeError(
		      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
		      'Received type ' + typeof string
		    )
		  }

		  var len = string.length;
		  var mustMatch = (arguments.length > 2 && arguments[2] === true);
		  if (!mustMatch && len === 0) return 0

		  // Use a for loop to avoid recursion
		  var loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return len
		      case 'utf8':
		      case 'utf-8':
		        return utf8ToBytes(string).length
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return len * 2
		      case 'hex':
		        return len >>> 1
		      case 'base64':
		        return base64ToBytes(string).length
		      default:
		        if (loweredCase) {
		          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
		        }
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		}
		Buffer.byteLength = byteLength;

		function slowToString (encoding, start, end) {
		  var loweredCase = false;

		  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
		  // property of a typed array.

		  // This behaves neither like String nor Uint8Array in that we set start/end
		  // to their upper/lower bounds if the value passed is out of range.
		  // undefined is handled specially as per ECMA-262 6th Edition,
		  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
		  if (start === undefined || start < 0) {
		    start = 0;
		  }
		  // Return early if start > this.length. Done here to prevent potential uint32
		  // coercion fail below.
		  if (start > this.length) {
		    return ''
		  }

		  if (end === undefined || end > this.length) {
		    end = this.length;
		  }

		  if (end <= 0) {
		    return ''
		  }

		  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
		  end >>>= 0;
		  start >>>= 0;

		  if (end <= start) {
		    return ''
		  }

		  if (!encoding) encoding = 'utf8';

		  while (true) {
		    switch (encoding) {
		      case 'hex':
		        return hexSlice(this, start, end)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Slice(this, start, end)

		      case 'ascii':
		        return asciiSlice(this, start, end)

		      case 'latin1':
		      case 'binary':
		        return latin1Slice(this, start, end)

		      case 'base64':
		        return base64Slice(this, start, end)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return utf16leSlice(this, start, end)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = (encoding + '').toLowerCase();
		        loweredCase = true;
		    }
		  }
		}

		// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
		// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
		// reliably in a browserify context because there could be multiple different
		// copies of the 'buffer' package in use. This method works even for Buffer
		// instances that were created from another copy of the `buffer` package.
		// See: https://github.com/feross/buffer/issues/154
		Buffer.prototype._isBuffer = true;

		function swap (b, n, m) {
		  var i = b[n];
		  b[n] = b[m];
		  b[m] = i;
		}

		Buffer.prototype.swap16 = function swap16 () {
		  var len = this.length;
		  if (len % 2 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 16-bits')
		  }
		  for (var i = 0; i < len; i += 2) {
		    swap(this, i, i + 1);
		  }
		  return this
		};

		Buffer.prototype.swap32 = function swap32 () {
		  var len = this.length;
		  if (len % 4 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 32-bits')
		  }
		  for (var i = 0; i < len; i += 4) {
		    swap(this, i, i + 3);
		    swap(this, i + 1, i + 2);
		  }
		  return this
		};

		Buffer.prototype.swap64 = function swap64 () {
		  var len = this.length;
		  if (len % 8 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 64-bits')
		  }
		  for (var i = 0; i < len; i += 8) {
		    swap(this, i, i + 7);
		    swap(this, i + 1, i + 6);
		    swap(this, i + 2, i + 5);
		    swap(this, i + 3, i + 4);
		  }
		  return this
		};

		Buffer.prototype.toString = function toString () {
		  var length = this.length;
		  if (length === 0) return ''
		  if (arguments.length === 0) return utf8Slice(this, 0, length)
		  return slowToString.apply(this, arguments)
		};

		Buffer.prototype.toLocaleString = Buffer.prototype.toString;

		Buffer.prototype.equals = function equals (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return true
		  return Buffer.compare(this, b) === 0
		};

		Buffer.prototype.inspect = function inspect () {
		  var str = '';
		  var max = exports.INSPECT_MAX_BYTES;
		  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
		  if (this.length > max) str += ' ... ';
		  return '<Buffer ' + str + '>'
		};

		Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
		  if (isInstance(target, Uint8Array)) {
		    target = Buffer.from(target, target.offset, target.byteLength);
		  }
		  if (!Buffer.isBuffer(target)) {
		    throw new TypeError(
		      'The "target" argument must be one of type Buffer or Uint8Array. ' +
		      'Received type ' + (typeof target)
		    )
		  }

		  if (start === undefined) {
		    start = 0;
		  }
		  if (end === undefined) {
		    end = target ? target.length : 0;
		  }
		  if (thisStart === undefined) {
		    thisStart = 0;
		  }
		  if (thisEnd === undefined) {
		    thisEnd = this.length;
		  }

		  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
		    throw new RangeError('out of range index')
		  }

		  if (thisStart >= thisEnd && start >= end) {
		    return 0
		  }
		  if (thisStart >= thisEnd) {
		    return -1
		  }
		  if (start >= end) {
		    return 1
		  }

		  start >>>= 0;
		  end >>>= 0;
		  thisStart >>>= 0;
		  thisEnd >>>= 0;

		  if (this === target) return 0

		  var x = thisEnd - thisStart;
		  var y = end - start;
		  var len = Math.min(x, y);

		  var thisCopy = this.slice(thisStart, thisEnd);
		  var targetCopy = target.slice(start, end);

		  for (var i = 0; i < len; ++i) {
		    if (thisCopy[i] !== targetCopy[i]) {
		      x = thisCopy[i];
		      y = targetCopy[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
		// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
		//
		// Arguments:
		// - buffer - a Buffer to search
		// - val - a string, Buffer, or number
		// - byteOffset - an index into `buffer`; will be clamped to an int32
		// - encoding - an optional encoding, relevant is val is a string
		// - dir - true for indexOf, false for lastIndexOf
		function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
		  // Empty buffer means no match
		  if (buffer.length === 0) return -1

		  // Normalize byteOffset
		  if (typeof byteOffset === 'string') {
		    encoding = byteOffset;
		    byteOffset = 0;
		  } else if (byteOffset > 0x7fffffff) {
		    byteOffset = 0x7fffffff;
		  } else if (byteOffset < -2147483648) {
		    byteOffset = -2147483648;
		  }
		  byteOffset = +byteOffset; // Coerce to Number.
		  if (numberIsNaN(byteOffset)) {
		    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
		    byteOffset = dir ? 0 : (buffer.length - 1);
		  }

		  // Normalize byteOffset: negative offsets start from the end of the buffer
		  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
		  if (byteOffset >= buffer.length) {
		    if (dir) return -1
		    else byteOffset = buffer.length - 1;
		  } else if (byteOffset < 0) {
		    if (dir) byteOffset = 0;
		    else return -1
		  }

		  // Normalize val
		  if (typeof val === 'string') {
		    val = Buffer.from(val, encoding);
		  }

		  // Finally, search either indexOf (if dir is true) or lastIndexOf
		  if (Buffer.isBuffer(val)) {
		    // Special case: looking for empty string/buffer always fails
		    if (val.length === 0) {
		      return -1
		    }
		    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
		  } else if (typeof val === 'number') {
		    val = val & 0xFF; // Search for a byte value [0-255]
		    if (typeof Uint8Array.prototype.indexOf === 'function') {
		      if (dir) {
		        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
		      } else {
		        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
		      }
		    }
		    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
		  }

		  throw new TypeError('val must be string, number or Buffer')
		}

		function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
		  var indexSize = 1;
		  var arrLength = arr.length;
		  var valLength = val.length;

		  if (encoding !== undefined) {
		    encoding = String(encoding).toLowerCase();
		    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
		        encoding === 'utf16le' || encoding === 'utf-16le') {
		      if (arr.length < 2 || val.length < 2) {
		        return -1
		      }
		      indexSize = 2;
		      arrLength /= 2;
		      valLength /= 2;
		      byteOffset /= 2;
		    }
		  }

		  function read (buf, i) {
		    if (indexSize === 1) {
		      return buf[i]
		    } else {
		      return buf.readUInt16BE(i * indexSize)
		    }
		  }

		  var i;
		  if (dir) {
		    var foundIndex = -1;
		    for (i = byteOffset; i < arrLength; i++) {
		      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
		        if (foundIndex === -1) foundIndex = i;
		        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
		      } else {
		        if (foundIndex !== -1) i -= i - foundIndex;
		        foundIndex = -1;
		      }
		    }
		  } else {
		    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
		    for (i = byteOffset; i >= 0; i--) {
		      var found = true;
		      for (var j = 0; j < valLength; j++) {
		        if (read(arr, i + j) !== read(val, j)) {
		          found = false;
		          break
		        }
		      }
		      if (found) return i
		    }
		  }

		  return -1
		}

		Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
		  return this.indexOf(val, byteOffset, encoding) !== -1
		};

		Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
		};

		Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
		};

		function hexWrite (buf, string, offset, length) {
		  offset = Number(offset) || 0;
		  var remaining = buf.length - offset;
		  if (!length) {
		    length = remaining;
		  } else {
		    length = Number(length);
		    if (length > remaining) {
		      length = remaining;
		    }
		  }

		  var strLen = string.length;

		  if (length > strLen / 2) {
		    length = strLen / 2;
		  }
		  for (var i = 0; i < length; ++i) {
		    var parsed = parseInt(string.substr(i * 2, 2), 16);
		    if (numberIsNaN(parsed)) return i
		    buf[offset + i] = parsed;
		  }
		  return i
		}

		function utf8Write (buf, string, offset, length) {
		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
		}

		function asciiWrite (buf, string, offset, length) {
		  return blitBuffer(asciiToBytes(string), buf, offset, length)
		}

		function latin1Write (buf, string, offset, length) {
		  return asciiWrite(buf, string, offset, length)
		}

		function base64Write (buf, string, offset, length) {
		  return blitBuffer(base64ToBytes(string), buf, offset, length)
		}

		function ucs2Write (buf, string, offset, length) {
		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
		}

		Buffer.prototype.write = function write (string, offset, length, encoding) {
		  // Buffer#write(string)
		  if (offset === undefined) {
		    encoding = 'utf8';
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, encoding)
		  } else if (length === undefined && typeof offset === 'string') {
		    encoding = offset;
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, offset[, length][, encoding])
		  } else if (isFinite(offset)) {
		    offset = offset >>> 0;
		    if (isFinite(length)) {
		      length = length >>> 0;
		      if (encoding === undefined) encoding = 'utf8';
		    } else {
		      encoding = length;
		      length = undefined;
		    }
		  } else {
		    throw new Error(
		      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
		    )
		  }

		  var remaining = this.length - offset;
		  if (length === undefined || length > remaining) length = remaining;

		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
		    throw new RangeError('Attempt to write outside buffer bounds')
		  }

		  if (!encoding) encoding = 'utf8';

		  var loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'hex':
		        return hexWrite(this, string, offset, length)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Write(this, string, offset, length)

		      case 'ascii':
		        return asciiWrite(this, string, offset, length)

		      case 'latin1':
		      case 'binary':
		        return latin1Write(this, string, offset, length)

		      case 'base64':
		        // Warning: maxLength not taken into account in base64Write
		        return base64Write(this, string, offset, length)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return ucs2Write(this, string, offset, length)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		};

		Buffer.prototype.toJSON = function toJSON () {
		  return {
		    type: 'Buffer',
		    data: Array.prototype.slice.call(this._arr || this, 0)
		  }
		};

		function base64Slice (buf, start, end) {
		  if (start === 0 && end === buf.length) {
		    return base64.fromByteArray(buf)
		  } else {
		    return base64.fromByteArray(buf.slice(start, end))
		  }
		}

		function utf8Slice (buf, start, end) {
		  end = Math.min(buf.length, end);
		  var res = [];

		  var i = start;
		  while (i < end) {
		    var firstByte = buf[i];
		    var codePoint = null;
		    var bytesPerSequence = (firstByte > 0xEF) ? 4
		      : (firstByte > 0xDF) ? 3
		        : (firstByte > 0xBF) ? 2
		          : 1;

		    if (i + bytesPerSequence <= end) {
		      var secondByte, thirdByte, fourthByte, tempCodePoint;

		      switch (bytesPerSequence) {
		        case 1:
		          if (firstByte < 0x80) {
		            codePoint = firstByte;
		          }
		          break
		        case 2:
		          secondByte = buf[i + 1];
		          if ((secondByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
		            if (tempCodePoint > 0x7F) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 3:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 4:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          fourthByte = buf[i + 3];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
		              codePoint = tempCodePoint;
		            }
		          }
		      }
		    }

		    if (codePoint === null) {
		      // we did not generate a valid codePoint so insert a
		      // replacement char (U+FFFD) and advance only 1 byte
		      codePoint = 0xFFFD;
		      bytesPerSequence = 1;
		    } else if (codePoint > 0xFFFF) {
		      // encode to utf16 (surrogate pair dance)
		      codePoint -= 0x10000;
		      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
		      codePoint = 0xDC00 | codePoint & 0x3FF;
		    }

		    res.push(codePoint);
		    i += bytesPerSequence;
		  }

		  return decodeCodePointsArray(res)
		}

		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
		// the lowest limit is Chrome, with 0x10000 args.
		// We go 1 magnitude less, for safety
		var MAX_ARGUMENTS_LENGTH = 0x1000;

		function decodeCodePointsArray (codePoints) {
		  var len = codePoints.length;
		  if (len <= MAX_ARGUMENTS_LENGTH) {
		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		  }

		  // Decode in chunks to avoid "call stack size exceeded".
		  var res = '';
		  var i = 0;
		  while (i < len) {
		    res += String.fromCharCode.apply(
		      String,
		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
		    );
		  }
		  return res
		}

		function asciiSlice (buf, start, end) {
		  var ret = '';
		  end = Math.min(buf.length, end);

		  for (var i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i] & 0x7F);
		  }
		  return ret
		}

		function latin1Slice (buf, start, end) {
		  var ret = '';
		  end = Math.min(buf.length, end);

		  for (var i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i]);
		  }
		  return ret
		}

		function hexSlice (buf, start, end) {
		  var len = buf.length;

		  if (!start || start < 0) start = 0;
		  if (!end || end < 0 || end > len) end = len;

		  var out = '';
		  for (var i = start; i < end; ++i) {
		    out += toHex(buf[i]);
		  }
		  return out
		}

		function utf16leSlice (buf, start, end) {
		  var bytes = buf.slice(start, end);
		  var res = '';
		  for (var i = 0; i < bytes.length; i += 2) {
		    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
		  }
		  return res
		}

		Buffer.prototype.slice = function slice (start, end) {
		  var len = this.length;
		  start = ~~start;
		  end = end === undefined ? len : ~~end;

		  if (start < 0) {
		    start += len;
		    if (start < 0) start = 0;
		  } else if (start > len) {
		    start = len;
		  }

		  if (end < 0) {
		    end += len;
		    if (end < 0) end = 0;
		  } else if (end > len) {
		    end = len;
		  }

		  if (end < start) end = start;

		  var newBuf = this.subarray(start, end);
		  // Return an augmented `Uint8Array` instance
		  newBuf.__proto__ = Buffer.prototype;
		  return newBuf
		};

		/*
		 * Need to make sure that buffer isn't trying to write out of bounds.
		 */
		function checkOffset (offset, ext, length) {
		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}

		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  var val = this[offset];
		  var mul = 1;
		  var i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    checkOffset(offset, byteLength, this.length);
		  }

		  var val = this[offset + --byteLength];
		  var mul = 1;
		  while (byteLength > 0 && (mul *= 0x100)) {
		    val += this[offset + --byteLength] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  return this[offset]
		};

		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return this[offset] | (this[offset + 1] << 8)
		};

		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return (this[offset] << 8) | this[offset + 1]
		};

		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return ((this[offset]) |
		      (this[offset + 1] << 8) |
		      (this[offset + 2] << 16)) +
		      (this[offset + 3] * 0x1000000)
		};

		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] * 0x1000000) +
		    ((this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    this[offset + 3])
		};

		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  var val = this[offset];
		  var mul = 1;
		  var i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  var i = byteLength;
		  var mul = 1;
		  var val = this[offset + --i];
		  while (i > 0 && (mul *= 0x100)) {
		    val += this[offset + --i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  if (!(this[offset] & 0x80)) return (this[offset])
		  return ((0xff - this[offset] + 1) * -1)
		};

		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  var val = this[offset] | (this[offset + 1] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  var val = this[offset + 1] | (this[offset] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset]) |
		    (this[offset + 1] << 8) |
		    (this[offset + 2] << 16) |
		    (this[offset + 3] << 24)
		};

		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] << 24) |
		    (this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    (this[offset + 3])
		};

		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, true, 23, 4)
		};

		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, false, 23, 4)
		};

		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, true, 52, 8)
		};

		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, false, 52, 8)
		};

		function checkInt (buf, value, offset, ext, max, min) {
		  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
		  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		}

		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  var mul = 1;
		  var i = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  var i = byteLength - 1;
		  var mul = 1;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset + 3] = (value >>> 24);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 1] = (value >>> 8);
		  this[offset] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    var limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  var i = 0;
		  var mul = 1;
		  var sub = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    var limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  var i = byteLength - 1;
		  var mul = 1;
		  var sub = 0;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
		  if (value < 0) value = 0xff + value + 1;
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 3] = (value >>> 24);
		  return offset + 4
		};

		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
		  if (value < 0) value = 0xffffffff + value + 1;
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		function checkIEEE754 (buf, value, offset, ext, max, min) {
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		  if (offset < 0) throw new RangeError('Index out of range')
		}

		function writeFloat (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 4);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 23, 4);
		  return offset + 4
		}

		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, false, noAssert)
		};

		function writeDouble (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 8);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 52, 8);
		  return offset + 8
		}

		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, false, noAssert)
		};

		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
		  if (!start) start = 0;
		  if (!end && end !== 0) end = this.length;
		  if (targetStart >= target.length) targetStart = target.length;
		  if (!targetStart) targetStart = 0;
		  if (end > 0 && end < start) end = start;

		  // Copy 0 bytes; we're done
		  if (end === start) return 0
		  if (target.length === 0 || this.length === 0) return 0

		  // Fatal error conditions
		  if (targetStart < 0) {
		    throw new RangeError('targetStart out of bounds')
		  }
		  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
		  if (end < 0) throw new RangeError('sourceEnd out of bounds')

		  // Are we oob?
		  if (end > this.length) end = this.length;
		  if (target.length - targetStart < end - start) {
		    end = target.length - targetStart + start;
		  }

		  var len = end - start;

		  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
		    // Use built-in when available, missing from IE11
		    this.copyWithin(targetStart, start, end);
		  } else if (this === target && start < targetStart && targetStart < end) {
		    // descending copy from end
		    for (var i = len - 1; i >= 0; --i) {
		      target[i + targetStart] = this[i + start];
		    }
		  } else {
		    Uint8Array.prototype.set.call(
		      target,
		      this.subarray(start, end),
		      targetStart
		    );
		  }

		  return len
		};

		// Usage:
		//    buffer.fill(number[, offset[, end]])
		//    buffer.fill(buffer[, offset[, end]])
		//    buffer.fill(string[, offset[, end]][, encoding])
		Buffer.prototype.fill = function fill (val, start, end, encoding) {
		  // Handle string cases:
		  if (typeof val === 'string') {
		    if (typeof start === 'string') {
		      encoding = start;
		      start = 0;
		      end = this.length;
		    } else if (typeof end === 'string') {
		      encoding = end;
		      end = this.length;
		    }
		    if (encoding !== undefined && typeof encoding !== 'string') {
		      throw new TypeError('encoding must be a string')
		    }
		    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
		      throw new TypeError('Unknown encoding: ' + encoding)
		    }
		    if (val.length === 1) {
		      var code = val.charCodeAt(0);
		      if ((encoding === 'utf8' && code < 128) ||
		          encoding === 'latin1') {
		        // Fast path: If `val` fits into a single byte, use that numeric value.
		        val = code;
		      }
		    }
		  } else if (typeof val === 'number') {
		    val = val & 255;
		  }

		  // Invalid ranges are not set to a default, so can range check early.
		  if (start < 0 || this.length < start || this.length < end) {
		    throw new RangeError('Out of range index')
		  }

		  if (end <= start) {
		    return this
		  }

		  start = start >>> 0;
		  end = end === undefined ? this.length : end >>> 0;

		  if (!val) val = 0;

		  var i;
		  if (typeof val === 'number') {
		    for (i = start; i < end; ++i) {
		      this[i] = val;
		    }
		  } else {
		    var bytes = Buffer.isBuffer(val)
		      ? val
		      : Buffer.from(val, encoding);
		    var len = bytes.length;
		    if (len === 0) {
		      throw new TypeError('The value "' + val +
		        '" is invalid for argument "value"')
		    }
		    for (i = 0; i < end - start; ++i) {
		      this[i + start] = bytes[i % len];
		    }
		  }

		  return this
		};

		// HELPER FUNCTIONS
		// ================

		var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

		function base64clean (str) {
		  // Node takes equal signs as end of the Base64 encoding
		  str = str.split('=')[0];
		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
		  str = str.trim().replace(INVALID_BASE64_RE, '');
		  // Node converts strings with length < 2 to ''
		  if (str.length < 2) return ''
		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		  while (str.length % 4 !== 0) {
		    str = str + '=';
		  }
		  return str
		}

		function toHex (n) {
		  if (n < 16) return '0' + n.toString(16)
		  return n.toString(16)
		}

		function utf8ToBytes (string, units) {
		  units = units || Infinity;
		  var codePoint;
		  var length = string.length;
		  var leadSurrogate = null;
		  var bytes = [];

		  for (var i = 0; i < length; ++i) {
		    codePoint = string.charCodeAt(i);

		    // is surrogate component
		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
		      // last char was a lead
		      if (!leadSurrogate) {
		        // no lead yet
		        if (codePoint > 0xDBFF) {
		          // unexpected trail
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        } else if (i + 1 === length) {
		          // unpaired lead
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        }

		        // valid lead
		        leadSurrogate = codePoint;

		        continue
		      }

		      // 2 leads in a row
		      if (codePoint < 0xDC00) {
		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		        leadSurrogate = codePoint;
		        continue
		      }

		      // valid surrogate pair
		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
		    } else if (leadSurrogate) {
		      // valid bmp char, but last char was a lead
		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		    }

		    leadSurrogate = null;

		    // encode utf8
		    if (codePoint < 0x80) {
		      if ((units -= 1) < 0) break
		      bytes.push(codePoint);
		    } else if (codePoint < 0x800) {
		      if ((units -= 2) < 0) break
		      bytes.push(
		        codePoint >> 0x6 | 0xC0,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x10000) {
		      if ((units -= 3) < 0) break
		      bytes.push(
		        codePoint >> 0xC | 0xE0,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x110000) {
		      if ((units -= 4) < 0) break
		      bytes.push(
		        codePoint >> 0x12 | 0xF0,
		        codePoint >> 0xC & 0x3F | 0x80,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else {
		      throw new Error('Invalid code point')
		    }
		  }

		  return bytes
		}

		function asciiToBytes (str) {
		  var byteArray = [];
		  for (var i = 0; i < str.length; ++i) {
		    // Node's code seems to be doing this and not & 0x7F..
		    byteArray.push(str.charCodeAt(i) & 0xFF);
		  }
		  return byteArray
		}

		function utf16leToBytes (str, units) {
		  var c, hi, lo;
		  var byteArray = [];
		  for (var i = 0; i < str.length; ++i) {
		    if ((units -= 2) < 0) break

		    c = str.charCodeAt(i);
		    hi = c >> 8;
		    lo = c % 256;
		    byteArray.push(lo);
		    byteArray.push(hi);
		  }

		  return byteArray
		}

		function base64ToBytes (str) {
		  return base64.toByteArray(base64clean(str))
		}

		function blitBuffer (src, dst, offset, length) {
		  for (var i = 0; i < length; ++i) {
		    if ((i + offset >= dst.length) || (i >= src.length)) break
		    dst[i + offset] = src[i];
		  }
		  return i
		}

		// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
		// the `instanceof` check but they should be treated as of that type.
		// See: https://github.com/feross/buffer/issues/166
		function isInstance (obj, type) {
		  return obj instanceof type ||
		    (obj != null && obj.constructor != null && obj.constructor.name != null &&
		      obj.constructor.name === type.name)
		}
		function numberIsNaN (obj) {
		  // For IE11 support
		  return obj !== obj // eslint-disable-line no-self-compare
		}

		}).call(this);}).call(this,require("buffer").Buffer);
		},{"base64-js":100,"buffer":103,"ieee754":400}],104:[function(require,module,exports){
		module.exports = {
		  "100": "Continue",
		  "101": "Switching Protocols",
		  "102": "Processing",
		  "200": "OK",
		  "201": "Created",
		  "202": "Accepted",
		  "203": "Non-Authoritative Information",
		  "204": "No Content",
		  "205": "Reset Content",
		  "206": "Partial Content",
		  "207": "Multi-Status",
		  "208": "Already Reported",
		  "226": "IM Used",
		  "300": "Multiple Choices",
		  "301": "Moved Permanently",
		  "302": "Found",
		  "303": "See Other",
		  "304": "Not Modified",
		  "305": "Use Proxy",
		  "307": "Temporary Redirect",
		  "308": "Permanent Redirect",
		  "400": "Bad Request",
		  "401": "Unauthorized",
		  "402": "Payment Required",
		  "403": "Forbidden",
		  "404": "Not Found",
		  "405": "Method Not Allowed",
		  "406": "Not Acceptable",
		  "407": "Proxy Authentication Required",
		  "408": "Request Timeout",
		  "409": "Conflict",
		  "410": "Gone",
		  "411": "Length Required",
		  "412": "Precondition Failed",
		  "413": "Payload Too Large",
		  "414": "URI Too Long",
		  "415": "Unsupported Media Type",
		  "416": "Range Not Satisfiable",
		  "417": "Expectation Failed",
		  "418": "I'm a teapot",
		  "421": "Misdirected Request",
		  "422": "Unprocessable Entity",
		  "423": "Locked",
		  "424": "Failed Dependency",
		  "425": "Unordered Collection",
		  "426": "Upgrade Required",
		  "428": "Precondition Required",
		  "429": "Too Many Requests",
		  "431": "Request Header Fields Too Large",
		  "451": "Unavailable For Legal Reasons",
		  "500": "Internal Server Error",
		  "501": "Not Implemented",
		  "502": "Bad Gateway",
		  "503": "Service Unavailable",
		  "504": "Gateway Timeout",
		  "505": "HTTP Version Not Supported",
		  "506": "Variant Also Negotiates",
		  "507": "Insufficient Storage",
		  "508": "Loop Detected",
		  "509": "Bandwidth Limit Exceeded",
		  "510": "Not Extended",
		  "511": "Network Authentication Required"
		};

		},{}],105:[function(require,module,exports){

		var GetIntrinsic = require('get-intrinsic');

		var callBind = require('./');

		var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

		module.exports = function callBoundIntrinsic(name, allowMissing) {
			var intrinsic = GetIntrinsic(name, !!allowMissing);
			if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
				return callBind(intrinsic);
			}
			return intrinsic;
		};

		},{"./":106,"get-intrinsic":390}],106:[function(require,module,exports){

		var bind = require('function-bind');
		var GetIntrinsic = require('get-intrinsic');
		var setFunctionLength = require('set-function-length');

		var $TypeError = GetIntrinsic('%TypeError%');
		var $apply = GetIntrinsic('%Function.prototype.apply%');
		var $call = GetIntrinsic('%Function.prototype.call%');
		var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

		var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
		var $max = GetIntrinsic('%Math.max%');

		if ($defineProperty) {
			try {
				$defineProperty({}, 'a', { value: 1 });
			} catch (e) {
				// IE 8 has a broken defineProperty
				$defineProperty = null;
			}
		}

		module.exports = function callBind(originalFunction) {
			if (typeof originalFunction !== 'function') {
				throw new $TypeError('a function is required');
			}
			var func = $reflectApply(bind, $call, arguments);
			return setFunctionLength(
				func,
				1 + $max(0, originalFunction.length - (arguments.length - 1)),
				true
			);
		};

		var applyBind = function applyBind() {
			return $reflectApply(bind, $apply, arguments);
		};

		if ($defineProperty) {
			$defineProperty(module.exports, 'apply', { value: applyBind });
		} else {
			module.exports.apply = applyBind;
		}

		},{"function-bind":389,"get-intrinsic":390,"set-function-length":466}],107:[function(require,module,exports){

		/**
		 * slice() reference.
		 */

		var slice = Array.prototype.slice;

		/**
		 * Expose copy
		 *
		 * ```
		 * copy({foo: 'nar', hello: 'copy'}).to({hello: 'world'});
		 * copy({foo: 'nar', hello: 'copy'}).toCover({hello: 'world'});
		 * ```
		 *
		 * @param {Object} src
		 * @return {Copy}
		 */

		module.exports = Copy;


		/**
		 * Copy
		 * @param {Object} src
		 * @param {Boolean} withAccess
		 */

		function Copy(src, withAccess) {
		  if (!(this instanceof Copy)) return new Copy(src, withAccess);
		  this.src = src;
		  this._withAccess = withAccess;
		}

		/**
		 * copy properties include getter and setter
		 * @param {[type]} val [description]
		 * @return {[type]} [description]
		 */

		Copy.prototype.withAccess = function (w) {
		  this._withAccess = w !== false;
		  return this;
		};

		/**
		 * pick keys in src
		 *
		 * @api: public
		 */

		Copy.prototype.pick = function(keys) {
		  if (!Array.isArray(keys)) {
		    keys = slice.call(arguments);
		  }
		  if (keys.length) {
		    this.keys = keys;
		  }
		  return this;
		};

		/**
		 * copy src to target,
		 * do not cover any property target has
		 * @param {Object} to
		 *
		 * @api: public
		 */

		Copy.prototype.to = function(to) {
		  to = to || {};

		  if (!this.src) return to;
		  var keys = this.keys || Object.keys(this.src);

		  if (!this._withAccess) {
		    for (var i = 0; i < keys.length; i++) {
		      key = keys[i];
		      if (to[key] !== undefined) continue;
		      to[key] = this.src[key];
		    }
		    return to;
		  }

		  for (var i = 0; i < keys.length; i++) {
		    var key = keys[i];
		    if (!notDefined(to, key)) continue;
		    var getter = this.src.__lookupGetter__(key);
		    var setter = this.src.__lookupSetter__(key);
		    if (getter) to.__defineGetter__(key, getter);
		    if (setter) to.__defineSetter__(key, setter);

		    if (!getter && !setter) {
		      to[key] = this.src[key];
		    }
		  }
		  return to;
		};

		/**
		 * copy src to target,
		 * override any property target has
		 * @param {Object} to
		 *
		 * @api: public
		 */

		Copy.prototype.toCover = function(to) {
		  var keys = this.keys || Object.keys(this.src);

		  for (var i = 0; i < keys.length; i++) {
		    var key = keys[i];
		    delete to[key];
		    var getter = this.src.__lookupGetter__(key);
		    var setter = this.src.__lookupSetter__(key);
		    if (getter) to.__defineGetter__(key, getter);
		    if (setter) to.__defineSetter__(key, setter);

		    if (!getter && !setter) {
		      to[key] = this.src[key];
		    }
		  }
		};

		Copy.prototype.override = Copy.prototype.toCover;

		/**
		 * append another object to src
		 * @param {Obj} obj
		 * @return {Copy}
		 */

		Copy.prototype.and = function (obj) {
		  var src = {};
		  this.to(src);
		  this.src = obj;
		  this.to(src);
		  this.src = src;

		  return this;
		};

		/**
		 * check obj[key] if not defiend
		 * @param {Object} obj
		 * @param {String} key
		 * @return {Boolean}
		 */

		function notDefined(obj, key) {
		  return obj[key] === undefined
		    && obj.__lookupGetter__(key) === undefined
		    && obj.__lookupSetter__(key) === undefined;
		}

		},{}],108:[function(require,module,exports){
		var isCallable = require('../internals/is-callable');
		var tryToString = require('../internals/try-to-string');

		var $TypeError = TypeError;

		// `Assert: IsCallable(argument) is true`
		module.exports = function (argument) {
		  if (isCallable(argument)) return argument;
		  throw new $TypeError(tryToString(argument) + ' is not a function');
		};

		},{"../internals/is-callable":203,"../internals/try-to-string":293}],109:[function(require,module,exports){
		var isConstructor = require('../internals/is-constructor');
		var tryToString = require('../internals/try-to-string');

		var $TypeError = TypeError;

		// `Assert: IsConstructor(argument) is true`
		module.exports = function (argument) {
		  if (isConstructor(argument)) return argument;
		  throw new $TypeError(tryToString(argument) + ' is not a constructor');
		};

		},{"../internals/is-constructor":204,"../internals/try-to-string":293}],110:[function(require,module,exports){
		var isPossiblePrototype = require('../internals/is-possible-prototype');

		var $String = String;
		var $TypeError = TypeError;

		module.exports = function (argument) {
		  if (isPossiblePrototype(argument)) return argument;
		  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
		};

		},{"../internals/is-possible-prototype":209}],111:[function(require,module,exports){
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var create = require('../internals/object-create');
		var defineProperty = require('../internals/object-define-property').f;

		var UNSCOPABLES = wellKnownSymbol('unscopables');
		var ArrayPrototype = Array.prototype;

		// Array.prototype[@@unscopables]
		// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
		if (ArrayPrototype[UNSCOPABLES] === undefined) {
		  defineProperty(ArrayPrototype, UNSCOPABLES, {
		    configurable: true,
		    value: create(null)
		  });
		}

		// add a key to Array.prototype[@@unscopables]
		module.exports = function (key) {
		  ArrayPrototype[UNSCOPABLES][key] = true;
		};

		},{"../internals/object-create":229,"../internals/object-define-property":231,"../internals/well-known-symbol":306}],112:[function(require,module,exports){
		var charAt = require('../internals/string-multibyte').charAt;

		// `AdvanceStringIndex` abstract operation
		// https://tc39.es/ecma262/#sec-advancestringindex
		module.exports = function (S, index, unicode) {
		  return index + (unicode ? charAt(S, index).length : 1);
		};

		},{"../internals/string-multibyte":271}],113:[function(require,module,exports){
		var isPrototypeOf = require('../internals/object-is-prototype-of');

		var $TypeError = TypeError;

		module.exports = function (it, Prototype) {
		  if (isPrototypeOf(Prototype, it)) return it;
		  throw new $TypeError('Incorrect invocation');
		};

		},{"../internals/object-is-prototype-of":238}],114:[function(require,module,exports){
		var isObject = require('../internals/is-object');

		var $String = String;
		var $TypeError = TypeError;

		// `Assert: Type(argument) is Object`
		module.exports = function (argument) {
		  if (isObject(argument)) return argument;
		  throw new $TypeError($String(argument) + ' is not an object');
		};

		},{"../internals/is-object":208}],115:[function(require,module,exports){
		// eslint-disable-next-line es/no-typed-arrays -- safe
		module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

		},{}],116:[function(require,module,exports){
		// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
		var fails = require('../internals/fails');

		module.exports = fails(function () {
		  if (typeof ArrayBuffer == 'function') {
		    var buffer = new ArrayBuffer(8);
		    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
		    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
		  }
		});

		},{"../internals/fails":171}],117:[function(require,module,exports){
		var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-basic-detection');
		var DESCRIPTORS = require('../internals/descriptors');
		var global = require('../internals/global');
		var isCallable = require('../internals/is-callable');
		var isObject = require('../internals/is-object');
		var hasOwn = require('../internals/has-own-property');
		var classof = require('../internals/classof');
		var tryToString = require('../internals/try-to-string');
		var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
		var defineBuiltIn = require('../internals/define-built-in');
		var defineBuiltInAccessor = require('../internals/define-built-in-accessor');
		var isPrototypeOf = require('../internals/object-is-prototype-of');
		var getPrototypeOf = require('../internals/object-get-prototype-of');
		var setPrototypeOf = require('../internals/object-set-prototype-of');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var uid = require('../internals/uid');
		var InternalStateModule = require('../internals/internal-state');

		var enforceInternalState = InternalStateModule.enforce;
		var getInternalState = InternalStateModule.get;
		var Int8Array = global.Int8Array;
		var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
		var Uint8ClampedArray = global.Uint8ClampedArray;
		var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
		var TypedArray = Int8Array && getPrototypeOf(Int8Array);
		var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
		var ObjectPrototype = Object.prototype;
		var TypeError = global.TypeError;

		var TO_STRING_TAG = wellKnownSymbol('toStringTag');
		var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
		var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
		// Fixing native typed arrays in Opera Presto crashes the browser, see #595
		var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
		var TYPED_ARRAY_TAG_REQUIRED = false;
		var NAME, Constructor, Prototype;

		var TypedArrayConstructorsList = {
		  Int8Array: 1,
		  Uint8Array: 1,
		  Uint8ClampedArray: 1,
		  Int16Array: 2,
		  Uint16Array: 2,
		  Int32Array: 4,
		  Uint32Array: 4,
		  Float32Array: 4,
		  Float64Array: 8
		};

		var BigIntArrayConstructorsList = {
		  BigInt64Array: 8,
		  BigUint64Array: 8
		};

		var isView = function isView(it) {
		  if (!isObject(it)) return false;
		  var klass = classof(it);
		  return klass === 'DataView'
		    || hasOwn(TypedArrayConstructorsList, klass)
		    || hasOwn(BigIntArrayConstructorsList, klass);
		};

		var getTypedArrayConstructor = function (it) {
		  var proto = getPrototypeOf(it);
		  if (!isObject(proto)) return;
		  var state = getInternalState(proto);
		  return (state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
		};

		var isTypedArray = function (it) {
		  if (!isObject(it)) return false;
		  var klass = classof(it);
		  return hasOwn(TypedArrayConstructorsList, klass)
		    || hasOwn(BigIntArrayConstructorsList, klass);
		};

		var aTypedArray = function (it) {
		  if (isTypedArray(it)) return it;
		  throw new TypeError('Target is not a typed array');
		};

		var aTypedArrayConstructor = function (C) {
		  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
		  throw new TypeError(tryToString(C) + ' is not a typed array constructor');
		};

		var exportTypedArrayMethod = function (KEY, property, forced, options) {
		  if (!DESCRIPTORS) return;
		  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
		    var TypedArrayConstructor = global[ARRAY];
		    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
		      delete TypedArrayConstructor.prototype[KEY];
		    } catch (error) {
		      // old WebKit bug - some methods are non-configurable
		      try {
		        TypedArrayConstructor.prototype[KEY] = property;
		      } catch (error2) { /* empty */ }
		    }
		  }
		  if (!TypedArrayPrototype[KEY] || forced) {
		    defineBuiltIn(TypedArrayPrototype, KEY, forced ? property
		      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
		  }
		};

		var exportTypedArrayStaticMethod = function (KEY, property, forced) {
		  var ARRAY, TypedArrayConstructor;
		  if (!DESCRIPTORS) return;
		  if (setPrototypeOf) {
		    if (forced) for (ARRAY in TypedArrayConstructorsList) {
		      TypedArrayConstructor = global[ARRAY];
		      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
		        delete TypedArrayConstructor[KEY];
		      } catch (error) { /* empty */ }
		    }
		    if (!TypedArray[KEY] || forced) {
		      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
		      try {
		        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
		      } catch (error) { /* empty */ }
		    } else return;
		  }
		  for (ARRAY in TypedArrayConstructorsList) {
		    TypedArrayConstructor = global[ARRAY];
		    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
		      defineBuiltIn(TypedArrayConstructor, KEY, property);
		    }
		  }
		};

		for (NAME in TypedArrayConstructorsList) {
		  Constructor = global[NAME];
		  Prototype = Constructor && Constructor.prototype;
		  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
		  else NATIVE_ARRAY_BUFFER_VIEWS = false;
		}

		for (NAME in BigIntArrayConstructorsList) {
		  Constructor = global[NAME];
		  Prototype = Constructor && Constructor.prototype;
		  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
		}

		// WebKit bug - typed arrays constructors prototype is Object.prototype
		if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
		  // eslint-disable-next-line no-shadow -- safe
		  TypedArray = function TypedArray() {
		    throw new TypeError('Incorrect invocation');
		  };
		  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
		    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
		  }
		}

		if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
		  TypedArrayPrototype = TypedArray.prototype;
		  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
		    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
		  }
		}

		// WebKit bug - one more object in Uint8ClampedArray prototype chain
		if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
		  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
		}

		if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
		  TYPED_ARRAY_TAG_REQUIRED = true;
		  defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
		    configurable: true,
		    get: function () {
		      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
		    }
		  });
		  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
		    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
		  }
		}

		module.exports = {
		  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
		  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
		  aTypedArray: aTypedArray,
		  aTypedArrayConstructor: aTypedArrayConstructor,
		  exportTypedArrayMethod: exportTypedArrayMethod,
		  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
		  getTypedArrayConstructor: getTypedArrayConstructor,
		  isView: isView,
		  isTypedArray: isTypedArray,
		  TypedArray: TypedArray,
		  TypedArrayPrototype: TypedArrayPrototype
		};

		},{"../internals/array-buffer-basic-detection":115,"../internals/classof":138,"../internals/create-non-enumerable-property":145,"../internals/define-built-in":149,"../internals/define-built-in-accessor":148,"../internals/descriptors":153,"../internals/global":188,"../internals/has-own-property":189,"../internals/internal-state":199,"../internals/is-callable":203,"../internals/is-object":208,"../internals/object-get-prototype-of":236,"../internals/object-is-prototype-of":238,"../internals/object-set-prototype-of":242,"../internals/try-to-string":293,"../internals/uid":299,"../internals/well-known-symbol":306}],118:[function(require,module,exports){
		var global = require('../internals/global');
		var uncurryThis = require('../internals/function-uncurry-this');
		var DESCRIPTORS = require('../internals/descriptors');
		var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-basic-detection');
		var FunctionName = require('../internals/function-name');
		var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
		var defineBuiltInAccessor = require('../internals/define-built-in-accessor');
		var defineBuiltIns = require('../internals/define-built-ins');
		var fails = require('../internals/fails');
		var anInstance = require('../internals/an-instance');
		var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
		var toLength = require('../internals/to-length');
		var toIndex = require('../internals/to-index');
		var fround = require('../internals/math-fround');
		var IEEE754 = require('../internals/ieee754');
		var getPrototypeOf = require('../internals/object-get-prototype-of');
		var setPrototypeOf = require('../internals/object-set-prototype-of');
		var arrayFill = require('../internals/array-fill');
		var arraySlice = require('../internals/array-slice');
		var inheritIfRequired = require('../internals/inherit-if-required');
		var copyConstructorProperties = require('../internals/copy-constructor-properties');
		var setToStringTag = require('../internals/set-to-string-tag');
		var InternalStateModule = require('../internals/internal-state');

		var PROPER_FUNCTION_NAME = FunctionName.PROPER;
		var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
		var ARRAY_BUFFER = 'ArrayBuffer';
		var DATA_VIEW = 'DataView';
		var PROTOTYPE = 'prototype';
		var WRONG_LENGTH = 'Wrong length';
		var WRONG_INDEX = 'Wrong index';
		var getInternalArrayBufferState = InternalStateModule.getterFor(ARRAY_BUFFER);
		var getInternalDataViewState = InternalStateModule.getterFor(DATA_VIEW);
		var setInternalState = InternalStateModule.set;
		var NativeArrayBuffer = global[ARRAY_BUFFER];
		var $ArrayBuffer = NativeArrayBuffer;
		var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
		var $DataView = global[DATA_VIEW];
		var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
		var ObjectPrototype = Object.prototype;
		var Array = global.Array;
		var RangeError = global.RangeError;
		var fill = uncurryThis(arrayFill);
		var reverse = uncurryThis([].reverse);

		var packIEEE754 = IEEE754.pack;
		var unpackIEEE754 = IEEE754.unpack;

		var packInt8 = function (number) {
		  return [number & 0xFF];
		};

		var packInt16 = function (number) {
		  return [number & 0xFF, number >> 8 & 0xFF];
		};

		var packInt32 = function (number) {
		  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
		};

		var unpackInt32 = function (buffer) {
		  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
		};

		var packFloat32 = function (number) {
		  return packIEEE754(fround(number), 23, 4);
		};

		var packFloat64 = function (number) {
		  return packIEEE754(number, 52, 8);
		};

		var addGetter = function (Constructor, key, getInternalState) {
		  defineBuiltInAccessor(Constructor[PROTOTYPE], key, {
		    configurable: true,
		    get: function () {
		      return getInternalState(this)[key];
		    }
		  });
		};

		var get = function (view, count, index, isLittleEndian) {
		  var store = getInternalDataViewState(view);
		  var intIndex = toIndex(index);
		  var boolIsLittleEndian = !!isLittleEndian;
		  if (intIndex + count > store.byteLength) throw new RangeError(WRONG_INDEX);
		  var bytes = store.bytes;
		  var start = intIndex + store.byteOffset;
		  var pack = arraySlice(bytes, start, start + count);
		  return boolIsLittleEndian ? pack : reverse(pack);
		};

		var set = function (view, count, index, conversion, value, isLittleEndian) {
		  var store = getInternalDataViewState(view);
		  var intIndex = toIndex(index);
		  var pack = conversion(+value);
		  var boolIsLittleEndian = !!isLittleEndian;
		  if (intIndex + count > store.byteLength) throw new RangeError(WRONG_INDEX);
		  var bytes = store.bytes;
		  var start = intIndex + store.byteOffset;
		  for (var i = 0; i < count; i++) bytes[start + i] = pack[boolIsLittleEndian ? i : count - i - 1];
		};

		if (!NATIVE_ARRAY_BUFFER) {
		  $ArrayBuffer = function ArrayBuffer(length) {
		    anInstance(this, ArrayBufferPrototype);
		    var byteLength = toIndex(length);
		    setInternalState(this, {
		      type: ARRAY_BUFFER,
		      bytes: fill(Array(byteLength), 0),
		      byteLength: byteLength
		    });
		    if (!DESCRIPTORS) {
		      this.byteLength = byteLength;
		      this.detached = false;
		    }
		  };

		  ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];

		  $DataView = function DataView(buffer, byteOffset, byteLength) {
		    anInstance(this, DataViewPrototype);
		    anInstance(buffer, ArrayBufferPrototype);
		    var bufferState = getInternalArrayBufferState(buffer);
		    var bufferLength = bufferState.byteLength;
		    var offset = toIntegerOrInfinity(byteOffset);
		    if (offset < 0 || offset > bufferLength) throw new RangeError('Wrong offset');
		    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
		    if (offset + byteLength > bufferLength) throw new RangeError(WRONG_LENGTH);
		    setInternalState(this, {
		      type: DATA_VIEW,
		      buffer: buffer,
		      byteLength: byteLength,
		      byteOffset: offset,
		      bytes: bufferState.bytes
		    });
		    if (!DESCRIPTORS) {
		      this.buffer = buffer;
		      this.byteLength = byteLength;
		      this.byteOffset = offset;
		    }
		  };

		  DataViewPrototype = $DataView[PROTOTYPE];

		  if (DESCRIPTORS) {
		    addGetter($ArrayBuffer, 'byteLength', getInternalArrayBufferState);
		    addGetter($DataView, 'buffer', getInternalDataViewState);
		    addGetter($DataView, 'byteLength', getInternalDataViewState);
		    addGetter($DataView, 'byteOffset', getInternalDataViewState);
		  }

		  defineBuiltIns(DataViewPrototype, {
		    getInt8: function getInt8(byteOffset) {
		      return get(this, 1, byteOffset)[0] << 24 >> 24;
		    },
		    getUint8: function getUint8(byteOffset) {
		      return get(this, 1, byteOffset)[0];
		    },
		    getInt16: function getInt16(byteOffset /* , littleEndian */) {
		      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
		      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
		    },
		    getUint16: function getUint16(byteOffset /* , littleEndian */) {
		      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
		      return bytes[1] << 8 | bytes[0];
		    },
		    getInt32: function getInt32(byteOffset /* , littleEndian */) {
		      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
		    },
		    getUint32: function getUint32(byteOffset /* , littleEndian */) {
		      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
		    },
		    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
		      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
		    },
		    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
		      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
		    },
		    setInt8: function setInt8(byteOffset, value) {
		      set(this, 1, byteOffset, packInt8, value);
		    },
		    setUint8: function setUint8(byteOffset, value) {
		      set(this, 1, byteOffset, packInt8, value);
		    },
		    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
		      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
		    },
		    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
		      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
		    },
		    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
		      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
		    },
		    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
		      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
		    },
		    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
		      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
		    },
		    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
		      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
		    }
		  });
		} else {
		  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
		  /* eslint-disable no-new -- required for testing */
		  if (!fails(function () {
		    NativeArrayBuffer(1);
		  }) || !fails(function () {
		    new NativeArrayBuffer(-1);
		  }) || fails(function () {
		    new NativeArrayBuffer();
		    new NativeArrayBuffer(1.5);
		    new NativeArrayBuffer(NaN);
		    return NativeArrayBuffer.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
		  })) {
		    /* eslint-enable no-new -- required for testing */
		    $ArrayBuffer = function ArrayBuffer(length) {
		      anInstance(this, ArrayBufferPrototype);
		      return inheritIfRequired(new NativeArrayBuffer(toIndex(length)), this, $ArrayBuffer);
		    };

		    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;

		    ArrayBufferPrototype.constructor = $ArrayBuffer;

		    copyConstructorProperties($ArrayBuffer, NativeArrayBuffer);
		  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
		    createNonEnumerableProperty(NativeArrayBuffer, 'name', ARRAY_BUFFER);
		  }

		  // WebKit bug - the same parent prototype for typed arrays and data view
		  if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
		    setPrototypeOf(DataViewPrototype, ObjectPrototype);
		  }

		  // iOS Safari 7.x bug
		  var testView = new $DataView(new $ArrayBuffer(2));
		  var $setInt8 = uncurryThis(DataViewPrototype.setInt8);
		  testView.setInt8(0, 2147483648);
		  testView.setInt8(1, 2147483649);
		  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
		    setInt8: function setInt8(byteOffset, value) {
		      $setInt8(this, byteOffset, value << 24 >> 24);
		    },
		    setUint8: function setUint8(byteOffset, value) {
		      $setInt8(this, byteOffset, value << 24 >> 24);
		    }
		  }, { unsafe: true });
		}

		setToStringTag($ArrayBuffer, ARRAY_BUFFER);
		setToStringTag($DataView, DATA_VIEW);

		module.exports = {
		  ArrayBuffer: $ArrayBuffer,
		  DataView: $DataView
		};

		},{"../internals/an-instance":113,"../internals/array-buffer-basic-detection":115,"../internals/array-fill":120,"../internals/array-slice":131,"../internals/copy-constructor-properties":141,"../internals/create-non-enumerable-property":145,"../internals/define-built-in-accessor":148,"../internals/define-built-ins":150,"../internals/descriptors":153,"../internals/fails":171,"../internals/function-name":178,"../internals/function-uncurry-this":181,"../internals/global":188,"../internals/ieee754":194,"../internals/inherit-if-required":196,"../internals/internal-state":199,"../internals/math-fround":222,"../internals/object-get-prototype-of":236,"../internals/object-set-prototype-of":242,"../internals/set-to-string-tag":266,"../internals/to-index":281,"../internals/to-integer-or-infinity":283,"../internals/to-length":284}],119:[function(require,module,exports){
		var toObject = require('../internals/to-object');
		var toAbsoluteIndex = require('../internals/to-absolute-index');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var deletePropertyOrThrow = require('../internals/delete-property-or-throw');

		var min = Math.min;

		// `Array.prototype.copyWithin` method implementation
		// https://tc39.es/ecma262/#sec-array.prototype.copywithin
		// eslint-disable-next-line es/no-array-prototype-copywithin -- safe
		module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
		  var O = toObject(this);
		  var len = lengthOfArrayLike(O);
		  var to = toAbsoluteIndex(target, len);
		  var from = toAbsoluteIndex(start, len);
		  var end = arguments.length > 2 ? arguments[2] : undefined;
		  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
		  var inc = 1;
		  if (from < to && to < from + count) {
		    inc = -1;
		    from += count - 1;
		    to += count - 1;
		  }
		  while (count-- > 0) {
		    if (from in O) O[to] = O[from];
		    else deletePropertyOrThrow(O, to);
		    to += inc;
		    from += inc;
		  } return O;
		};

		},{"../internals/delete-property-or-throw":152,"../internals/length-of-array-like":219,"../internals/to-absolute-index":279,"../internals/to-object":285}],120:[function(require,module,exports){
		var toObject = require('../internals/to-object');
		var toAbsoluteIndex = require('../internals/to-absolute-index');
		var lengthOfArrayLike = require('../internals/length-of-array-like');

		// `Array.prototype.fill` method implementation
		// https://tc39.es/ecma262/#sec-array.prototype.fill
		module.exports = function fill(value /* , start = 0, end = @length */) {
		  var O = toObject(this);
		  var length = lengthOfArrayLike(O);
		  var argumentsLength = arguments.length;
		  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
		  var end = argumentsLength > 2 ? arguments[2] : undefined;
		  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
		  while (endPos > index) O[index++] = value;
		  return O;
		};

		},{"../internals/length-of-array-like":219,"../internals/to-absolute-index":279,"../internals/to-object":285}],121:[function(require,module,exports){
		var $forEach = require('../internals/array-iteration').forEach;
		var arrayMethodIsStrict = require('../internals/array-method-is-strict');

		var STRICT_METHOD = arrayMethodIsStrict('forEach');

		// `Array.prototype.forEach` method implementation
		// https://tc39.es/ecma262/#sec-array.prototype.foreach
		module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
		  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		// eslint-disable-next-line es/no-array-prototype-foreach -- safe
		} : [].forEach;

		},{"../internals/array-iteration":125,"../internals/array-method-is-strict":128}],122:[function(require,module,exports){
		var lengthOfArrayLike = require('../internals/length-of-array-like');

		module.exports = function (Constructor, list, $length) {
		  var index = 0;
		  var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
		  var result = new Constructor(length);
		  while (length > index) result[index] = list[index++];
		  return result;
		};

		},{"../internals/length-of-array-like":219}],123:[function(require,module,exports){
		var bind = require('../internals/function-bind-context');
		var call = require('../internals/function-call');
		var toObject = require('../internals/to-object');
		var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');
		var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
		var isConstructor = require('../internals/is-constructor');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var createProperty = require('../internals/create-property');
		var getIterator = require('../internals/get-iterator');
		var getIteratorMethod = require('../internals/get-iterator-method');

		var $Array = Array;

		// `Array.from` method implementation
		// https://tc39.es/ecma262/#sec-array.from
		module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
		  var O = toObject(arrayLike);
		  var IS_CONSTRUCTOR = isConstructor(this);
		  var argumentsLength = arguments.length;
		  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
		  var mapping = mapfn !== undefined;
		  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
		  var iteratorMethod = getIteratorMethod(O);
		  var index = 0;
		  var length, result, step, iterator, next, value;
		  // if the target is not iterable or it's an array with the default iterator - use a simple case
		  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
		    iterator = getIterator(O, iteratorMethod);
		    next = iterator.next;
		    result = IS_CONSTRUCTOR ? new this() : [];
		    for (;!(step = call(next, iterator)).done; index++) {
		      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
		      createProperty(result, index, value);
		    }
		  } else {
		    length = lengthOfArrayLike(O);
		    result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
		    for (;length > index; index++) {
		      value = mapping ? mapfn(O[index], index) : O[index];
		      createProperty(result, index, value);
		    }
		  }
		  result.length = index;
		  return result;
		};

		},{"../internals/call-with-safe-iteration-closing":135,"../internals/create-property":147,"../internals/function-bind-context":175,"../internals/function-call":177,"../internals/get-iterator":184,"../internals/get-iterator-method":183,"../internals/is-array-iterator-method":200,"../internals/is-constructor":204,"../internals/length-of-array-like":219,"../internals/to-object":285}],124:[function(require,module,exports){
		var toIndexedObject = require('../internals/to-indexed-object');
		var toAbsoluteIndex = require('../internals/to-absolute-index');
		var lengthOfArrayLike = require('../internals/length-of-array-like');

		// `Array.prototype.{ indexOf, includes }` methods implementation
		var createMethod = function (IS_INCLUDES) {
		  return function ($this, el, fromIndex) {
		    var O = toIndexedObject($this);
		    var length = lengthOfArrayLike(O);
		    var index = toAbsoluteIndex(fromIndex, length);
		    var value;
		    // Array#includes uses SameValueZero equality algorithm
		    // eslint-disable-next-line no-self-compare -- NaN check
		    if (IS_INCLUDES && el !== el) while (length > index) {
		      value = O[index++];
		      // eslint-disable-next-line no-self-compare -- NaN check
		      if (value !== value) return true;
		    // Array#indexOf ignores holes, Array#includes - not
		    } else for (;length > index; index++) {
		      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
		    } return !IS_INCLUDES && -1;
		  };
		};

		module.exports = {
		  // `Array.prototype.includes` method
		  // https://tc39.es/ecma262/#sec-array.prototype.includes
		  includes: createMethod(true),
		  // `Array.prototype.indexOf` method
		  // https://tc39.es/ecma262/#sec-array.prototype.indexof
		  indexOf: createMethod(false)
		};

		},{"../internals/length-of-array-like":219,"../internals/to-absolute-index":279,"../internals/to-indexed-object":282}],125:[function(require,module,exports){
		var bind = require('../internals/function-bind-context');
		var uncurryThis = require('../internals/function-uncurry-this');
		var IndexedObject = require('../internals/indexed-object');
		var toObject = require('../internals/to-object');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var arraySpeciesCreate = require('../internals/array-species-create');

		var push = uncurryThis([].push);

		// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
		var createMethod = function (TYPE) {
		  var IS_MAP = TYPE === 1;
		  var IS_FILTER = TYPE === 2;
		  var IS_SOME = TYPE === 3;
		  var IS_EVERY = TYPE === 4;
		  var IS_FIND_INDEX = TYPE === 6;
		  var IS_FILTER_REJECT = TYPE === 7;
		  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
		  return function ($this, callbackfn, that, specificCreate) {
		    var O = toObject($this);
		    var self = IndexedObject(O);
		    var length = lengthOfArrayLike(self);
		    var boundFunction = bind(callbackfn, that);
		    var index = 0;
		    var create = specificCreate || arraySpeciesCreate;
		    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
		    var value, result;
		    for (;length > index; index++) if (NO_HOLES || index in self) {
		      value = self[index];
		      result = boundFunction(value, index, O);
		      if (TYPE) {
		        if (IS_MAP) target[index] = result; // map
		        else if (result) switch (TYPE) {
		          case 3: return true;              // some
		          case 5: return value;             // find
		          case 6: return index;             // findIndex
		          case 2: push(target, value);      // filter
		        } else switch (TYPE) {
		          case 4: return false;             // every
		          case 7: push(target, value);      // filterReject
		        }
		      }
		    }
		    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
		  };
		};

		module.exports = {
		  // `Array.prototype.forEach` method
		  // https://tc39.es/ecma262/#sec-array.prototype.foreach
		  forEach: createMethod(0),
		  // `Array.prototype.map` method
		  // https://tc39.es/ecma262/#sec-array.prototype.map
		  map: createMethod(1),
		  // `Array.prototype.filter` method
		  // https://tc39.es/ecma262/#sec-array.prototype.filter
		  filter: createMethod(2),
		  // `Array.prototype.some` method
		  // https://tc39.es/ecma262/#sec-array.prototype.some
		  some: createMethod(3),
		  // `Array.prototype.every` method
		  // https://tc39.es/ecma262/#sec-array.prototype.every
		  every: createMethod(4),
		  // `Array.prototype.find` method
		  // https://tc39.es/ecma262/#sec-array.prototype.find
		  find: createMethod(5),
		  // `Array.prototype.findIndex` method
		  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
		  findIndex: createMethod(6),
		  // `Array.prototype.filterReject` method
		  // https://github.com/tc39/proposal-array-filtering
		  filterReject: createMethod(7)
		};

		},{"../internals/array-species-create":134,"../internals/function-bind-context":175,"../internals/function-uncurry-this":181,"../internals/indexed-object":195,"../internals/length-of-array-like":219,"../internals/to-object":285}],126:[function(require,module,exports){
		/* eslint-disable es/no-array-prototype-lastindexof -- safe */
		var apply = require('../internals/function-apply');
		var toIndexedObject = require('../internals/to-indexed-object');
		var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var arrayMethodIsStrict = require('../internals/array-method-is-strict');

		var min = Math.min;
		var $lastIndexOf = [].lastIndexOf;
		var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
		var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
		var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;

		// `Array.prototype.lastIndexOf` method implementation
		// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
		module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
		  // convert -0 to +0
		  if (NEGATIVE_ZERO) return apply($lastIndexOf, this, arguments) || 0;
		  var O = toIndexedObject(this);
		  var length = lengthOfArrayLike(O);
		  var index = length - 1;
		  if (arguments.length > 1) index = min(index, toIntegerOrInfinity(arguments[1]));
		  if (index < 0) index = length + index;
		  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
		  return -1;
		} : $lastIndexOf;

		},{"../internals/array-method-is-strict":128,"../internals/function-apply":174,"../internals/length-of-array-like":219,"../internals/to-indexed-object":282,"../internals/to-integer-or-infinity":283}],127:[function(require,module,exports){
		var fails = require('../internals/fails');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var V8_VERSION = require('../internals/engine-v8-version');

		var SPECIES = wellKnownSymbol('species');

		module.exports = function (METHOD_NAME) {
		  // We can't use this feature detection in V8 since it causes
		  // deoptimization and serious performance degradation
		  // https://github.com/zloirock/core-js/issues/677
		  return V8_VERSION >= 51 || !fails(function () {
		    var array = [];
		    var constructor = array.constructor = {};
		    constructor[SPECIES] = function () {
		      return { foo: 1 };
		    };
		    return array[METHOD_NAME](Boolean).foo !== 1;
		  });
		};

		},{"../internals/engine-v8-version":167,"../internals/fails":171,"../internals/well-known-symbol":306}],128:[function(require,module,exports){
		var fails = require('../internals/fails');

		module.exports = function (METHOD_NAME, argument) {
		  var method = [][METHOD_NAME];
		  return !!method && fails(function () {
		    // eslint-disable-next-line no-useless-call -- required for testing
		    method.call(null, argument || function () { return 1; }, 1);
		  });
		};

		},{"../internals/fails":171}],129:[function(require,module,exports){
		var aCallable = require('../internals/a-callable');
		var toObject = require('../internals/to-object');
		var IndexedObject = require('../internals/indexed-object');
		var lengthOfArrayLike = require('../internals/length-of-array-like');

		var $TypeError = TypeError;

		// `Array.prototype.{ reduce, reduceRight }` methods implementation
		var createMethod = function (IS_RIGHT) {
		  return function (that, callbackfn, argumentsLength, memo) {
		    var O = toObject(that);
		    var self = IndexedObject(O);
		    var length = lengthOfArrayLike(O);
		    aCallable(callbackfn);
		    var index = IS_RIGHT ? length - 1 : 0;
		    var i = IS_RIGHT ? -1 : 1;
		    if (argumentsLength < 2) while (true) {
		      if (index in self) {
		        memo = self[index];
		        index += i;
		        break;
		      }
		      index += i;
		      if (IS_RIGHT ? index < 0 : length <= index) {
		        throw new $TypeError('Reduce of empty array with no initial value');
		      }
		    }
		    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
		      memo = callbackfn(memo, self[index], index, O);
		    }
		    return memo;
		  };
		};

		module.exports = {
		  // `Array.prototype.reduce` method
		  // https://tc39.es/ecma262/#sec-array.prototype.reduce
		  left: createMethod(false),
		  // `Array.prototype.reduceRight` method
		  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
		  right: createMethod(true)
		};

		},{"../internals/a-callable":108,"../internals/indexed-object":195,"../internals/length-of-array-like":219,"../internals/to-object":285}],130:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var isArray = require('../internals/is-array');

		var $TypeError = TypeError;
		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

		// Safari < 13 does not throw an error in this case
		var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
		  // makes no sense without proper strict mode support
		  if (this !== undefined) return true;
		  try {
		    // eslint-disable-next-line es/no-object-defineproperty -- safe
		    Object.defineProperty([], 'length', { writable: false }).length = 1;
		  } catch (error) {
		    return error instanceof TypeError;
		  }
		}();

		module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
		  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
		    throw new $TypeError('Cannot set read only .length');
		  } return O.length = length;
		} : function (O, length) {
		  return O.length = length;
		};

		},{"../internals/descriptors":153,"../internals/is-array":201}],131:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');

		module.exports = uncurryThis([].slice);

		},{"../internals/function-uncurry-this":181}],132:[function(require,module,exports){
		var arraySlice = require('../internals/array-slice');

		var floor = Math.floor;

		var sort = function (array, comparefn) {
		  var length = array.length;

		  if (length < 8) {
		    // insertion sort
		    var i = 1;
		    var element, j;

		    while (i < length) {
		      j = i;
		      element = array[i];
		      while (j && comparefn(array[j - 1], element) > 0) {
		        array[j] = array[--j];
		      }
		      if (j !== i++) array[j] = element;
		    }
		  } else {
		    // merge sort
		    var middle = floor(length / 2);
		    var left = sort(arraySlice(array, 0, middle), comparefn);
		    var right = sort(arraySlice(array, middle), comparefn);
		    var llength = left.length;
		    var rlength = right.length;
		    var lindex = 0;
		    var rindex = 0;

		    while (lindex < llength || rindex < rlength) {
		      array[lindex + rindex] = (lindex < llength && rindex < rlength)
		        ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
		        : lindex < llength ? left[lindex++] : right[rindex++];
		    }
		  }

		  return array;
		};

		module.exports = sort;

		},{"../internals/array-slice":131}],133:[function(require,module,exports){
		var isArray = require('../internals/is-array');
		var isConstructor = require('../internals/is-constructor');
		var isObject = require('../internals/is-object');
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var SPECIES = wellKnownSymbol('species');
		var $Array = Array;

		// a part of `ArraySpeciesCreate` abstract operation
		// https://tc39.es/ecma262/#sec-arrayspeciescreate
		module.exports = function (originalArray) {
		  var C;
		  if (isArray(originalArray)) {
		    C = originalArray.constructor;
		    // cross-realm fallback
		    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
		    else if (isObject(C)) {
		      C = C[SPECIES];
		      if (C === null) C = undefined;
		    }
		  } return C === undefined ? $Array : C;
		};

		},{"../internals/is-array":201,"../internals/is-constructor":204,"../internals/is-object":208,"../internals/well-known-symbol":306}],134:[function(require,module,exports){
		var arraySpeciesConstructor = require('../internals/array-species-constructor');

		// `ArraySpeciesCreate` abstract operation
		// https://tc39.es/ecma262/#sec-arrayspeciescreate
		module.exports = function (originalArray, length) {
		  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
		};

		},{"../internals/array-species-constructor":133}],135:[function(require,module,exports){
		var anObject = require('../internals/an-object');
		var iteratorClose = require('../internals/iterator-close');

		// call something on iterator step with safe closing on error
		module.exports = function (iterator, fn, value, ENTRIES) {
		  try {
		    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
		  } catch (error) {
		    iteratorClose(iterator, 'throw', error);
		  }
		};

		},{"../internals/an-object":114,"../internals/iterator-close":214}],136:[function(require,module,exports){
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var ITERATOR = wellKnownSymbol('iterator');
		var SAFE_CLOSING = false;

		try {
		  var called = 0;
		  var iteratorWithReturn = {
		    next: function () {
		      return { done: !!called++ };
		    },
		    'return': function () {
		      SAFE_CLOSING = true;
		    }
		  };
		  iteratorWithReturn[ITERATOR] = function () {
		    return this;
		  };
		  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
		  Array.from(iteratorWithReturn, function () { throw 2; });
		} catch (error) { /* empty */ }

		module.exports = function (exec, SKIP_CLOSING) {
		  try {
		    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
		  } catch (error) { return false; } // workaround of old WebKit + `eval` bug
		  var ITERATION_SUPPORT = false;
		  try {
		    var object = {};
		    object[ITERATOR] = function () {
		      return {
		        next: function () {
		          return { done: ITERATION_SUPPORT = true };
		        }
		      };
		    };
		    exec(object);
		  } catch (error) { /* empty */ }
		  return ITERATION_SUPPORT;
		};

		},{"../internals/well-known-symbol":306}],137:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');

		var toString = uncurryThis({}.toString);
		var stringSlice = uncurryThis(''.slice);

		module.exports = function (it) {
		  return stringSlice(toString(it), 8, -1);
		};

		},{"../internals/function-uncurry-this":181}],138:[function(require,module,exports){
		var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
		var isCallable = require('../internals/is-callable');
		var classofRaw = require('../internals/classof-raw');
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var TO_STRING_TAG = wellKnownSymbol('toStringTag');
		var $Object = Object;

		// ES3 wrong here
		var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

		// fallback for IE11 Script Access Denied error
		var tryGet = function (it, key) {
		  try {
		    return it[key];
		  } catch (error) { /* empty */ }
		};

		// getting tag from ES6+ `Object.prototype.toString`
		module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
		  var O, tag, result;
		  return it === undefined ? 'Undefined' : it === null ? 'Null'
		    // @@toStringTag case
		    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
		    // builtinTag case
		    : CORRECT_ARGUMENTS ? classofRaw(O)
		    // ES3 arguments fallback
		    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
		};

		},{"../internals/classof-raw":137,"../internals/is-callable":203,"../internals/to-string-tag-support":290,"../internals/well-known-symbol":306}],139:[function(require,module,exports){
		var create = require('../internals/object-create');
		var defineBuiltInAccessor = require('../internals/define-built-in-accessor');
		var defineBuiltIns = require('../internals/define-built-ins');
		var bind = require('../internals/function-bind-context');
		var anInstance = require('../internals/an-instance');
		var isNullOrUndefined = require('../internals/is-null-or-undefined');
		var iterate = require('../internals/iterate');
		var defineIterator = require('../internals/iterator-define');
		var createIterResultObject = require('../internals/create-iter-result-object');
		var setSpecies = require('../internals/set-species');
		var DESCRIPTORS = require('../internals/descriptors');
		var fastKey = require('../internals/internal-metadata').fastKey;
		var InternalStateModule = require('../internals/internal-state');

		var setInternalState = InternalStateModule.set;
		var internalStateGetterFor = InternalStateModule.getterFor;

		module.exports = {
		  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
		    var Constructor = wrapper(function (that, iterable) {
		      anInstance(that, Prototype);
		      setInternalState(that, {
		        type: CONSTRUCTOR_NAME,
		        index: create(null),
		        first: undefined,
		        last: undefined,
		        size: 0
		      });
		      if (!DESCRIPTORS) that.size = 0;
		      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
		    });

		    var Prototype = Constructor.prototype;

		    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

		    var define = function (that, key, value) {
		      var state = getInternalState(that);
		      var entry = getEntry(that, key);
		      var previous, index;
		      // change existing entry
		      if (entry) {
		        entry.value = value;
		      // create new entry
		      } else {
		        state.last = entry = {
		          index: index = fastKey(key, true),
		          key: key,
		          value: value,
		          previous: previous = state.last,
		          next: undefined,
		          removed: false
		        };
		        if (!state.first) state.first = entry;
		        if (previous) previous.next = entry;
		        if (DESCRIPTORS) state.size++;
		        else that.size++;
		        // add to index
		        if (index !== 'F') state.index[index] = entry;
		      } return that;
		    };

		    var getEntry = function (that, key) {
		      var state = getInternalState(that);
		      // fast case
		      var index = fastKey(key);
		      var entry;
		      if (index !== 'F') return state.index[index];
		      // frozen object case
		      for (entry = state.first; entry; entry = entry.next) {
		        if (entry.key === key) return entry;
		      }
		    };

		    defineBuiltIns(Prototype, {
		      // `{ Map, Set }.prototype.clear()` methods
		      // https://tc39.es/ecma262/#sec-map.prototype.clear
		      // https://tc39.es/ecma262/#sec-set.prototype.clear
		      clear: function clear() {
		        var that = this;
		        var state = getInternalState(that);
		        var entry = state.first;
		        while (entry) {
		          entry.removed = true;
		          if (entry.previous) entry.previous = entry.previous.next = undefined;
		          entry = entry.next;
		        }
		        state.first = state.last = undefined;
		        state.index = create(null);
		        if (DESCRIPTORS) state.size = 0;
		        else that.size = 0;
		      },
		      // `{ Map, Set }.prototype.delete(key)` methods
		      // https://tc39.es/ecma262/#sec-map.prototype.delete
		      // https://tc39.es/ecma262/#sec-set.prototype.delete
		      'delete': function (key) {
		        var that = this;
		        var state = getInternalState(that);
		        var entry = getEntry(that, key);
		        if (entry) {
		          var next = entry.next;
		          var prev = entry.previous;
		          delete state.index[entry.index];
		          entry.removed = true;
		          if (prev) prev.next = next;
		          if (next) next.previous = prev;
		          if (state.first === entry) state.first = next;
		          if (state.last === entry) state.last = prev;
		          if (DESCRIPTORS) state.size--;
		          else that.size--;
		        } return !!entry;
		      },
		      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
		      // https://tc39.es/ecma262/#sec-map.prototype.foreach
		      // https://tc39.es/ecma262/#sec-set.prototype.foreach
		      forEach: function forEach(callbackfn /* , that = undefined */) {
		        var state = getInternalState(this);
		        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		        var entry;
		        while (entry = entry ? entry.next : state.first) {
		          boundFunction(entry.value, entry.key, this);
		          // revert to the last existing entry
		          while (entry && entry.removed) entry = entry.previous;
		        }
		      },
		      // `{ Map, Set}.prototype.has(key)` methods
		      // https://tc39.es/ecma262/#sec-map.prototype.has
		      // https://tc39.es/ecma262/#sec-set.prototype.has
		      has: function has(key) {
		        return !!getEntry(this, key);
		      }
		    });

		    defineBuiltIns(Prototype, IS_MAP ? {
		      // `Map.prototype.get(key)` method
		      // https://tc39.es/ecma262/#sec-map.prototype.get
		      get: function get(key) {
		        var entry = getEntry(this, key);
		        return entry && entry.value;
		      },
		      // `Map.prototype.set(key, value)` method
		      // https://tc39.es/ecma262/#sec-map.prototype.set
		      set: function set(key, value) {
		        return define(this, key === 0 ? 0 : key, value);
		      }
		    } : {
		      // `Set.prototype.add(value)` method
		      // https://tc39.es/ecma262/#sec-set.prototype.add
		      add: function add(value) {
		        return define(this, value = value === 0 ? 0 : value, value);
		      }
		    });
		    if (DESCRIPTORS) defineBuiltInAccessor(Prototype, 'size', {
		      configurable: true,
		      get: function () {
		        return getInternalState(this).size;
		      }
		    });
		    return Constructor;
		  },
		  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
		    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
		    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
		    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
		    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
		    // https://tc39.es/ecma262/#sec-map.prototype.entries
		    // https://tc39.es/ecma262/#sec-map.prototype.keys
		    // https://tc39.es/ecma262/#sec-map.prototype.values
		    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
		    // https://tc39.es/ecma262/#sec-set.prototype.entries
		    // https://tc39.es/ecma262/#sec-set.prototype.keys
		    // https://tc39.es/ecma262/#sec-set.prototype.values
		    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
		    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
		      setInternalState(this, {
		        type: ITERATOR_NAME,
		        target: iterated,
		        state: getInternalCollectionState(iterated),
		        kind: kind,
		        last: undefined
		      });
		    }, function () {
		      var state = getInternalIteratorState(this);
		      var kind = state.kind;
		      var entry = state.last;
		      // revert to the last existing entry
		      while (entry && entry.removed) entry = entry.previous;
		      // get next entry
		      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
		        // or finish the iteration
		        state.target = undefined;
		        return createIterResultObject(undefined, true);
		      }
		      // return step by kind
		      if (kind === 'keys') return createIterResultObject(entry.key, false);
		      if (kind === 'values') return createIterResultObject(entry.value, false);
		      return createIterResultObject([entry.key, entry.value], false);
		    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

		    // `{ Map, Set }.prototype[@@species]` accessors
		    // https://tc39.es/ecma262/#sec-get-map-@@species
		    // https://tc39.es/ecma262/#sec-get-set-@@species
		    setSpecies(CONSTRUCTOR_NAME);
		  }
		};

		},{"../internals/an-instance":113,"../internals/create-iter-result-object":144,"../internals/define-built-in-accessor":148,"../internals/define-built-ins":150,"../internals/descriptors":153,"../internals/function-bind-context":175,"../internals/internal-metadata":198,"../internals/internal-state":199,"../internals/is-null-or-undefined":207,"../internals/iterate":213,"../internals/iterator-define":216,"../internals/object-create":229,"../internals/set-species":265}],140:[function(require,module,exports){
		var $ = require('../internals/export');
		var global = require('../internals/global');
		var uncurryThis = require('../internals/function-uncurry-this');
		var isForced = require('../internals/is-forced');
		var defineBuiltIn = require('../internals/define-built-in');
		var InternalMetadataModule = require('../internals/internal-metadata');
		var iterate = require('../internals/iterate');
		var anInstance = require('../internals/an-instance');
		var isCallable = require('../internals/is-callable');
		var isNullOrUndefined = require('../internals/is-null-or-undefined');
		var isObject = require('../internals/is-object');
		var fails = require('../internals/fails');
		var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
		var setToStringTag = require('../internals/set-to-string-tag');
		var inheritIfRequired = require('../internals/inherit-if-required');

		module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
		  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
		  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
		  var ADDER = IS_MAP ? 'set' : 'add';
		  var NativeConstructor = global[CONSTRUCTOR_NAME];
		  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
		  var Constructor = NativeConstructor;
		  var exported = {};

		  var fixMethod = function (KEY) {
		    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
		    defineBuiltIn(NativePrototype, KEY,
		      KEY === 'add' ? function add(value) {
		        uncurriedNativeMethod(this, value === 0 ? 0 : value);
		        return this;
		      } : KEY === 'delete' ? function (key) {
		        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
		      } : KEY === 'get' ? function get(key) {
		        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
		      } : KEY === 'has' ? function has(key) {
		        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
		      } : function set(key, value) {
		        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
		        return this;
		      }
		    );
		  };

		  var REPLACE = isForced(
		    CONSTRUCTOR_NAME,
		    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
		      new NativeConstructor().entries().next();
		    }))
		  );

		  if (REPLACE) {
		    // create collection constructor
		    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
		    InternalMetadataModule.enable();
		  } else if (isForced(CONSTRUCTOR_NAME, true)) {
		    var instance = new Constructor();
		    // early implementations not supports chaining
		    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
		    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
		    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
		    // most early implementations doesn't supports iterables, most modern - not close it correctly
		    // eslint-disable-next-line no-new -- required for testing
		    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
		    // for early implementations -0 and +0 not the same
		    var BUGGY_ZERO = !IS_WEAK && fails(function () {
		      // V8 ~ Chromium 42- fails only with 5+ elements
		      var $instance = new NativeConstructor();
		      var index = 5;
		      while (index--) $instance[ADDER](index, index);
		      return !$instance.has(-0);
		    });

		    if (!ACCEPT_ITERABLES) {
		      Constructor = wrapper(function (dummy, iterable) {
		        anInstance(dummy, NativePrototype);
		        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
		        if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
		        return that;
		      });
		      Constructor.prototype = NativePrototype;
		      NativePrototype.constructor = Constructor;
		    }

		    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
		      fixMethod('delete');
		      fixMethod('has');
		      IS_MAP && fixMethod('get');
		    }

		    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

		    // weak collections should not contains .clear method
		    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
		  }

		  exported[CONSTRUCTOR_NAME] = Constructor;
		  $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);

		  setToStringTag(Constructor, CONSTRUCTOR_NAME);

		  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

		  return Constructor;
		};

		},{"../internals/an-instance":113,"../internals/check-correctness-of-iteration":136,"../internals/define-built-in":149,"../internals/export":170,"../internals/fails":171,"../internals/function-uncurry-this":181,"../internals/global":188,"../internals/inherit-if-required":196,"../internals/internal-metadata":198,"../internals/is-callable":203,"../internals/is-forced":205,"../internals/is-null-or-undefined":207,"../internals/is-object":208,"../internals/iterate":213,"../internals/set-to-string-tag":266}],141:[function(require,module,exports){
		var hasOwn = require('../internals/has-own-property');
		var ownKeys = require('../internals/own-keys');
		var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
		var definePropertyModule = require('../internals/object-define-property');

		module.exports = function (target, source, exceptions) {
		  var keys = ownKeys(source);
		  var defineProperty = definePropertyModule.f;
		  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
		  for (var i = 0; i < keys.length; i++) {
		    var key = keys[i];
		    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
		      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
		    }
		  }
		};

		},{"../internals/has-own-property":189,"../internals/object-define-property":231,"../internals/object-get-own-property-descriptor":232,"../internals/own-keys":246}],142:[function(require,module,exports){
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var MATCH = wellKnownSymbol('match');

		module.exports = function (METHOD_NAME) {
		  var regexp = /./;
		  try {
		    '/./'[METHOD_NAME](regexp);
		  } catch (error1) {
		    try {
		      regexp[MATCH] = false;
		      return '/./'[METHOD_NAME](regexp);
		    } catch (error2) { /* empty */ }
		  } return false;
		};

		},{"../internals/well-known-symbol":306}],143:[function(require,module,exports){
		var fails = require('../internals/fails');

		module.exports = !fails(function () {
		  function F() { /* empty */ }
		  F.prototype.constructor = null;
		  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
		  return Object.getPrototypeOf(new F()) !== F.prototype;
		});

		},{"../internals/fails":171}],144:[function(require,module,exports){
		// `CreateIterResultObject` abstract operation
		// https://tc39.es/ecma262/#sec-createiterresultobject
		module.exports = function (value, done) {
		  return { value: value, done: done };
		};

		},{}],145:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var definePropertyModule = require('../internals/object-define-property');
		var createPropertyDescriptor = require('../internals/create-property-descriptor');

		module.exports = DESCRIPTORS ? function (object, key, value) {
		  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
		} : function (object, key, value) {
		  object[key] = value;
		  return object;
		};

		},{"../internals/create-property-descriptor":146,"../internals/descriptors":153,"../internals/object-define-property":231}],146:[function(require,module,exports){
		module.exports = function (bitmap, value) {
		  return {
		    enumerable: !(bitmap & 1),
		    configurable: !(bitmap & 2),
		    writable: !(bitmap & 4),
		    value: value
		  };
		};

		},{}],147:[function(require,module,exports){
		var toPropertyKey = require('../internals/to-property-key');
		var definePropertyModule = require('../internals/object-define-property');
		var createPropertyDescriptor = require('../internals/create-property-descriptor');

		module.exports = function (object, key, value) {
		  var propertyKey = toPropertyKey(key);
		  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
		  else object[propertyKey] = value;
		};

		},{"../internals/create-property-descriptor":146,"../internals/object-define-property":231,"../internals/to-property-key":289}],148:[function(require,module,exports){
		var makeBuiltIn = require('../internals/make-built-in');
		var defineProperty = require('../internals/object-define-property');

		module.exports = function (target, name, descriptor) {
		  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
		  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
		  return defineProperty.f(target, name, descriptor);
		};

		},{"../internals/make-built-in":220,"../internals/object-define-property":231}],149:[function(require,module,exports){
		var isCallable = require('../internals/is-callable');
		var definePropertyModule = require('../internals/object-define-property');
		var makeBuiltIn = require('../internals/make-built-in');
		var defineGlobalProperty = require('../internals/define-global-property');

		module.exports = function (O, key, value, options) {
		  if (!options) options = {};
		  var simple = options.enumerable;
		  var name = options.name !== undefined ? options.name : key;
		  if (isCallable(value)) makeBuiltIn(value, name, options);
		  if (options.global) {
		    if (simple) O[key] = value;
		    else defineGlobalProperty(key, value);
		  } else {
		    try {
		      if (!options.unsafe) delete O[key];
		      else if (O[key]) simple = true;
		    } catch (error) { /* empty */ }
		    if (simple) O[key] = value;
		    else definePropertyModule.f(O, key, {
		      value: value,
		      enumerable: false,
		      configurable: !options.nonConfigurable,
		      writable: !options.nonWritable
		    });
		  } return O;
		};

		},{"../internals/define-global-property":151,"../internals/is-callable":203,"../internals/make-built-in":220,"../internals/object-define-property":231}],150:[function(require,module,exports){
		var defineBuiltIn = require('../internals/define-built-in');

		module.exports = function (target, src, options) {
		  for (var key in src) defineBuiltIn(target, key, src[key], options);
		  return target;
		};

		},{"../internals/define-built-in":149}],151:[function(require,module,exports){
		var global = require('../internals/global');

		// eslint-disable-next-line es/no-object-defineproperty -- safe
		var defineProperty = Object.defineProperty;

		module.exports = function (key, value) {
		  try {
		    defineProperty(global, key, { value: value, configurable: true, writable: true });
		  } catch (error) {
		    global[key] = value;
		  } return value;
		};

		},{"../internals/global":188}],152:[function(require,module,exports){
		var tryToString = require('../internals/try-to-string');

		var $TypeError = TypeError;

		module.exports = function (O, P) {
		  if (!delete O[P]) throw new $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
		};

		},{"../internals/try-to-string":293}],153:[function(require,module,exports){
		var fails = require('../internals/fails');

		// Detect IE8's incomplete defineProperty implementation
		module.exports = !fails(function () {
		  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
		  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
		});

		},{"../internals/fails":171}],154:[function(require,module,exports){
		var global = require('../internals/global');
		var isObject = require('../internals/is-object');

		var document = global.document;
		// typeof document.createElement is 'object' in old IE
		var EXISTS = isObject(document) && isObject(document.createElement);

		module.exports = function (it) {
		  return EXISTS ? document.createElement(it) : {};
		};

		},{"../internals/global":188,"../internals/is-object":208}],155:[function(require,module,exports){
		var $TypeError = TypeError;
		var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

		module.exports = function (it) {
		  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
		  return it;
		};

		},{}],156:[function(require,module,exports){
		// iterable DOM collections
		// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
		module.exports = {
		  CSSRuleList: 0,
		  CSSStyleDeclaration: 0,
		  CSSValueList: 0,
		  ClientRectList: 0,
		  DOMRectList: 0,
		  DOMStringList: 0,
		  DOMTokenList: 1,
		  DataTransferItemList: 0,
		  FileList: 0,
		  HTMLAllCollection: 0,
		  HTMLCollection: 0,
		  HTMLFormElement: 0,
		  HTMLSelectElement: 0,
		  MediaList: 0,
		  MimeTypeArray: 0,
		  NamedNodeMap: 0,
		  NodeList: 1,
		  PaintRequestList: 0,
		  Plugin: 0,
		  PluginArray: 0,
		  SVGLengthList: 0,
		  SVGNumberList: 0,
		  SVGPathSegList: 0,
		  SVGPointList: 0,
		  SVGStringList: 0,
		  SVGTransformList: 0,
		  SourceBufferList: 0,
		  StyleSheetList: 0,
		  TextTrackCueList: 0,
		  TextTrackList: 0,
		  TouchList: 0
		};

		},{}],157:[function(require,module,exports){
		// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
		var documentCreateElement = require('../internals/document-create-element');

		var classList = documentCreateElement('span').classList;
		var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

		module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;

		},{"../internals/document-create-element":154}],158:[function(require,module,exports){
		var userAgent = require('../internals/engine-user-agent');

		var firefox = userAgent.match(/firefox\/(\d+)/i);

		module.exports = !!firefox && +firefox[1];

		},{"../internals/engine-user-agent":166}],159:[function(require,module,exports){
		var IS_DENO = require('../internals/engine-is-deno');
		var IS_NODE = require('../internals/engine-is-node');

		module.exports = !IS_DENO && !IS_NODE
		  && typeof window == 'object'
		  && typeof document == 'object';

		},{"../internals/engine-is-deno":160,"../internals/engine-is-node":164}],160:[function(require,module,exports){
		/* global Deno -- Deno case */
		module.exports = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';

		},{}],161:[function(require,module,exports){
		var UA = require('../internals/engine-user-agent');

		module.exports = /MSIE|Trident/.test(UA);

		},{"../internals/engine-user-agent":166}],162:[function(require,module,exports){
		var userAgent = require('../internals/engine-user-agent');

		module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != 'undefined';

		},{"../internals/engine-user-agent":166}],163:[function(require,module,exports){
		var userAgent = require('../internals/engine-user-agent');

		// eslint-disable-next-line redos/no-vulnerable -- safe
		module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);

		},{"../internals/engine-user-agent":166}],164:[function(require,module,exports){
		var global = require('../internals/global');
		var classof = require('../internals/classof-raw');

		module.exports = classof(global.process) === 'process';

		},{"../internals/classof-raw":137,"../internals/global":188}],165:[function(require,module,exports){
		var userAgent = require('../internals/engine-user-agent');

		module.exports = /web0s(?!.*chrome)/i.test(userAgent);

		},{"../internals/engine-user-agent":166}],166:[function(require,module,exports){
		module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';

		},{}],167:[function(require,module,exports){
		var global = require('../internals/global');
		var userAgent = require('../internals/engine-user-agent');

		var process = global.process;
		var Deno = global.Deno;
		var versions = process && process.versions || Deno && Deno.version;
		var v8 = versions && versions.v8;
		var match, version;

		if (v8) {
		  match = v8.split('.');
		  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
		  // but their correct versions are not interesting for us
		  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
		}

		// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
		// so check `userAgent` even if `.v8` exists, but 0
		if (!version && userAgent) {
		  match = userAgent.match(/Edge\/(\d+)/);
		  if (!match || match[1] >= 74) {
		    match = userAgent.match(/Chrome\/(\d+)/);
		    if (match) version = +match[1];
		  }
		}

		module.exports = version;

		},{"../internals/engine-user-agent":166,"../internals/global":188}],168:[function(require,module,exports){
		var userAgent = require('../internals/engine-user-agent');

		var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

		module.exports = !!webkit && +webkit[1];

		},{"../internals/engine-user-agent":166}],169:[function(require,module,exports){
		// IE8- don't enum bug keys
		module.exports = [
		  'constructor',
		  'hasOwnProperty',
		  'isPrototypeOf',
		  'propertyIsEnumerable',
		  'toLocaleString',
		  'toString',
		  'valueOf'
		];

		},{}],170:[function(require,module,exports){
		var global = require('../internals/global');
		var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
		var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
		var defineBuiltIn = require('../internals/define-built-in');
		var defineGlobalProperty = require('../internals/define-global-property');
		var copyConstructorProperties = require('../internals/copy-constructor-properties');
		var isForced = require('../internals/is-forced');

		/*
		  options.target         - name of the target object
		  options.global         - target is the global object
		  options.stat           - export as static methods of target
		  options.proto          - export as prototype methods of target
		  options.real           - real prototype method for the `pure` version
		  options.forced         - export even if the native feature is available
		  options.bind           - bind methods to the target, required for the `pure` version
		  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
		  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
		  options.sham           - add a flag to not completely full polyfills
		  options.enumerable     - export as enumerable property
		  options.dontCallGetSet - prevent calling a getter on target
		  options.name           - the .name of the function if it does not match the key
		*/
		module.exports = function (options, source) {
		  var TARGET = options.target;
		  var GLOBAL = options.global;
		  var STATIC = options.stat;
		  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
		  if (GLOBAL) {
		    target = global;
		  } else if (STATIC) {
		    target = global[TARGET] || defineGlobalProperty(TARGET, {});
		  } else {
		    target = (global[TARGET] || {}).prototype;
		  }
		  if (target) for (key in source) {
		    sourceProperty = source[key];
		    if (options.dontCallGetSet) {
		      descriptor = getOwnPropertyDescriptor(target, key);
		      targetProperty = descriptor && descriptor.value;
		    } else targetProperty = target[key];
		    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
		    // contained in target
		    if (!FORCED && targetProperty !== undefined) {
		      if (typeof sourceProperty == typeof targetProperty) continue;
		      copyConstructorProperties(sourceProperty, targetProperty);
		    }
		    // add a flag to not completely full polyfills
		    if (options.sham || (targetProperty && targetProperty.sham)) {
		      createNonEnumerableProperty(sourceProperty, 'sham', true);
		    }
		    defineBuiltIn(target, key, sourceProperty, options);
		  }
		};

		},{"../internals/copy-constructor-properties":141,"../internals/create-non-enumerable-property":145,"../internals/define-built-in":149,"../internals/define-global-property":151,"../internals/global":188,"../internals/is-forced":205,"../internals/object-get-own-property-descriptor":232}],171:[function(require,module,exports){
		module.exports = function (exec) {
		  try {
		    return !!exec();
		  } catch (error) {
		    return true;
		  }
		};

		},{}],172:[function(require,module,exports){
		// TODO: Remove from `core-js@4` since it's moved to entry points
		require('../modules/es.regexp.exec');
		var uncurryThis = require('../internals/function-uncurry-this-clause');
		var defineBuiltIn = require('../internals/define-built-in');
		var regexpExec = require('../internals/regexp-exec');
		var fails = require('../internals/fails');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

		var SPECIES = wellKnownSymbol('species');
		var RegExpPrototype = RegExp.prototype;

		module.exports = function (KEY, exec, FORCED, SHAM) {
		  var SYMBOL = wellKnownSymbol(KEY);

		  var DELEGATES_TO_SYMBOL = !fails(function () {
		    // String methods call symbol-named RegEp methods
		    var O = {};
		    O[SYMBOL] = function () { return 7; };
		    return ''[KEY](O) !== 7;
		  });

		  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
		    // Symbol-named RegExp methods call .exec
		    var execCalled = false;
		    var re = /a/;

		    if (KEY === 'split') {
		      // We can't use real regex here since it causes deoptimization
		      // and serious performance degradation in V8
		      // https://github.com/zloirock/core-js/issues/306
		      re = {};
		      // RegExp[@@split] doesn't call the regex's exec method, but first creates
		      // a new one. We need to return the patched regex when creating the new one.
		      re.constructor = {};
		      re.constructor[SPECIES] = function () { return re; };
		      re.flags = '';
		      re[SYMBOL] = /./[SYMBOL];
		    }

		    re.exec = function () {
		      execCalled = true;
		      return null;
		    };

		    re[SYMBOL]('');
		    return !execCalled;
		  });

		  if (
		    !DELEGATES_TO_SYMBOL ||
		    !DELEGATES_TO_EXEC ||
		    FORCED
		  ) {
		    var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
		    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
		      var uncurriedNativeMethod = uncurryThis(nativeMethod);
		      var $exec = regexp.exec;
		      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
		        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
		          // The native String method already delegates to @@method (this
		          // polyfilled function), leasing to infinite recursion.
		          // We avoid it by directly calling the native @@method method.
		          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
		        }
		        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
		      }
		      return { done: false };
		    });

		    defineBuiltIn(String.prototype, KEY, methods[0]);
		    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
		  }

		  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
		};

		},{"../internals/create-non-enumerable-property":145,"../internals/define-built-in":149,"../internals/fails":171,"../internals/function-uncurry-this-clause":180,"../internals/regexp-exec":256,"../internals/well-known-symbol":306,"../modules/es.regexp.exec":338}],173:[function(require,module,exports){
		var fails = require('../internals/fails');

		module.exports = !fails(function () {
		  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
		  return Object.isExtensible(Object.preventExtensions({}));
		});

		},{"../internals/fails":171}],174:[function(require,module,exports){
		var NATIVE_BIND = require('../internals/function-bind-native');

		var FunctionPrototype = Function.prototype;
		var apply = FunctionPrototype.apply;
		var call = FunctionPrototype.call;

		// eslint-disable-next-line es/no-reflect -- safe
		module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
		  return call.apply(apply, arguments);
		});

		},{"../internals/function-bind-native":176}],175:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this-clause');
		var aCallable = require('../internals/a-callable');
		var NATIVE_BIND = require('../internals/function-bind-native');

		var bind = uncurryThis(uncurryThis.bind);

		// optional / simple context binding
		module.exports = function (fn, that) {
		  aCallable(fn);
		  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
		    return fn.apply(that, arguments);
		  };
		};

		},{"../internals/a-callable":108,"../internals/function-bind-native":176,"../internals/function-uncurry-this-clause":180}],176:[function(require,module,exports){
		var fails = require('../internals/fails');

		module.exports = !fails(function () {
		  // eslint-disable-next-line es/no-function-prototype-bind -- safe
		  var test = (function () { /* empty */ }).bind();
		  // eslint-disable-next-line no-prototype-builtins -- safe
		  return typeof test != 'function' || test.hasOwnProperty('prototype');
		});

		},{"../internals/fails":171}],177:[function(require,module,exports){
		var NATIVE_BIND = require('../internals/function-bind-native');

		var call = Function.prototype.call;

		module.exports = NATIVE_BIND ? call.bind(call) : function () {
		  return call.apply(call, arguments);
		};

		},{"../internals/function-bind-native":176}],178:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var hasOwn = require('../internals/has-own-property');

		var FunctionPrototype = Function.prototype;
		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

		var EXISTS = hasOwn(FunctionPrototype, 'name');
		// additional protection from minified / mangled / dropped function names
		var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
		var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

		module.exports = {
		  EXISTS: EXISTS,
		  PROPER: PROPER,
		  CONFIGURABLE: CONFIGURABLE
		};

		},{"../internals/descriptors":153,"../internals/has-own-property":189}],179:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var aCallable = require('../internals/a-callable');

		module.exports = function (object, key, method) {
		  try {
		    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
		  } catch (error) { /* empty */ }
		};

		},{"../internals/a-callable":108,"../internals/function-uncurry-this":181}],180:[function(require,module,exports){
		var classofRaw = require('../internals/classof-raw');
		var uncurryThis = require('../internals/function-uncurry-this');

		module.exports = function (fn) {
		  // Nashorn bug:
		  //   https://github.com/zloirock/core-js/issues/1128
		  //   https://github.com/zloirock/core-js/issues/1130
		  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
		};

		},{"../internals/classof-raw":137,"../internals/function-uncurry-this":181}],181:[function(require,module,exports){
		var NATIVE_BIND = require('../internals/function-bind-native');

		var FunctionPrototype = Function.prototype;
		var call = FunctionPrototype.call;
		var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

		module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
		  return function () {
		    return call.apply(fn, arguments);
		  };
		};

		},{"../internals/function-bind-native":176}],182:[function(require,module,exports){
		var global = require('../internals/global');
		var isCallable = require('../internals/is-callable');

		var aFunction = function (argument) {
		  return isCallable(argument) ? argument : undefined;
		};

		module.exports = function (namespace, method) {
		  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
		};

		},{"../internals/global":188,"../internals/is-callable":203}],183:[function(require,module,exports){
		var classof = require('../internals/classof');
		var getMethod = require('../internals/get-method');
		var isNullOrUndefined = require('../internals/is-null-or-undefined');
		var Iterators = require('../internals/iterators');
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var ITERATOR = wellKnownSymbol('iterator');

		module.exports = function (it) {
		  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
		    || getMethod(it, '@@iterator')
		    || Iterators[classof(it)];
		};

		},{"../internals/classof":138,"../internals/get-method":186,"../internals/is-null-or-undefined":207,"../internals/iterators":218,"../internals/well-known-symbol":306}],184:[function(require,module,exports){
		var call = require('../internals/function-call');
		var aCallable = require('../internals/a-callable');
		var anObject = require('../internals/an-object');
		var tryToString = require('../internals/try-to-string');
		var getIteratorMethod = require('../internals/get-iterator-method');

		var $TypeError = TypeError;

		module.exports = function (argument, usingIterator) {
		  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
		  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
		  throw new $TypeError(tryToString(argument) + ' is not iterable');
		};

		},{"../internals/a-callable":108,"../internals/an-object":114,"../internals/function-call":177,"../internals/get-iterator-method":183,"../internals/try-to-string":293}],185:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var isArray = require('../internals/is-array');
		var isCallable = require('../internals/is-callable');
		var classof = require('../internals/classof-raw');
		var toString = require('../internals/to-string');

		var push = uncurryThis([].push);

		module.exports = function (replacer) {
		  if (isCallable(replacer)) return replacer;
		  if (!isArray(replacer)) return;
		  var rawLength = replacer.length;
		  var keys = [];
		  for (var i = 0; i < rawLength; i++) {
		    var element = replacer[i];
		    if (typeof element == 'string') push(keys, element);
		    else if (typeof element == 'number' || classof(element) === 'Number' || classof(element) === 'String') push(keys, toString(element));
		  }
		  var keysLength = keys.length;
		  var root = true;
		  return function (key, value) {
		    if (root) {
		      root = false;
		      return value;
		    }
		    if (isArray(this)) return value;
		    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
		  };
		};

		},{"../internals/classof-raw":137,"../internals/function-uncurry-this":181,"../internals/is-array":201,"../internals/is-callable":203,"../internals/to-string":291}],186:[function(require,module,exports){
		var aCallable = require('../internals/a-callable');
		var isNullOrUndefined = require('../internals/is-null-or-undefined');

		// `GetMethod` abstract operation
		// https://tc39.es/ecma262/#sec-getmethod
		module.exports = function (V, P) {
		  var func = V[P];
		  return isNullOrUndefined(func) ? undefined : aCallable(func);
		};

		},{"../internals/a-callable":108,"../internals/is-null-or-undefined":207}],187:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var toObject = require('../internals/to-object');

		var floor = Math.floor;
		var charAt = uncurryThis(''.charAt);
		var replace = uncurryThis(''.replace);
		var stringSlice = uncurryThis(''.slice);
		// eslint-disable-next-line redos/no-vulnerable -- safe
		var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
		var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

		// `GetSubstitution` abstract operation
		// https://tc39.es/ecma262/#sec-getsubstitution
		module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
		  var tailPos = position + matched.length;
		  var m = captures.length;
		  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
		  if (namedCaptures !== undefined) {
		    namedCaptures = toObject(namedCaptures);
		    symbols = SUBSTITUTION_SYMBOLS;
		  }
		  return replace(replacement, symbols, function (match, ch) {
		    var capture;
		    switch (charAt(ch, 0)) {
		      case '$': return '$';
		      case '&': return matched;
		      case '`': return stringSlice(str, 0, position);
		      case "'": return stringSlice(str, tailPos);
		      case '<':
		        capture = namedCaptures[stringSlice(ch, 1, -1)];
		        break;
		      default: // \d\d?
		        var n = +ch;
		        if (n === 0) return match;
		        if (n > m) {
		          var f = floor(n / 10);
		          if (f === 0) return match;
		          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
		          return match;
		        }
		        capture = captures[n - 1];
		    }
		    return capture === undefined ? '' : capture;
		  });
		};

		},{"../internals/function-uncurry-this":181,"../internals/to-object":285}],188:[function(require,module,exports){
		(function (global){(function (){
		var check = function (it) {
		  return it && it.Math === Math && it;
		};

		// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
		module.exports =
		  // eslint-disable-next-line es/no-global-this -- safe
		  check(typeof globalThis == 'object' && globalThis) ||
		  check(typeof window == 'object' && window) ||
		  // eslint-disable-next-line no-restricted-globals -- safe
		  check(typeof self == 'object' && self) ||
		  check(typeof global == 'object' && global) ||
		  check(typeof this == 'object' && this) ||
		  // eslint-disable-next-line no-new-func -- fallback
		  (function () { return this; })() || Function('return this')();

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],189:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var toObject = require('../internals/to-object');

		var hasOwnProperty = uncurryThis({}.hasOwnProperty);

		// `HasOwnProperty` abstract operation
		// https://tc39.es/ecma262/#sec-hasownproperty
		// eslint-disable-next-line es/no-object-hasown -- safe
		module.exports = Object.hasOwn || function hasOwn(it, key) {
		  return hasOwnProperty(toObject(it), key);
		};

		},{"../internals/function-uncurry-this":181,"../internals/to-object":285}],190:[function(require,module,exports){
		module.exports = {};

		},{}],191:[function(require,module,exports){
		module.exports = function (a, b) {
		  try {
		    // eslint-disable-next-line no-console -- safe
		    arguments.length === 1 ? console.error(a) : console.error(a, b);
		  } catch (error) { /* empty */ }
		};

		},{}],192:[function(require,module,exports){
		var getBuiltIn = require('../internals/get-built-in');

		module.exports = getBuiltIn('document', 'documentElement');

		},{"../internals/get-built-in":182}],193:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var fails = require('../internals/fails');
		var createElement = require('../internals/document-create-element');

		// Thanks to IE8 for its funny defineProperty
		module.exports = !DESCRIPTORS && !fails(function () {
		  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
		  return Object.defineProperty(createElement('div'), 'a', {
		    get: function () { return 7; }
		  }).a !== 7;
		});

		},{"../internals/descriptors":153,"../internals/document-create-element":154,"../internals/fails":171}],194:[function(require,module,exports){
		// IEEE754 conversions based on https://github.com/feross/ieee754
		var $Array = Array;
		var abs = Math.abs;
		var pow = Math.pow;
		var floor = Math.floor;
		var log = Math.log;
		var LN2 = Math.LN2;

		var pack = function (number, mantissaLength, bytes) {
		  var buffer = $Array(bytes);
		  var exponentLength = bytes * 8 - mantissaLength - 1;
		  var eMax = (1 << exponentLength) - 1;
		  var eBias = eMax >> 1;
		  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
		  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
		  var index = 0;
		  var exponent, mantissa, c;
		  number = abs(number);
		  // eslint-disable-next-line no-self-compare -- NaN check
		  if (number !== number || number === Infinity) {
		    // eslint-disable-next-line no-self-compare -- NaN check
		    mantissa = number !== number ? 1 : 0;
		    exponent = eMax;
		  } else {
		    exponent = floor(log(number) / LN2);
		    c = pow(2, -exponent);
		    if (number * c < 1) {
		      exponent--;
		      c *= 2;
		    }
		    if (exponent + eBias >= 1) {
		      number += rt / c;
		    } else {
		      number += rt * pow(2, 1 - eBias);
		    }
		    if (number * c >= 2) {
		      exponent++;
		      c /= 2;
		    }
		    if (exponent + eBias >= eMax) {
		      mantissa = 0;
		      exponent = eMax;
		    } else if (exponent + eBias >= 1) {
		      mantissa = (number * c - 1) * pow(2, mantissaLength);
		      exponent += eBias;
		    } else {
		      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
		      exponent = 0;
		    }
		  }
		  while (mantissaLength >= 8) {
		    buffer[index++] = mantissa & 255;
		    mantissa /= 256;
		    mantissaLength -= 8;
		  }
		  exponent = exponent << mantissaLength | mantissa;
		  exponentLength += mantissaLength;
		  while (exponentLength > 0) {
		    buffer[index++] = exponent & 255;
		    exponent /= 256;
		    exponentLength -= 8;
		  }
		  buffer[--index] |= sign * 128;
		  return buffer;
		};

		var unpack = function (buffer, mantissaLength) {
		  var bytes = buffer.length;
		  var exponentLength = bytes * 8 - mantissaLength - 1;
		  var eMax = (1 << exponentLength) - 1;
		  var eBias = eMax >> 1;
		  var nBits = exponentLength - 7;
		  var index = bytes - 1;
		  var sign = buffer[index--];
		  var exponent = sign & 127;
		  var mantissa;
		  sign >>= 7;
		  while (nBits > 0) {
		    exponent = exponent * 256 + buffer[index--];
		    nBits -= 8;
		  }
		  mantissa = exponent & (1 << -nBits) - 1;
		  exponent >>= -nBits;
		  nBits += mantissaLength;
		  while (nBits > 0) {
		    mantissa = mantissa * 256 + buffer[index--];
		    nBits -= 8;
		  }
		  if (exponent === 0) {
		    exponent = 1 - eBias;
		  } else if (exponent === eMax) {
		    return mantissa ? NaN : sign ? -Infinity : Infinity;
		  } else {
		    mantissa += pow(2, mantissaLength);
		    exponent -= eBias;
		  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
		};

		module.exports = {
		  pack: pack,
		  unpack: unpack
		};

		},{}],195:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var fails = require('../internals/fails');
		var classof = require('../internals/classof-raw');

		var $Object = Object;
		var split = uncurryThis(''.split);

		// fallback for non-array-like ES3 and non-enumerable old V8 strings
		module.exports = fails(function () {
		  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
		  // eslint-disable-next-line no-prototype-builtins -- safe
		  return !$Object('z').propertyIsEnumerable(0);
		}) ? function (it) {
		  return classof(it) === 'String' ? split(it, '') : $Object(it);
		} : $Object;

		},{"../internals/classof-raw":137,"../internals/fails":171,"../internals/function-uncurry-this":181}],196:[function(require,module,exports){
		var isCallable = require('../internals/is-callable');
		var isObject = require('../internals/is-object');
		var setPrototypeOf = require('../internals/object-set-prototype-of');

		// makes subclassing work correct for wrapped built-ins
		module.exports = function ($this, dummy, Wrapper) {
		  var NewTarget, NewTargetPrototype;
		  if (
		    // it can work only with native `setPrototypeOf`
		    setPrototypeOf &&
		    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
		    isCallable(NewTarget = dummy.constructor) &&
		    NewTarget !== Wrapper &&
		    isObject(NewTargetPrototype = NewTarget.prototype) &&
		    NewTargetPrototype !== Wrapper.prototype
		  ) setPrototypeOf($this, NewTargetPrototype);
		  return $this;
		};

		},{"../internals/is-callable":203,"../internals/is-object":208,"../internals/object-set-prototype-of":242}],197:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var isCallable = require('../internals/is-callable');
		var store = require('../internals/shared-store');

		var functionToString = uncurryThis(Function.toString);

		// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
		if (!isCallable(store.inspectSource)) {
		  store.inspectSource = function (it) {
		    return functionToString(it);
		  };
		}

		module.exports = store.inspectSource;

		},{"../internals/function-uncurry-this":181,"../internals/is-callable":203,"../internals/shared-store":268}],198:[function(require,module,exports){
		var $ = require('../internals/export');
		var uncurryThis = require('../internals/function-uncurry-this');
		var hiddenKeys = require('../internals/hidden-keys');
		var isObject = require('../internals/is-object');
		var hasOwn = require('../internals/has-own-property');
		var defineProperty = require('../internals/object-define-property').f;
		var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
		var getOwnPropertyNamesExternalModule = require('../internals/object-get-own-property-names-external');
		var isExtensible = require('../internals/object-is-extensible');
		var uid = require('../internals/uid');
		var FREEZING = require('../internals/freezing');

		var REQUIRED = false;
		var METADATA = uid('meta');
		var id = 0;

		var setMetadata = function (it) {
		  defineProperty(it, METADATA, { value: {
		    objectID: 'O' + id++, // object ID
		    weakData: {}          // weak collections IDs
		  } });
		};

		var fastKey = function (it, create) {
		  // return a primitive with prefix
		  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
		  if (!hasOwn(it, METADATA)) {
		    // can't set metadata to uncaught frozen object
		    if (!isExtensible(it)) return 'F';
		    // not necessary to add metadata
		    if (!create) return 'E';
		    // add missing metadata
		    setMetadata(it);
		  // return object ID
		  } return it[METADATA].objectID;
		};

		var getWeakData = function (it, create) {
		  if (!hasOwn(it, METADATA)) {
		    // can't set metadata to uncaught frozen object
		    if (!isExtensible(it)) return true;
		    // not necessary to add metadata
		    if (!create) return false;
		    // add missing metadata
		    setMetadata(it);
		  // return the store of weak collections IDs
		  } return it[METADATA].weakData;
		};

		// add metadata on freeze-family methods calling
		var onFreeze = function (it) {
		  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
		  return it;
		};

		var enable = function () {
		  meta.enable = function () { /* empty */ };
		  REQUIRED = true;
		  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
		  var splice = uncurryThis([].splice);
		  var test = {};
		  test[METADATA] = 1;

		  // prevent exposing of metadata key
		  if (getOwnPropertyNames(test).length) {
		    getOwnPropertyNamesModule.f = function (it) {
		      var result = getOwnPropertyNames(it);
		      for (var i = 0, length = result.length; i < length; i++) {
		        if (result[i] === METADATA) {
		          splice(result, i, 1);
		          break;
		        }
		      } return result;
		    };

		    $({ target: 'Object', stat: true, forced: true }, {
		      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
		    });
		  }
		};

		var meta = module.exports = {
		  enable: enable,
		  fastKey: fastKey,
		  getWeakData: getWeakData,
		  onFreeze: onFreeze
		};

		hiddenKeys[METADATA] = true;

		},{"../internals/export":170,"../internals/freezing":173,"../internals/function-uncurry-this":181,"../internals/has-own-property":189,"../internals/hidden-keys":190,"../internals/is-object":208,"../internals/object-define-property":231,"../internals/object-get-own-property-names":234,"../internals/object-get-own-property-names-external":233,"../internals/object-is-extensible":237,"../internals/uid":299}],199:[function(require,module,exports){
		var NATIVE_WEAK_MAP = require('../internals/weak-map-basic-detection');
		var global = require('../internals/global');
		var isObject = require('../internals/is-object');
		var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
		var hasOwn = require('../internals/has-own-property');
		var shared = require('../internals/shared-store');
		var sharedKey = require('../internals/shared-key');
		var hiddenKeys = require('../internals/hidden-keys');

		var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
		var TypeError = global.TypeError;
		var WeakMap = global.WeakMap;
		var set, get, has;

		var enforce = function (it) {
		  return has(it) ? get(it) : set(it, {});
		};

		var getterFor = function (TYPE) {
		  return function (it) {
		    var state;
		    if (!isObject(it) || (state = get(it)).type !== TYPE) {
		      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
		    } return state;
		  };
		};

		if (NATIVE_WEAK_MAP || shared.state) {
		  var store = shared.state || (shared.state = new WeakMap());
		  /* eslint-disable no-self-assign -- prototype methods protection */
		  store.get = store.get;
		  store.has = store.has;
		  store.set = store.set;
		  /* eslint-enable no-self-assign -- prototype methods protection */
		  set = function (it, metadata) {
		    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
		    metadata.facade = it;
		    store.set(it, metadata);
		    return metadata;
		  };
		  get = function (it) {
		    return store.get(it) || {};
		  };
		  has = function (it) {
		    return store.has(it);
		  };
		} else {
		  var STATE = sharedKey('state');
		  hiddenKeys[STATE] = true;
		  set = function (it, metadata) {
		    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
		    metadata.facade = it;
		    createNonEnumerableProperty(it, STATE, metadata);
		    return metadata;
		  };
		  get = function (it) {
		    return hasOwn(it, STATE) ? it[STATE] : {};
		  };
		  has = function (it) {
		    return hasOwn(it, STATE);
		  };
		}

		module.exports = {
		  set: set,
		  get: get,
		  has: has,
		  enforce: enforce,
		  getterFor: getterFor
		};

		},{"../internals/create-non-enumerable-property":145,"../internals/global":188,"../internals/has-own-property":189,"../internals/hidden-keys":190,"../internals/is-object":208,"../internals/shared-key":267,"../internals/shared-store":268,"../internals/weak-map-basic-detection":303}],200:[function(require,module,exports){
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var Iterators = require('../internals/iterators');

		var ITERATOR = wellKnownSymbol('iterator');
		var ArrayPrototype = Array.prototype;

		// check on default Array iterator
		module.exports = function (it) {
		  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
		};

		},{"../internals/iterators":218,"../internals/well-known-symbol":306}],201:[function(require,module,exports){
		var classof = require('../internals/classof-raw');

		// `IsArray` abstract operation
		// https://tc39.es/ecma262/#sec-isarray
		// eslint-disable-next-line es/no-array-isarray -- safe
		module.exports = Array.isArray || function isArray(argument) {
		  return classof(argument) === 'Array';
		};

		},{"../internals/classof-raw":137}],202:[function(require,module,exports){
		var classof = require('../internals/classof');

		module.exports = function (it) {
		  var klass = classof(it);
		  return klass === 'BigInt64Array' || klass === 'BigUint64Array';
		};

		},{"../internals/classof":138}],203:[function(require,module,exports){
		// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
		var documentAll = typeof document == 'object' && document.all;

		// `IsCallable` abstract operation
		// https://tc39.es/ecma262/#sec-iscallable
		// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
		module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
		  return typeof argument == 'function' || argument === documentAll;
		} : function (argument) {
		  return typeof argument == 'function';
		};

		},{}],204:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var fails = require('../internals/fails');
		var isCallable = require('../internals/is-callable');
		var classof = require('../internals/classof');
		var getBuiltIn = require('../internals/get-built-in');
		var inspectSource = require('../internals/inspect-source');

		var noop = function () { /* empty */ };
		var empty = [];
		var construct = getBuiltIn('Reflect', 'construct');
		var constructorRegExp = /^\s*(?:class|function)\b/;
		var exec = uncurryThis(constructorRegExp.exec);
		var INCORRECT_TO_STRING = !constructorRegExp.test(noop);

		var isConstructorModern = function isConstructor(argument) {
		  if (!isCallable(argument)) return false;
		  try {
		    construct(noop, empty, argument);
		    return true;
		  } catch (error) {
		    return false;
		  }
		};

		var isConstructorLegacy = function isConstructor(argument) {
		  if (!isCallable(argument)) return false;
		  switch (classof(argument)) {
		    case 'AsyncFunction':
		    case 'GeneratorFunction':
		    case 'AsyncGeneratorFunction': return false;
		  }
		  try {
		    // we can't check .prototype since constructors produced by .bind haven't it
		    // `Function#toString` throws on some built-it function in some legacy engines
		    // (for example, `DOMQuad` and similar in FF41-)
		    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
		  } catch (error) {
		    return true;
		  }
		};

		isConstructorLegacy.sham = true;

		// `IsConstructor` abstract operation
		// https://tc39.es/ecma262/#sec-isconstructor
		module.exports = !construct || fails(function () {
		  var called;
		  return isConstructorModern(isConstructorModern.call)
		    || !isConstructorModern(Object)
		    || !isConstructorModern(function () { called = true; })
		    || called;
		}) ? isConstructorLegacy : isConstructorModern;

		},{"../internals/classof":138,"../internals/fails":171,"../internals/function-uncurry-this":181,"../internals/get-built-in":182,"../internals/inspect-source":197,"../internals/is-callable":203}],205:[function(require,module,exports){
		var fails = require('../internals/fails');
		var isCallable = require('../internals/is-callable');

		var replacement = /#|\.prototype\./;

		var isForced = function (feature, detection) {
		  var value = data[normalize(feature)];
		  return value === POLYFILL ? true
		    : value === NATIVE ? false
		    : isCallable(detection) ? fails(detection)
		    : !!detection;
		};

		var normalize = isForced.normalize = function (string) {
		  return String(string).replace(replacement, '.').toLowerCase();
		};

		var data = isForced.data = {};
		var NATIVE = isForced.NATIVE = 'N';
		var POLYFILL = isForced.POLYFILL = 'P';

		module.exports = isForced;

		},{"../internals/fails":171,"../internals/is-callable":203}],206:[function(require,module,exports){
		var isObject = require('../internals/is-object');

		var floor = Math.floor;

		// `IsIntegralNumber` abstract operation
		// https://tc39.es/ecma262/#sec-isintegralnumber
		// eslint-disable-next-line es/no-number-isinteger -- safe
		module.exports = Number.isInteger || function isInteger(it) {
		  return !isObject(it) && isFinite(it) && floor(it) === it;
		};

		},{"../internals/is-object":208}],207:[function(require,module,exports){
		// we can't use just `it == null` since of `document.all` special case
		// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
		module.exports = function (it) {
		  return it === null || it === undefined;
		};

		},{}],208:[function(require,module,exports){
		var isCallable = require('../internals/is-callable');

		module.exports = function (it) {
		  return typeof it == 'object' ? it !== null : isCallable(it);
		};

		},{"../internals/is-callable":203}],209:[function(require,module,exports){
		var isObject = require('../internals/is-object');

		module.exports = function (argument) {
		  return isObject(argument) || argument === null;
		};

		},{"../internals/is-object":208}],210:[function(require,module,exports){
		module.exports = false;

		},{}],211:[function(require,module,exports){
		var isObject = require('../internals/is-object');
		var classof = require('../internals/classof-raw');
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var MATCH = wellKnownSymbol('match');

		// `IsRegExp` abstract operation
		// https://tc39.es/ecma262/#sec-isregexp
		module.exports = function (it) {
		  var isRegExp;
		  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) === 'RegExp');
		};

		},{"../internals/classof-raw":137,"../internals/is-object":208,"../internals/well-known-symbol":306}],212:[function(require,module,exports){
		var getBuiltIn = require('../internals/get-built-in');
		var isCallable = require('../internals/is-callable');
		var isPrototypeOf = require('../internals/object-is-prototype-of');
		var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');

		var $Object = Object;

		module.exports = USE_SYMBOL_AS_UID ? function (it) {
		  return typeof it == 'symbol';
		} : function (it) {
		  var $Symbol = getBuiltIn('Symbol');
		  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
		};

		},{"../internals/get-built-in":182,"../internals/is-callable":203,"../internals/object-is-prototype-of":238,"../internals/use-symbol-as-uid":300}],213:[function(require,module,exports){
		var bind = require('../internals/function-bind-context');
		var call = require('../internals/function-call');
		var anObject = require('../internals/an-object');
		var tryToString = require('../internals/try-to-string');
		var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var isPrototypeOf = require('../internals/object-is-prototype-of');
		var getIterator = require('../internals/get-iterator');
		var getIteratorMethod = require('../internals/get-iterator-method');
		var iteratorClose = require('../internals/iterator-close');

		var $TypeError = TypeError;

		var Result = function (stopped, result) {
		  this.stopped = stopped;
		  this.result = result;
		};

		var ResultPrototype = Result.prototype;

		module.exports = function (iterable, unboundFunction, options) {
		  var that = options && options.that;
		  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
		  var IS_RECORD = !!(options && options.IS_RECORD);
		  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
		  var INTERRUPTED = !!(options && options.INTERRUPTED);
		  var fn = bind(unboundFunction, that);
		  var iterator, iterFn, index, length, result, next, step;

		  var stop = function (condition) {
		    if (iterator) iteratorClose(iterator, 'normal', condition);
		    return new Result(true, condition);
		  };

		  var callFn = function (value) {
		    if (AS_ENTRIES) {
		      anObject(value);
		      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
		    } return INTERRUPTED ? fn(value, stop) : fn(value);
		  };

		  if (IS_RECORD) {
		    iterator = iterable.iterator;
		  } else if (IS_ITERATOR) {
		    iterator = iterable;
		  } else {
		    iterFn = getIteratorMethod(iterable);
		    if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
		    // optimisation for array iterators
		    if (isArrayIteratorMethod(iterFn)) {
		      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
		        result = callFn(iterable[index]);
		        if (result && isPrototypeOf(ResultPrototype, result)) return result;
		      } return new Result(false);
		    }
		    iterator = getIterator(iterable, iterFn);
		  }

		  next = IS_RECORD ? iterable.next : iterator.next;
		  while (!(step = call(next, iterator)).done) {
		    try {
		      result = callFn(step.value);
		    } catch (error) {
		      iteratorClose(iterator, 'throw', error);
		    }
		    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
		  } return new Result(false);
		};

		},{"../internals/an-object":114,"../internals/function-bind-context":175,"../internals/function-call":177,"../internals/get-iterator":184,"../internals/get-iterator-method":183,"../internals/is-array-iterator-method":200,"../internals/iterator-close":214,"../internals/length-of-array-like":219,"../internals/object-is-prototype-of":238,"../internals/try-to-string":293}],214:[function(require,module,exports){
		var call = require('../internals/function-call');
		var anObject = require('../internals/an-object');
		var getMethod = require('../internals/get-method');

		module.exports = function (iterator, kind, value) {
		  var innerResult, innerError;
		  anObject(iterator);
		  try {
		    innerResult = getMethod(iterator, 'return');
		    if (!innerResult) {
		      if (kind === 'throw') throw value;
		      return value;
		    }
		    innerResult = call(innerResult, iterator);
		  } catch (error) {
		    innerError = true;
		    innerResult = error;
		  }
		  if (kind === 'throw') throw value;
		  if (innerError) throw innerResult;
		  anObject(innerResult);
		  return value;
		};

		},{"../internals/an-object":114,"../internals/function-call":177,"../internals/get-method":186}],215:[function(require,module,exports){
		var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
		var create = require('../internals/object-create');
		var createPropertyDescriptor = require('../internals/create-property-descriptor');
		var setToStringTag = require('../internals/set-to-string-tag');
		var Iterators = require('../internals/iterators');

		var returnThis = function () { return this; };

		module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
		  var TO_STRING_TAG = NAME + ' Iterator';
		  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
		  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
		  Iterators[TO_STRING_TAG] = returnThis;
		  return IteratorConstructor;
		};

		},{"../internals/create-property-descriptor":146,"../internals/iterators":218,"../internals/iterators-core":217,"../internals/object-create":229,"../internals/set-to-string-tag":266}],216:[function(require,module,exports){
		var $ = require('../internals/export');
		var call = require('../internals/function-call');
		var IS_PURE = require('../internals/is-pure');
		var FunctionName = require('../internals/function-name');
		var isCallable = require('../internals/is-callable');
		var createIteratorConstructor = require('../internals/iterator-create-constructor');
		var getPrototypeOf = require('../internals/object-get-prototype-of');
		var setPrototypeOf = require('../internals/object-set-prototype-of');
		var setToStringTag = require('../internals/set-to-string-tag');
		var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
		var defineBuiltIn = require('../internals/define-built-in');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var Iterators = require('../internals/iterators');
		var IteratorsCore = require('../internals/iterators-core');

		var PROPER_FUNCTION_NAME = FunctionName.PROPER;
		var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
		var IteratorPrototype = IteratorsCore.IteratorPrototype;
		var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
		var ITERATOR = wellKnownSymbol('iterator');
		var KEYS = 'keys';
		var VALUES = 'values';
		var ENTRIES = 'entries';

		var returnThis = function () { return this; };

		module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
		  createIteratorConstructor(IteratorConstructor, NAME, next);

		  var getIterationMethod = function (KIND) {
		    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
		    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];

		    switch (KIND) {
		      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
		      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
		      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
		    }

		    return function () { return new IteratorConstructor(this); };
		  };

		  var TO_STRING_TAG = NAME + ' Iterator';
		  var INCORRECT_VALUES_NAME = false;
		  var IterablePrototype = Iterable.prototype;
		  var nativeIterator = IterablePrototype[ITERATOR]
		    || IterablePrototype['@@iterator']
		    || DEFAULT && IterablePrototype[DEFAULT];
		  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
		  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
		  var CurrentIteratorPrototype, methods, KEY;

		  // fix native
		  if (anyNativeIterator) {
		    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
		    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
		      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
		        if (setPrototypeOf) {
		          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
		        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
		          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
		        }
		      }
		      // Set @@toStringTag to native iterators
		      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
		      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
		    }
		  }

		  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
		  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
		    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
		      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
		    } else {
		      INCORRECT_VALUES_NAME = true;
		      defaultIterator = function values() { return call(nativeIterator, this); };
		    }
		  }

		  // export additional methods
		  if (DEFAULT) {
		    methods = {
		      values: getIterationMethod(VALUES),
		      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
		      entries: getIterationMethod(ENTRIES)
		    };
		    if (FORCED) for (KEY in methods) {
		      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
		        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
		      }
		    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
		  }

		  // define iterator
		  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
		    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
		  }
		  Iterators[NAME] = defaultIterator;

		  return methods;
		};

		},{"../internals/create-non-enumerable-property":145,"../internals/define-built-in":149,"../internals/export":170,"../internals/function-call":177,"../internals/function-name":178,"../internals/is-callable":203,"../internals/is-pure":210,"../internals/iterator-create-constructor":215,"../internals/iterators":218,"../internals/iterators-core":217,"../internals/object-get-prototype-of":236,"../internals/object-set-prototype-of":242,"../internals/set-to-string-tag":266,"../internals/well-known-symbol":306}],217:[function(require,module,exports){
		var fails = require('../internals/fails');
		var isCallable = require('../internals/is-callable');
		var isObject = require('../internals/is-object');
		var create = require('../internals/object-create');
		var getPrototypeOf = require('../internals/object-get-prototype-of');
		var defineBuiltIn = require('../internals/define-built-in');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var IS_PURE = require('../internals/is-pure');

		var ITERATOR = wellKnownSymbol('iterator');
		var BUGGY_SAFARI_ITERATORS = false;

		// `%IteratorPrototype%` object
		// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
		var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

		/* eslint-disable es/no-array-prototype-keys -- safe */
		if ([].keys) {
		  arrayIterator = [].keys();
		  // Safari 8 has buggy iterators w/o `next`
		  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
		  else {
		    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
		    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
		  }
		}

		var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
		  var test = {};
		  // FF44- legacy iterators case
		  return IteratorPrototype[ITERATOR].call(test) !== test;
		});

		if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
		else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

		// `%IteratorPrototype%[@@iterator]()` method
		// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
		if (!isCallable(IteratorPrototype[ITERATOR])) {
		  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
		    return this;
		  });
		}

		module.exports = {
		  IteratorPrototype: IteratorPrototype,
		  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
		};

		},{"../internals/define-built-in":149,"../internals/fails":171,"../internals/is-callable":203,"../internals/is-object":208,"../internals/is-pure":210,"../internals/object-create":229,"../internals/object-get-prototype-of":236,"../internals/well-known-symbol":306}],218:[function(require,module,exports){
		arguments[4][190][0].apply(exports,arguments);
		},{"dup":190}],219:[function(require,module,exports){
		var toLength = require('../internals/to-length');

		// `LengthOfArrayLike` abstract operation
		// https://tc39.es/ecma262/#sec-lengthofarraylike
		module.exports = function (obj) {
		  return toLength(obj.length);
		};

		},{"../internals/to-length":284}],220:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var fails = require('../internals/fails');
		var isCallable = require('../internals/is-callable');
		var hasOwn = require('../internals/has-own-property');
		var DESCRIPTORS = require('../internals/descriptors');
		var CONFIGURABLE_FUNCTION_NAME = require('../internals/function-name').CONFIGURABLE;
		var inspectSource = require('../internals/inspect-source');
		var InternalStateModule = require('../internals/internal-state');

		var enforceInternalState = InternalStateModule.enforce;
		var getInternalState = InternalStateModule.get;
		var $String = String;
		// eslint-disable-next-line es/no-object-defineproperty -- safe
		var defineProperty = Object.defineProperty;
		var stringSlice = uncurryThis(''.slice);
		var replace = uncurryThis(''.replace);
		var join = uncurryThis([].join);

		var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
		  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
		});

		var TEMPLATE = String(String).split('String');

		var makeBuiltIn = module.exports = function (value, name, options) {
		  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
		    name = '[' + replace($String(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
		  }
		  if (options && options.getter) name = 'get ' + name;
		  if (options && options.setter) name = 'set ' + name;
		  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
		    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
		    else value.name = name;
		  }
		  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
		    defineProperty(value, 'length', { value: options.arity });
		  }
		  try {
		    if (options && hasOwn(options, 'constructor') && options.constructor) {
		      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
		    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
		    } else if (value.prototype) value.prototype = undefined;
		  } catch (error) { /* empty */ }
		  var state = enforceInternalState(value);
		  if (!hasOwn(state, 'source')) {
		    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
		  } return value;
		};

		// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
		// eslint-disable-next-line no-extend-native -- required
		Function.prototype.toString = makeBuiltIn(function toString() {
		  return isCallable(this) && getInternalState(this).source || inspectSource(this);
		}, 'toString');

		},{"../internals/descriptors":153,"../internals/fails":171,"../internals/function-name":178,"../internals/function-uncurry-this":181,"../internals/has-own-property":189,"../internals/inspect-source":197,"../internals/internal-state":199,"../internals/is-callable":203}],221:[function(require,module,exports){
		var sign = require('../internals/math-sign');

		var abs = Math.abs;

		var EPSILON = 2.220446049250313e-16; // Number.EPSILON
		var INVERSE_EPSILON = 1 / EPSILON;

		var roundTiesToEven = function (n) {
		  return n + INVERSE_EPSILON - INVERSE_EPSILON;
		};

		module.exports = function (x, FLOAT_EPSILON, FLOAT_MAX_VALUE, FLOAT_MIN_VALUE) {
		  var n = +x;
		  var absolute = abs(n);
		  var s = sign(n);
		  if (absolute < FLOAT_MIN_VALUE) return s * roundTiesToEven(absolute / FLOAT_MIN_VALUE / FLOAT_EPSILON) * FLOAT_MIN_VALUE * FLOAT_EPSILON;
		  var a = (1 + FLOAT_EPSILON / EPSILON) * absolute;
		  var result = a - (a - absolute);
		  // eslint-disable-next-line no-self-compare -- NaN check
		  if (result > FLOAT_MAX_VALUE || result !== result) return s * Infinity;
		  return s * result;
		};

		},{"../internals/math-sign":223}],222:[function(require,module,exports){
		var floatRound = require('../internals/math-float-round');

		var FLOAT32_EPSILON = 1.1920928955078125e-7; // 2 ** -23;
		var FLOAT32_MAX_VALUE = 3.4028234663852886e+38; // 2 ** 128 - 2 ** 104
		var FLOAT32_MIN_VALUE = 1.1754943508222875e-38; // 2 ** -126;

		// `Math.fround` method implementation
		// https://tc39.es/ecma262/#sec-math.fround
		// eslint-disable-next-line es/no-math-fround -- safe
		module.exports = Math.fround || function fround(x) {
		  return floatRound(x, FLOAT32_EPSILON, FLOAT32_MAX_VALUE, FLOAT32_MIN_VALUE);
		};

		},{"../internals/math-float-round":221}],223:[function(require,module,exports){
		// `Math.sign` method implementation
		// https://tc39.es/ecma262/#sec-math.sign
		// eslint-disable-next-line es/no-math-sign -- safe
		module.exports = Math.sign || function sign(x) {
		  var n = +x;
		  // eslint-disable-next-line no-self-compare -- NaN check
		  return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
		};

		},{}],224:[function(require,module,exports){
		var ceil = Math.ceil;
		var floor = Math.floor;

		// `Math.trunc` method
		// https://tc39.es/ecma262/#sec-math.trunc
		// eslint-disable-next-line es/no-math-trunc -- safe
		module.exports = Math.trunc || function trunc(x) {
		  var n = +x;
		  return (n > 0 ? floor : ceil)(n);
		};

		},{}],225:[function(require,module,exports){
		var global = require('../internals/global');
		var safeGetBuiltIn = require('../internals/safe-get-built-in');
		var bind = require('../internals/function-bind-context');
		var macrotask = require('../internals/task').set;
		var Queue = require('../internals/queue');
		var IS_IOS = require('../internals/engine-is-ios');
		var IS_IOS_PEBBLE = require('../internals/engine-is-ios-pebble');
		var IS_WEBOS_WEBKIT = require('../internals/engine-is-webos-webkit');
		var IS_NODE = require('../internals/engine-is-node');

		var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
		var document = global.document;
		var process = global.process;
		var Promise = global.Promise;
		var microtask = safeGetBuiltIn('queueMicrotask');
		var notify, toggle, node, promise, then;

		// modern engines have queueMicrotask method
		if (!microtask) {
		  var queue = new Queue();

		  var flush = function () {
		    var parent, fn;
		    if (IS_NODE && (parent = process.domain)) parent.exit();
		    while (fn = queue.get()) try {
		      fn();
		    } catch (error) {
		      if (queue.head) notify();
		      throw error;
		    }
		    if (parent) parent.enter();
		  };

		  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
		  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
		  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
		    toggle = true;
		    node = document.createTextNode('');
		    new MutationObserver(flush).observe(node, { characterData: true });
		    notify = function () {
		      node.data = toggle = !toggle;
		    };
		  // environments with maybe non-completely correct, but existent Promise
		  } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
		    // Promise.resolve without an argument throws an error in LG WebOS 2
		    promise = Promise.resolve(undefined);
		    // workaround of WebKit ~ iOS Safari 10.1 bug
		    promise.constructor = Promise;
		    then = bind(promise.then, promise);
		    notify = function () {
		      then(flush);
		    };
		  // Node.js without promises
		  } else if (IS_NODE) {
		    notify = function () {
		      process.nextTick(flush);
		    };
		  // for other environments - macrotask based on:
		  // - setImmediate
		  // - MessageChannel
		  // - window.postMessage
		  // - onreadystatechange
		  // - setTimeout
		  } else {
		    // `webpack` dev server bug on IE global methods - use bind(fn, global)
		    macrotask = bind(macrotask, global);
		    notify = function () {
		      macrotask(flush);
		    };
		  }

		  microtask = function (fn) {
		    if (!queue.head) notify();
		    queue.add(fn);
		  };
		}

		module.exports = microtask;

		},{"../internals/engine-is-ios":163,"../internals/engine-is-ios-pebble":162,"../internals/engine-is-node":164,"../internals/engine-is-webos-webkit":165,"../internals/function-bind-context":175,"../internals/global":188,"../internals/queue":254,"../internals/safe-get-built-in":263,"../internals/task":277}],226:[function(require,module,exports){
		var aCallable = require('../internals/a-callable');

		var $TypeError = TypeError;

		var PromiseCapability = function (C) {
		  var resolve, reject;
		  this.promise = new C(function ($$resolve, $$reject) {
		    if (resolve !== undefined || reject !== undefined) throw new $TypeError('Bad Promise constructor');
		    resolve = $$resolve;
		    reject = $$reject;
		  });
		  this.resolve = aCallable(resolve);
		  this.reject = aCallable(reject);
		};

		// `NewPromiseCapability` abstract operation
		// https://tc39.es/ecma262/#sec-newpromisecapability
		module.exports.f = function (C) {
		  return new PromiseCapability(C);
		};

		},{"../internals/a-callable":108}],227:[function(require,module,exports){
		var isRegExp = require('../internals/is-regexp');

		var $TypeError = TypeError;

		module.exports = function (it) {
		  if (isRegExp(it)) {
		    throw new $TypeError("The method doesn't accept regular expressions");
		  } return it;
		};

		},{"../internals/is-regexp":211}],228:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var uncurryThis = require('../internals/function-uncurry-this');
		var call = require('../internals/function-call');
		var fails = require('../internals/fails');
		var objectKeys = require('../internals/object-keys');
		var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
		var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
		var toObject = require('../internals/to-object');
		var IndexedObject = require('../internals/indexed-object');

		// eslint-disable-next-line es/no-object-assign -- safe
		var $assign = Object.assign;
		// eslint-disable-next-line es/no-object-defineproperty -- required for testing
		var defineProperty = Object.defineProperty;
		var concat = uncurryThis([].concat);

		// `Object.assign` method
		// https://tc39.es/ecma262/#sec-object.assign
		module.exports = !$assign || fails(function () {
		  // should have correct order of operations (Edge bug)
		  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
		    enumerable: true,
		    get: function () {
		      defineProperty(this, 'b', {
		        value: 3,
		        enumerable: false
		      });
		    }
		  }), { b: 2 })).b !== 1) return true;
		  // should work with symbols and should have deterministic property order (V8 bug)
		  var A = {};
		  var B = {};
		  // eslint-disable-next-line es/no-symbol -- safe
		  var symbol = Symbol('assign detection');
		  var alphabet = 'abcdefghijklmnopqrst';
		  A[symbol] = 7;
		  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
		  return $assign({}, A)[symbol] !== 7 || objectKeys($assign({}, B)).join('') !== alphabet;
		}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
		  var T = toObject(target);
		  var argumentsLength = arguments.length;
		  var index = 1;
		  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
		  var propertyIsEnumerable = propertyIsEnumerableModule.f;
		  while (argumentsLength > index) {
		    var S = IndexedObject(arguments[index++]);
		    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
		    var length = keys.length;
		    var j = 0;
		    var key;
		    while (length > j) {
		      key = keys[j++];
		      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
		    }
		  } return T;
		} : $assign;

		},{"../internals/descriptors":153,"../internals/fails":171,"../internals/function-call":177,"../internals/function-uncurry-this":181,"../internals/indexed-object":195,"../internals/object-get-own-property-symbols":235,"../internals/object-keys":240,"../internals/object-property-is-enumerable":241,"../internals/to-object":285}],229:[function(require,module,exports){
		/* global ActiveXObject -- old IE, WSH */
		var anObject = require('../internals/an-object');
		var definePropertiesModule = require('../internals/object-define-properties');
		var enumBugKeys = require('../internals/enum-bug-keys');
		var hiddenKeys = require('../internals/hidden-keys');
		var html = require('../internals/html');
		var documentCreateElement = require('../internals/document-create-element');
		var sharedKey = require('../internals/shared-key');

		var GT = '>';
		var LT = '<';
		var PROTOTYPE = 'prototype';
		var SCRIPT = 'script';
		var IE_PROTO = sharedKey('IE_PROTO');

		var EmptyConstructor = function () { /* empty */ };

		var scriptTag = function (content) {
		  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
		};

		// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
		var NullProtoObjectViaActiveX = function (activeXDocument) {
		  activeXDocument.write(scriptTag(''));
		  activeXDocument.close();
		  var temp = activeXDocument.parentWindow.Object;
		  activeXDocument = null; // avoid memory leak
		  return temp;
		};

		// Create object with fake `null` prototype: use iframe Object with cleared prototype
		var NullProtoObjectViaIFrame = function () {
		  // Thrash, waste and sodomy: IE GC bug
		  var iframe = documentCreateElement('iframe');
		  var JS = 'java' + SCRIPT + ':';
		  var iframeDocument;
		  iframe.style.display = 'none';
		  html.appendChild(iframe);
		  // https://github.com/zloirock/core-js/issues/475
		  iframe.src = String(JS);
		  iframeDocument = iframe.contentWindow.document;
		  iframeDocument.open();
		  iframeDocument.write(scriptTag('document.F=Object'));
		  iframeDocument.close();
		  return iframeDocument.F;
		};

		// Check for document.domain and active x support
		// No need to use active x approach when document.domain is not set
		// see https://github.com/es-shims/es5-shim/issues/150
		// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
		// avoid IE GC bug
		var activeXDocument;
		var NullProtoObject = function () {
		  try {
		    activeXDocument = new ActiveXObject('htmlfile');
		  } catch (error) { /* ignore */ }
		  NullProtoObject = typeof document != 'undefined'
		    ? document.domain && activeXDocument
		      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
		      : NullProtoObjectViaIFrame()
		    : NullProtoObjectViaActiveX(activeXDocument); // WSH
		  var length = enumBugKeys.length;
		  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
		  return NullProtoObject();
		};

		hiddenKeys[IE_PROTO] = true;

		// `Object.create` method
		// https://tc39.es/ecma262/#sec-object.create
		// eslint-disable-next-line es/no-object-create -- safe
		module.exports = Object.create || function create(O, Properties) {
		  var result;
		  if (O !== null) {
		    EmptyConstructor[PROTOTYPE] = anObject(O);
		    result = new EmptyConstructor();
		    EmptyConstructor[PROTOTYPE] = null;
		    // add "__proto__" for Object.getPrototypeOf polyfill
		    result[IE_PROTO] = O;
		  } else result = NullProtoObject();
		  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
		};

		},{"../internals/an-object":114,"../internals/document-create-element":154,"../internals/enum-bug-keys":169,"../internals/hidden-keys":190,"../internals/html":192,"../internals/object-define-properties":230,"../internals/shared-key":267}],230:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');
		var definePropertyModule = require('../internals/object-define-property');
		var anObject = require('../internals/an-object');
		var toIndexedObject = require('../internals/to-indexed-object');
		var objectKeys = require('../internals/object-keys');

		// `Object.defineProperties` method
		// https://tc39.es/ecma262/#sec-object.defineproperties
		// eslint-disable-next-line es/no-object-defineproperties -- safe
		exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
		  anObject(O);
		  var props = toIndexedObject(Properties);
		  var keys = objectKeys(Properties);
		  var length = keys.length;
		  var index = 0;
		  var key;
		  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
		  return O;
		};

		},{"../internals/an-object":114,"../internals/descriptors":153,"../internals/object-define-property":231,"../internals/object-keys":240,"../internals/to-indexed-object":282,"../internals/v8-prototype-define-bug":301}],231:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
		var V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');
		var anObject = require('../internals/an-object');
		var toPropertyKey = require('../internals/to-property-key');

		var $TypeError = TypeError;
		// eslint-disable-next-line es/no-object-defineproperty -- safe
		var $defineProperty = Object.defineProperty;
		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
		var ENUMERABLE = 'enumerable';
		var CONFIGURABLE = 'configurable';
		var WRITABLE = 'writable';

		// `Object.defineProperty` method
		// https://tc39.es/ecma262/#sec-object.defineproperty
		exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
		  anObject(O);
		  P = toPropertyKey(P);
		  anObject(Attributes);
		  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
		    var current = $getOwnPropertyDescriptor(O, P);
		    if (current && current[WRITABLE]) {
		      O[P] = Attributes.value;
		      Attributes = {
		        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
		        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
		        writable: false
		      };
		    }
		  } return $defineProperty(O, P, Attributes);
		} : $defineProperty : function defineProperty(O, P, Attributes) {
		  anObject(O);
		  P = toPropertyKey(P);
		  anObject(Attributes);
		  if (IE8_DOM_DEFINE) try {
		    return $defineProperty(O, P, Attributes);
		  } catch (error) { /* empty */ }
		  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
		  if ('value' in Attributes) O[P] = Attributes.value;
		  return O;
		};

		},{"../internals/an-object":114,"../internals/descriptors":153,"../internals/ie8-dom-define":193,"../internals/to-property-key":289,"../internals/v8-prototype-define-bug":301}],232:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var call = require('../internals/function-call');
		var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
		var createPropertyDescriptor = require('../internals/create-property-descriptor');
		var toIndexedObject = require('../internals/to-indexed-object');
		var toPropertyKey = require('../internals/to-property-key');
		var hasOwn = require('../internals/has-own-property');
		var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');

		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

		// `Object.getOwnPropertyDescriptor` method
		// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
		exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
		  O = toIndexedObject(O);
		  P = toPropertyKey(P);
		  if (IE8_DOM_DEFINE) try {
		    return $getOwnPropertyDescriptor(O, P);
		  } catch (error) { /* empty */ }
		  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
		};

		},{"../internals/create-property-descriptor":146,"../internals/descriptors":153,"../internals/function-call":177,"../internals/has-own-property":189,"../internals/ie8-dom-define":193,"../internals/object-property-is-enumerable":241,"../internals/to-indexed-object":282,"../internals/to-property-key":289}],233:[function(require,module,exports){
		/* eslint-disable es/no-object-getownpropertynames -- safe */
		var classof = require('../internals/classof-raw');
		var toIndexedObject = require('../internals/to-indexed-object');
		var $getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
		var arraySlice = require('../internals/array-slice');

		var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
		  ? Object.getOwnPropertyNames(window) : [];

		var getWindowNames = function (it) {
		  try {
		    return $getOwnPropertyNames(it);
		  } catch (error) {
		    return arraySlice(windowNames);
		  }
		};

		// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
		module.exports.f = function getOwnPropertyNames(it) {
		  return windowNames && classof(it) === 'Window'
		    ? getWindowNames(it)
		    : $getOwnPropertyNames(toIndexedObject(it));
		};

		},{"../internals/array-slice":131,"../internals/classof-raw":137,"../internals/object-get-own-property-names":234,"../internals/to-indexed-object":282}],234:[function(require,module,exports){
		var internalObjectKeys = require('../internals/object-keys-internal');
		var enumBugKeys = require('../internals/enum-bug-keys');

		var hiddenKeys = enumBugKeys.concat('length', 'prototype');

		// `Object.getOwnPropertyNames` method
		// https://tc39.es/ecma262/#sec-object.getownpropertynames
		// eslint-disable-next-line es/no-object-getownpropertynames -- safe
		exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
		  return internalObjectKeys(O, hiddenKeys);
		};

		},{"../internals/enum-bug-keys":169,"../internals/object-keys-internal":239}],235:[function(require,module,exports){
		// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
		exports.f = Object.getOwnPropertySymbols;

		},{}],236:[function(require,module,exports){
		var hasOwn = require('../internals/has-own-property');
		var isCallable = require('../internals/is-callable');
		var toObject = require('../internals/to-object');
		var sharedKey = require('../internals/shared-key');
		var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');

		var IE_PROTO = sharedKey('IE_PROTO');
		var $Object = Object;
		var ObjectPrototype = $Object.prototype;

		// `Object.getPrototypeOf` method
		// https://tc39.es/ecma262/#sec-object.getprototypeof
		// eslint-disable-next-line es/no-object-getprototypeof -- safe
		module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
		  var object = toObject(O);
		  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
		  var constructor = object.constructor;
		  if (isCallable(constructor) && object instanceof constructor) {
		    return constructor.prototype;
		  } return object instanceof $Object ? ObjectPrototype : null;
		};

		},{"../internals/correct-prototype-getter":143,"../internals/has-own-property":189,"../internals/is-callable":203,"../internals/shared-key":267,"../internals/to-object":285}],237:[function(require,module,exports){
		var fails = require('../internals/fails');
		var isObject = require('../internals/is-object');
		var classof = require('../internals/classof-raw');
		var ARRAY_BUFFER_NON_EXTENSIBLE = require('../internals/array-buffer-non-extensible');

		// eslint-disable-next-line es/no-object-isextensible -- safe
		var $isExtensible = Object.isExtensible;
		var FAILS_ON_PRIMITIVES = fails(function () { });

		// `Object.isExtensible` method
		// https://tc39.es/ecma262/#sec-object.isextensible
		module.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
		  if (!isObject(it)) return false;
		  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === 'ArrayBuffer') return false;
		  return $isExtensible ? $isExtensible(it) : true;
		} : $isExtensible;

		},{"../internals/array-buffer-non-extensible":116,"../internals/classof-raw":137,"../internals/fails":171,"../internals/is-object":208}],238:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');

		module.exports = uncurryThis({}.isPrototypeOf);

		},{"../internals/function-uncurry-this":181}],239:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var hasOwn = require('../internals/has-own-property');
		var toIndexedObject = require('../internals/to-indexed-object');
		var indexOf = require('../internals/array-includes').indexOf;
		var hiddenKeys = require('../internals/hidden-keys');

		var push = uncurryThis([].push);

		module.exports = function (object, names) {
		  var O = toIndexedObject(object);
		  var i = 0;
		  var result = [];
		  var key;
		  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
		  // Don't enum bug & hidden keys
		  while (names.length > i) if (hasOwn(O, key = names[i++])) {
		    ~indexOf(result, key) || push(result, key);
		  }
		  return result;
		};

		},{"../internals/array-includes":124,"../internals/function-uncurry-this":181,"../internals/has-own-property":189,"../internals/hidden-keys":190,"../internals/to-indexed-object":282}],240:[function(require,module,exports){
		var internalObjectKeys = require('../internals/object-keys-internal');
		var enumBugKeys = require('../internals/enum-bug-keys');

		// `Object.keys` method
		// https://tc39.es/ecma262/#sec-object.keys
		// eslint-disable-next-line es/no-object-keys -- safe
		module.exports = Object.keys || function keys(O) {
		  return internalObjectKeys(O, enumBugKeys);
		};

		},{"../internals/enum-bug-keys":169,"../internals/object-keys-internal":239}],241:[function(require,module,exports){
		var $propertyIsEnumerable = {}.propertyIsEnumerable;
		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

		// Nashorn ~ JDK8 bug
		var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

		// `Object.prototype.propertyIsEnumerable` method implementation
		// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
		exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
		  var descriptor = getOwnPropertyDescriptor(this, V);
		  return !!descriptor && descriptor.enumerable;
		} : $propertyIsEnumerable;

		},{}],242:[function(require,module,exports){
		/* eslint-disable no-proto -- safe */
		var uncurryThisAccessor = require('../internals/function-uncurry-this-accessor');
		var anObject = require('../internals/an-object');
		var aPossiblePrototype = require('../internals/a-possible-prototype');

		// `Object.setPrototypeOf` method
		// https://tc39.es/ecma262/#sec-object.setprototypeof
		// Works with __proto__ only. Old v8 can't work with null proto objects.
		// eslint-disable-next-line es/no-object-setprototypeof -- safe
		module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
		  var CORRECT_SETTER = false;
		  var test = {};
		  var setter;
		  try {
		    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
		    setter(test, []);
		    CORRECT_SETTER = test instanceof Array;
		  } catch (error) { /* empty */ }
		  return function setPrototypeOf(O, proto) {
		    anObject(O);
		    aPossiblePrototype(proto);
		    if (CORRECT_SETTER) setter(O, proto);
		    else O.__proto__ = proto;
		    return O;
		  };
		}() : undefined);

		},{"../internals/a-possible-prototype":110,"../internals/an-object":114,"../internals/function-uncurry-this-accessor":179}],243:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var fails = require('../internals/fails');
		var uncurryThis = require('../internals/function-uncurry-this');
		var objectGetPrototypeOf = require('../internals/object-get-prototype-of');
		var objectKeys = require('../internals/object-keys');
		var toIndexedObject = require('../internals/to-indexed-object');
		var $propertyIsEnumerable = require('../internals/object-property-is-enumerable').f;

		var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
		var push = uncurryThis([].push);

		// in some IE versions, `propertyIsEnumerable` returns incorrect result on integer keys
		// of `null` prototype objects
		var IE_BUG = DESCRIPTORS && fails(function () {
		  // eslint-disable-next-line es/no-object-create -- safe
		  var O = Object.create(null);
		  O[2] = 2;
		  return !propertyIsEnumerable(O, 2);
		});

		// `Object.{ entries, values }` methods implementation
		var createMethod = function (TO_ENTRIES) {
		  return function (it) {
		    var O = toIndexedObject(it);
		    var keys = objectKeys(O);
		    var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
		    var length = keys.length;
		    var i = 0;
		    var result = [];
		    var key;
		    while (length > i) {
		      key = keys[i++];
		      if (!DESCRIPTORS || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
		        push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
		      }
		    }
		    return result;
		  };
		};

		module.exports = {
		  // `Object.entries` method
		  // https://tc39.es/ecma262/#sec-object.entries
		  entries: createMethod(true),
		  // `Object.values` method
		  // https://tc39.es/ecma262/#sec-object.values
		  values: createMethod(false)
		};

		},{"../internals/descriptors":153,"../internals/fails":171,"../internals/function-uncurry-this":181,"../internals/object-get-prototype-of":236,"../internals/object-keys":240,"../internals/object-property-is-enumerable":241,"../internals/to-indexed-object":282}],244:[function(require,module,exports){
		var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
		var classof = require('../internals/classof');

		// `Object.prototype.toString` method implementation
		// https://tc39.es/ecma262/#sec-object.prototype.tostring
		module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
		  return '[object ' + classof(this) + ']';
		};

		},{"../internals/classof":138,"../internals/to-string-tag-support":290}],245:[function(require,module,exports){
		var call = require('../internals/function-call');
		var isCallable = require('../internals/is-callable');
		var isObject = require('../internals/is-object');

		var $TypeError = TypeError;

		// `OrdinaryToPrimitive` abstract operation
		// https://tc39.es/ecma262/#sec-ordinarytoprimitive
		module.exports = function (input, pref) {
		  var fn, val;
		  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
		  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
		  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
		  throw new $TypeError("Can't convert object to primitive value");
		};

		},{"../internals/function-call":177,"../internals/is-callable":203,"../internals/is-object":208}],246:[function(require,module,exports){
		var getBuiltIn = require('../internals/get-built-in');
		var uncurryThis = require('../internals/function-uncurry-this');
		var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
		var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
		var anObject = require('../internals/an-object');

		var concat = uncurryThis([].concat);

		// all object keys, includes non-enumerable and symbols
		module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
		  var keys = getOwnPropertyNamesModule.f(anObject(it));
		  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
		  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
		};

		},{"../internals/an-object":114,"../internals/function-uncurry-this":181,"../internals/get-built-in":182,"../internals/object-get-own-property-names":234,"../internals/object-get-own-property-symbols":235}],247:[function(require,module,exports){
		var global = require('../internals/global');

		module.exports = global;

		},{"../internals/global":188}],248:[function(require,module,exports){
		module.exports = function (exec) {
		  try {
		    return { error: false, value: exec() };
		  } catch (error) {
		    return { error: true, value: error };
		  }
		};

		},{}],249:[function(require,module,exports){
		var global = require('../internals/global');
		var NativePromiseConstructor = require('../internals/promise-native-constructor');
		var isCallable = require('../internals/is-callable');
		var isForced = require('../internals/is-forced');
		var inspectSource = require('../internals/inspect-source');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var IS_BROWSER = require('../internals/engine-is-browser');
		var IS_DENO = require('../internals/engine-is-deno');
		var IS_PURE = require('../internals/is-pure');
		var V8_VERSION = require('../internals/engine-v8-version');

		var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
		var SPECIES = wellKnownSymbol('species');
		var SUBCLASSING = false;
		var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);

		var FORCED_PROMISE_CONSTRUCTOR = isForced('Promise', function () {
		  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
		  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
		  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
		  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
		  // We can't detect it synchronously, so just check versions
		  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
		  // We need Promise#{ catch, finally } in the pure version for preventing prototype pollution
		  if (IS_PURE && !(NativePromisePrototype['catch'] && NativePromisePrototype['finally'])) return true;
		  // We can't use @@species feature detection in V8 since it causes
		  // deoptimization and performance degradation
		  // https://github.com/zloirock/core-js/issues/679
		  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
		    // Detect correctness of subclassing with @@species support
		    var promise = new NativePromiseConstructor(function (resolve) { resolve(1); });
		    var FakePromise = function (exec) {
		      exec(function () { /* empty */ }, function () { /* empty */ });
		    };
		    var constructor = promise.constructor = {};
		    constructor[SPECIES] = FakePromise;
		    SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
		    if (!SUBCLASSING) return true;
		  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
		  } return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
		});

		module.exports = {
		  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
		  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
		  SUBCLASSING: SUBCLASSING
		};

		},{"../internals/engine-is-browser":159,"../internals/engine-is-deno":160,"../internals/engine-v8-version":167,"../internals/global":188,"../internals/inspect-source":197,"../internals/is-callable":203,"../internals/is-forced":205,"../internals/is-pure":210,"../internals/promise-native-constructor":250,"../internals/well-known-symbol":306}],250:[function(require,module,exports){
		var global = require('../internals/global');

		module.exports = global.Promise;

		},{"../internals/global":188}],251:[function(require,module,exports){
		var anObject = require('../internals/an-object');
		var isObject = require('../internals/is-object');
		var newPromiseCapability = require('../internals/new-promise-capability');

		module.exports = function (C, x) {
		  anObject(C);
		  if (isObject(x) && x.constructor === C) return x;
		  var promiseCapability = newPromiseCapability.f(C);
		  var resolve = promiseCapability.resolve;
		  resolve(x);
		  return promiseCapability.promise;
		};

		},{"../internals/an-object":114,"../internals/is-object":208,"../internals/new-promise-capability":226}],252:[function(require,module,exports){
		var NativePromiseConstructor = require('../internals/promise-native-constructor');
		var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
		var FORCED_PROMISE_CONSTRUCTOR = require('../internals/promise-constructor-detection').CONSTRUCTOR;

		module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function (iterable) {
		  NativePromiseConstructor.all(iterable).then(undefined, function () { /* empty */ });
		});

		},{"../internals/check-correctness-of-iteration":136,"../internals/promise-constructor-detection":249,"../internals/promise-native-constructor":250}],253:[function(require,module,exports){
		var defineProperty = require('../internals/object-define-property').f;

		module.exports = function (Target, Source, key) {
		  key in Target || defineProperty(Target, key, {
		    configurable: true,
		    get: function () { return Source[key]; },
		    set: function (it) { Source[key] = it; }
		  });
		};

		},{"../internals/object-define-property":231}],254:[function(require,module,exports){
		var Queue = function () {
		  this.head = null;
		  this.tail = null;
		};

		Queue.prototype = {
		  add: function (item) {
		    var entry = { item: item, next: null };
		    var tail = this.tail;
		    if (tail) tail.next = entry;
		    else this.head = entry;
		    this.tail = entry;
		  },
		  get: function () {
		    var entry = this.head;
		    if (entry) {
		      var next = this.head = entry.next;
		      if (next === null) this.tail = null;
		      return entry.item;
		    }
		  }
		};

		module.exports = Queue;

		},{}],255:[function(require,module,exports){
		var call = require('../internals/function-call');
		var anObject = require('../internals/an-object');
		var isCallable = require('../internals/is-callable');
		var classof = require('../internals/classof-raw');
		var regexpExec = require('../internals/regexp-exec');

		var $TypeError = TypeError;

		// `RegExpExec` abstract operation
		// https://tc39.es/ecma262/#sec-regexpexec
		module.exports = function (R, S) {
		  var exec = R.exec;
		  if (isCallable(exec)) {
		    var result = call(exec, R, S);
		    if (result !== null) anObject(result);
		    return result;
		  }
		  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
		  throw new $TypeError('RegExp#exec called on incompatible receiver');
		};

		},{"../internals/an-object":114,"../internals/classof-raw":137,"../internals/function-call":177,"../internals/is-callable":203,"../internals/regexp-exec":256}],256:[function(require,module,exports){
		/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
		/* eslint-disable regexp/no-useless-quantifier -- testing */
		var call = require('../internals/function-call');
		var uncurryThis = require('../internals/function-uncurry-this');
		var toString = require('../internals/to-string');
		var regexpFlags = require('../internals/regexp-flags');
		var stickyHelpers = require('../internals/regexp-sticky-helpers');
		var shared = require('../internals/shared');
		var create = require('../internals/object-create');
		var getInternalState = require('../internals/internal-state').get;
		var UNSUPPORTED_DOT_ALL = require('../internals/regexp-unsupported-dot-all');
		var UNSUPPORTED_NCG = require('../internals/regexp-unsupported-ncg');

		var nativeReplace = shared('native-string-replace', String.prototype.replace);
		var nativeExec = RegExp.prototype.exec;
		var patchedExec = nativeExec;
		var charAt = uncurryThis(''.charAt);
		var indexOf = uncurryThis(''.indexOf);
		var replace = uncurryThis(''.replace);
		var stringSlice = uncurryThis(''.slice);

		var UPDATES_LAST_INDEX_WRONG = (function () {
		  var re1 = /a/;
		  var re2 = /b*/g;
		  call(nativeExec, re1, 'a');
		  call(nativeExec, re2, 'a');
		  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
		})();

		var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

		// nonparticipating capturing group, copied from es5-shim's String#split patch.
		var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

		var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

		if (PATCH) {
		  patchedExec = function exec(string) {
		    var re = this;
		    var state = getInternalState(re);
		    var str = toString(string);
		    var raw = state.raw;
		    var result, reCopy, lastIndex, match, i, object, group;

		    if (raw) {
		      raw.lastIndex = re.lastIndex;
		      result = call(patchedExec, raw, str);
		      re.lastIndex = raw.lastIndex;
		      return result;
		    }

		    var groups = state.groups;
		    var sticky = UNSUPPORTED_Y && re.sticky;
		    var flags = call(regexpFlags, re);
		    var source = re.source;
		    var charsAdded = 0;
		    var strCopy = str;

		    if (sticky) {
		      flags = replace(flags, 'y', '');
		      if (indexOf(flags, 'g') === -1) {
		        flags += 'g';
		      }

		      strCopy = stringSlice(str, re.lastIndex);
		      // Support anchored sticky behavior.
		      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
		        source = '(?: ' + source + ')';
		        strCopy = ' ' + strCopy;
		        charsAdded++;
		      }
		      // ^(? + rx + ) is needed, in combination with some str slicing, to
		      // simulate the 'y' flag.
		      reCopy = new RegExp('^(?:' + source + ')', flags);
		    }

		    if (NPCG_INCLUDED) {
		      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
		    }
		    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

		    match = call(nativeExec, sticky ? reCopy : re, strCopy);

		    if (sticky) {
		      if (match) {
		        match.input = stringSlice(match.input, charsAdded);
		        match[0] = stringSlice(match[0], charsAdded);
		        match.index = re.lastIndex;
		        re.lastIndex += match[0].length;
		      } else re.lastIndex = 0;
		    } else if (UPDATES_LAST_INDEX_WRONG && match) {
		      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
		    }
		    if (NPCG_INCLUDED && match && match.length > 1) {
		      // Fix browsers whose `exec` methods don't consistently return `undefined`
		      // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
		      call(nativeReplace, match[0], reCopy, function () {
		        for (i = 1; i < arguments.length - 2; i++) {
		          if (arguments[i] === undefined) match[i] = undefined;
		        }
		      });
		    }

		    if (match && groups) {
		      match.groups = object = create(null);
		      for (i = 0; i < groups.length; i++) {
		        group = groups[i];
		        object[group[0]] = match[group[1]];
		      }
		    }

		    return match;
		  };
		}

		module.exports = patchedExec;

		},{"../internals/function-call":177,"../internals/function-uncurry-this":181,"../internals/internal-state":199,"../internals/object-create":229,"../internals/regexp-flags":257,"../internals/regexp-sticky-helpers":259,"../internals/regexp-unsupported-dot-all":260,"../internals/regexp-unsupported-ncg":261,"../internals/shared":269,"../internals/to-string":291}],257:[function(require,module,exports){
		var anObject = require('../internals/an-object');

		// `RegExp.prototype.flags` getter implementation
		// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
		module.exports = function () {
		  var that = anObject(this);
		  var result = '';
		  if (that.hasIndices) result += 'd';
		  if (that.global) result += 'g';
		  if (that.ignoreCase) result += 'i';
		  if (that.multiline) result += 'm';
		  if (that.dotAll) result += 's';
		  if (that.unicode) result += 'u';
		  if (that.unicodeSets) result += 'v';
		  if (that.sticky) result += 'y';
		  return result;
		};

		},{"../internals/an-object":114}],258:[function(require,module,exports){
		var call = require('../internals/function-call');
		var hasOwn = require('../internals/has-own-property');
		var isPrototypeOf = require('../internals/object-is-prototype-of');
		var regExpFlags = require('../internals/regexp-flags');

		var RegExpPrototype = RegExp.prototype;

		module.exports = function (R) {
		  var flags = R.flags;
		  return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R)
		    ? call(regExpFlags, R) : flags;
		};

		},{"../internals/function-call":177,"../internals/has-own-property":189,"../internals/object-is-prototype-of":238,"../internals/regexp-flags":257}],259:[function(require,module,exports){
		var fails = require('../internals/fails');
		var global = require('../internals/global');

		// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
		var $RegExp = global.RegExp;

		var UNSUPPORTED_Y = fails(function () {
		  var re = $RegExp('a', 'y');
		  re.lastIndex = 2;
		  return re.exec('abcd') !== null;
		});

		// UC Browser bug
		// https://github.com/zloirock/core-js/issues/1008
		var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
		  return !$RegExp('a', 'y').sticky;
		});

		var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
		  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
		  var re = $RegExp('^r', 'gy');
		  re.lastIndex = 2;
		  return re.exec('str') !== null;
		});

		module.exports = {
		  BROKEN_CARET: BROKEN_CARET,
		  MISSED_STICKY: MISSED_STICKY,
		  UNSUPPORTED_Y: UNSUPPORTED_Y
		};

		},{"../internals/fails":171,"../internals/global":188}],260:[function(require,module,exports){
		var fails = require('../internals/fails');
		var global = require('../internals/global');

		// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
		var $RegExp = global.RegExp;

		module.exports = fails(function () {
		  var re = $RegExp('.', 's');
		  return !(re.dotAll && re.test('\n') && re.flags === 's');
		});

		},{"../internals/fails":171,"../internals/global":188}],261:[function(require,module,exports){
		var fails = require('../internals/fails');
		var global = require('../internals/global');

		// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
		var $RegExp = global.RegExp;

		module.exports = fails(function () {
		  var re = $RegExp('(?<a>b)', 'g');
		  return re.exec('b').groups.a !== 'b' ||
		    'b'.replace(re, '$<a>c') !== 'bc';
		});

		},{"../internals/fails":171,"../internals/global":188}],262:[function(require,module,exports){
		var isNullOrUndefined = require('../internals/is-null-or-undefined');

		var $TypeError = TypeError;

		// `RequireObjectCoercible` abstract operation
		// https://tc39.es/ecma262/#sec-requireobjectcoercible
		module.exports = function (it) {
		  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
		  return it;
		};

		},{"../internals/is-null-or-undefined":207}],263:[function(require,module,exports){
		var global = require('../internals/global');
		var DESCRIPTORS = require('../internals/descriptors');

		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

		// Avoid NodeJS experimental warning
		module.exports = function (name) {
		  if (!DESCRIPTORS) return global[name];
		  var descriptor = getOwnPropertyDescriptor(global, name);
		  return descriptor && descriptor.value;
		};

		},{"../internals/descriptors":153,"../internals/global":188}],264:[function(require,module,exports){
		// `SameValue` abstract operation
		// https://tc39.es/ecma262/#sec-samevalue
		// eslint-disable-next-line es/no-object-is -- safe
		module.exports = Object.is || function is(x, y) {
		  // eslint-disable-next-line no-self-compare -- NaN check
		  return x === y ? x !== 0 || 1 / x === 1 / y : x !== x && y !== y;
		};

		},{}],265:[function(require,module,exports){
		var getBuiltIn = require('../internals/get-built-in');
		var defineBuiltInAccessor = require('../internals/define-built-in-accessor');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var DESCRIPTORS = require('../internals/descriptors');

		var SPECIES = wellKnownSymbol('species');

		module.exports = function (CONSTRUCTOR_NAME) {
		  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);

		  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
		    defineBuiltInAccessor(Constructor, SPECIES, {
		      configurable: true,
		      get: function () { return this; }
		    });
		  }
		};

		},{"../internals/define-built-in-accessor":148,"../internals/descriptors":153,"../internals/get-built-in":182,"../internals/well-known-symbol":306}],266:[function(require,module,exports){
		var defineProperty = require('../internals/object-define-property').f;
		var hasOwn = require('../internals/has-own-property');
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var TO_STRING_TAG = wellKnownSymbol('toStringTag');

		module.exports = function (target, TAG, STATIC) {
		  if (target && !STATIC) target = target.prototype;
		  if (target && !hasOwn(target, TO_STRING_TAG)) {
		    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
		  }
		};

		},{"../internals/has-own-property":189,"../internals/object-define-property":231,"../internals/well-known-symbol":306}],267:[function(require,module,exports){
		var shared = require('../internals/shared');
		var uid = require('../internals/uid');

		var keys = shared('keys');

		module.exports = function (key) {
		  return keys[key] || (keys[key] = uid(key));
		};

		},{"../internals/shared":269,"../internals/uid":299}],268:[function(require,module,exports){
		var global = require('../internals/global');
		var defineGlobalProperty = require('../internals/define-global-property');

		var SHARED = '__core-js_shared__';
		var store = global[SHARED] || defineGlobalProperty(SHARED, {});

		module.exports = store;

		},{"../internals/define-global-property":151,"../internals/global":188}],269:[function(require,module,exports){
		var IS_PURE = require('../internals/is-pure');
		var store = require('../internals/shared-store');

		(module.exports = function (key, value) {
		  return store[key] || (store[key] = value !== undefined ? value : {});
		})('versions', []).push({
		  version: '3.35.0',
		  mode: IS_PURE ? 'pure' : 'global',
		  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',
		  license: 'https://github.com/zloirock/core-js/blob/v3.35.0/LICENSE',
		  source: 'https://github.com/zloirock/core-js'
		});

		},{"../internals/is-pure":210,"../internals/shared-store":268}],270:[function(require,module,exports){
		var anObject = require('../internals/an-object');
		var aConstructor = require('../internals/a-constructor');
		var isNullOrUndefined = require('../internals/is-null-or-undefined');
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var SPECIES = wellKnownSymbol('species');

		// `SpeciesConstructor` abstract operation
		// https://tc39.es/ecma262/#sec-speciesconstructor
		module.exports = function (O, defaultConstructor) {
		  var C = anObject(O).constructor;
		  var S;
		  return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
		};

		},{"../internals/a-constructor":109,"../internals/an-object":114,"../internals/is-null-or-undefined":207,"../internals/well-known-symbol":306}],271:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
		var toString = require('../internals/to-string');
		var requireObjectCoercible = require('../internals/require-object-coercible');

		var charAt = uncurryThis(''.charAt);
		var charCodeAt = uncurryThis(''.charCodeAt);
		var stringSlice = uncurryThis(''.slice);

		var createMethod = function (CONVERT_TO_STRING) {
		  return function ($this, pos) {
		    var S = toString(requireObjectCoercible($this));
		    var position = toIntegerOrInfinity(pos);
		    var size = S.length;
		    var first, second;
		    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
		    first = charCodeAt(S, position);
		    return first < 0xD800 || first > 0xDBFF || position + 1 === size
		      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
		        ? CONVERT_TO_STRING
		          ? charAt(S, position)
		          : first
		        : CONVERT_TO_STRING
		          ? stringSlice(S, position, position + 2)
		          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
		  };
		};

		module.exports = {
		  // `String.prototype.codePointAt` method
		  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
		  codeAt: createMethod(false),
		  // `String.prototype.at` method
		  // https://github.com/mathiasbynens/String.prototype.at
		  charAt: createMethod(true)
		};

		},{"../internals/function-uncurry-this":181,"../internals/require-object-coercible":262,"../internals/to-integer-or-infinity":283,"../internals/to-string":291}],272:[function(require,module,exports){
		var PROPER_FUNCTION_NAME = require('../internals/function-name').PROPER;
		var fails = require('../internals/fails');
		var whitespaces = require('../internals/whitespaces');

		var non = '\u200B\u0085\u180E';

		// check that a method works with the correct list
		// of whitespaces and has a correct name
		module.exports = function (METHOD_NAME) {
		  return fails(function () {
		    return !!whitespaces[METHOD_NAME]()
		      || non[METHOD_NAME]() !== non
		      || (PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME);
		  });
		};

		},{"../internals/fails":171,"../internals/function-name":178,"../internals/whitespaces":307}],273:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var requireObjectCoercible = require('../internals/require-object-coercible');
		var toString = require('../internals/to-string');
		var whitespaces = require('../internals/whitespaces');

		var replace = uncurryThis(''.replace);
		var ltrim = RegExp('^[' + whitespaces + ']+');
		var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

		// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
		var createMethod = function (TYPE) {
		  return function ($this) {
		    var string = toString(requireObjectCoercible($this));
		    if (TYPE & 1) string = replace(string, ltrim, '');
		    if (TYPE & 2) string = replace(string, rtrim, '$1');
		    return string;
		  };
		};

		module.exports = {
		  // `String.prototype.{ trimLeft, trimStart }` methods
		  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
		  start: createMethod(1),
		  // `String.prototype.{ trimRight, trimEnd }` methods
		  // https://tc39.es/ecma262/#sec-string.prototype.trimend
		  end: createMethod(2),
		  // `String.prototype.trim` method
		  // https://tc39.es/ecma262/#sec-string.prototype.trim
		  trim: createMethod(3)
		};

		},{"../internals/function-uncurry-this":181,"../internals/require-object-coercible":262,"../internals/to-string":291,"../internals/whitespaces":307}],274:[function(require,module,exports){
		/* eslint-disable es/no-symbol -- required for testing */
		var V8_VERSION = require('../internals/engine-v8-version');
		var fails = require('../internals/fails');
		var global = require('../internals/global');

		var $String = global.String;

		// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
		module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
		  var symbol = Symbol('symbol detection');
		  // Chrome 38 Symbol has incorrect toString conversion
		  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
		  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
		  // of course, fail.
		  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
		    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
		    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
		});

		},{"../internals/engine-v8-version":167,"../internals/fails":171,"../internals/global":188}],275:[function(require,module,exports){
		var call = require('../internals/function-call');
		var getBuiltIn = require('../internals/get-built-in');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var defineBuiltIn = require('../internals/define-built-in');

		module.exports = function () {
		  var Symbol = getBuiltIn('Symbol');
		  var SymbolPrototype = Symbol && Symbol.prototype;
		  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
		  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

		  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
		    // `Symbol.prototype[@@toPrimitive]` method
		    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
		    // eslint-disable-next-line no-unused-vars -- required for .length
		    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
		      return call(valueOf, this);
		    }, { arity: 1 });
		  }
		};

		},{"../internals/define-built-in":149,"../internals/function-call":177,"../internals/get-built-in":182,"../internals/well-known-symbol":306}],276:[function(require,module,exports){
		var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');

		/* eslint-disable es/no-symbol -- safe */
		module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;

		},{"../internals/symbol-constructor-detection":274}],277:[function(require,module,exports){
		var global = require('../internals/global');
		var apply = require('../internals/function-apply');
		var bind = require('../internals/function-bind-context');
		var isCallable = require('../internals/is-callable');
		var hasOwn = require('../internals/has-own-property');
		var fails = require('../internals/fails');
		var html = require('../internals/html');
		var arraySlice = require('../internals/array-slice');
		var createElement = require('../internals/document-create-element');
		var validateArgumentsLength = require('../internals/validate-arguments-length');
		var IS_IOS = require('../internals/engine-is-ios');
		var IS_NODE = require('../internals/engine-is-node');

		var set = global.setImmediate;
		var clear = global.clearImmediate;
		var process = global.process;
		var Dispatch = global.Dispatch;
		var Function = global.Function;
		var MessageChannel = global.MessageChannel;
		var String = global.String;
		var counter = 0;
		var queue = {};
		var ONREADYSTATECHANGE = 'onreadystatechange';
		var $location, defer, channel, port;

		fails(function () {
		  // Deno throws a ReferenceError on `location` access without `--location` flag
		  $location = global.location;
		});

		var run = function (id) {
		  if (hasOwn(queue, id)) {
		    var fn = queue[id];
		    delete queue[id];
		    fn();
		  }
		};

		var runner = function (id) {
		  return function () {
		    run(id);
		  };
		};

		var eventListener = function (event) {
		  run(event.data);
		};

		var globalPostMessageDefer = function (id) {
		  // old engines have not location.origin
		  global.postMessage(String(id), $location.protocol + '//' + $location.host);
		};

		// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
		if (!set || !clear) {
		  set = function setImmediate(handler) {
		    validateArgumentsLength(arguments.length, 1);
		    var fn = isCallable(handler) ? handler : Function(handler);
		    var args = arraySlice(arguments, 1);
		    queue[++counter] = function () {
		      apply(fn, undefined, args);
		    };
		    defer(counter);
		    return counter;
		  };
		  clear = function clearImmediate(id) {
		    delete queue[id];
		  };
		  // Node.js 0.8-
		  if (IS_NODE) {
		    defer = function (id) {
		      process.nextTick(runner(id));
		    };
		  // Sphere (JS game engine) Dispatch API
		  } else if (Dispatch && Dispatch.now) {
		    defer = function (id) {
		      Dispatch.now(runner(id));
		    };
		  // Browsers with MessageChannel, includes WebWorkers
		  // except iOS - https://github.com/zloirock/core-js/issues/624
		  } else if (MessageChannel && !IS_IOS) {
		    channel = new MessageChannel();
		    port = channel.port2;
		    channel.port1.onmessage = eventListener;
		    defer = bind(port.postMessage, port);
		  // Browsers with postMessage, skip WebWorkers
		  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
		  } else if (
		    global.addEventListener &&
		    isCallable(global.postMessage) &&
		    !global.importScripts &&
		    $location && $location.protocol !== 'file:' &&
		    !fails(globalPostMessageDefer)
		  ) {
		    defer = globalPostMessageDefer;
		    global.addEventListener('message', eventListener, false);
		  // IE8-
		  } else if (ONREADYSTATECHANGE in createElement('script')) {
		    defer = function (id) {
		      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
		        html.removeChild(this);
		        run(id);
		      };
		    };
		  // Rest old browsers
		  } else {
		    defer = function (id) {
		      setTimeout(runner(id), 0);
		    };
		  }
		}

		module.exports = {
		  set: set,
		  clear: clear
		};

		},{"../internals/array-slice":131,"../internals/document-create-element":154,"../internals/engine-is-ios":163,"../internals/engine-is-node":164,"../internals/fails":171,"../internals/function-apply":174,"../internals/function-bind-context":175,"../internals/global":188,"../internals/has-own-property":189,"../internals/html":192,"../internals/is-callable":203,"../internals/validate-arguments-length":302}],278:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');

		// `thisNumberValue` abstract operation
		// https://tc39.es/ecma262/#sec-thisnumbervalue
		module.exports = uncurryThis(1.0.valueOf);

		},{"../internals/function-uncurry-this":181}],279:[function(require,module,exports){
		var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');

		var max = Math.max;
		var min = Math.min;

		// Helper for a popular repeating case of the spec:
		// Let integer be ? ToInteger(index).
		// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
		module.exports = function (index, length) {
		  var integer = toIntegerOrInfinity(index);
		  return integer < 0 ? max(integer + length, 0) : min(integer, length);
		};

		},{"../internals/to-integer-or-infinity":283}],280:[function(require,module,exports){
		var toPrimitive = require('../internals/to-primitive');

		var $TypeError = TypeError;

		// `ToBigInt` abstract operation
		// https://tc39.es/ecma262/#sec-tobigint
		module.exports = function (argument) {
		  var prim = toPrimitive(argument, 'number');
		  if (typeof prim == 'number') throw new $TypeError("Can't convert number to bigint");
		  // eslint-disable-next-line es/no-bigint -- safe
		  return BigInt(prim);
		};

		},{"../internals/to-primitive":288}],281:[function(require,module,exports){
		var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
		var toLength = require('../internals/to-length');

		var $RangeError = RangeError;

		// `ToIndex` abstract operation
		// https://tc39.es/ecma262/#sec-toindex
		module.exports = function (it) {
		  if (it === undefined) return 0;
		  var number = toIntegerOrInfinity(it);
		  var length = toLength(number);
		  if (number !== length) throw new $RangeError('Wrong length or index');
		  return length;
		};

		},{"../internals/to-integer-or-infinity":283,"../internals/to-length":284}],282:[function(require,module,exports){
		// toObject with fallback for non-array-like ES3 strings
		var IndexedObject = require('../internals/indexed-object');
		var requireObjectCoercible = require('../internals/require-object-coercible');

		module.exports = function (it) {
		  return IndexedObject(requireObjectCoercible(it));
		};

		},{"../internals/indexed-object":195,"../internals/require-object-coercible":262}],283:[function(require,module,exports){
		var trunc = require('../internals/math-trunc');

		// `ToIntegerOrInfinity` abstract operation
		// https://tc39.es/ecma262/#sec-tointegerorinfinity
		module.exports = function (argument) {
		  var number = +argument;
		  // eslint-disable-next-line no-self-compare -- NaN check
		  return number !== number || number === 0 ? 0 : trunc(number);
		};

		},{"../internals/math-trunc":224}],284:[function(require,module,exports){
		var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');

		var min = Math.min;

		// `ToLength` abstract operation
		// https://tc39.es/ecma262/#sec-tolength
		module.exports = function (argument) {
		  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
		};

		},{"../internals/to-integer-or-infinity":283}],285:[function(require,module,exports){
		var requireObjectCoercible = require('../internals/require-object-coercible');

		var $Object = Object;

		// `ToObject` abstract operation
		// https://tc39.es/ecma262/#sec-toobject
		module.exports = function (argument) {
		  return $Object(requireObjectCoercible(argument));
		};

		},{"../internals/require-object-coercible":262}],286:[function(require,module,exports){
		var toPositiveInteger = require('../internals/to-positive-integer');

		var $RangeError = RangeError;

		module.exports = function (it, BYTES) {
		  var offset = toPositiveInteger(it);
		  if (offset % BYTES) throw new $RangeError('Wrong offset');
		  return offset;
		};

		},{"../internals/to-positive-integer":287}],287:[function(require,module,exports){
		var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');

		var $RangeError = RangeError;

		module.exports = function (it) {
		  var result = toIntegerOrInfinity(it);
		  if (result < 0) throw new $RangeError("The argument can't be less than 0");
		  return result;
		};

		},{"../internals/to-integer-or-infinity":283}],288:[function(require,module,exports){
		var call = require('../internals/function-call');
		var isObject = require('../internals/is-object');
		var isSymbol = require('../internals/is-symbol');
		var getMethod = require('../internals/get-method');
		var ordinaryToPrimitive = require('../internals/ordinary-to-primitive');
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var $TypeError = TypeError;
		var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

		// `ToPrimitive` abstract operation
		// https://tc39.es/ecma262/#sec-toprimitive
		module.exports = function (input, pref) {
		  if (!isObject(input) || isSymbol(input)) return input;
		  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
		  var result;
		  if (exoticToPrim) {
		    if (pref === undefined) pref = 'default';
		    result = call(exoticToPrim, input, pref);
		    if (!isObject(result) || isSymbol(result)) return result;
		    throw new $TypeError("Can't convert object to primitive value");
		  }
		  if (pref === undefined) pref = 'number';
		  return ordinaryToPrimitive(input, pref);
		};

		},{"../internals/function-call":177,"../internals/get-method":186,"../internals/is-object":208,"../internals/is-symbol":212,"../internals/ordinary-to-primitive":245,"../internals/well-known-symbol":306}],289:[function(require,module,exports){
		var toPrimitive = require('../internals/to-primitive');
		var isSymbol = require('../internals/is-symbol');

		// `ToPropertyKey` abstract operation
		// https://tc39.es/ecma262/#sec-topropertykey
		module.exports = function (argument) {
		  var key = toPrimitive(argument, 'string');
		  return isSymbol(key) ? key : key + '';
		};

		},{"../internals/is-symbol":212,"../internals/to-primitive":288}],290:[function(require,module,exports){
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var TO_STRING_TAG = wellKnownSymbol('toStringTag');
		var test = {};

		test[TO_STRING_TAG] = 'z';

		module.exports = String(test) === '[object z]';

		},{"../internals/well-known-symbol":306}],291:[function(require,module,exports){
		var classof = require('../internals/classof');

		var $String = String;

		module.exports = function (argument) {
		  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
		  return $String(argument);
		};

		},{"../internals/classof":138}],292:[function(require,module,exports){
		var round = Math.round;

		module.exports = function (it) {
		  var value = round(it);
		  return value < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
		};

		},{}],293:[function(require,module,exports){
		var $String = String;

		module.exports = function (argument) {
		  try {
		    return $String(argument);
		  } catch (error) {
		    return 'Object';
		  }
		};

		},{}],294:[function(require,module,exports){
		var $ = require('../internals/export');
		var global = require('../internals/global');
		var call = require('../internals/function-call');
		var DESCRIPTORS = require('../internals/descriptors');
		var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var ArrayBufferModule = require('../internals/array-buffer');
		var anInstance = require('../internals/an-instance');
		var createPropertyDescriptor = require('../internals/create-property-descriptor');
		var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
		var isIntegralNumber = require('../internals/is-integral-number');
		var toLength = require('../internals/to-length');
		var toIndex = require('../internals/to-index');
		var toOffset = require('../internals/to-offset');
		var toUint8Clamped = require('../internals/to-uint8-clamped');
		var toPropertyKey = require('../internals/to-property-key');
		var hasOwn = require('../internals/has-own-property');
		var classof = require('../internals/classof');
		var isObject = require('../internals/is-object');
		var isSymbol = require('../internals/is-symbol');
		var create = require('../internals/object-create');
		var isPrototypeOf = require('../internals/object-is-prototype-of');
		var setPrototypeOf = require('../internals/object-set-prototype-of');
		var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
		var typedArrayFrom = require('../internals/typed-array-from');
		var forEach = require('../internals/array-iteration').forEach;
		var setSpecies = require('../internals/set-species');
		var defineBuiltInAccessor = require('../internals/define-built-in-accessor');
		var definePropertyModule = require('../internals/object-define-property');
		var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
		var arrayFromConstructorAndList = require('../internals/array-from-constructor-and-list');
		var InternalStateModule = require('../internals/internal-state');
		var inheritIfRequired = require('../internals/inherit-if-required');

		var getInternalState = InternalStateModule.get;
		var setInternalState = InternalStateModule.set;
		var enforceInternalState = InternalStateModule.enforce;
		var nativeDefineProperty = definePropertyModule.f;
		var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
		var RangeError = global.RangeError;
		var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
		var ArrayBufferPrototype = ArrayBuffer.prototype;
		var DataView = ArrayBufferModule.DataView;
		var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
		var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
		var TypedArray = ArrayBufferViewCore.TypedArray;
		var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
		var isTypedArray = ArrayBufferViewCore.isTypedArray;
		var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
		var WRONG_LENGTH = 'Wrong length';

		var addGetter = function (it, key) {
		  defineBuiltInAccessor(it, key, {
		    configurable: true,
		    get: function () {
		      return getInternalState(this)[key];
		    }
		  });
		};

		var isArrayBuffer = function (it) {
		  var klass;
		  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) === 'ArrayBuffer' || klass === 'SharedArrayBuffer';
		};

		var isTypedArrayIndex = function (target, key) {
		  return isTypedArray(target)
		    && !isSymbol(key)
		    && key in target
		    && isIntegralNumber(+key)
		    && key >= 0;
		};

		var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
		  key = toPropertyKey(key);
		  return isTypedArrayIndex(target, key)
		    ? createPropertyDescriptor(2, target[key])
		    : nativeGetOwnPropertyDescriptor(target, key);
		};

		var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
		  key = toPropertyKey(key);
		  if (isTypedArrayIndex(target, key)
		    && isObject(descriptor)
		    && hasOwn(descriptor, 'value')
		    && !hasOwn(descriptor, 'get')
		    && !hasOwn(descriptor, 'set')
		    // TODO: add validation descriptor w/o calling accessors
		    && !descriptor.configurable
		    && (!hasOwn(descriptor, 'writable') || descriptor.writable)
		    && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)
		  ) {
		    target[key] = descriptor.value;
		    return target;
		  } return nativeDefineProperty(target, key, descriptor);
		};

		if (DESCRIPTORS) {
		  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
		    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
		    definePropertyModule.f = wrappedDefineProperty;
		    addGetter(TypedArrayPrototype, 'buffer');
		    addGetter(TypedArrayPrototype, 'byteOffset');
		    addGetter(TypedArrayPrototype, 'byteLength');
		    addGetter(TypedArrayPrototype, 'length');
		  }

		  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
		    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
		    defineProperty: wrappedDefineProperty
		  });

		  module.exports = function (TYPE, wrapper, CLAMPED) {
		    var BYTES = TYPE.match(/\d+/)[0] / 8;
		    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
		    var GETTER = 'get' + TYPE;
		    var SETTER = 'set' + TYPE;
		    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
		    var TypedArrayConstructor = NativeTypedArrayConstructor;
		    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
		    var exported = {};

		    var getter = function (that, index) {
		      var data = getInternalState(that);
		      return data.view[GETTER](index * BYTES + data.byteOffset, true);
		    };

		    var setter = function (that, index, value) {
		      var data = getInternalState(that);
		      data.view[SETTER](index * BYTES + data.byteOffset, CLAMPED ? toUint8Clamped(value) : value, true);
		    };

		    var addElement = function (that, index) {
		      nativeDefineProperty(that, index, {
		        get: function () {
		          return getter(this, index);
		        },
		        set: function (value) {
		          return setter(this, index, value);
		        },
		        enumerable: true
		      });
		    };

		    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
		      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
		        anInstance(that, TypedArrayConstructorPrototype);
		        var index = 0;
		        var byteOffset = 0;
		        var buffer, byteLength, length;
		        if (!isObject(data)) {
		          length = toIndex(data);
		          byteLength = length * BYTES;
		          buffer = new ArrayBuffer(byteLength);
		        } else if (isArrayBuffer(data)) {
		          buffer = data;
		          byteOffset = toOffset(offset, BYTES);
		          var $len = data.byteLength;
		          if ($length === undefined) {
		            if ($len % BYTES) throw new RangeError(WRONG_LENGTH);
		            byteLength = $len - byteOffset;
		            if (byteLength < 0) throw new RangeError(WRONG_LENGTH);
		          } else {
		            byteLength = toLength($length) * BYTES;
		            if (byteLength + byteOffset > $len) throw new RangeError(WRONG_LENGTH);
		          }
		          length = byteLength / BYTES;
		        } else if (isTypedArray(data)) {
		          return arrayFromConstructorAndList(TypedArrayConstructor, data);
		        } else {
		          return call(typedArrayFrom, TypedArrayConstructor, data);
		        }
		        setInternalState(that, {
		          buffer: buffer,
		          byteOffset: byteOffset,
		          byteLength: byteLength,
		          length: length,
		          view: new DataView(buffer)
		        });
		        while (index < length) addElement(that, index++);
		      });

		      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
		      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
		    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
		      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
		        anInstance(dummy, TypedArrayConstructorPrototype);
		        return inheritIfRequired(function () {
		          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
		          if (isArrayBuffer(data)) return $length !== undefined
		            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
		            : typedArrayOffset !== undefined
		              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
		              : new NativeTypedArrayConstructor(data);
		          if (isTypedArray(data)) return arrayFromConstructorAndList(TypedArrayConstructor, data);
		          return call(typedArrayFrom, TypedArrayConstructor, data);
		        }(), dummy, TypedArrayConstructor);
		      });

		      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
		      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
		        if (!(key in TypedArrayConstructor)) {
		          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
		        }
		      });
		      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
		    }

		    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
		      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
		    }

		    enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;

		    if (TYPED_ARRAY_TAG) {
		      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
		    }

		    var FORCED = TypedArrayConstructor !== NativeTypedArrayConstructor;

		    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

		    $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);

		    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
		      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
		    }

		    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
		      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
		    }

		    setSpecies(CONSTRUCTOR_NAME);
		  };
		} else module.exports = function () { /* empty */ };

		},{"../internals/an-instance":113,"../internals/array-buffer":118,"../internals/array-buffer-view-core":117,"../internals/array-from-constructor-and-list":122,"../internals/array-iteration":125,"../internals/classof":138,"../internals/create-non-enumerable-property":145,"../internals/create-property-descriptor":146,"../internals/define-built-in-accessor":148,"../internals/descriptors":153,"../internals/export":170,"../internals/function-call":177,"../internals/global":188,"../internals/has-own-property":189,"../internals/inherit-if-required":196,"../internals/internal-state":199,"../internals/is-integral-number":206,"../internals/is-object":208,"../internals/is-symbol":212,"../internals/object-create":229,"../internals/object-define-property":231,"../internals/object-get-own-property-descriptor":232,"../internals/object-get-own-property-names":234,"../internals/object-is-prototype-of":238,"../internals/object-set-prototype-of":242,"../internals/set-species":265,"../internals/to-index":281,"../internals/to-length":284,"../internals/to-offset":286,"../internals/to-property-key":289,"../internals/to-uint8-clamped":292,"../internals/typed-array-constructors-require-wrappers":295,"../internals/typed-array-from":297}],295:[function(require,module,exports){
		/* eslint-disable no-new -- required for testing */
		var global = require('../internals/global');
		var fails = require('../internals/fails');
		var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
		var NATIVE_ARRAY_BUFFER_VIEWS = require('../internals/array-buffer-view-core').NATIVE_ARRAY_BUFFER_VIEWS;

		var ArrayBuffer = global.ArrayBuffer;
		var Int8Array = global.Int8Array;

		module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
		  Int8Array(1);
		}) || !fails(function () {
		  new Int8Array(-1);
		}) || !checkCorrectnessOfIteration(function (iterable) {
		  new Int8Array();
		  new Int8Array(null);
		  new Int8Array(1.5);
		  new Int8Array(iterable);
		}, true) || fails(function () {
		  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
		  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
		});

		},{"../internals/array-buffer-view-core":117,"../internals/check-correctness-of-iteration":136,"../internals/fails":171,"../internals/global":188}],296:[function(require,module,exports){
		var arrayFromConstructorAndList = require('../internals/array-from-constructor-and-list');
		var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');

		module.exports = function (instance, list) {
		  return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
		};

		},{"../internals/array-from-constructor-and-list":122,"../internals/typed-array-species-constructor":298}],297:[function(require,module,exports){
		var bind = require('../internals/function-bind-context');
		var call = require('../internals/function-call');
		var aConstructor = require('../internals/a-constructor');
		var toObject = require('../internals/to-object');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var getIterator = require('../internals/get-iterator');
		var getIteratorMethod = require('../internals/get-iterator-method');
		var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
		var isBigIntArray = require('../internals/is-big-int-array');
		var aTypedArrayConstructor = require('../internals/array-buffer-view-core').aTypedArrayConstructor;
		var toBigInt = require('../internals/to-big-int');

		module.exports = function from(source /* , mapfn, thisArg */) {
		  var C = aConstructor(this);
		  var O = toObject(source);
		  var argumentsLength = arguments.length;
		  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
		  var mapping = mapfn !== undefined;
		  var iteratorMethod = getIteratorMethod(O);
		  var i, length, result, thisIsBigIntArray, value, step, iterator, next;
		  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
		    iterator = getIterator(O, iteratorMethod);
		    next = iterator.next;
		    O = [];
		    while (!(step = call(next, iterator)).done) {
		      O.push(step.value);
		    }
		  }
		  if (mapping && argumentsLength > 2) {
		    mapfn = bind(mapfn, arguments[2]);
		  }
		  length = lengthOfArrayLike(O);
		  result = new (aTypedArrayConstructor(C))(length);
		  thisIsBigIntArray = isBigIntArray(result);
		  for (i = 0; length > i; i++) {
		    value = mapping ? mapfn(O[i], i) : O[i];
		    // FF30- typed arrays doesn't properly convert objects to typed array values
		    result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
		  }
		  return result;
		};

		},{"../internals/a-constructor":109,"../internals/array-buffer-view-core":117,"../internals/function-bind-context":175,"../internals/function-call":177,"../internals/get-iterator":184,"../internals/get-iterator-method":183,"../internals/is-array-iterator-method":200,"../internals/is-big-int-array":202,"../internals/length-of-array-like":219,"../internals/to-big-int":280,"../internals/to-object":285}],298:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var speciesConstructor = require('../internals/species-constructor');

		var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
		var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;

		// a part of `TypedArraySpeciesCreate` abstract operation
		// https://tc39.es/ecma262/#typedarray-species-create
		module.exports = function (originalArray) {
		  return aTypedArrayConstructor(speciesConstructor(originalArray, getTypedArrayConstructor(originalArray)));
		};

		},{"../internals/array-buffer-view-core":117,"../internals/species-constructor":270}],299:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');

		var id = 0;
		var postfix = Math.random();
		var toString = uncurryThis(1.0.toString);

		module.exports = function (key) {
		  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
		};

		},{"../internals/function-uncurry-this":181}],300:[function(require,module,exports){
		/* eslint-disable es/no-symbol -- required for testing */
		var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');

		module.exports = NATIVE_SYMBOL
		  && !Symbol.sham
		  && typeof Symbol.iterator == 'symbol';

		},{"../internals/symbol-constructor-detection":274}],301:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var fails = require('../internals/fails');

		// V8 ~ Chrome 36-
		// https://bugs.chromium.org/p/v8/issues/detail?id=3334
		module.exports = DESCRIPTORS && fails(function () {
		  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
		  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
		    value: 42,
		    writable: false
		  }).prototype !== 42;
		});

		},{"../internals/descriptors":153,"../internals/fails":171}],302:[function(require,module,exports){
		var $TypeError = TypeError;

		module.exports = function (passed, required) {
		  if (passed < required) throw new $TypeError('Not enough arguments');
		  return passed;
		};

		},{}],303:[function(require,module,exports){
		var global = require('../internals/global');
		var isCallable = require('../internals/is-callable');

		var WeakMap = global.WeakMap;

		module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));

		},{"../internals/global":188,"../internals/is-callable":203}],304:[function(require,module,exports){
		var path = require('../internals/path');
		var hasOwn = require('../internals/has-own-property');
		var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
		var defineProperty = require('../internals/object-define-property').f;

		module.exports = function (NAME) {
		  var Symbol = path.Symbol || (path.Symbol = {});
		  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
		    value: wrappedWellKnownSymbolModule.f(NAME)
		  });
		};

		},{"../internals/has-own-property":189,"../internals/object-define-property":231,"../internals/path":247,"../internals/well-known-symbol-wrapped":305}],305:[function(require,module,exports){
		var wellKnownSymbol = require('../internals/well-known-symbol');

		exports.f = wellKnownSymbol;

		},{"../internals/well-known-symbol":306}],306:[function(require,module,exports){
		var global = require('../internals/global');
		var shared = require('../internals/shared');
		var hasOwn = require('../internals/has-own-property');
		var uid = require('../internals/uid');
		var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');
		var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');

		var Symbol = global.Symbol;
		var WellKnownSymbolsStore = shared('wks');
		var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

		module.exports = function (name) {
		  if (!hasOwn(WellKnownSymbolsStore, name)) {
		    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
		      ? Symbol[name]
		      : createWellKnownSymbol('Symbol.' + name);
		  } return WellKnownSymbolsStore[name];
		};

		},{"../internals/global":188,"../internals/has-own-property":189,"../internals/shared":269,"../internals/symbol-constructor-detection":274,"../internals/uid":299,"../internals/use-symbol-as-uid":300}],307:[function(require,module,exports){
		// a string of all valid unicode whitespaces
		module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
		  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

		},{}],308:[function(require,module,exports){
		var $ = require('../internals/export');
		var global = require('../internals/global');
		var arrayBufferModule = require('../internals/array-buffer');
		var setSpecies = require('../internals/set-species');

		var ARRAY_BUFFER = 'ArrayBuffer';
		var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
		var NativeArrayBuffer = global[ARRAY_BUFFER];

		// `ArrayBuffer` constructor
		// https://tc39.es/ecma262/#sec-arraybuffer-constructor
		$({ global: true, constructor: true, forced: NativeArrayBuffer !== ArrayBuffer }, {
		  ArrayBuffer: ArrayBuffer
		});

		setSpecies(ARRAY_BUFFER);

		},{"../internals/array-buffer":118,"../internals/export":170,"../internals/global":188,"../internals/set-species":265}],309:[function(require,module,exports){
		var $ = require('../internals/export');
		var uncurryThis = require('../internals/function-uncurry-this-clause');
		var fails = require('../internals/fails');
		var ArrayBufferModule = require('../internals/array-buffer');
		var anObject = require('../internals/an-object');
		var toAbsoluteIndex = require('../internals/to-absolute-index');
		var toLength = require('../internals/to-length');
		var speciesConstructor = require('../internals/species-constructor');

		var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
		var DataView = ArrayBufferModule.DataView;
		var DataViewPrototype = DataView.prototype;
		var nativeArrayBufferSlice = uncurryThis(ArrayBuffer.prototype.slice);
		var getUint8 = uncurryThis(DataViewPrototype.getUint8);
		var setUint8 = uncurryThis(DataViewPrototype.setUint8);

		var INCORRECT_SLICE = fails(function () {
		  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
		});

		// `ArrayBuffer.prototype.slice` method
		// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
		$({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
		  slice: function slice(start, end) {
		    if (nativeArrayBufferSlice && end === undefined) {
		      return nativeArrayBufferSlice(anObject(this), start); // FF fix
		    }
		    var length = anObject(this).byteLength;
		    var first = toAbsoluteIndex(start, length);
		    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
		    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
		    var viewSource = new DataView(this);
		    var viewTarget = new DataView(result);
		    var index = 0;
		    while (first < fin) {
		      setUint8(viewTarget, index++, getUint8(viewSource, first++));
		    } return result;
		  }
		});

		},{"../internals/an-object":114,"../internals/array-buffer":118,"../internals/export":170,"../internals/fails":171,"../internals/function-uncurry-this-clause":180,"../internals/species-constructor":270,"../internals/to-absolute-index":279,"../internals/to-length":284}],310:[function(require,module,exports){
		var $ = require('../internals/export');
		var fails = require('../internals/fails');
		var isArray = require('../internals/is-array');
		var isObject = require('../internals/is-object');
		var toObject = require('../internals/to-object');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var doesNotExceedSafeInteger = require('../internals/does-not-exceed-safe-integer');
		var createProperty = require('../internals/create-property');
		var arraySpeciesCreate = require('../internals/array-species-create');
		var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var V8_VERSION = require('../internals/engine-v8-version');

		var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

		// We can't use this feature detection in V8 since it causes
		// deoptimization and serious performance degradation
		// https://github.com/zloirock/core-js/issues/679
		var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
		  var array = [];
		  array[IS_CONCAT_SPREADABLE] = false;
		  return array.concat()[0] !== array;
		});

		var isConcatSpreadable = function (O) {
		  if (!isObject(O)) return false;
		  var spreadable = O[IS_CONCAT_SPREADABLE];
		  return spreadable !== undefined ? !!spreadable : isArray(O);
		};

		var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

		// `Array.prototype.concat` method
		// https://tc39.es/ecma262/#sec-array.prototype.concat
		// with adding support of @@isConcatSpreadable and @@species
		$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
		  // eslint-disable-next-line no-unused-vars -- required for `.length`
		  concat: function concat(arg) {
		    var O = toObject(this);
		    var A = arraySpeciesCreate(O, 0);
		    var n = 0;
		    var i, k, length, len, E;
		    for (i = -1, length = arguments.length; i < length; i++) {
		      E = i === -1 ? O : arguments[i];
		      if (isConcatSpreadable(E)) {
		        len = lengthOfArrayLike(E);
		        doesNotExceedSafeInteger(n + len);
		        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
		      } else {
		        doesNotExceedSafeInteger(n + 1);
		        createProperty(A, n++, E);
		      }
		    }
		    A.length = n;
		    return A;
		  }
		});

		},{"../internals/array-method-has-species-support":127,"../internals/array-species-create":134,"../internals/create-property":147,"../internals/does-not-exceed-safe-integer":155,"../internals/engine-v8-version":167,"../internals/export":170,"../internals/fails":171,"../internals/is-array":201,"../internals/is-object":208,"../internals/length-of-array-like":219,"../internals/to-object":285,"../internals/well-known-symbol":306}],311:[function(require,module,exports){
		var $ = require('../internals/export');
		var fill = require('../internals/array-fill');
		var addToUnscopables = require('../internals/add-to-unscopables');

		// `Array.prototype.fill` method
		// https://tc39.es/ecma262/#sec-array.prototype.fill
		$({ target: 'Array', proto: true }, {
		  fill: fill
		});

		// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
		addToUnscopables('fill');

		},{"../internals/add-to-unscopables":111,"../internals/array-fill":120,"../internals/export":170}],312:[function(require,module,exports){
		var $ = require('../internals/export');
		var $filter = require('../internals/array-iteration').filter;
		var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');

		var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

		// `Array.prototype.filter` method
		// https://tc39.es/ecma262/#sec-array.prototype.filter
		// with adding support of @@species
		$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
		  filter: function filter(callbackfn /* , thisArg */) {
		    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		  }
		});

		},{"../internals/array-iteration":125,"../internals/array-method-has-species-support":127,"../internals/export":170}],313:[function(require,module,exports){
		var $ = require('../internals/export');
		var $find = require('../internals/array-iteration').find;
		var addToUnscopables = require('../internals/add-to-unscopables');

		var FIND = 'find';
		var SKIPS_HOLES = true;

		// Shouldn't skip holes
		// eslint-disable-next-line es/no-array-prototype-find -- testing
		if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

		// `Array.prototype.find` method
		// https://tc39.es/ecma262/#sec-array.prototype.find
		$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
		  find: function find(callbackfn /* , that = undefined */) {
		    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		  }
		});

		// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
		addToUnscopables(FIND);

		},{"../internals/add-to-unscopables":111,"../internals/array-iteration":125,"../internals/export":170}],314:[function(require,module,exports){
		var $ = require('../internals/export');
		var from = require('../internals/array-from');
		var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');

		var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
		  // eslint-disable-next-line es/no-array-from -- required for testing
		  Array.from(iterable);
		});

		// `Array.from` method
		// https://tc39.es/ecma262/#sec-array.from
		$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
		  from: from
		});

		},{"../internals/array-from":123,"../internals/check-correctness-of-iteration":136,"../internals/export":170}],315:[function(require,module,exports){
		var $ = require('../internals/export');
		var $includes = require('../internals/array-includes').includes;
		var fails = require('../internals/fails');
		var addToUnscopables = require('../internals/add-to-unscopables');

		// FF99+ bug
		var BROKEN_ON_SPARSE = fails(function () {
		  // eslint-disable-next-line es/no-array-prototype-includes -- detection
		  return !Array(1).includes();
		});

		// `Array.prototype.includes` method
		// https://tc39.es/ecma262/#sec-array.prototype.includes
		$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
		  includes: function includes(el /* , fromIndex = 0 */) {
		    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
		  }
		});

		// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
		addToUnscopables('includes');

		},{"../internals/add-to-unscopables":111,"../internals/array-includes":124,"../internals/export":170,"../internals/fails":171}],316:[function(require,module,exports){
		var toIndexedObject = require('../internals/to-indexed-object');
		var addToUnscopables = require('../internals/add-to-unscopables');
		var Iterators = require('../internals/iterators');
		var InternalStateModule = require('../internals/internal-state');
		var defineProperty = require('../internals/object-define-property').f;
		var defineIterator = require('../internals/iterator-define');
		var createIterResultObject = require('../internals/create-iter-result-object');
		var IS_PURE = require('../internals/is-pure');
		var DESCRIPTORS = require('../internals/descriptors');

		var ARRAY_ITERATOR = 'Array Iterator';
		var setInternalState = InternalStateModule.set;
		var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

		// `Array.prototype.entries` method
		// https://tc39.es/ecma262/#sec-array.prototype.entries
		// `Array.prototype.keys` method
		// https://tc39.es/ecma262/#sec-array.prototype.keys
		// `Array.prototype.values` method
		// https://tc39.es/ecma262/#sec-array.prototype.values
		// `Array.prototype[@@iterator]` method
		// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
		// `CreateArrayIterator` internal method
		// https://tc39.es/ecma262/#sec-createarrayiterator
		module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
		  setInternalState(this, {
		    type: ARRAY_ITERATOR,
		    target: toIndexedObject(iterated), // target
		    index: 0,                          // next index
		    kind: kind                         // kind
		  });
		// `%ArrayIteratorPrototype%.next` method
		// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
		}, function () {
		  var state = getInternalState(this);
		  var target = state.target;
		  var index = state.index++;
		  if (!target || index >= target.length) {
		    state.target = undefined;
		    return createIterResultObject(undefined, true);
		  }
		  switch (state.kind) {
		    case 'keys': return createIterResultObject(index, false);
		    case 'values': return createIterResultObject(target[index], false);
		  } return createIterResultObject([index, target[index]], false);
		}, 'values');

		// argumentsList[@@iterator] is %ArrayProto_values%
		// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
		// https://tc39.es/ecma262/#sec-createmappedargumentsobject
		var values = Iterators.Arguments = Iterators.Array;

		// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
		addToUnscopables('keys');
		addToUnscopables('values');
		addToUnscopables('entries');

		// V8 ~ Chrome 45- bug
		if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
		  defineProperty(values, 'name', { value: 'values' });
		} catch (error) { /* empty */ }

		},{"../internals/add-to-unscopables":111,"../internals/create-iter-result-object":144,"../internals/descriptors":153,"../internals/internal-state":199,"../internals/is-pure":210,"../internals/iterator-define":216,"../internals/iterators":218,"../internals/object-define-property":231,"../internals/to-indexed-object":282}],317:[function(require,module,exports){
		var $ = require('../internals/export');
		var uncurryThis = require('../internals/function-uncurry-this');
		var IndexedObject = require('../internals/indexed-object');
		var toIndexedObject = require('../internals/to-indexed-object');
		var arrayMethodIsStrict = require('../internals/array-method-is-strict');

		var nativeJoin = uncurryThis([].join);

		var ES3_STRINGS = IndexedObject !== Object;
		var FORCED = ES3_STRINGS || !arrayMethodIsStrict('join', ',');

		// `Array.prototype.join` method
		// https://tc39.es/ecma262/#sec-array.prototype.join
		$({ target: 'Array', proto: true, forced: FORCED }, {
		  join: function join(separator) {
		    return nativeJoin(toIndexedObject(this), separator === undefined ? ',' : separator);
		  }
		});

		},{"../internals/array-method-is-strict":128,"../internals/export":170,"../internals/function-uncurry-this":181,"../internals/indexed-object":195,"../internals/to-indexed-object":282}],318:[function(require,module,exports){
		var $ = require('../internals/export');
		var $map = require('../internals/array-iteration').map;
		var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');

		var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

		// `Array.prototype.map` method
		// https://tc39.es/ecma262/#sec-array.prototype.map
		// with adding support of @@species
		$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
		  map: function map(callbackfn /* , thisArg */) {
		    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		  }
		});

		},{"../internals/array-iteration":125,"../internals/array-method-has-species-support":127,"../internals/export":170}],319:[function(require,module,exports){
		var $ = require('../internals/export');
		var isArray = require('../internals/is-array');
		var isConstructor = require('../internals/is-constructor');
		var isObject = require('../internals/is-object');
		var toAbsoluteIndex = require('../internals/to-absolute-index');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var toIndexedObject = require('../internals/to-indexed-object');
		var createProperty = require('../internals/create-property');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
		var nativeSlice = require('../internals/array-slice');

		var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

		var SPECIES = wellKnownSymbol('species');
		var $Array = Array;
		var max = Math.max;

		// `Array.prototype.slice` method
		// https://tc39.es/ecma262/#sec-array.prototype.slice
		// fallback for not array-like ES3 strings and DOM objects
		$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
		  slice: function slice(start, end) {
		    var O = toIndexedObject(this);
		    var length = lengthOfArrayLike(O);
		    var k = toAbsoluteIndex(start, length);
		    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
		    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
		    var Constructor, result, n;
		    if (isArray(O)) {
		      Constructor = O.constructor;
		      // cross-realm fallback
		      if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
		        Constructor = undefined;
		      } else if (isObject(Constructor)) {
		        Constructor = Constructor[SPECIES];
		        if (Constructor === null) Constructor = undefined;
		      }
		      if (Constructor === $Array || Constructor === undefined) {
		        return nativeSlice(O, k, fin);
		      }
		    }
		    result = new (Constructor === undefined ? $Array : Constructor)(max(fin - k, 0));
		    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
		    result.length = n;
		    return result;
		  }
		});

		},{"../internals/array-method-has-species-support":127,"../internals/array-slice":131,"../internals/create-property":147,"../internals/export":170,"../internals/is-array":201,"../internals/is-constructor":204,"../internals/is-object":208,"../internals/length-of-array-like":219,"../internals/to-absolute-index":279,"../internals/to-indexed-object":282,"../internals/well-known-symbol":306}],320:[function(require,module,exports){
		var $ = require('../internals/export');
		var uncurryThis = require('../internals/function-uncurry-this');
		var aCallable = require('../internals/a-callable');
		var toObject = require('../internals/to-object');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var deletePropertyOrThrow = require('../internals/delete-property-or-throw');
		var toString = require('../internals/to-string');
		var fails = require('../internals/fails');
		var internalSort = require('../internals/array-sort');
		var arrayMethodIsStrict = require('../internals/array-method-is-strict');
		var FF = require('../internals/engine-ff-version');
		var IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');
		var V8 = require('../internals/engine-v8-version');
		var WEBKIT = require('../internals/engine-webkit-version');

		var test = [];
		var nativeSort = uncurryThis(test.sort);
		var push = uncurryThis(test.push);

		// IE8-
		var FAILS_ON_UNDEFINED = fails(function () {
		  test.sort(undefined);
		});
		// V8 bug
		var FAILS_ON_NULL = fails(function () {
		  test.sort(null);
		});
		// Old WebKit
		var STRICT_METHOD = arrayMethodIsStrict('sort');

		var STABLE_SORT = !fails(function () {
		  // feature detection can be too slow, so check engines versions
		  if (V8) return V8 < 70;
		  if (FF && FF > 3) return;
		  if (IE_OR_EDGE) return true;
		  if (WEBKIT) return WEBKIT < 603;

		  var result = '';
		  var code, chr, value, index;

		  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
		  for (code = 65; code < 76; code++) {
		    chr = String.fromCharCode(code);

		    switch (code) {
		      case 66: case 69: case 70: case 72: value = 3; break;
		      case 68: case 71: value = 4; break;
		      default: value = 2;
		    }

		    for (index = 0; index < 47; index++) {
		      test.push({ k: chr + index, v: value });
		    }
		  }

		  test.sort(function (a, b) { return b.v - a.v; });

		  for (index = 0; index < test.length; index++) {
		    chr = test[index].k.charAt(0);
		    if (result.charAt(result.length - 1) !== chr) result += chr;
		  }

		  return result !== 'DGBEFHACIJK';
		});

		var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

		var getSortCompare = function (comparefn) {
		  return function (x, y) {
		    if (y === undefined) return -1;
		    if (x === undefined) return 1;
		    if (comparefn !== undefined) return +comparefn(x, y) || 0;
		    return toString(x) > toString(y) ? 1 : -1;
		  };
		};

		// `Array.prototype.sort` method
		// https://tc39.es/ecma262/#sec-array.prototype.sort
		$({ target: 'Array', proto: true, forced: FORCED }, {
		  sort: function sort(comparefn) {
		    if (comparefn !== undefined) aCallable(comparefn);

		    var array = toObject(this);

		    if (STABLE_SORT) return comparefn === undefined ? nativeSort(array) : nativeSort(array, comparefn);

		    var items = [];
		    var arrayLength = lengthOfArrayLike(array);
		    var itemsLength, index;

		    for (index = 0; index < arrayLength; index++) {
		      if (index in array) push(items, array[index]);
		    }

		    internalSort(items, getSortCompare(comparefn));

		    itemsLength = lengthOfArrayLike(items);
		    index = 0;

		    while (index < itemsLength) array[index] = items[index++];
		    while (index < arrayLength) deletePropertyOrThrow(array, index++);

		    return array;
		  }
		});

		},{"../internals/a-callable":108,"../internals/array-method-is-strict":128,"../internals/array-sort":132,"../internals/delete-property-or-throw":152,"../internals/engine-ff-version":158,"../internals/engine-is-ie-or-edge":161,"../internals/engine-v8-version":167,"../internals/engine-webkit-version":168,"../internals/export":170,"../internals/fails":171,"../internals/function-uncurry-this":181,"../internals/length-of-array-like":219,"../internals/to-object":285,"../internals/to-string":291}],321:[function(require,module,exports){
		var $ = require('../internals/export');
		var toObject = require('../internals/to-object');
		var toAbsoluteIndex = require('../internals/to-absolute-index');
		var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var setArrayLength = require('../internals/array-set-length');
		var doesNotExceedSafeInteger = require('../internals/does-not-exceed-safe-integer');
		var arraySpeciesCreate = require('../internals/array-species-create');
		var createProperty = require('../internals/create-property');
		var deletePropertyOrThrow = require('../internals/delete-property-or-throw');
		var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');

		var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

		var max = Math.max;
		var min = Math.min;

		// `Array.prototype.splice` method
		// https://tc39.es/ecma262/#sec-array.prototype.splice
		// with adding support of @@species
		$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
		  splice: function splice(start, deleteCount /* , ...items */) {
		    var O = toObject(this);
		    var len = lengthOfArrayLike(O);
		    var actualStart = toAbsoluteIndex(start, len);
		    var argumentsLength = arguments.length;
		    var insertCount, actualDeleteCount, A, k, from, to;
		    if (argumentsLength === 0) {
		      insertCount = actualDeleteCount = 0;
		    } else if (argumentsLength === 1) {
		      insertCount = 0;
		      actualDeleteCount = len - actualStart;
		    } else {
		      insertCount = argumentsLength - 2;
		      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
		    }
		    doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
		    A = arraySpeciesCreate(O, actualDeleteCount);
		    for (k = 0; k < actualDeleteCount; k++) {
		      from = actualStart + k;
		      if (from in O) createProperty(A, k, O[from]);
		    }
		    A.length = actualDeleteCount;
		    if (insertCount < actualDeleteCount) {
		      for (k = actualStart; k < len - actualDeleteCount; k++) {
		        from = k + actualDeleteCount;
		        to = k + insertCount;
		        if (from in O) O[to] = O[from];
		        else deletePropertyOrThrow(O, to);
		      }
		      for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O, k - 1);
		    } else if (insertCount > actualDeleteCount) {
		      for (k = len - actualDeleteCount; k > actualStart; k--) {
		        from = k + actualDeleteCount - 1;
		        to = k + insertCount - 1;
		        if (from in O) O[to] = O[from];
		        else deletePropertyOrThrow(O, to);
		      }
		    }
		    for (k = 0; k < insertCount; k++) {
		      O[k + actualStart] = arguments[k + 2];
		    }
		    setArrayLength(O, len - actualDeleteCount + insertCount);
		    return A;
		  }
		});

		},{"../internals/array-method-has-species-support":127,"../internals/array-set-length":130,"../internals/array-species-create":134,"../internals/create-property":147,"../internals/delete-property-or-throw":152,"../internals/does-not-exceed-safe-integer":155,"../internals/export":170,"../internals/length-of-array-like":219,"../internals/to-absolute-index":279,"../internals/to-integer-or-infinity":283,"../internals/to-object":285}],322:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var FUNCTION_NAME_EXISTS = require('../internals/function-name').EXISTS;
		var uncurryThis = require('../internals/function-uncurry-this');
		var defineBuiltInAccessor = require('../internals/define-built-in-accessor');

		var FunctionPrototype = Function.prototype;
		var functionToString = uncurryThis(FunctionPrototype.toString);
		var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
		var regExpExec = uncurryThis(nameRE.exec);
		var NAME = 'name';

		// Function instances `.name` property
		// https://tc39.es/ecma262/#sec-function-instances-name
		if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
		  defineBuiltInAccessor(FunctionPrototype, NAME, {
		    configurable: true,
		    get: function () {
		      try {
		        return regExpExec(nameRE, functionToString(this))[1];
		      } catch (error) {
		        return '';
		      }
		    }
		  });
		}

		},{"../internals/define-built-in-accessor":148,"../internals/descriptors":153,"../internals/function-name":178,"../internals/function-uncurry-this":181}],323:[function(require,module,exports){
		var $ = require('../internals/export');
		var getBuiltIn = require('../internals/get-built-in');
		var apply = require('../internals/function-apply');
		var call = require('../internals/function-call');
		var uncurryThis = require('../internals/function-uncurry-this');
		var fails = require('../internals/fails');
		var isCallable = require('../internals/is-callable');
		var isSymbol = require('../internals/is-symbol');
		var arraySlice = require('../internals/array-slice');
		var getReplacerFunction = require('../internals/get-json-replacer-function');
		var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');

		var $String = String;
		var $stringify = getBuiltIn('JSON', 'stringify');
		var exec = uncurryThis(/./.exec);
		var charAt = uncurryThis(''.charAt);
		var charCodeAt = uncurryThis(''.charCodeAt);
		var replace = uncurryThis(''.replace);
		var numberToString = uncurryThis(1.0.toString);

		var tester = /[\uD800-\uDFFF]/g;
		var low = /^[\uD800-\uDBFF]$/;
		var hi = /^[\uDC00-\uDFFF]$/;

		var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
		  var symbol = getBuiltIn('Symbol')('stringify detection');
		  // MS Edge converts symbol values to JSON as {}
		  return $stringify([symbol]) !== '[null]'
		    // WebKit converts symbol values to JSON as null
		    || $stringify({ a: symbol }) !== '{}'
		    // V8 throws on boxed symbols
		    || $stringify(Object(symbol)) !== '{}';
		});

		// https://github.com/tc39/proposal-well-formed-stringify
		var ILL_FORMED_UNICODE = fails(function () {
		  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
		    || $stringify('\uDEAD') !== '"\\udead"';
		});

		var stringifyWithSymbolsFix = function (it, replacer) {
		  var args = arraySlice(arguments);
		  var $replacer = getReplacerFunction(replacer);
		  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
		  args[1] = function (key, value) {
		    // some old implementations (like WebKit) could pass numbers as keys
		    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
		    if (!isSymbol(value)) return value;
		  };
		  return apply($stringify, null, args);
		};

		var fixIllFormed = function (match, offset, string) {
		  var prev = charAt(string, offset - 1);
		  var next = charAt(string, offset + 1);
		  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
		    return '\\u' + numberToString(charCodeAt(match, 0), 16);
		  } return match;
		};

		if ($stringify) {
		  // `JSON.stringify` method
		  // https://tc39.es/ecma262/#sec-json.stringify
		  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
		    // eslint-disable-next-line no-unused-vars -- required for `.length`
		    stringify: function stringify(it, replacer, space) {
		      var args = arraySlice(arguments);
		      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
		      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
		    }
		  });
		}

		},{"../internals/array-slice":131,"../internals/export":170,"../internals/fails":171,"../internals/function-apply":174,"../internals/function-call":177,"../internals/function-uncurry-this":181,"../internals/get-built-in":182,"../internals/get-json-replacer-function":185,"../internals/is-callable":203,"../internals/is-symbol":212,"../internals/symbol-constructor-detection":274}],324:[function(require,module,exports){
		var $ = require('../internals/export');
		var IS_PURE = require('../internals/is-pure');
		var DESCRIPTORS = require('../internals/descriptors');
		var global = require('../internals/global');
		var path = require('../internals/path');
		var uncurryThis = require('../internals/function-uncurry-this');
		var isForced = require('../internals/is-forced');
		var hasOwn = require('../internals/has-own-property');
		var inheritIfRequired = require('../internals/inherit-if-required');
		var isPrototypeOf = require('../internals/object-is-prototype-of');
		var isSymbol = require('../internals/is-symbol');
		var toPrimitive = require('../internals/to-primitive');
		var fails = require('../internals/fails');
		var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
		var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
		var defineProperty = require('../internals/object-define-property').f;
		var thisNumberValue = require('../internals/this-number-value');
		var trim = require('../internals/string-trim').trim;

		var NUMBER = 'Number';
		var NativeNumber = global[NUMBER];
		var PureNumberNamespace = path[NUMBER];
		var NumberPrototype = NativeNumber.prototype;
		var TypeError = global.TypeError;
		var stringSlice = uncurryThis(''.slice);
		var charCodeAt = uncurryThis(''.charCodeAt);

		// `ToNumeric` abstract operation
		// https://tc39.es/ecma262/#sec-tonumeric
		var toNumeric = function (value) {
		  var primValue = toPrimitive(value, 'number');
		  return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
		};

		// `ToNumber` abstract operation
		// https://tc39.es/ecma262/#sec-tonumber
		var toNumber = function (argument) {
		  var it = toPrimitive(argument, 'number');
		  var first, third, radix, maxCode, digits, length, index, code;
		  if (isSymbol(it)) throw new TypeError('Cannot convert a Symbol value to a number');
		  if (typeof it == 'string' && it.length > 2) {
		    it = trim(it);
		    first = charCodeAt(it, 0);
		    if (first === 43 || first === 45) {
		      third = charCodeAt(it, 2);
		      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
		    } else if (first === 48) {
		      switch (charCodeAt(it, 1)) {
		        // fast equal of /^0b[01]+$/i
		        case 66:
		        case 98:
		          radix = 2;
		          maxCode = 49;
		          break;
		        // fast equal of /^0o[0-7]+$/i
		        case 79:
		        case 111:
		          radix = 8;
		          maxCode = 55;
		          break;
		        default:
		          return +it;
		      }
		      digits = stringSlice(it, 2);
		      length = digits.length;
		      for (index = 0; index < length; index++) {
		        code = charCodeAt(digits, index);
		        // parseInt parses a string to a first unavailable symbol
		        // but ToNumber should return NaN if a string contains unavailable symbols
		        if (code < 48 || code > maxCode) return NaN;
		      } return parseInt(digits, radix);
		    }
		  } return +it;
		};

		var FORCED = isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'));

		var calledWithNew = function (dummy) {
		  // includes check on 1..constructor(foo) case
		  return isPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); });
		};

		// `Number` constructor
		// https://tc39.es/ecma262/#sec-number-constructor
		var NumberWrapper = function Number(value) {
		  var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
		  return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
		};

		NumberWrapper.prototype = NumberPrototype;
		if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;

		$({ global: true, constructor: true, wrap: true, forced: FORCED }, {
		  Number: NumberWrapper
		});

		// Use `internal/copy-constructor-properties` helper in `core-js@4`
		var copyConstructorProperties = function (target, source) {
		  for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
		    // ES3:
		    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
		    // ES2015 (in case, if modules with ES2015 Number statics required before):
		    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
		    // ESNext
		    'fromString,range'
		  ).split(','), j = 0, key; keys.length > j; j++) {
		    if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
		      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
		    }
		  }
		};

		if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
		if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);

		},{"../internals/descriptors":153,"../internals/export":170,"../internals/fails":171,"../internals/function-uncurry-this":181,"../internals/global":188,"../internals/has-own-property":189,"../internals/inherit-if-required":196,"../internals/is-forced":205,"../internals/is-pure":210,"../internals/is-symbol":212,"../internals/object-define-property":231,"../internals/object-get-own-property-descriptor":232,"../internals/object-get-own-property-names":234,"../internals/object-is-prototype-of":238,"../internals/path":247,"../internals/string-trim":273,"../internals/this-number-value":278,"../internals/to-primitive":288}],325:[function(require,module,exports){
		var $ = require('../internals/export');
		var assign = require('../internals/object-assign');

		// `Object.assign` method
		// https://tc39.es/ecma262/#sec-object.assign
		// eslint-disable-next-line es/no-object-assign -- required for testing
		$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {
		  assign: assign
		});

		},{"../internals/export":170,"../internals/object-assign":228}],326:[function(require,module,exports){
		var $ = require('../internals/export');
		var $entries = require('../internals/object-to-array').entries;

		// `Object.entries` method
		// https://tc39.es/ecma262/#sec-object.entries
		$({ target: 'Object', stat: true }, {
		  entries: function entries(O) {
		    return $entries(O);
		  }
		});

		},{"../internals/export":170,"../internals/object-to-array":243}],327:[function(require,module,exports){
		var $ = require('../internals/export');
		var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');
		var fails = require('../internals/fails');
		var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
		var toObject = require('../internals/to-object');

		// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
		// https://bugs.chromium.org/p/v8/issues/detail?id=3443
		var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

		// `Object.getOwnPropertySymbols` method
		// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
		$({ target: 'Object', stat: true, forced: FORCED }, {
		  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
		    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
		    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
		  }
		});

		},{"../internals/export":170,"../internals/fails":171,"../internals/object-get-own-property-symbols":235,"../internals/symbol-constructor-detection":274,"../internals/to-object":285}],328:[function(require,module,exports){
		var $ = require('../internals/export');
		var toObject = require('../internals/to-object');
		var nativeKeys = require('../internals/object-keys');
		var fails = require('../internals/fails');

		var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

		// `Object.keys` method
		// https://tc39.es/ecma262/#sec-object.keys
		$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
		  keys: function keys(it) {
		    return nativeKeys(toObject(it));
		  }
		});

		},{"../internals/export":170,"../internals/fails":171,"../internals/object-keys":240,"../internals/to-object":285}],329:[function(require,module,exports){
		var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
		var defineBuiltIn = require('../internals/define-built-in');
		var toString = require('../internals/object-to-string');

		// `Object.prototype.toString` method
		// https://tc39.es/ecma262/#sec-object.prototype.tostring
		if (!TO_STRING_TAG_SUPPORT) {
		  defineBuiltIn(Object.prototype, 'toString', toString, { unsafe: true });
		}

		},{"../internals/define-built-in":149,"../internals/object-to-string":244,"../internals/to-string-tag-support":290}],330:[function(require,module,exports){
		var $ = require('../internals/export');
		var call = require('../internals/function-call');
		var aCallable = require('../internals/a-callable');
		var newPromiseCapabilityModule = require('../internals/new-promise-capability');
		var perform = require('../internals/perform');
		var iterate = require('../internals/iterate');
		var PROMISE_STATICS_INCORRECT_ITERATION = require('../internals/promise-statics-incorrect-iteration');

		// `Promise.all` method
		// https://tc39.es/ecma262/#sec-promise.all
		$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
		  all: function all(iterable) {
		    var C = this;
		    var capability = newPromiseCapabilityModule.f(C);
		    var resolve = capability.resolve;
		    var reject = capability.reject;
		    var result = perform(function () {
		      var $promiseResolve = aCallable(C.resolve);
		      var values = [];
		      var counter = 0;
		      var remaining = 1;
		      iterate(iterable, function (promise) {
		        var index = counter++;
		        var alreadyCalled = false;
		        remaining++;
		        call($promiseResolve, C, promise).then(function (value) {
		          if (alreadyCalled) return;
		          alreadyCalled = true;
		          values[index] = value;
		          --remaining || resolve(values);
		        }, reject);
		      });
		      --remaining || resolve(values);
		    });
		    if (result.error) reject(result.value);
		    return capability.promise;
		  }
		});

		},{"../internals/a-callable":108,"../internals/export":170,"../internals/function-call":177,"../internals/iterate":213,"../internals/new-promise-capability":226,"../internals/perform":248,"../internals/promise-statics-incorrect-iteration":252}],331:[function(require,module,exports){
		var $ = require('../internals/export');
		var IS_PURE = require('../internals/is-pure');
		var FORCED_PROMISE_CONSTRUCTOR = require('../internals/promise-constructor-detection').CONSTRUCTOR;
		var NativePromiseConstructor = require('../internals/promise-native-constructor');
		var getBuiltIn = require('../internals/get-built-in');
		var isCallable = require('../internals/is-callable');
		var defineBuiltIn = require('../internals/define-built-in');

		var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

		// `Promise.prototype.catch` method
		// https://tc39.es/ecma262/#sec-promise.prototype.catch
		$({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
		  'catch': function (onRejected) {
		    return this.then(undefined, onRejected);
		  }
		});

		// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
		if (!IS_PURE && isCallable(NativePromiseConstructor)) {
		  var method = getBuiltIn('Promise').prototype['catch'];
		  if (NativePromisePrototype['catch'] !== method) {
		    defineBuiltIn(NativePromisePrototype, 'catch', method, { unsafe: true });
		  }
		}

		},{"../internals/define-built-in":149,"../internals/export":170,"../internals/get-built-in":182,"../internals/is-callable":203,"../internals/is-pure":210,"../internals/promise-constructor-detection":249,"../internals/promise-native-constructor":250}],332:[function(require,module,exports){
		var $ = require('../internals/export');
		var IS_PURE = require('../internals/is-pure');
		var IS_NODE = require('../internals/engine-is-node');
		var global = require('../internals/global');
		var call = require('../internals/function-call');
		var defineBuiltIn = require('../internals/define-built-in');
		var setPrototypeOf = require('../internals/object-set-prototype-of');
		var setToStringTag = require('../internals/set-to-string-tag');
		var setSpecies = require('../internals/set-species');
		var aCallable = require('../internals/a-callable');
		var isCallable = require('../internals/is-callable');
		var isObject = require('../internals/is-object');
		var anInstance = require('../internals/an-instance');
		var speciesConstructor = require('../internals/species-constructor');
		var task = require('../internals/task').set;
		var microtask = require('../internals/microtask');
		var hostReportErrors = require('../internals/host-report-errors');
		var perform = require('../internals/perform');
		var Queue = require('../internals/queue');
		var InternalStateModule = require('../internals/internal-state');
		var NativePromiseConstructor = require('../internals/promise-native-constructor');
		var PromiseConstructorDetection = require('../internals/promise-constructor-detection');
		var newPromiseCapabilityModule = require('../internals/new-promise-capability');

		var PROMISE = 'Promise';
		var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
		var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
		var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
		var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
		var setInternalState = InternalStateModule.set;
		var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
		var PromiseConstructor = NativePromiseConstructor;
		var PromisePrototype = NativePromisePrototype;
		var TypeError = global.TypeError;
		var document = global.document;
		var process = global.process;
		var newPromiseCapability = newPromiseCapabilityModule.f;
		var newGenericPromiseCapability = newPromiseCapability;

		var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
		var UNHANDLED_REJECTION = 'unhandledrejection';
		var REJECTION_HANDLED = 'rejectionhandled';
		var PENDING = 0;
		var FULFILLED = 1;
		var REJECTED = 2;
		var HANDLED = 1;
		var UNHANDLED = 2;

		var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

		// helpers
		var isThenable = function (it) {
		  var then;
		  return isObject(it) && isCallable(then = it.then) ? then : false;
		};

		var callReaction = function (reaction, state) {
		  var value = state.value;
		  var ok = state.state === FULFILLED;
		  var handler = ok ? reaction.ok : reaction.fail;
		  var resolve = reaction.resolve;
		  var reject = reaction.reject;
		  var domain = reaction.domain;
		  var result, then, exited;
		  try {
		    if (handler) {
		      if (!ok) {
		        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
		        state.rejection = HANDLED;
		      }
		      if (handler === true) result = value;
		      else {
		        if (domain) domain.enter();
		        result = handler(value); // can throw
		        if (domain) {
		          domain.exit();
		          exited = true;
		        }
		      }
		      if (result === reaction.promise) {
		        reject(new TypeError('Promise-chain cycle'));
		      } else if (then = isThenable(result)) {
		        call(then, result, resolve, reject);
		      } else resolve(result);
		    } else reject(value);
		  } catch (error) {
		    if (domain && !exited) domain.exit();
		    reject(error);
		  }
		};

		var notify = function (state, isReject) {
		  if (state.notified) return;
		  state.notified = true;
		  microtask(function () {
		    var reactions = state.reactions;
		    var reaction;
		    while (reaction = reactions.get()) {
		      callReaction(reaction, state);
		    }
		    state.notified = false;
		    if (isReject && !state.rejection) onUnhandled(state);
		  });
		};

		var dispatchEvent = function (name, promise, reason) {
		  var event, handler;
		  if (DISPATCH_EVENT) {
		    event = document.createEvent('Event');
		    event.promise = promise;
		    event.reason = reason;
		    event.initEvent(name, false, true);
		    global.dispatchEvent(event);
		  } else event = { promise: promise, reason: reason };
		  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
		  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
		};

		var onUnhandled = function (state) {
		  call(task, global, function () {
		    var promise = state.facade;
		    var value = state.value;
		    var IS_UNHANDLED = isUnhandled(state);
		    var result;
		    if (IS_UNHANDLED) {
		      result = perform(function () {
		        if (IS_NODE) {
		          process.emit('unhandledRejection', value, promise);
		        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
		      });
		      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
		      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
		      if (result.error) throw result.value;
		    }
		  });
		};

		var isUnhandled = function (state) {
		  return state.rejection !== HANDLED && !state.parent;
		};

		var onHandleUnhandled = function (state) {
		  call(task, global, function () {
		    var promise = state.facade;
		    if (IS_NODE) {
		      process.emit('rejectionHandled', promise);
		    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
		  });
		};

		var bind = function (fn, state, unwrap) {
		  return function (value) {
		    fn(state, value, unwrap);
		  };
		};

		var internalReject = function (state, value, unwrap) {
		  if (state.done) return;
		  state.done = true;
		  if (unwrap) state = unwrap;
		  state.value = value;
		  state.state = REJECTED;
		  notify(state, true);
		};

		var internalResolve = function (state, value, unwrap) {
		  if (state.done) return;
		  state.done = true;
		  if (unwrap) state = unwrap;
		  try {
		    if (state.facade === value) throw new TypeError("Promise can't be resolved itself");
		    var then = isThenable(value);
		    if (then) {
		      microtask(function () {
		        var wrapper = { done: false };
		        try {
		          call(then, value,
		            bind(internalResolve, wrapper, state),
		            bind(internalReject, wrapper, state)
		          );
		        } catch (error) {
		          internalReject(wrapper, error, state);
		        }
		      });
		    } else {
		      state.value = value;
		      state.state = FULFILLED;
		      notify(state, false);
		    }
		  } catch (error) {
		    internalReject({ done: false }, error, state);
		  }
		};

		// constructor polyfill
		if (FORCED_PROMISE_CONSTRUCTOR) {
		  // 25.4.3.1 Promise(executor)
		  PromiseConstructor = function Promise(executor) {
		    anInstance(this, PromisePrototype);
		    aCallable(executor);
		    call(Internal, this);
		    var state = getInternalPromiseState(this);
		    try {
		      executor(bind(internalResolve, state), bind(internalReject, state));
		    } catch (error) {
		      internalReject(state, error);
		    }
		  };

		  PromisePrototype = PromiseConstructor.prototype;

		  // eslint-disable-next-line no-unused-vars -- required for `.length`
		  Internal = function Promise(executor) {
		    setInternalState(this, {
		      type: PROMISE,
		      done: false,
		      notified: false,
		      parent: false,
		      reactions: new Queue(),
		      rejection: false,
		      state: PENDING,
		      value: undefined
		    });
		  };

		  // `Promise.prototype.then` method
		  // https://tc39.es/ecma262/#sec-promise.prototype.then
		  Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
		    var state = getInternalPromiseState(this);
		    var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
		    state.parent = true;
		    reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
		    reaction.fail = isCallable(onRejected) && onRejected;
		    reaction.domain = IS_NODE ? process.domain : undefined;
		    if (state.state === PENDING) state.reactions.add(reaction);
		    else microtask(function () {
		      callReaction(reaction, state);
		    });
		    return reaction.promise;
		  });

		  OwnPromiseCapability = function () {
		    var promise = new Internal();
		    var state = getInternalPromiseState(promise);
		    this.promise = promise;
		    this.resolve = bind(internalResolve, state);
		    this.reject = bind(internalReject, state);
		  };

		  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
		    return C === PromiseConstructor || C === PromiseWrapper
		      ? new OwnPromiseCapability(C)
		      : newGenericPromiseCapability(C);
		  };

		  if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
		    nativeThen = NativePromisePrototype.then;

		    if (!NATIVE_PROMISE_SUBCLASSING) {
		      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
		      defineBuiltIn(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
		        var that = this;
		        return new PromiseConstructor(function (resolve, reject) {
		          call(nativeThen, that, resolve, reject);
		        }).then(onFulfilled, onRejected);
		      // https://github.com/zloirock/core-js/issues/640
		      }, { unsafe: true });
		    }

		    // make `.constructor === Promise` work for native promise-based APIs
		    try {
		      delete NativePromisePrototype.constructor;
		    } catch (error) { /* empty */ }

		    // make `instanceof Promise` work for native promise-based APIs
		    if (setPrototypeOf) {
		      setPrototypeOf(NativePromisePrototype, PromisePrototype);
		    }
		  }
		}

		$({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
		  Promise: PromiseConstructor
		});

		setToStringTag(PromiseConstructor, PROMISE, false, true);
		setSpecies(PROMISE);

		},{"../internals/a-callable":108,"../internals/an-instance":113,"../internals/define-built-in":149,"../internals/engine-is-node":164,"../internals/export":170,"../internals/function-call":177,"../internals/global":188,"../internals/host-report-errors":191,"../internals/internal-state":199,"../internals/is-callable":203,"../internals/is-object":208,"../internals/is-pure":210,"../internals/microtask":225,"../internals/new-promise-capability":226,"../internals/object-set-prototype-of":242,"../internals/perform":248,"../internals/promise-constructor-detection":249,"../internals/promise-native-constructor":250,"../internals/queue":254,"../internals/set-species":265,"../internals/set-to-string-tag":266,"../internals/species-constructor":270,"../internals/task":277}],333:[function(require,module,exports){
		// TODO: Remove this module from `core-js@4` since it's split to modules listed below
		require('../modules/es.promise.constructor');
		require('../modules/es.promise.all');
		require('../modules/es.promise.catch');
		require('../modules/es.promise.race');
		require('../modules/es.promise.reject');
		require('../modules/es.promise.resolve');

		},{"../modules/es.promise.all":330,"../modules/es.promise.catch":331,"../modules/es.promise.constructor":332,"../modules/es.promise.race":334,"../modules/es.promise.reject":335,"../modules/es.promise.resolve":336}],334:[function(require,module,exports){
		var $ = require('../internals/export');
		var call = require('../internals/function-call');
		var aCallable = require('../internals/a-callable');
		var newPromiseCapabilityModule = require('../internals/new-promise-capability');
		var perform = require('../internals/perform');
		var iterate = require('../internals/iterate');
		var PROMISE_STATICS_INCORRECT_ITERATION = require('../internals/promise-statics-incorrect-iteration');

		// `Promise.race` method
		// https://tc39.es/ecma262/#sec-promise.race
		$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
		  race: function race(iterable) {
		    var C = this;
		    var capability = newPromiseCapabilityModule.f(C);
		    var reject = capability.reject;
		    var result = perform(function () {
		      var $promiseResolve = aCallable(C.resolve);
		      iterate(iterable, function (promise) {
		        call($promiseResolve, C, promise).then(capability.resolve, reject);
		      });
		    });
		    if (result.error) reject(result.value);
		    return capability.promise;
		  }
		});

		},{"../internals/a-callable":108,"../internals/export":170,"../internals/function-call":177,"../internals/iterate":213,"../internals/new-promise-capability":226,"../internals/perform":248,"../internals/promise-statics-incorrect-iteration":252}],335:[function(require,module,exports){
		var $ = require('../internals/export');
		var newPromiseCapabilityModule = require('../internals/new-promise-capability');
		var FORCED_PROMISE_CONSTRUCTOR = require('../internals/promise-constructor-detection').CONSTRUCTOR;

		// `Promise.reject` method
		// https://tc39.es/ecma262/#sec-promise.reject
		$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
		  reject: function reject(r) {
		    var capability = newPromiseCapabilityModule.f(this);
		    var capabilityReject = capability.reject;
		    capabilityReject(r);
		    return capability.promise;
		  }
		});

		},{"../internals/export":170,"../internals/new-promise-capability":226,"../internals/promise-constructor-detection":249}],336:[function(require,module,exports){
		var $ = require('../internals/export');
		var getBuiltIn = require('../internals/get-built-in');
		var IS_PURE = require('../internals/is-pure');
		var NativePromiseConstructor = require('../internals/promise-native-constructor');
		var FORCED_PROMISE_CONSTRUCTOR = require('../internals/promise-constructor-detection').CONSTRUCTOR;
		var promiseResolve = require('../internals/promise-resolve');

		var PromiseConstructorWrapper = getBuiltIn('Promise');
		var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;

		// `Promise.resolve` method
		// https://tc39.es/ecma262/#sec-promise.resolve
		$({ target: 'Promise', stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
		  resolve: function resolve(x) {
		    return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
		  }
		});

		},{"../internals/export":170,"../internals/get-built-in":182,"../internals/is-pure":210,"../internals/promise-constructor-detection":249,"../internals/promise-native-constructor":250,"../internals/promise-resolve":251}],337:[function(require,module,exports){
		var DESCRIPTORS = require('../internals/descriptors');
		var global = require('../internals/global');
		var uncurryThis = require('../internals/function-uncurry-this');
		var isForced = require('../internals/is-forced');
		var inheritIfRequired = require('../internals/inherit-if-required');
		var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
		var create = require('../internals/object-create');
		var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
		var isPrototypeOf = require('../internals/object-is-prototype-of');
		var isRegExp = require('../internals/is-regexp');
		var toString = require('../internals/to-string');
		var getRegExpFlags = require('../internals/regexp-get-flags');
		var stickyHelpers = require('../internals/regexp-sticky-helpers');
		var proxyAccessor = require('../internals/proxy-accessor');
		var defineBuiltIn = require('../internals/define-built-in');
		var fails = require('../internals/fails');
		var hasOwn = require('../internals/has-own-property');
		var enforceInternalState = require('../internals/internal-state').enforce;
		var setSpecies = require('../internals/set-species');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var UNSUPPORTED_DOT_ALL = require('../internals/regexp-unsupported-dot-all');
		var UNSUPPORTED_NCG = require('../internals/regexp-unsupported-ncg');

		var MATCH = wellKnownSymbol('match');
		var NativeRegExp = global.RegExp;
		var RegExpPrototype = NativeRegExp.prototype;
		var SyntaxError = global.SyntaxError;
		var exec = uncurryThis(RegExpPrototype.exec);
		var charAt = uncurryThis(''.charAt);
		var replace = uncurryThis(''.replace);
		var stringIndexOf = uncurryThis(''.indexOf);
		var stringSlice = uncurryThis(''.slice);
		// TODO: Use only proper RegExpIdentifierName
		var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
		var re1 = /a/g;
		var re2 = /a/g;

		// "new" should create a new object, old webkit bug
		var CORRECT_NEW = new NativeRegExp(re1) !== re1;

		var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
		var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;

		var BASE_FORCED = DESCRIPTORS &&
		  (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function () {
		    re2[MATCH] = false;
		    // RegExp constructor can alter flags and IsRegExp works correct with @@match
		    return NativeRegExp(re1) !== re1 || NativeRegExp(re2) === re2 || String(NativeRegExp(re1, 'i')) !== '/a/i';
		  }));

		var handleDotAll = function (string) {
		  var length = string.length;
		  var index = 0;
		  var result = '';
		  var brackets = false;
		  var chr;
		  for (; index <= length; index++) {
		    chr = charAt(string, index);
		    if (chr === '\\') {
		      result += chr + charAt(string, ++index);
		      continue;
		    }
		    if (!brackets && chr === '.') {
		      result += '[\\s\\S]';
		    } else {
		      if (chr === '[') {
		        brackets = true;
		      } else if (chr === ']') {
		        brackets = false;
		      } result += chr;
		    }
		  } return result;
		};

		var handleNCG = function (string) {
		  var length = string.length;
		  var index = 0;
		  var result = '';
		  var named = [];
		  var names = create(null);
		  var brackets = false;
		  var ncg = false;
		  var groupid = 0;
		  var groupname = '';
		  var chr;
		  for (; index <= length; index++) {
		    chr = charAt(string, index);
		    if (chr === '\\') {
		      chr += charAt(string, ++index);
		    } else if (chr === ']') {
		      brackets = false;
		    } else if (!brackets) switch (true) {
		      case chr === '[':
		        brackets = true;
		        break;
		      case chr === '(':
		        if (exec(IS_NCG, stringSlice(string, index + 1))) {
		          index += 2;
		          ncg = true;
		        }
		        result += chr;
		        groupid++;
		        continue;
		      case chr === '>' && ncg:
		        if (groupname === '' || hasOwn(names, groupname)) {
		          throw new SyntaxError('Invalid capture group name');
		        }
		        names[groupname] = true;
		        named[named.length] = [groupname, groupid];
		        ncg = false;
		        groupname = '';
		        continue;
		    }
		    if (ncg) groupname += chr;
		    else result += chr;
		  } return [result, named];
		};

		// `RegExp` constructor
		// https://tc39.es/ecma262/#sec-regexp-constructor
		if (isForced('RegExp', BASE_FORCED)) {
		  var RegExpWrapper = function RegExp(pattern, flags) {
		    var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
		    var patternIsRegExp = isRegExp(pattern);
		    var flagsAreUndefined = flags === undefined;
		    var groups = [];
		    var rawPattern = pattern;
		    var rawFlags, dotAll, sticky, handled, result, state;

		    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
		      return pattern;
		    }

		    if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
		      pattern = pattern.source;
		      if (flagsAreUndefined) flags = getRegExpFlags(rawPattern);
		    }

		    pattern = pattern === undefined ? '' : toString(pattern);
		    flags = flags === undefined ? '' : toString(flags);
		    rawPattern = pattern;

		    if (UNSUPPORTED_DOT_ALL && 'dotAll' in re1) {
		      dotAll = !!flags && stringIndexOf(flags, 's') > -1;
		      if (dotAll) flags = replace(flags, /s/g, '');
		    }

		    rawFlags = flags;

		    if (MISSED_STICKY && 'sticky' in re1) {
		      sticky = !!flags && stringIndexOf(flags, 'y') > -1;
		      if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, '');
		    }

		    if (UNSUPPORTED_NCG) {
		      handled = handleNCG(pattern);
		      pattern = handled[0];
		      groups = handled[1];
		    }

		    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);

		    if (dotAll || sticky || groups.length) {
		      state = enforceInternalState(result);
		      if (dotAll) {
		        state.dotAll = true;
		        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
		      }
		      if (sticky) state.sticky = true;
		      if (groups.length) state.groups = groups;
		    }

		    if (pattern !== rawPattern) try {
		      // fails in old engines, but we have no alternatives for unsupported regex syntax
		      createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
		    } catch (error) { /* empty */ }

		    return result;
		  };

		  for (var keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index;) {
		    proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
		  }

		  RegExpPrototype.constructor = RegExpWrapper;
		  RegExpWrapper.prototype = RegExpPrototype;
		  defineBuiltIn(global, 'RegExp', RegExpWrapper, { constructor: true });
		}

		// https://tc39.es/ecma262/#sec-get-regexp-@@species
		setSpecies('RegExp');

		},{"../internals/create-non-enumerable-property":145,"../internals/define-built-in":149,"../internals/descriptors":153,"../internals/fails":171,"../internals/function-uncurry-this":181,"../internals/global":188,"../internals/has-own-property":189,"../internals/inherit-if-required":196,"../internals/internal-state":199,"../internals/is-forced":205,"../internals/is-regexp":211,"../internals/object-create":229,"../internals/object-get-own-property-names":234,"../internals/object-is-prototype-of":238,"../internals/proxy-accessor":253,"../internals/regexp-get-flags":258,"../internals/regexp-sticky-helpers":259,"../internals/regexp-unsupported-dot-all":260,"../internals/regexp-unsupported-ncg":261,"../internals/set-species":265,"../internals/to-string":291,"../internals/well-known-symbol":306}],338:[function(require,module,exports){
		var $ = require('../internals/export');
		var exec = require('../internals/regexp-exec');

		// `RegExp.prototype.exec` method
		// https://tc39.es/ecma262/#sec-regexp.prototype.exec
		$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
		  exec: exec
		});

		},{"../internals/export":170,"../internals/regexp-exec":256}],339:[function(require,module,exports){
		var PROPER_FUNCTION_NAME = require('../internals/function-name').PROPER;
		var defineBuiltIn = require('../internals/define-built-in');
		var anObject = require('../internals/an-object');
		var $toString = require('../internals/to-string');
		var fails = require('../internals/fails');
		var getRegExpFlags = require('../internals/regexp-get-flags');

		var TO_STRING = 'toString';
		var RegExpPrototype = RegExp.prototype;
		var nativeToString = RegExpPrototype[TO_STRING];

		var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) !== '/a/b'; });
		// FF44- RegExp#toString has a wrong name
		var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;

		// `RegExp.prototype.toString` method
		// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
		if (NOT_GENERIC || INCORRECT_NAME) {
		  defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
		    var R = anObject(this);
		    var pattern = $toString(R.source);
		    var flags = $toString(getRegExpFlags(R));
		    return '/' + pattern + '/' + flags;
		  }, { unsafe: true });
		}

		},{"../internals/an-object":114,"../internals/define-built-in":149,"../internals/fails":171,"../internals/function-name":178,"../internals/regexp-get-flags":258,"../internals/to-string":291}],340:[function(require,module,exports){
		var collection = require('../internals/collection');
		var collectionStrong = require('../internals/collection-strong');

		// `Set` constructor
		// https://tc39.es/ecma262/#sec-set-objects
		collection('Set', function (init) {
		  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
		}, collectionStrong);

		},{"../internals/collection":140,"../internals/collection-strong":139}],341:[function(require,module,exports){
		// TODO: Remove this module from `core-js@4` since it's replaced to module below
		require('../modules/es.set.constructor');

		},{"../modules/es.set.constructor":340}],342:[function(require,module,exports){
		var $ = require('../internals/export');
		var uncurryThis = require('../internals/function-uncurry-this');
		var notARegExp = require('../internals/not-a-regexp');
		var requireObjectCoercible = require('../internals/require-object-coercible');
		var toString = require('../internals/to-string');
		var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');

		var stringIndexOf = uncurryThis(''.indexOf);

		// `String.prototype.includes` method
		// https://tc39.es/ecma262/#sec-string.prototype.includes
		$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
		  includes: function includes(searchString /* , position = 0 */) {
		    return !!~stringIndexOf(
		      toString(requireObjectCoercible(this)),
		      toString(notARegExp(searchString)),
		      arguments.length > 1 ? arguments[1] : undefined
		    );
		  }
		});

		},{"../internals/correct-is-regexp-logic":142,"../internals/export":170,"../internals/function-uncurry-this":181,"../internals/not-a-regexp":227,"../internals/require-object-coercible":262,"../internals/to-string":291}],343:[function(require,module,exports){
		var charAt = require('../internals/string-multibyte').charAt;
		var toString = require('../internals/to-string');
		var InternalStateModule = require('../internals/internal-state');
		var defineIterator = require('../internals/iterator-define');
		var createIterResultObject = require('../internals/create-iter-result-object');

		var STRING_ITERATOR = 'String Iterator';
		var setInternalState = InternalStateModule.set;
		var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

		// `String.prototype[@@iterator]` method
		// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
		defineIterator(String, 'String', function (iterated) {
		  setInternalState(this, {
		    type: STRING_ITERATOR,
		    string: toString(iterated),
		    index: 0
		  });
		// `%StringIteratorPrototype%.next` method
		// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
		}, function next() {
		  var state = getInternalState(this);
		  var string = state.string;
		  var index = state.index;
		  var point;
		  if (index >= string.length) return createIterResultObject(undefined, true);
		  point = charAt(string, index);
		  state.index += point.length;
		  return createIterResultObject(point, false);
		});

		},{"../internals/create-iter-result-object":144,"../internals/internal-state":199,"../internals/iterator-define":216,"../internals/string-multibyte":271,"../internals/to-string":291}],344:[function(require,module,exports){
		var call = require('../internals/function-call');
		var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
		var anObject = require('../internals/an-object');
		var isNullOrUndefined = require('../internals/is-null-or-undefined');
		var toLength = require('../internals/to-length');
		var toString = require('../internals/to-string');
		var requireObjectCoercible = require('../internals/require-object-coercible');
		var getMethod = require('../internals/get-method');
		var advanceStringIndex = require('../internals/advance-string-index');
		var regExpExec = require('../internals/regexp-exec-abstract');

		// @@match logic
		fixRegExpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
		  return [
		    // `String.prototype.match` method
		    // https://tc39.es/ecma262/#sec-string.prototype.match
		    function match(regexp) {
		      var O = requireObjectCoercible(this);
		      var matcher = isNullOrUndefined(regexp) ? undefined : getMethod(regexp, MATCH);
		      return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
		    },
		    // `RegExp.prototype[@@match]` method
		    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
		    function (string) {
		      var rx = anObject(this);
		      var S = toString(string);
		      var res = maybeCallNative(nativeMatch, rx, S);

		      if (res.done) return res.value;

		      if (!rx.global) return regExpExec(rx, S);

		      var fullUnicode = rx.unicode;
		      rx.lastIndex = 0;
		      var A = [];
		      var n = 0;
		      var result;
		      while ((result = regExpExec(rx, S)) !== null) {
		        var matchStr = toString(result[0]);
		        A[n] = matchStr;
		        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
		        n++;
		      }
		      return n === 0 ? null : A;
		    }
		  ];
		});

		},{"../internals/advance-string-index":112,"../internals/an-object":114,"../internals/fix-regexp-well-known-symbol-logic":172,"../internals/function-call":177,"../internals/get-method":186,"../internals/is-null-or-undefined":207,"../internals/regexp-exec-abstract":255,"../internals/require-object-coercible":262,"../internals/to-length":284,"../internals/to-string":291}],345:[function(require,module,exports){
		var apply = require('../internals/function-apply');
		var call = require('../internals/function-call');
		var uncurryThis = require('../internals/function-uncurry-this');
		var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
		var fails = require('../internals/fails');
		var anObject = require('../internals/an-object');
		var isCallable = require('../internals/is-callable');
		var isNullOrUndefined = require('../internals/is-null-or-undefined');
		var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
		var toLength = require('../internals/to-length');
		var toString = require('../internals/to-string');
		var requireObjectCoercible = require('../internals/require-object-coercible');
		var advanceStringIndex = require('../internals/advance-string-index');
		var getMethod = require('../internals/get-method');
		var getSubstitution = require('../internals/get-substitution');
		var regExpExec = require('../internals/regexp-exec-abstract');
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var REPLACE = wellKnownSymbol('replace');
		var max = Math.max;
		var min = Math.min;
		var concat = uncurryThis([].concat);
		var push = uncurryThis([].push);
		var stringIndexOf = uncurryThis(''.indexOf);
		var stringSlice = uncurryThis(''.slice);

		var maybeToString = function (it) {
		  return it === undefined ? it : String(it);
		};

		// IE <= 11 replaces $0 with the whole match, as if it was $&
		// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
		var REPLACE_KEEPS_$0 = (function () {
		  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
		  return 'a'.replace(/./, '$0') === '$0';
		})();

		// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
		var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
		  if (/./[REPLACE]) {
		    return /./[REPLACE]('a', '$0') === '';
		  }
		  return false;
		})();

		var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
		  var re = /./;
		  re.exec = function () {
		    var result = [];
		    result.groups = { a: '7' };
		    return result;
		  };
		  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
		  return ''.replace(re, '$<a>') !== '7';
		});

		// @@replace logic
		fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
		  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

		  return [
		    // `String.prototype.replace` method
		    // https://tc39.es/ecma262/#sec-string.prototype.replace
		    function replace(searchValue, replaceValue) {
		      var O = requireObjectCoercible(this);
		      var replacer = isNullOrUndefined(searchValue) ? undefined : getMethod(searchValue, REPLACE);
		      return replacer
		        ? call(replacer, searchValue, O, replaceValue)
		        : call(nativeReplace, toString(O), searchValue, replaceValue);
		    },
		    // `RegExp.prototype[@@replace]` method
		    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
		    function (string, replaceValue) {
		      var rx = anObject(this);
		      var S = toString(string);

		      if (
		        typeof replaceValue == 'string' &&
		        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
		        stringIndexOf(replaceValue, '$<') === -1
		      ) {
		        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
		        if (res.done) return res.value;
		      }

		      var functionalReplace = isCallable(replaceValue);
		      if (!functionalReplace) replaceValue = toString(replaceValue);

		      var global = rx.global;
		      var fullUnicode;
		      if (global) {
		        fullUnicode = rx.unicode;
		        rx.lastIndex = 0;
		      }

		      var results = [];
		      var result;
		      while (true) {
		        result = regExpExec(rx, S);
		        if (result === null) break;

		        push(results, result);
		        if (!global) break;

		        var matchStr = toString(result[0]);
		        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
		      }

		      var accumulatedResult = '';
		      var nextSourcePosition = 0;
		      for (var i = 0; i < results.length; i++) {
		        result = results[i];

		        var matched = toString(result[0]);
		        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
		        var captures = [];
		        var replacement;
		        // NOTE: This is equivalent to
		        //   captures = result.slice(1).map(maybeToString)
		        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
		        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
		        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
		        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
		        var namedCaptures = result.groups;
		        if (functionalReplace) {
		          var replacerArgs = concat([matched], captures, position, S);
		          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
		          replacement = toString(apply(replaceValue, undefined, replacerArgs));
		        } else {
		          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
		        }
		        if (position >= nextSourcePosition) {
		          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
		          nextSourcePosition = position + matched.length;
		        }
		      }

		      return accumulatedResult + stringSlice(S, nextSourcePosition);
		    }
		  ];
		}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

		},{"../internals/advance-string-index":112,"../internals/an-object":114,"../internals/fails":171,"../internals/fix-regexp-well-known-symbol-logic":172,"../internals/function-apply":174,"../internals/function-call":177,"../internals/function-uncurry-this":181,"../internals/get-method":186,"../internals/get-substitution":187,"../internals/is-callable":203,"../internals/is-null-or-undefined":207,"../internals/regexp-exec-abstract":255,"../internals/require-object-coercible":262,"../internals/to-integer-or-infinity":283,"../internals/to-length":284,"../internals/to-string":291,"../internals/well-known-symbol":306}],346:[function(require,module,exports){
		var call = require('../internals/function-call');
		var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
		var anObject = require('../internals/an-object');
		var isNullOrUndefined = require('../internals/is-null-or-undefined');
		var requireObjectCoercible = require('../internals/require-object-coercible');
		var sameValue = require('../internals/same-value');
		var toString = require('../internals/to-string');
		var getMethod = require('../internals/get-method');
		var regExpExec = require('../internals/regexp-exec-abstract');

		// @@search logic
		fixRegExpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
		  return [
		    // `String.prototype.search` method
		    // https://tc39.es/ecma262/#sec-string.prototype.search
		    function search(regexp) {
		      var O = requireObjectCoercible(this);
		      var searcher = isNullOrUndefined(regexp) ? undefined : getMethod(regexp, SEARCH);
		      return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
		    },
		    // `RegExp.prototype[@@search]` method
		    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
		    function (string) {
		      var rx = anObject(this);
		      var S = toString(string);
		      var res = maybeCallNative(nativeSearch, rx, S);

		      if (res.done) return res.value;

		      var previousLastIndex = rx.lastIndex;
		      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
		      var result = regExpExec(rx, S);
		      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
		      return result === null ? -1 : result.index;
		    }
		  ];
		});

		},{"../internals/an-object":114,"../internals/fix-regexp-well-known-symbol-logic":172,"../internals/function-call":177,"../internals/get-method":186,"../internals/is-null-or-undefined":207,"../internals/regexp-exec-abstract":255,"../internals/require-object-coercible":262,"../internals/same-value":264,"../internals/to-string":291}],347:[function(require,module,exports){
		var apply = require('../internals/function-apply');
		var call = require('../internals/function-call');
		var uncurryThis = require('../internals/function-uncurry-this');
		var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
		var anObject = require('../internals/an-object');
		var isNullOrUndefined = require('../internals/is-null-or-undefined');
		var isRegExp = require('../internals/is-regexp');
		var requireObjectCoercible = require('../internals/require-object-coercible');
		var speciesConstructor = require('../internals/species-constructor');
		var advanceStringIndex = require('../internals/advance-string-index');
		var toLength = require('../internals/to-length');
		var toString = require('../internals/to-string');
		var getMethod = require('../internals/get-method');
		var arraySlice = require('../internals/array-slice');
		var callRegExpExec = require('../internals/regexp-exec-abstract');
		var regexpExec = require('../internals/regexp-exec');
		var stickyHelpers = require('../internals/regexp-sticky-helpers');
		var fails = require('../internals/fails');

		var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
		var MAX_UINT32 = 0xFFFFFFFF;
		var min = Math.min;
		var $push = [].push;
		var exec = uncurryThis(/./.exec);
		var push = uncurryThis($push);
		var stringSlice = uncurryThis(''.slice);

		// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
		// Weex JS has frozen built-in prototypes, so use try / catch wrapper
		var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
		  // eslint-disable-next-line regexp/no-empty-group -- required for testing
		  var re = /(?:)/;
		  var originalExec = re.exec;
		  re.exec = function () { return originalExec.apply(this, arguments); };
		  var result = 'ab'.split(re);
		  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
		});

		// @@split logic
		fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
		  var internalSplit;
		  if (
		    'abbc'.split(/(b)*/)[1] === 'c' ||
		    // eslint-disable-next-line regexp/no-empty-group -- required for testing
		    'test'.split(/(?:)/, -1).length !== 4 ||
		    'ab'.split(/(?:ab)*/).length !== 2 ||
		    '.'.split(/(.?)(.?)/).length !== 4 ||
		    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
		    '.'.split(/()()/).length > 1 ||
		    ''.split(/.?/).length
		  ) {
		    // based on es5-shim implementation, need to rework it
		    internalSplit = function (separator, limit) {
		      var string = toString(requireObjectCoercible(this));
		      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
		      if (lim === 0) return [];
		      if (separator === undefined) return [string];
		      // If `separator` is not a regex, use native split
		      if (!isRegExp(separator)) {
		        return call(nativeSplit, string, separator, lim);
		      }
		      var output = [];
		      var flags = (separator.ignoreCase ? 'i' : '') +
		                  (separator.multiline ? 'm' : '') +
		                  (separator.unicode ? 'u' : '') +
		                  (separator.sticky ? 'y' : '');
		      var lastLastIndex = 0;
		      // Make `global` and avoid `lastIndex` issues by working with a copy
		      var separatorCopy = new RegExp(separator.source, flags + 'g');
		      var match, lastIndex, lastLength;
		      while (match = call(regexpExec, separatorCopy, string)) {
		        lastIndex = separatorCopy.lastIndex;
		        if (lastIndex > lastLastIndex) {
		          push(output, stringSlice(string, lastLastIndex, match.index));
		          if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));
		          lastLength = match[0].length;
		          lastLastIndex = lastIndex;
		          if (output.length >= lim) break;
		        }
		        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
		      }
		      if (lastLastIndex === string.length) {
		        if (lastLength || !exec(separatorCopy, '')) push(output, '');
		      } else push(output, stringSlice(string, lastLastIndex));
		      return output.length > lim ? arraySlice(output, 0, lim) : output;
		    };
		  // Chakra, V8
		  } else if ('0'.split(undefined, 0).length) {
		    internalSplit = function (separator, limit) {
		      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
		    };
		  } else internalSplit = nativeSplit;

		  return [
		    // `String.prototype.split` method
		    // https://tc39.es/ecma262/#sec-string.prototype.split
		    function split(separator, limit) {
		      var O = requireObjectCoercible(this);
		      var splitter = isNullOrUndefined(separator) ? undefined : getMethod(separator, SPLIT);
		      return splitter
		        ? call(splitter, separator, O, limit)
		        : call(internalSplit, toString(O), separator, limit);
		    },
		    // `RegExp.prototype[@@split]` method
		    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
		    //
		    // NOTE: This cannot be properly polyfilled in engines that don't support
		    // the 'y' flag.
		    function (string, limit) {
		      var rx = anObject(this);
		      var S = toString(string);
		      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);

		      if (res.done) return res.value;

		      var C = speciesConstructor(rx, RegExp);

		      var unicodeMatching = rx.unicode;
		      var flags = (rx.ignoreCase ? 'i' : '') +
		                  (rx.multiline ? 'm' : '') +
		                  (rx.unicode ? 'u' : '') +
		                  (UNSUPPORTED_Y ? 'g' : 'y');

		      // ^(? + rx + ) is needed, in combination with some S slicing, to
		      // simulate the 'y' flag.
		      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
		      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
		      if (lim === 0) return [];
		      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
		      var p = 0;
		      var q = 0;
		      var A = [];
		      while (q < S.length) {
		        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
		        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
		        var e;
		        if (
		          z === null ||
		          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
		        ) {
		          q = advanceStringIndex(S, q, unicodeMatching);
		        } else {
		          push(A, stringSlice(S, p, q));
		          if (A.length === lim) return A;
		          for (var i = 1; i <= z.length - 1; i++) {
		            push(A, z[i]);
		            if (A.length === lim) return A;
		          }
		          q = p = e;
		        }
		      }
		      push(A, stringSlice(S, p));
		      return A;
		    }
		  ];
		}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);

		},{"../internals/advance-string-index":112,"../internals/an-object":114,"../internals/array-slice":131,"../internals/fails":171,"../internals/fix-regexp-well-known-symbol-logic":172,"../internals/function-apply":174,"../internals/function-call":177,"../internals/function-uncurry-this":181,"../internals/get-method":186,"../internals/is-null-or-undefined":207,"../internals/is-regexp":211,"../internals/regexp-exec":256,"../internals/regexp-exec-abstract":255,"../internals/regexp-sticky-helpers":259,"../internals/require-object-coercible":262,"../internals/species-constructor":270,"../internals/to-length":284,"../internals/to-string":291}],348:[function(require,module,exports){
		var $ = require('../internals/export');
		var uncurryThis = require('../internals/function-uncurry-this-clause');
		var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
		var toLength = require('../internals/to-length');
		var toString = require('../internals/to-string');
		var notARegExp = require('../internals/not-a-regexp');
		var requireObjectCoercible = require('../internals/require-object-coercible');
		var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
		var IS_PURE = require('../internals/is-pure');

		var stringSlice = uncurryThis(''.slice);
		var min = Math.min;

		var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
		// https://github.com/zloirock/core-js/pull/702
		var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
		  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
		  return descriptor && !descriptor.writable;
		}();

		// `String.prototype.startsWith` method
		// https://tc39.es/ecma262/#sec-string.prototype.startswith
		$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
		  startsWith: function startsWith(searchString /* , position = 0 */) {
		    var that = toString(requireObjectCoercible(this));
		    notARegExp(searchString);
		    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
		    var search = toString(searchString);
		    return stringSlice(that, index, index + search.length) === search;
		  }
		});

		},{"../internals/correct-is-regexp-logic":142,"../internals/export":170,"../internals/function-uncurry-this-clause":180,"../internals/is-pure":210,"../internals/not-a-regexp":227,"../internals/object-get-own-property-descriptor":232,"../internals/require-object-coercible":262,"../internals/to-length":284,"../internals/to-string":291}],349:[function(require,module,exports){
		var $ = require('../internals/export');
		var $trim = require('../internals/string-trim').trim;
		var forcedStringTrimMethod = require('../internals/string-trim-forced');

		// `String.prototype.trim` method
		// https://tc39.es/ecma262/#sec-string.prototype.trim
		$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
		  trim: function trim() {
		    return $trim(this);
		  }
		});

		},{"../internals/export":170,"../internals/string-trim":273,"../internals/string-trim-forced":272}],350:[function(require,module,exports){
		var $ = require('../internals/export');
		var global = require('../internals/global');
		var call = require('../internals/function-call');
		var uncurryThis = require('../internals/function-uncurry-this');
		var IS_PURE = require('../internals/is-pure');
		var DESCRIPTORS = require('../internals/descriptors');
		var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');
		var fails = require('../internals/fails');
		var hasOwn = require('../internals/has-own-property');
		var isPrototypeOf = require('../internals/object-is-prototype-of');
		var anObject = require('../internals/an-object');
		var toIndexedObject = require('../internals/to-indexed-object');
		var toPropertyKey = require('../internals/to-property-key');
		var $toString = require('../internals/to-string');
		var createPropertyDescriptor = require('../internals/create-property-descriptor');
		var nativeObjectCreate = require('../internals/object-create');
		var objectKeys = require('../internals/object-keys');
		var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
		var getOwnPropertyNamesExternal = require('../internals/object-get-own-property-names-external');
		var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
		var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
		var definePropertyModule = require('../internals/object-define-property');
		var definePropertiesModule = require('../internals/object-define-properties');
		var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
		var defineBuiltIn = require('../internals/define-built-in');
		var defineBuiltInAccessor = require('../internals/define-built-in-accessor');
		var shared = require('../internals/shared');
		var sharedKey = require('../internals/shared-key');
		var hiddenKeys = require('../internals/hidden-keys');
		var uid = require('../internals/uid');
		var wellKnownSymbol = require('../internals/well-known-symbol');
		var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
		var defineWellKnownSymbol = require('../internals/well-known-symbol-define');
		var defineSymbolToPrimitive = require('../internals/symbol-define-to-primitive');
		var setToStringTag = require('../internals/set-to-string-tag');
		var InternalStateModule = require('../internals/internal-state');
		var $forEach = require('../internals/array-iteration').forEach;

		var HIDDEN = sharedKey('hidden');
		var SYMBOL = 'Symbol';
		var PROTOTYPE = 'prototype';

		var setInternalState = InternalStateModule.set;
		var getInternalState = InternalStateModule.getterFor(SYMBOL);

		var ObjectPrototype = Object[PROTOTYPE];
		var $Symbol = global.Symbol;
		var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
		var RangeError = global.RangeError;
		var TypeError = global.TypeError;
		var QObject = global.QObject;
		var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
		var nativeDefineProperty = definePropertyModule.f;
		var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
		var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
		var push = uncurryThis([].push);

		var AllSymbols = shared('symbols');
		var ObjectPrototypeSymbols = shared('op-symbols');
		var WellKnownSymbolsStore = shared('wks');

		// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
		var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

		// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
		var fallbackDefineProperty = function (O, P, Attributes) {
		  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
		  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
		  nativeDefineProperty(O, P, Attributes);
		  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
		    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
		  }
		};

		var setSymbolDescriptor = DESCRIPTORS && fails(function () {
		  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
		    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
		  })).a !== 7;
		}) ? fallbackDefineProperty : nativeDefineProperty;

		var wrap = function (tag, description) {
		  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
		  setInternalState(symbol, {
		    type: SYMBOL,
		    tag: tag,
		    description: description
		  });
		  if (!DESCRIPTORS) symbol.description = description;
		  return symbol;
		};

		var $defineProperty = function defineProperty(O, P, Attributes) {
		  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
		  anObject(O);
		  var key = toPropertyKey(P);
		  anObject(Attributes);
		  if (hasOwn(AllSymbols, key)) {
		    if (!Attributes.enumerable) {
		      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
		      O[HIDDEN][key] = true;
		    } else {
		      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
		      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
		    } return setSymbolDescriptor(O, key, Attributes);
		  } return nativeDefineProperty(O, key, Attributes);
		};

		var $defineProperties = function defineProperties(O, Properties) {
		  anObject(O);
		  var properties = toIndexedObject(Properties);
		  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
		  $forEach(keys, function (key) {
		    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
		  });
		  return O;
		};

		var $create = function create(O, Properties) {
		  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
		};

		var $propertyIsEnumerable = function propertyIsEnumerable(V) {
		  var P = toPropertyKey(V);
		  var enumerable = call(nativePropertyIsEnumerable, this, P);
		  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
		  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
		    ? enumerable : true;
		};

		var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
		  var it = toIndexedObject(O);
		  var key = toPropertyKey(P);
		  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
		  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
		  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
		    descriptor.enumerable = true;
		  }
		  return descriptor;
		};

		var $getOwnPropertyNames = function getOwnPropertyNames(O) {
		  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
		  var result = [];
		  $forEach(names, function (key) {
		    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
		  });
		  return result;
		};

		var $getOwnPropertySymbols = function (O) {
		  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
		  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
		  var result = [];
		  $forEach(names, function (key) {
		    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
		      push(result, AllSymbols[key]);
		    }
		  });
		  return result;
		};

		// `Symbol` constructor
		// https://tc39.es/ecma262/#sec-symbol-constructor
		if (!NATIVE_SYMBOL) {
		  $Symbol = function Symbol() {
		    if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError('Symbol is not a constructor');
		    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
		    var tag = uid(description);
		    var setter = function (value) {
		      var $this = this === undefined ? global : this;
		      if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
		      if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
		      var descriptor = createPropertyDescriptor(1, value);
		      try {
		        setSymbolDescriptor($this, tag, descriptor);
		      } catch (error) {
		        if (!(error instanceof RangeError)) throw error;
		        fallbackDefineProperty($this, tag, descriptor);
		      }
		    };
		    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
		    return wrap(tag, description);
		  };

		  SymbolPrototype = $Symbol[PROTOTYPE];

		  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
		    return getInternalState(this).tag;
		  });

		  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
		    return wrap(uid(description), description);
		  });

		  propertyIsEnumerableModule.f = $propertyIsEnumerable;
		  definePropertyModule.f = $defineProperty;
		  definePropertiesModule.f = $defineProperties;
		  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
		  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
		  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

		  wrappedWellKnownSymbolModule.f = function (name) {
		    return wrap(wellKnownSymbol(name), name);
		  };

		  if (DESCRIPTORS) {
		    // https://github.com/tc39/proposal-Symbol-description
		    defineBuiltInAccessor(SymbolPrototype, 'description', {
		      configurable: true,
		      get: function description() {
		        return getInternalState(this).description;
		      }
		    });
		    if (!IS_PURE) {
		      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
		    }
		  }
		}

		$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
		  Symbol: $Symbol
		});

		$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
		  defineWellKnownSymbol(name);
		});

		$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
		  useSetter: function () { USE_SETTER = true; },
		  useSimple: function () { USE_SETTER = false; }
		});

		$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
		  // `Object.create` method
		  // https://tc39.es/ecma262/#sec-object.create
		  create: $create,
		  // `Object.defineProperty` method
		  // https://tc39.es/ecma262/#sec-object.defineproperty
		  defineProperty: $defineProperty,
		  // `Object.defineProperties` method
		  // https://tc39.es/ecma262/#sec-object.defineproperties
		  defineProperties: $defineProperties,
		  // `Object.getOwnPropertyDescriptor` method
		  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
		  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
		});

		$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
		  // `Object.getOwnPropertyNames` method
		  // https://tc39.es/ecma262/#sec-object.getownpropertynames
		  getOwnPropertyNames: $getOwnPropertyNames
		});

		// `Symbol.prototype[@@toPrimitive]` method
		// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
		defineSymbolToPrimitive();

		// `Symbol.prototype[@@toStringTag]` property
		// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
		setToStringTag($Symbol, SYMBOL);

		hiddenKeys[HIDDEN] = true;

		},{"../internals/an-object":114,"../internals/array-iteration":125,"../internals/create-property-descriptor":146,"../internals/define-built-in":149,"../internals/define-built-in-accessor":148,"../internals/descriptors":153,"../internals/export":170,"../internals/fails":171,"../internals/function-call":177,"../internals/function-uncurry-this":181,"../internals/global":188,"../internals/has-own-property":189,"../internals/hidden-keys":190,"../internals/internal-state":199,"../internals/is-pure":210,"../internals/object-create":229,"../internals/object-define-properties":230,"../internals/object-define-property":231,"../internals/object-get-own-property-descriptor":232,"../internals/object-get-own-property-names":234,"../internals/object-get-own-property-names-external":233,"../internals/object-get-own-property-symbols":235,"../internals/object-is-prototype-of":238,"../internals/object-keys":240,"../internals/object-property-is-enumerable":241,"../internals/set-to-string-tag":266,"../internals/shared":269,"../internals/shared-key":267,"../internals/symbol-constructor-detection":274,"../internals/symbol-define-to-primitive":275,"../internals/to-indexed-object":282,"../internals/to-property-key":289,"../internals/to-string":291,"../internals/uid":299,"../internals/well-known-symbol":306,"../internals/well-known-symbol-define":304,"../internals/well-known-symbol-wrapped":305}],351:[function(require,module,exports){
		var $ = require('../internals/export');
		var DESCRIPTORS = require('../internals/descriptors');
		var global = require('../internals/global');
		var uncurryThis = require('../internals/function-uncurry-this');
		var hasOwn = require('../internals/has-own-property');
		var isCallable = require('../internals/is-callable');
		var isPrototypeOf = require('../internals/object-is-prototype-of');
		var toString = require('../internals/to-string');
		var defineBuiltInAccessor = require('../internals/define-built-in-accessor');
		var copyConstructorProperties = require('../internals/copy-constructor-properties');

		var NativeSymbol = global.Symbol;
		var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

		if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
		  // Safari 12 bug
		  NativeSymbol().description !== undefined
		)) {
		  var EmptyStringDescriptionStore = {};
		  // wrap Symbol constructor for correct work with undefined description
		  var SymbolWrapper = function Symbol() {
		    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
		    var result = isPrototypeOf(SymbolPrototype, this)
		      ? new NativeSymbol(description)
		      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
		      : description === undefined ? NativeSymbol() : NativeSymbol(description);
		    if (description === '') EmptyStringDescriptionStore[result] = true;
		    return result;
		  };

		  copyConstructorProperties(SymbolWrapper, NativeSymbol);
		  SymbolWrapper.prototype = SymbolPrototype;
		  SymbolPrototype.constructor = SymbolWrapper;

		  var NATIVE_SYMBOL = String(NativeSymbol('description detection')) === 'Symbol(description detection)';
		  var thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
		  var symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
		  var regexp = /^Symbol\((.*)\)[^)]+$/;
		  var replace = uncurryThis(''.replace);
		  var stringSlice = uncurryThis(''.slice);

		  defineBuiltInAccessor(SymbolPrototype, 'description', {
		    configurable: true,
		    get: function description() {
		      var symbol = thisSymbolValue(this);
		      if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
		      var string = symbolDescriptiveString(symbol);
		      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
		      return desc === '' ? undefined : desc;
		    }
		  });

		  $({ global: true, constructor: true, forced: true }, {
		    Symbol: SymbolWrapper
		  });
		}

		},{"../internals/copy-constructor-properties":141,"../internals/define-built-in-accessor":148,"../internals/descriptors":153,"../internals/export":170,"../internals/function-uncurry-this":181,"../internals/global":188,"../internals/has-own-property":189,"../internals/is-callable":203,"../internals/object-is-prototype-of":238,"../internals/to-string":291}],352:[function(require,module,exports){
		var $ = require('../internals/export');
		var getBuiltIn = require('../internals/get-built-in');
		var hasOwn = require('../internals/has-own-property');
		var toString = require('../internals/to-string');
		var shared = require('../internals/shared');
		var NATIVE_SYMBOL_REGISTRY = require('../internals/symbol-registry-detection');

		var StringToSymbolRegistry = shared('string-to-symbol-registry');
		var SymbolToStringRegistry = shared('symbol-to-string-registry');

		// `Symbol.for` method
		// https://tc39.es/ecma262/#sec-symbol.for
		$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
		  'for': function (key) {
		    var string = toString(key);
		    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
		    var symbol = getBuiltIn('Symbol')(string);
		    StringToSymbolRegistry[string] = symbol;
		    SymbolToStringRegistry[symbol] = string;
		    return symbol;
		  }
		});

		},{"../internals/export":170,"../internals/get-built-in":182,"../internals/has-own-property":189,"../internals/shared":269,"../internals/symbol-registry-detection":276,"../internals/to-string":291}],353:[function(require,module,exports){
		var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

		// `Symbol.iterator` well-known symbol
		// https://tc39.es/ecma262/#sec-symbol.iterator
		defineWellKnownSymbol('iterator');

		},{"../internals/well-known-symbol-define":304}],354:[function(require,module,exports){
		// TODO: Remove this module from `core-js@4` since it's split to modules listed below
		require('../modules/es.symbol.constructor');
		require('../modules/es.symbol.for');
		require('../modules/es.symbol.key-for');
		require('../modules/es.json.stringify');
		require('../modules/es.object.get-own-property-symbols');

		},{"../modules/es.json.stringify":323,"../modules/es.object.get-own-property-symbols":327,"../modules/es.symbol.constructor":350,"../modules/es.symbol.for":352,"../modules/es.symbol.key-for":355}],355:[function(require,module,exports){
		var $ = require('../internals/export');
		var hasOwn = require('../internals/has-own-property');
		var isSymbol = require('../internals/is-symbol');
		var tryToString = require('../internals/try-to-string');
		var shared = require('../internals/shared');
		var NATIVE_SYMBOL_REGISTRY = require('../internals/symbol-registry-detection');

		var SymbolToStringRegistry = shared('symbol-to-string-registry');

		// `Symbol.keyFor` method
		// https://tc39.es/ecma262/#sec-symbol.keyfor
		$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
		  keyFor: function keyFor(sym) {
		    if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + ' is not a symbol');
		    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
		  }
		});

		},{"../internals/export":170,"../internals/has-own-property":189,"../internals/is-symbol":212,"../internals/shared":269,"../internals/symbol-registry-detection":276,"../internals/try-to-string":293}],356:[function(require,module,exports){
		var uncurryThis = require('../internals/function-uncurry-this');
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $ArrayCopyWithin = require('../internals/array-copy-within');

		var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.copyWithin` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
		exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
		  return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-copy-within":119,"../internals/function-uncurry-this":181}],357:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $every = require('../internals/array-iteration').every;

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.every` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
		exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
		  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-iteration":125}],358:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $fill = require('../internals/array-fill');
		var toBigInt = require('../internals/to-big-int');
		var classof = require('../internals/classof');
		var call = require('../internals/function-call');
		var uncurryThis = require('../internals/function-uncurry-this');
		var fails = require('../internals/fails');

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
		var slice = uncurryThis(''.slice);

		// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18
		var CONVERSION_BUG = fails(function () {
		  var count = 0;
		  // eslint-disable-next-line es/no-typed-arrays -- safe
		  new Int8Array(2).fill({ valueOf: function () { return count++; } });
		  return count !== 1;
		});

		// `%TypedArray%.prototype.fill` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
		exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
		  var length = arguments.length;
		  aTypedArray(this);
		  var actualValue = slice(classof(this), 0, 3) === 'Big' ? toBigInt(value) : +value;
		  return call($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);
		}, CONVERSION_BUG);

		},{"../internals/array-buffer-view-core":117,"../internals/array-fill":120,"../internals/classof":138,"../internals/fails":171,"../internals/function-call":177,"../internals/function-uncurry-this":181,"../internals/to-big-int":280}],359:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $filter = require('../internals/array-iteration').filter;
		var fromSpeciesAndList = require('../internals/typed-array-from-species-and-list');

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.filter` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
		exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
		  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		  return fromSpeciesAndList(this, list);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-iteration":125,"../internals/typed-array-from-species-and-list":296}],360:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $findIndex = require('../internals/array-iteration').findIndex;

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.findIndex` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
		exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
		  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-iteration":125}],361:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $find = require('../internals/array-iteration').find;

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.find` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
		exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
		  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-iteration":125}],362:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $forEach = require('../internals/array-iteration').forEach;

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.forEach` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
		exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
		  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-iteration":125}],363:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $includes = require('../internals/array-includes').includes;

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.includes` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
		exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
		  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-includes":124}],364:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $indexOf = require('../internals/array-includes').indexOf;

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.indexOf` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
		exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
		  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-includes":124}],365:[function(require,module,exports){
		var global = require('../internals/global');
		var fails = require('../internals/fails');
		var uncurryThis = require('../internals/function-uncurry-this');
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var ArrayIterators = require('../modules/es.array.iterator');
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var ITERATOR = wellKnownSymbol('iterator');
		var Uint8Array = global.Uint8Array;
		var arrayValues = uncurryThis(ArrayIterators.values);
		var arrayKeys = uncurryThis(ArrayIterators.keys);
		var arrayEntries = uncurryThis(ArrayIterators.entries);
		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
		var TypedArrayPrototype = Uint8Array && Uint8Array.prototype;

		var GENERIC = !fails(function () {
		  TypedArrayPrototype[ITERATOR].call([1]);
		});

		var ITERATOR_IS_VALUES = !!TypedArrayPrototype
		  && TypedArrayPrototype.values
		  && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values
		  && TypedArrayPrototype.values.name === 'values';

		var typedArrayValues = function values() {
		  return arrayValues(aTypedArray(this));
		};

		// `%TypedArray%.prototype.entries` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
		exportTypedArrayMethod('entries', function entries() {
		  return arrayEntries(aTypedArray(this));
		}, GENERIC);
		// `%TypedArray%.prototype.keys` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
		exportTypedArrayMethod('keys', function keys() {
		  return arrayKeys(aTypedArray(this));
		}, GENERIC);
		// `%TypedArray%.prototype.values` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
		exportTypedArrayMethod('values', typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });
		// `%TypedArray%.prototype[@@iterator]` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
		exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });

		},{"../internals/array-buffer-view-core":117,"../internals/fails":171,"../internals/function-uncurry-this":181,"../internals/global":188,"../internals/well-known-symbol":306,"../modules/es.array.iterator":316}],366:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var uncurryThis = require('../internals/function-uncurry-this');

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
		var $join = uncurryThis([].join);

		// `%TypedArray%.prototype.join` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
		exportTypedArrayMethod('join', function join(separator) {
		  return $join(aTypedArray(this), separator);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/function-uncurry-this":181}],367:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var apply = require('../internals/function-apply');
		var $lastIndexOf = require('../internals/array-last-index-of');

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.lastIndexOf` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
		exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
		  var length = arguments.length;
		  return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-last-index-of":126,"../internals/function-apply":174}],368:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $map = require('../internals/array-iteration').map;
		var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.map` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
		exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
		  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
		    return new (typedArraySpeciesConstructor(O))(length);
		  });
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-iteration":125,"../internals/typed-array-species-constructor":298}],369:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $reduceRight = require('../internals/array-reduce').right;

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.reduceRight` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
		exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
		  var length = arguments.length;
		  return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-reduce":129}],370:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $reduce = require('../internals/array-reduce').left;

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.reduce` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
		exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
		  var length = arguments.length;
		  return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-reduce":129}],371:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
		var floor = Math.floor;

		// `%TypedArray%.prototype.reverse` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
		exportTypedArrayMethod('reverse', function reverse() {
		  var that = this;
		  var length = aTypedArray(that).length;
		  var middle = floor(length / 2);
		  var index = 0;
		  var value;
		  while (index < middle) {
		    value = that[index];
		    that[index++] = that[--length];
		    that[length] = value;
		  } return that;
		});

		},{"../internals/array-buffer-view-core":117}],372:[function(require,module,exports){
		var global = require('../internals/global');
		var call = require('../internals/function-call');
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var lengthOfArrayLike = require('../internals/length-of-array-like');
		var toOffset = require('../internals/to-offset');
		var toIndexedObject = require('../internals/to-object');
		var fails = require('../internals/fails');

		var RangeError = global.RangeError;
		var Int8Array = global.Int8Array;
		var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
		var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function () {
		  // eslint-disable-next-line es/no-typed-arrays -- required for testing
		  var array = new Uint8ClampedArray(2);
		  call($set, array, { length: 1, 0: 3 }, 1);
		  return array[1] !== 3;
		});

		// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
		var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
		  var array = new Int8Array(2);
		  array.set(1);
		  array.set('2', 1);
		  return array[0] !== 0 || array[1] !== 2;
		});

		// `%TypedArray%.prototype.set` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
		exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
		  aTypedArray(this);
		  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
		  var src = toIndexedObject(arrayLike);
		  if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
		  var length = this.length;
		  var len = lengthOfArrayLike(src);
		  var index = 0;
		  if (len + offset > length) throw new RangeError('Wrong length');
		  while (index < len) this[offset + index] = src[index++];
		}, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);

		},{"../internals/array-buffer-view-core":117,"../internals/fails":171,"../internals/function-call":177,"../internals/global":188,"../internals/length-of-array-like":219,"../internals/to-object":285,"../internals/to-offset":286}],373:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');
		var fails = require('../internals/fails');
		var arraySlice = require('../internals/array-slice');

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		var FORCED = fails(function () {
		  // eslint-disable-next-line es/no-typed-arrays -- required for testing
		  new Int8Array(1).slice();
		});

		// `%TypedArray%.prototype.slice` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
		exportTypedArrayMethod('slice', function slice(start, end) {
		  var list = arraySlice(aTypedArray(this), start, end);
		  var C = typedArraySpeciesConstructor(this);
		  var index = 0;
		  var length = list.length;
		  var result = new C(length);
		  while (length > index) result[index] = list[index++];
		  return result;
		}, FORCED);

		},{"../internals/array-buffer-view-core":117,"../internals/array-slice":131,"../internals/fails":171,"../internals/typed-array-species-constructor":298}],374:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var $some = require('../internals/array-iteration').some;

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.some` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
		exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
		  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		});

		},{"../internals/array-buffer-view-core":117,"../internals/array-iteration":125}],375:[function(require,module,exports){
		var global = require('../internals/global');
		var uncurryThis = require('../internals/function-uncurry-this-clause');
		var fails = require('../internals/fails');
		var aCallable = require('../internals/a-callable');
		var internalSort = require('../internals/array-sort');
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var FF = require('../internals/engine-ff-version');
		var IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');
		var V8 = require('../internals/engine-v8-version');
		var WEBKIT = require('../internals/engine-webkit-version');

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
		var Uint16Array = global.Uint16Array;
		var nativeSort = Uint16Array && uncurryThis(Uint16Array.prototype.sort);

		// WebKit
		var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function () {
		  nativeSort(new Uint16Array(2), null);
		}) && fails(function () {
		  nativeSort(new Uint16Array(2), {});
		}));

		var STABLE_SORT = !!nativeSort && !fails(function () {
		  // feature detection can be too slow, so check engines versions
		  if (V8) return V8 < 74;
		  if (FF) return FF < 67;
		  if (IE_OR_EDGE) return true;
		  if (WEBKIT) return WEBKIT < 602;

		  var array = new Uint16Array(516);
		  var expected = Array(516);
		  var index, mod;

		  for (index = 0; index < 516; index++) {
		    mod = index % 4;
		    array[index] = 515 - index;
		    expected[index] = index - 2 * mod + 3;
		  }

		  nativeSort(array, function (a, b) {
		    return (a / 4 | 0) - (b / 4 | 0);
		  });

		  for (index = 0; index < 516; index++) {
		    if (array[index] !== expected[index]) return true;
		  }
		});

		var getSortCompare = function (comparefn) {
		  return function (x, y) {
		    if (comparefn !== undefined) return +comparefn(x, y) || 0;
		    // eslint-disable-next-line no-self-compare -- NaN check
		    if (y !== y) return -1;
		    // eslint-disable-next-line no-self-compare -- NaN check
		    if (x !== x) return 1;
		    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
		    return x > y;
		  };
		};

		// `%TypedArray%.prototype.sort` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
		exportTypedArrayMethod('sort', function sort(comparefn) {
		  if (comparefn !== undefined) aCallable(comparefn);
		  if (STABLE_SORT) return nativeSort(this, comparefn);

		  return internalSort(aTypedArray(this), getSortCompare(comparefn));
		}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);

		},{"../internals/a-callable":108,"../internals/array-buffer-view-core":117,"../internals/array-sort":132,"../internals/engine-ff-version":158,"../internals/engine-is-ie-or-edge":161,"../internals/engine-v8-version":167,"../internals/engine-webkit-version":168,"../internals/fails":171,"../internals/function-uncurry-this-clause":180,"../internals/global":188}],376:[function(require,module,exports){
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var toLength = require('../internals/to-length');
		var toAbsoluteIndex = require('../internals/to-absolute-index');
		var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');

		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

		// `%TypedArray%.prototype.subarray` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
		exportTypedArrayMethod('subarray', function subarray(begin, end) {
		  var O = aTypedArray(this);
		  var length = O.length;
		  var beginIndex = toAbsoluteIndex(begin, length);
		  var C = typedArraySpeciesConstructor(O);
		  return new C(
		    O.buffer,
		    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
		    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
		  );
		});

		},{"../internals/array-buffer-view-core":117,"../internals/to-absolute-index":279,"../internals/to-length":284,"../internals/typed-array-species-constructor":298}],377:[function(require,module,exports){
		var global = require('../internals/global');
		var apply = require('../internals/function-apply');
		var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
		var fails = require('../internals/fails');
		var arraySlice = require('../internals/array-slice');

		var Int8Array = global.Int8Array;
		var aTypedArray = ArrayBufferViewCore.aTypedArray;
		var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
		var $toLocaleString = [].toLocaleString;

		// iOS Safari 6.x fails here
		var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
		  $toLocaleString.call(new Int8Array(1));
		});

		var FORCED = fails(function () {
		  return [1, 2].toLocaleString() !== new Int8Array([1, 2]).toLocaleString();
		}) || !fails(function () {
		  Int8Array.prototype.toLocaleString.call([1, 2]);
		});

		// `%TypedArray%.prototype.toLocaleString` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
		exportTypedArrayMethod('toLocaleString', function toLocaleString() {
		  return apply(
		    $toLocaleString,
		    TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this),
		    arraySlice(arguments)
		  );
		}, FORCED);

		},{"../internals/array-buffer-view-core":117,"../internals/array-slice":131,"../internals/fails":171,"../internals/function-apply":174,"../internals/global":188}],378:[function(require,module,exports){
		var exportTypedArrayMethod = require('../internals/array-buffer-view-core').exportTypedArrayMethod;
		var fails = require('../internals/fails');
		var global = require('../internals/global');
		var uncurryThis = require('../internals/function-uncurry-this');

		var Uint8Array = global.Uint8Array;
		var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
		var arrayToString = [].toString;
		var join = uncurryThis([].join);

		if (fails(function () { arrayToString.call({}); })) {
		  arrayToString = function toString() {
		    return join(this);
		  };
		}

		var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString !== arrayToString;

		// `%TypedArray%.prototype.toString` method
		// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
		exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);

		},{"../internals/array-buffer-view-core":117,"../internals/fails":171,"../internals/function-uncurry-this":181,"../internals/global":188}],379:[function(require,module,exports){
		var createTypedArrayConstructor = require('../internals/typed-array-constructor');

		// `Uint8Array` constructor
		// https://tc39.es/ecma262/#sec-typedarray-objects
		createTypedArrayConstructor('Uint8', function (init) {
		  return function Uint8Array(data, byteOffset, length) {
		    return init(this, data, byteOffset, length);
		  };
		});

		},{"../internals/typed-array-constructor":294}],380:[function(require,module,exports){
		var global = require('../internals/global');
		var DOMIterables = require('../internals/dom-iterables');
		var DOMTokenListPrototype = require('../internals/dom-token-list-prototype');
		var forEach = require('../internals/array-for-each');
		var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

		var handlePrototype = function (CollectionPrototype) {
		  // some Chrome versions have non-configurable methods on DOMTokenList
		  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
		    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
		  } catch (error) {
		    CollectionPrototype.forEach = forEach;
		  }
		};

		for (var COLLECTION_NAME in DOMIterables) {
		  if (DOMIterables[COLLECTION_NAME]) {
		    handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype);
		  }
		}

		handlePrototype(DOMTokenListPrototype);

		},{"../internals/array-for-each":121,"../internals/create-non-enumerable-property":145,"../internals/dom-iterables":156,"../internals/dom-token-list-prototype":157,"../internals/global":188}],381:[function(require,module,exports){
		var global = require('../internals/global');
		var DOMIterables = require('../internals/dom-iterables');
		var DOMTokenListPrototype = require('../internals/dom-token-list-prototype');
		var ArrayIteratorMethods = require('../modules/es.array.iterator');
		var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
		var setToStringTag = require('../internals/set-to-string-tag');
		var wellKnownSymbol = require('../internals/well-known-symbol');

		var ITERATOR = wellKnownSymbol('iterator');
		var ArrayValues = ArrayIteratorMethods.values;

		var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
		  if (CollectionPrototype) {
		    // some Chrome versions have non-configurable methods on DOMTokenList
		    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
		      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
		    } catch (error) {
		      CollectionPrototype[ITERATOR] = ArrayValues;
		    }
		    setToStringTag(CollectionPrototype, COLLECTION_NAME, true);
		    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
		      // some Chrome versions have non-configurable methods on DOMTokenList
		      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
		        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
		      } catch (error) {
		        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
		      }
		    }
		  }
		};

		for (var COLLECTION_NAME in DOMIterables) {
		  handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype, COLLECTION_NAME);
		}

		handlePrototype(DOMTokenListPrototype, 'DOMTokenList');

		},{"../internals/create-non-enumerable-property":145,"../internals/dom-iterables":156,"../internals/dom-token-list-prototype":157,"../internals/global":188,"../internals/set-to-string-tag":266,"../internals/well-known-symbol":306,"../modules/es.array.iterator":316}],382:[function(require,module,exports){
		// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.

		// NOTE: These type checking functions intentionally don't use `instanceof`
		// because it is fragile and can be easily faked with `Object.create()`.

		function isArray(arg) {
		  if (Array.isArray) {
		    return Array.isArray(arg);
		  }
		  return objectToString(arg) === '[object Array]';
		}
		exports.isArray = isArray;

		function isBoolean(arg) {
		  return typeof arg === 'boolean';
		}
		exports.isBoolean = isBoolean;

		function isNull(arg) {
		  return arg === null;
		}
		exports.isNull = isNull;

		function isNullOrUndefined(arg) {
		  return arg == null;
		}
		exports.isNullOrUndefined = isNullOrUndefined;

		function isNumber(arg) {
		  return typeof arg === 'number';
		}
		exports.isNumber = isNumber;

		function isString(arg) {
		  return typeof arg === 'string';
		}
		exports.isString = isString;

		function isSymbol(arg) {
		  return typeof arg === 'symbol';
		}
		exports.isSymbol = isSymbol;

		function isUndefined(arg) {
		  return arg === void 0;
		}
		exports.isUndefined = isUndefined;

		function isRegExp(re) {
		  return objectToString(re) === '[object RegExp]';
		}
		exports.isRegExp = isRegExp;

		function isObject(arg) {
		  return typeof arg === 'object' && arg !== null;
		}
		exports.isObject = isObject;

		function isDate(d) {
		  return objectToString(d) === '[object Date]';
		}
		exports.isDate = isDate;

		function isError(e) {
		  return (objectToString(e) === '[object Error]' || e instanceof Error);
		}
		exports.isError = isError;

		function isFunction(arg) {
		  return typeof arg === 'function';
		}
		exports.isFunction = isFunction;

		function isPrimitive(arg) {
		  return arg === null ||
		         typeof arg === 'boolean' ||
		         typeof arg === 'number' ||
		         typeof arg === 'string' ||
		         typeof arg === 'symbol' ||  // ES6 symbol
		         typeof arg === 'undefined';
		}
		exports.isPrimitive = isPrimitive;

		exports.isBuffer = require('buffer').Buffer.isBuffer;

		function objectToString(o) {
		  return Object.prototype.toString.call(o);
		}

		},{"buffer":103}],383:[function(require,module,exports){
		/*
		 * Date Format 1.2.3
		 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
		 * MIT license
		 *
		 * Includes enhancements by Scott Trenda <scott.trenda.net>
		 * and Kris Kowal <cixar.com/~kris.kowal/>
		 *
		 * Accepts a date, a mask, or a date and a mask.
		 * Returns a formatted version of the given date.
		 * The date defaults to the current date/time.
		 * The mask defaults to dateFormat.masks.default.
		 */

		(function(global) {

		  var dateFormat = (function() {
		      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|'[^']*'|'[^']*'/g;
		      var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
		      var timezoneClip = /[^-+\dA-Z]/g;
		  
		      // Regexes and supporting functions are cached through closure
		      return function (date, mask, utc, gmt) {
		  
		        // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
		        if (arguments.length === 1 && kindOf(date) === 'string' && !/\d/.test(date)) {
		          mask = date;
		          date = undefined;
		        }
		  
		        date = date || new Date;
		  
		        if(!(date instanceof Date)) {
		          date = new Date(date);
		        }
		  
		        if (isNaN(date)) {
		          throw TypeError('Invalid date');
		        }
		  
		        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);
		  
		        // Allow setting the utc/gmt argument via the mask
		        var maskSlice = mask.slice(0, 4);
		        if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
		          mask = mask.slice(4);
		          utc = true;
		          if (maskSlice === 'GMT:') {
		            gmt = true;
		          }
		        }
		  
		        var _ = utc ? 'getUTC' : 'get';
		        var d = date[_ + 'Date']();
		        var D = date[_ + 'Day']();
		        var m = date[_ + 'Month']();
		        var y = date[_ + 'FullYear']();
		        var H = date[_ + 'Hours']();
		        var M = date[_ + 'Minutes']();
		        var s = date[_ + 'Seconds']();
		        var L = date[_ + 'Milliseconds']();
		        var o = utc ? 0 : date.getTimezoneOffset();
		        var W = getWeek(date);
		        var N = getDayOfWeek(date);
		        var flags = {
		          d:    d,
		          dd:   pad(d),
		          ddd:  dateFormat.i18n.dayNames[D],
		          dddd: dateFormat.i18n.dayNames[D + 7],
		          m:    m + 1,
		          mm:   pad(m + 1),
		          mmm:  dateFormat.i18n.monthNames[m],
		          mmmm: dateFormat.i18n.monthNames[m + 12],
		          yy:   String(y).slice(2),
		          yyyy: y,
		          h:    H % 12 || 12,
		          hh:   pad(H % 12 || 12),
		          H:    H,
		          HH:   pad(H),
		          M:    M,
		          MM:   pad(M),
		          s:    s,
		          ss:   pad(s),
		          l:    pad(L, 3),
		          L:    pad(Math.round(L / 10)),
		          t:    H < 12 ? 'a'  : 'p',
		          tt:   H < 12 ? 'am' : 'pm',
		          T:    H < 12 ? 'A'  : 'P',
		          TT:   H < 12 ? 'AM' : 'PM',
		          Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
		          o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
		          S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
		          W:    W,
		          N:    N
		        };
		  
		        return mask.replace(token, function (match) {
		          if (match in flags) {
		            return flags[match];
		          }
		          return match.slice(1, match.length - 1);
		        });
		      };
		    })();

		  dateFormat.masks = {
		    'default':               'ddd mmm dd yyyy HH:MM:ss',
		    'shortDate':             'm/d/yy',
		    'mediumDate':            'mmm d, yyyy',
		    'longDate':              'mmmm d, yyyy',
		    'fullDate':              'dddd, mmmm d, yyyy',
		    'shortTime':             'h:MM TT',
		    'mediumTime':            'h:MM:ss TT',
		    'longTime':              'h:MM:ss TT Z',
		    'isoDate':               'yyyy-mm-dd',
		    'isoTime':               'HH:MM:ss',
		    'isoDateTime':           'yyyy-mm-dd\'T\'HH:MM:sso',
		    'isoUtcDateTime':        'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
		    'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'
		  };

		  // Internationalization strings
		  dateFormat.i18n = {
		    dayNames: [
		      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
		      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
		    ],
		    monthNames: [
		      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
		      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
		    ]
		  };

		function pad(val, len) {
		  val = String(val);
		  len = len || 2;
		  while (val.length < len) {
		    val = '0' + val;
		  }
		  return val;
		}

		/**
		 * Get the ISO 8601 week number
		 * Based on comments from
		 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
		 *
		 * @param  {Object} `date`
		 * @return {Number}
		 */
		function getWeek(date) {
		  // Remove time components of date
		  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

		  // Change date to Thursday same week
		  targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);

		  // Take January 4th as it is always in week 1 (see ISO 8601)
		  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

		  // Change date to Thursday same week
		  firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

		  // Check if daylight-saving-time-switch occurred and correct for it
		  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
		  targetThursday.setHours(targetThursday.getHours() - ds);

		  // Number of weeks between target Thursday and first Thursday
		  var weekDiff = (targetThursday - firstThursday) / (86400000*7);
		  return 1 + Math.floor(weekDiff);
		}

		/**
		 * Get ISO-8601 numeric representation of the day of the week
		 * 1 (for Monday) through 7 (for Sunday)
		 * 
		 * @param  {Object} `date`
		 * @return {Number}
		 */
		function getDayOfWeek(date) {
		  var dow = date.getDay();
		  if(dow === 0) {
		    dow = 7;
		  }
		  return dow;
		}

		/**
		 * kind-of shortcut
		 * @param  {*} val
		 * @return {String}
		 */
		function kindOf(val) {
		  if (val === null) {
		    return 'null';
		  }

		  if (val === undefined) {
		    return 'undefined';
		  }

		  if (typeof val !== 'object') {
		    return typeof val;
		  }

		  if (Array.isArray(val)) {
		    return 'array';
		  }

		  return {}.toString.call(val)
		    .slice(8, -1).toLowerCase();
		}


		  if (typeof exports === 'object') {
		    module.exports = dateFormat;
		  } else {
		    global.dateFormat = dateFormat;
		  }
		})(this);

		},{}],384:[function(require,module,exports){

		var hasPropertyDescriptors = require('has-property-descriptors')();

		var GetIntrinsic = require('get-intrinsic');

		var $defineProperty = hasPropertyDescriptors && GetIntrinsic('%Object.defineProperty%', true);
		if ($defineProperty) {
			try {
				$defineProperty({}, 'a', { value: 1 });
			} catch (e) {
				// IE 8 has a broken defineProperty
				$defineProperty = false;
			}
		}

		var $SyntaxError = GetIntrinsic('%SyntaxError%');
		var $TypeError = GetIntrinsic('%TypeError%');

		var gopd = require('gopd');

		/** @type {(obj: Record<PropertyKey, unknown>, property: PropertyKey, value: unknown, nonEnumerable?: boolean | null, nonWritable?: boolean | null, nonConfigurable?: boolean | null, loose?: boolean) => void} */
		module.exports = function defineDataProperty(
			obj,
			property,
			value
		) {
			if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
				throw new $TypeError('`obj` must be an object or a function`');
			}
			if (typeof property !== 'string' && typeof property !== 'symbol') {
				throw new $TypeError('`property` must be a string or a symbol`');
			}
			if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
				throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
			}
			if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
				throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
			}
			if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
				throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
			}
			if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
				throw new $TypeError('`loose`, if provided, must be a boolean');
			}

			var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
			var nonWritable = arguments.length > 4 ? arguments[4] : null;
			var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
			var loose = arguments.length > 6 ? arguments[6] : false;

			/* @type {false | TypedPropertyDescriptor<unknown>} */
			var desc = !!gopd && gopd(obj, property);

			if ($defineProperty) {
				$defineProperty(obj, property, {
					configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
					enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
					value: value,
					writable: nonWritable === null && desc ? desc.writable : !nonWritable
				});
			} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
				// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
				obj[property] = value; // eslint-disable-line no-param-reassign
			} else {
				throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
			}
		};

		},{"get-intrinsic":390,"gopd":391,"has-property-descriptors":392}],385:[function(require,module,exports){

		/**
		 * Module variables.
		 * @private
		 */

		var matchHtmlRegExp = /["'&<>]/;

		/**
		 * Module exports.
		 * @public
		 */

		module.exports = escapeHtml;

		/**
		 * Escape special characters in the given string of html.
		 *
		 * @param  {string} string The string to escape for inserting into HTML
		 * @return {string}
		 * @public
		 */

		function escapeHtml(string) {
		  var str = '' + string;
		  var match = matchHtmlRegExp.exec(str);

		  if (!match) {
		    return str;
		  }

		  var escape;
		  var html = '';
		  var index = 0;
		  var lastIndex = 0;

		  for (index = match.index; index < str.length; index++) {
		    switch (str.charCodeAt(index)) {
		      case 34: // "
		        escape = '&quot;';
		        break;
		      case 38: // &
		        escape = '&amp;';
		        break;
		      case 39: // '
		        escape = '&#39;';
		        break;
		      case 60: // <
		        escape = '&lt;';
		        break;
		      case 62: // >
		        escape = '&gt;';
		        break;
		      default:
		        continue;
		    }

		    if (lastIndex !== index) {
		      html += str.substring(lastIndex, index);
		    }

		    lastIndex = index + 1;
		    html += escape;
		  }

		  return lastIndex !== index
		    ? html + str.substring(lastIndex, index)
		    : html;
		}

		},{}],386:[function(require,module,exports){

		var R = typeof Reflect === 'object' ? Reflect : null;
		var ReflectApply = R && typeof R.apply === 'function'
		  ? R.apply
		  : function ReflectApply(target, receiver, args) {
		    return Function.prototype.apply.call(target, receiver, args);
		  };

		var ReflectOwnKeys;
		if (R && typeof R.ownKeys === 'function') {
		  ReflectOwnKeys = R.ownKeys;
		} else if (Object.getOwnPropertySymbols) {
		  ReflectOwnKeys = function ReflectOwnKeys(target) {
		    return Object.getOwnPropertyNames(target)
		      .concat(Object.getOwnPropertySymbols(target));
		  };
		} else {
		  ReflectOwnKeys = function ReflectOwnKeys(target) {
		    return Object.getOwnPropertyNames(target);
		  };
		}

		function ProcessEmitWarning(warning) {
		  if (console && console.warn) console.warn(warning);
		}

		var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
		  return value !== value;
		};

		function EventEmitter() {
		  EventEmitter.init.call(this);
		}
		module.exports = EventEmitter;
		module.exports.once = once;

		// Backwards-compat with node 0.10.x
		EventEmitter.EventEmitter = EventEmitter;

		EventEmitter.prototype._events = undefined;
		EventEmitter.prototype._eventsCount = 0;
		EventEmitter.prototype._maxListeners = undefined;

		// By default EventEmitters will print a warning if more than 10 listeners are
		// added to it. This is a useful default which helps finding memory leaks.
		var defaultMaxListeners = 10;

		function checkListener(listener) {
		  if (typeof listener !== 'function') {
		    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
		  }
		}

		Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
		  enumerable: true,
		  get: function() {
		    return defaultMaxListeners;
		  },
		  set: function(arg) {
		    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
		      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
		    }
		    defaultMaxListeners = arg;
		  }
		});

		EventEmitter.init = function() {

		  if (this._events === undefined ||
		      this._events === Object.getPrototypeOf(this)._events) {
		    this._events = Object.create(null);
		    this._eventsCount = 0;
		  }

		  this._maxListeners = this._maxListeners || undefined;
		};

		// Obviously not all Emitters should be limited to 10. This function allows
		// that to be increased. Set to zero for unlimited.
		EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
		  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
		    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
		  }
		  this._maxListeners = n;
		  return this;
		};

		function _getMaxListeners(that) {
		  if (that._maxListeners === undefined)
		    return EventEmitter.defaultMaxListeners;
		  return that._maxListeners;
		}

		EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
		  return _getMaxListeners(this);
		};

		EventEmitter.prototype.emit = function emit(type) {
		  var args = [];
		  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
		  var doError = (type === 'error');

		  var events = this._events;
		  if (events !== undefined)
		    doError = (doError && events.error === undefined);
		  else if (!doError)
		    return false;

		  // If there is no 'error' event listener then throw.
		  if (doError) {
		    var er;
		    if (args.length > 0)
		      er = args[0];
		    if (er instanceof Error) {
		      // Note: The comments on the `throw` lines are intentional, they show
		      // up in Node's output if this results in an unhandled exception.
		      throw er; // Unhandled 'error' event
		    }
		    // At least give some kind of context to the user
		    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
		    err.context = er;
		    throw err; // Unhandled 'error' event
		  }

		  var handler = events[type];

		  if (handler === undefined)
		    return false;

		  if (typeof handler === 'function') {
		    ReflectApply(handler, this, args);
		  } else {
		    var len = handler.length;
		    var listeners = arrayClone(handler, len);
		    for (var i = 0; i < len; ++i)
		      ReflectApply(listeners[i], this, args);
		  }

		  return true;
		};

		function _addListener(target, type, listener, prepend) {
		  var m;
		  var events;
		  var existing;

		  checkListener(listener);

		  events = target._events;
		  if (events === undefined) {
		    events = target._events = Object.create(null);
		    target._eventsCount = 0;
		  } else {
		    // To avoid recursion in the case that type === "newListener"! Before
		    // adding it to the listeners, first emit "newListener".
		    if (events.newListener !== undefined) {
		      target.emit('newListener', type,
		                  listener.listener ? listener.listener : listener);

		      // Re-assign `events` because a newListener handler could have caused the
		      // this._events to be assigned to a new object
		      events = target._events;
		    }
		    existing = events[type];
		  }

		  if (existing === undefined) {
		    // Optimize the case of one listener. Don't need the extra array object.
		    existing = events[type] = listener;
		    ++target._eventsCount;
		  } else {
		    if (typeof existing === 'function') {
		      // Adding the second element, need to change to array.
		      existing = events[type] =
		        prepend ? [listener, existing] : [existing, listener];
		      // If we've already got an array, just append.
		    } else if (prepend) {
		      existing.unshift(listener);
		    } else {
		      existing.push(listener);
		    }

		    // Check for listener leak
		    m = _getMaxListeners(target);
		    if (m > 0 && existing.length > m && !existing.warned) {
		      existing.warned = true;
		      // No error code for this since it is a Warning
		      // eslint-disable-next-line no-restricted-syntax
		      var w = new Error('Possible EventEmitter memory leak detected. ' +
		                          existing.length + ' ' + String(type) + ' listeners ' +
		                          'added. Use emitter.setMaxListeners() to ' +
		                          'increase limit');
		      w.name = 'MaxListenersExceededWarning';
		      w.emitter = target;
		      w.type = type;
		      w.count = existing.length;
		      ProcessEmitWarning(w);
		    }
		  }

		  return target;
		}

		EventEmitter.prototype.addListener = function addListener(type, listener) {
		  return _addListener(this, type, listener, false);
		};

		EventEmitter.prototype.on = EventEmitter.prototype.addListener;

		EventEmitter.prototype.prependListener =
		    function prependListener(type, listener) {
		      return _addListener(this, type, listener, true);
		    };

		function onceWrapper() {
		  if (!this.fired) {
		    this.target.removeListener(this.type, this.wrapFn);
		    this.fired = true;
		    if (arguments.length === 0)
		      return this.listener.call(this.target);
		    return this.listener.apply(this.target, arguments);
		  }
		}

		function _onceWrap(target, type, listener) {
		  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
		  var wrapped = onceWrapper.bind(state);
		  wrapped.listener = listener;
		  state.wrapFn = wrapped;
		  return wrapped;
		}

		EventEmitter.prototype.once = function once(type, listener) {
		  checkListener(listener);
		  this.on(type, _onceWrap(this, type, listener));
		  return this;
		};

		EventEmitter.prototype.prependOnceListener =
		    function prependOnceListener(type, listener) {
		      checkListener(listener);
		      this.prependListener(type, _onceWrap(this, type, listener));
		      return this;
		    };

		// Emits a 'removeListener' event if and only if the listener was removed.
		EventEmitter.prototype.removeListener =
		    function removeListener(type, listener) {
		      var list, events, position, i, originalListener;

		      checkListener(listener);

		      events = this._events;
		      if (events === undefined)
		        return this;

		      list = events[type];
		      if (list === undefined)
		        return this;

		      if (list === listener || list.listener === listener) {
		        if (--this._eventsCount === 0)
		          this._events = Object.create(null);
		        else {
		          delete events[type];
		          if (events.removeListener)
		            this.emit('removeListener', type, list.listener || listener);
		        }
		      } else if (typeof list !== 'function') {
		        position = -1;

		        for (i = list.length - 1; i >= 0; i--) {
		          if (list[i] === listener || list[i].listener === listener) {
		            originalListener = list[i].listener;
		            position = i;
		            break;
		          }
		        }

		        if (position < 0)
		          return this;

		        if (position === 0)
		          list.shift();
		        else {
		          spliceOne(list, position);
		        }

		        if (list.length === 1)
		          events[type] = list[0];

		        if (events.removeListener !== undefined)
		          this.emit('removeListener', type, originalListener || listener);
		      }

		      return this;
		    };

		EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

		EventEmitter.prototype.removeAllListeners =
		    function removeAllListeners(type) {
		      var listeners, events, i;

		      events = this._events;
		      if (events === undefined)
		        return this;

		      // not listening for removeListener, no need to emit
		      if (events.removeListener === undefined) {
		        if (arguments.length === 0) {
		          this._events = Object.create(null);
		          this._eventsCount = 0;
		        } else if (events[type] !== undefined) {
		          if (--this._eventsCount === 0)
		            this._events = Object.create(null);
		          else
		            delete events[type];
		        }
		        return this;
		      }

		      // emit removeListener for all listeners on all events
		      if (arguments.length === 0) {
		        var keys = Object.keys(events);
		        var key;
		        for (i = 0; i < keys.length; ++i) {
		          key = keys[i];
		          if (key === 'removeListener') continue;
		          this.removeAllListeners(key);
		        }
		        this.removeAllListeners('removeListener');
		        this._events = Object.create(null);
		        this._eventsCount = 0;
		        return this;
		      }

		      listeners = events[type];

		      if (typeof listeners === 'function') {
		        this.removeListener(type, listeners);
		      } else if (listeners !== undefined) {
		        // LIFO order
		        for (i = listeners.length - 1; i >= 0; i--) {
		          this.removeListener(type, listeners[i]);
		        }
		      }

		      return this;
		    };

		function _listeners(target, type, unwrap) {
		  var events = target._events;

		  if (events === undefined)
		    return [];

		  var evlistener = events[type];
		  if (evlistener === undefined)
		    return [];

		  if (typeof evlistener === 'function')
		    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

		  return unwrap ?
		    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
		}

		EventEmitter.prototype.listeners = function listeners(type) {
		  return _listeners(this, type, true);
		};

		EventEmitter.prototype.rawListeners = function rawListeners(type) {
		  return _listeners(this, type, false);
		};

		EventEmitter.listenerCount = function(emitter, type) {
		  if (typeof emitter.listenerCount === 'function') {
		    return emitter.listenerCount(type);
		  } else {
		    return listenerCount.call(emitter, type);
		  }
		};

		EventEmitter.prototype.listenerCount = listenerCount;
		function listenerCount(type) {
		  var events = this._events;

		  if (events !== undefined) {
		    var evlistener = events[type];

		    if (typeof evlistener === 'function') {
		      return 1;
		    } else if (evlistener !== undefined) {
		      return evlistener.length;
		    }
		  }

		  return 0;
		}

		EventEmitter.prototype.eventNames = function eventNames() {
		  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
		};

		function arrayClone(arr, n) {
		  var copy = new Array(n);
		  for (var i = 0; i < n; ++i)
		    copy[i] = arr[i];
		  return copy;
		}

		function spliceOne(list, index) {
		  for (; index + 1 < list.length; index++)
		    list[index] = list[index + 1];
		  list.pop();
		}

		function unwrapListeners(arr) {
		  var ret = new Array(arr.length);
		  for (var i = 0; i < ret.length; ++i) {
		    ret[i] = arr[i].listener || arr[i];
		  }
		  return ret;
		}

		function once(emitter, name) {
		  return new Promise(function (resolve, reject) {
		    function errorListener(err) {
		      emitter.removeListener(name, resolver);
		      reject(err);
		    }

		    function resolver() {
		      if (typeof emitter.removeListener === 'function') {
		        emitter.removeListener('error', errorListener);
		      }
		      resolve([].slice.call(arguments));
		    }
		    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
		    if (name !== 'error') {
		      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
		    }
		  });
		}

		function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
		  if (typeof emitter.on === 'function') {
		    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
		  }
		}

		function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
		  if (typeof emitter.on === 'function') {
		    if (flags.once) {
		      emitter.once(name, listener);
		    } else {
		      emitter.on(name, listener);
		    }
		  } else if (typeof emitter.addEventListener === 'function') {
		    // EventTarget does not have `error` event semantics like Node
		    // EventEmitters, we do not listen for `error` events here.
		    emitter.addEventListener(name, function wrapListener(arg) {
		      // IE does not have builtin `{ once: true }` support so we
		      // have to do it manually.
		      if (flags.once) {
		        emitter.removeEventListener(name, wrapListener);
		      }
		      listener(arg);
		    });
		  } else {
		    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
		  }
		}

		},{}],387:[function(require,module,exports){

		var isCallable = require('is-callable');

		var toStr = Object.prototype.toString;
		var hasOwnProperty = Object.prototype.hasOwnProperty;

		var forEachArray = function forEachArray(array, iterator, receiver) {
		    for (var i = 0, len = array.length; i < len; i++) {
		        if (hasOwnProperty.call(array, i)) {
		            if (receiver == null) {
		                iterator(array[i], i, array);
		            } else {
		                iterator.call(receiver, array[i], i, array);
		            }
		        }
		    }
		};

		var forEachString = function forEachString(string, iterator, receiver) {
		    for (var i = 0, len = string.length; i < len; i++) {
		        // no such thing as a sparse string.
		        if (receiver == null) {
		            iterator(string.charAt(i), i, string);
		        } else {
		            iterator.call(receiver, string.charAt(i), i, string);
		        }
		    }
		};

		var forEachObject = function forEachObject(object, iterator, receiver) {
		    for (var k in object) {
		        if (hasOwnProperty.call(object, k)) {
		            if (receiver == null) {
		                iterator(object[k], k, object);
		            } else {
		                iterator.call(receiver, object[k], k, object);
		            }
		        }
		    }
		};

		var forEach = function forEach(list, iterator, thisArg) {
		    if (!isCallable(iterator)) {
		        throw new TypeError('iterator must be a function');
		    }

		    var receiver;
		    if (arguments.length >= 3) {
		        receiver = thisArg;
		    }

		    if (toStr.call(list) === '[object Array]') {
		        forEachArray(list, iterator, receiver);
		    } else if (typeof list === 'string') {
		        forEachString(list, iterator, receiver);
		    } else {
		        forEachObject(list, iterator, receiver);
		    }
		};

		module.exports = forEach;

		},{"is-callable":410}],388:[function(require,module,exports){

		/* eslint no-invalid-this: 1 */

		var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
		var toStr = Object.prototype.toString;
		var max = Math.max;
		var funcType = '[object Function]';

		var concatty = function concatty(a, b) {
		    var arr = [];

		    for (var i = 0; i < a.length; i += 1) {
		        arr[i] = a[i];
		    }
		    for (var j = 0; j < b.length; j += 1) {
		        arr[j + a.length] = b[j];
		    }

		    return arr;
		};

		var slicy = function slicy(arrLike, offset) {
		    var arr = [];
		    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
		        arr[j] = arrLike[i];
		    }
		    return arr;
		};

		var joiny = function (arr, joiner) {
		    var str = '';
		    for (var i = 0; i < arr.length; i += 1) {
		        str += arr[i];
		        if (i + 1 < arr.length) {
		            str += joiner;
		        }
		    }
		    return str;
		};

		module.exports = function bind(that) {
		    var target = this;
		    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
		        throw new TypeError(ERROR_MESSAGE + target);
		    }
		    var args = slicy(arguments, 1);

		    var bound;
		    var binder = function () {
		        if (this instanceof bound) {
		            var result = target.apply(
		                this,
		                concatty(args, arguments)
		            );
		            if (Object(result) === result) {
		                return result;
		            }
		            return this;
		        }
		        return target.apply(
		            that,
		            concatty(args, arguments)
		        );

		    };

		    var boundLength = max(0, target.length - args.length);
		    var boundArgs = [];
		    for (var i = 0; i < boundLength; i++) {
		        boundArgs[i] = '$' + i;
		    }

		    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

		    if (target.prototype) {
		        var Empty = function Empty() {};
		        Empty.prototype = target.prototype;
		        bound.prototype = new Empty();
		        Empty.prototype = null;
		    }

		    return bound;
		};

		},{}],389:[function(require,module,exports){

		var implementation = require('./implementation');

		module.exports = Function.prototype.bind || implementation;

		},{"./implementation":388}],390:[function(require,module,exports){

		var undefined$1;

		var $SyntaxError = SyntaxError;
		var $Function = Function;
		var $TypeError = TypeError;

		// eslint-disable-next-line consistent-return
		var getEvalledConstructor = function (expressionSyntax) {
			try {
				return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
			} catch (e) {}
		};

		var $gOPD = Object.getOwnPropertyDescriptor;
		if ($gOPD) {
			try {
				$gOPD({}, '');
			} catch (e) {
				$gOPD = null; // this is IE 8, which has a broken gOPD
			}
		}

		var throwTypeError = function () {
			throw new $TypeError();
		};
		var ThrowTypeError = $gOPD
			? (function () {
				try {
					// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
					arguments.callee; // IE 8 does not throw here
					return throwTypeError;
				} catch (calleeThrows) {
					try {
						// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
						return $gOPD(arguments, 'callee').get;
					} catch (gOPDthrows) {
						return throwTypeError;
					}
				}
			}())
			: throwTypeError;

		var hasSymbols = require('has-symbols')();
		var hasProto = require('has-proto')();

		var getProto = Object.getPrototypeOf || (
			hasProto
				? function (x) { return x.__proto__; } // eslint-disable-line no-proto
				: null
		);

		var needsEval = {};

		var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);

		var INTRINSICS = {
			'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
			'%Array%': Array,
			'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
			'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
			'%AsyncFromSyncIteratorPrototype%': undefined$1,
			'%AsyncFunction%': needsEval,
			'%AsyncGenerator%': needsEval,
			'%AsyncGeneratorFunction%': needsEval,
			'%AsyncIteratorPrototype%': needsEval,
			'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
			'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
			'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
			'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
			'%Boolean%': Boolean,
			'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
			'%Date%': Date,
			'%decodeURI%': decodeURI,
			'%decodeURIComponent%': decodeURIComponent,
			'%encodeURI%': encodeURI,
			'%encodeURIComponent%': encodeURIComponent,
			'%Error%': Error,
			'%eval%': eval, // eslint-disable-line no-eval
			'%EvalError%': EvalError,
			'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
			'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
			'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
			'%Function%': $Function,
			'%GeneratorFunction%': needsEval,
			'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
			'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
			'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
			'%isFinite%': isFinite,
			'%isNaN%': isNaN,
			'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
			'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
			'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
			'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
			'%Math%': Math,
			'%Number%': Number,
			'%Object%': Object,
			'%parseFloat%': parseFloat,
			'%parseInt%': parseInt,
			'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
			'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
			'%RangeError%': RangeError,
			'%ReferenceError%': ReferenceError,
			'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
			'%RegExp%': RegExp,
			'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
			'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
			'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
			'%String%': String,
			'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
			'%Symbol%': hasSymbols ? Symbol : undefined$1,
			'%SyntaxError%': $SyntaxError,
			'%ThrowTypeError%': ThrowTypeError,
			'%TypedArray%': TypedArray,
			'%TypeError%': $TypeError,
			'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
			'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
			'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
			'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
			'%URIError%': URIError,
			'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
			'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
			'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
		};

		if (getProto) {
			try {
				null.error; // eslint-disable-line no-unused-expressions
			} catch (e) {
				// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
				var errorProto = getProto(getProto(e));
				INTRINSICS['%Error.prototype%'] = errorProto;
			}
		}

		var doEval = function doEval(name) {
			var value;
			if (name === '%AsyncFunction%') {
				value = getEvalledConstructor('async function () {}');
			} else if (name === '%GeneratorFunction%') {
				value = getEvalledConstructor('function* () {}');
			} else if (name === '%AsyncGeneratorFunction%') {
				value = getEvalledConstructor('async function* () {}');
			} else if (name === '%AsyncGenerator%') {
				var fn = doEval('%AsyncGeneratorFunction%');
				if (fn) {
					value = fn.prototype;
				}
			} else if (name === '%AsyncIteratorPrototype%') {
				var gen = doEval('%AsyncGenerator%');
				if (gen && getProto) {
					value = getProto(gen.prototype);
				}
			}

			INTRINSICS[name] = value;

			return value;
		};

		var LEGACY_ALIASES = {
			'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
			'%ArrayPrototype%': ['Array', 'prototype'],
			'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
			'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
			'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
			'%ArrayProto_values%': ['Array', 'prototype', 'values'],
			'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
			'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
			'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
			'%BooleanPrototype%': ['Boolean', 'prototype'],
			'%DataViewPrototype%': ['DataView', 'prototype'],
			'%DatePrototype%': ['Date', 'prototype'],
			'%ErrorPrototype%': ['Error', 'prototype'],
			'%EvalErrorPrototype%': ['EvalError', 'prototype'],
			'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
			'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
			'%FunctionPrototype%': ['Function', 'prototype'],
			'%Generator%': ['GeneratorFunction', 'prototype'],
			'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
			'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
			'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
			'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
			'%JSONParse%': ['JSON', 'parse'],
			'%JSONStringify%': ['JSON', 'stringify'],
			'%MapPrototype%': ['Map', 'prototype'],
			'%NumberPrototype%': ['Number', 'prototype'],
			'%ObjectPrototype%': ['Object', 'prototype'],
			'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
			'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
			'%PromisePrototype%': ['Promise', 'prototype'],
			'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
			'%Promise_all%': ['Promise', 'all'],
			'%Promise_reject%': ['Promise', 'reject'],
			'%Promise_resolve%': ['Promise', 'resolve'],
			'%RangeErrorPrototype%': ['RangeError', 'prototype'],
			'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
			'%RegExpPrototype%': ['RegExp', 'prototype'],
			'%SetPrototype%': ['Set', 'prototype'],
			'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
			'%StringPrototype%': ['String', 'prototype'],
			'%SymbolPrototype%': ['Symbol', 'prototype'],
			'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
			'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
			'%TypeErrorPrototype%': ['TypeError', 'prototype'],
			'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
			'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
			'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
			'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
			'%URIErrorPrototype%': ['URIError', 'prototype'],
			'%WeakMapPrototype%': ['WeakMap', 'prototype'],
			'%WeakSetPrototype%': ['WeakSet', 'prototype']
		};

		var bind = require('function-bind');
		var hasOwn = require('hasown');
		var $concat = bind.call(Function.call, Array.prototype.concat);
		var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
		var $replace = bind.call(Function.call, String.prototype.replace);
		var $strSlice = bind.call(Function.call, String.prototype.slice);
		var $exec = bind.call(Function.call, RegExp.prototype.exec);

		/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
		var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
		var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
		var stringToPath = function stringToPath(string) {
			var first = $strSlice(string, 0, 1);
			var last = $strSlice(string, -1);
			if (first === '%' && last !== '%') {
				throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
			} else if (last === '%' && first !== '%') {
				throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
			}
			var result = [];
			$replace(string, rePropName, function (match, number, quote, subString) {
				result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
			});
			return result;
		};
		/* end adaptation */

		var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
			var intrinsicName = name;
			var alias;
			if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
				alias = LEGACY_ALIASES[intrinsicName];
				intrinsicName = '%' + alias[0] + '%';
			}

			if (hasOwn(INTRINSICS, intrinsicName)) {
				var value = INTRINSICS[intrinsicName];
				if (value === needsEval) {
					value = doEval(intrinsicName);
				}
				if (typeof value === 'undefined' && !allowMissing) {
					throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
				}

				return {
					alias: alias,
					name: intrinsicName,
					value: value
				};
			}

			throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
		};

		module.exports = function GetIntrinsic(name, allowMissing) {
			if (typeof name !== 'string' || name.length === 0) {
				throw new $TypeError('intrinsic name must be a non-empty string');
			}
			if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
				throw new $TypeError('"allowMissing" argument must be a boolean');
			}

			if ($exec(/^%?[^%]*%?$/, name) === null) {
				throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
			}
			var parts = stringToPath(name);
			var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

			var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
			var intrinsicRealName = intrinsic.name;
			var value = intrinsic.value;
			var skipFurtherCaching = false;

			var alias = intrinsic.alias;
			if (alias) {
				intrinsicBaseName = alias[0];
				$spliceApply(parts, $concat([0, 1], alias));
			}

			for (var i = 1, isOwn = true; i < parts.length; i += 1) {
				var part = parts[i];
				var first = $strSlice(part, 0, 1);
				var last = $strSlice(part, -1);
				if (
					(
						(first === '"' || first === "'" || first === '`')
						|| (last === '"' || last === "'" || last === '`')
					)
					&& first !== last
				) {
					throw new $SyntaxError('property names with quotes must have matching quotes');
				}
				if (part === 'constructor' || !isOwn) {
					skipFurtherCaching = true;
				}

				intrinsicBaseName += '.' + part;
				intrinsicRealName = '%' + intrinsicBaseName + '%';

				if (hasOwn(INTRINSICS, intrinsicRealName)) {
					value = INTRINSICS[intrinsicRealName];
				} else if (value != null) {
					if (!(part in value)) {
						if (!allowMissing) {
							throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
						}
						return void 0;
					}
					if ($gOPD && (i + 1) >= parts.length) {
						var desc = $gOPD(value, part);
						isOwn = !!desc;

						// By convention, when a data property is converted to an accessor
						// property to emulate a data property that does not suffer from
						// the override mistake, that accessor's getter is marked with
						// an `originalValue` property. Here, when we detect this, we
						// uphold the illusion by pretending to see that original data
						// property, i.e., returning the value rather than the getter
						// itself.
						if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
							value = desc.get;
						} else {
							value = value[part];
						}
					} else {
						isOwn = hasOwn(value, part);
						value = value[part];
					}

					if (isOwn && !skipFurtherCaching) {
						INTRINSICS[intrinsicRealName] = value;
					}
				}
			}
			return value;
		};

		},{"function-bind":389,"has-proto":393,"has-symbols":394,"hasown":397}],391:[function(require,module,exports){

		var GetIntrinsic = require('get-intrinsic');

		var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

		if ($gOPD) {
			try {
				$gOPD([], 'length');
			} catch (e) {
				// IE 8 has a broken gOPD
				$gOPD = null;
			}
		}

		module.exports = $gOPD;

		},{"get-intrinsic":390}],392:[function(require,module,exports){

		var GetIntrinsic = require('get-intrinsic');

		var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

		var hasPropertyDescriptors = function hasPropertyDescriptors() {
			if ($defineProperty) {
				try {
					$defineProperty({}, 'a', { value: 1 });
					return true;
				} catch (e) {
					// IE 8 has a broken defineProperty
					return false;
				}
			}
			return false;
		};

		hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
			// node v0.6 has a bug where array lengths can be Set but not Defined
			if (!hasPropertyDescriptors()) {
				return null;
			}
			try {
				return $defineProperty([], 'length', { value: 1 }).length !== 1;
			} catch (e) {
				// In Firefox 4-22, defining length on an array throws an exception.
				return true;
			}
		};

		module.exports = hasPropertyDescriptors;

		},{"get-intrinsic":390}],393:[function(require,module,exports){

		var test = {
			foo: {}
		};

		var $Object = Object;

		module.exports = function hasProto() {
			return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
		};

		},{}],394:[function(require,module,exports){

		var origSymbol = typeof Symbol !== 'undefined' && Symbol;
		var hasSymbolSham = require('./shams');

		module.exports = function hasNativeSymbols() {
			if (typeof origSymbol !== 'function') { return false; }
			if (typeof Symbol !== 'function') { return false; }
			if (typeof origSymbol('foo') !== 'symbol') { return false; }
			if (typeof Symbol('bar') !== 'symbol') { return false; }

			return hasSymbolSham();
		};

		},{"./shams":395}],395:[function(require,module,exports){

		/* eslint complexity: [2, 18], max-statements: [2, 33] */
		module.exports = function hasSymbols() {
			if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
			if (typeof Symbol.iterator === 'symbol') { return true; }

			var obj = {};
			var sym = Symbol('test');
			var symObj = Object(sym);
			if (typeof sym === 'string') { return false; }

			if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
			if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

			// temp disabled per https://github.com/ljharb/object.assign/issues/17
			// if (sym instanceof Symbol) { return false; }
			// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
			// if (!(symObj instanceof Symbol)) { return false; }

			// if (typeof Symbol.prototype.toString !== 'function') { return false; }
			// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

			var symVal = 42;
			obj[sym] = symVal;
			for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
			if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

			if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

			var syms = Object.getOwnPropertySymbols(obj);
			if (syms.length !== 1 || syms[0] !== sym) { return false; }

			if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

			if (typeof Object.getOwnPropertyDescriptor === 'function') {
				var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
				if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
			}

			return true;
		};

		},{}],396:[function(require,module,exports){

		var hasSymbols = require('has-symbols/shams');

		module.exports = function hasToStringTagShams() {
			return hasSymbols() && !!Symbol.toStringTag;
		};

		},{"has-symbols/shams":395}],397:[function(require,module,exports){

		var call = Function.prototype.call;
		var $hasOwn = Object.prototype.hasOwnProperty;
		var bind = require('function-bind');

		/** @type {(o: {}, p: PropertyKey) => p is keyof o} */
		module.exports = bind.call(call, $hasOwn);

		},{"function-bind":389}],398:[function(require,module,exports){
		var http = require('http');
		var url = require('url');

		var https = module.exports;

		for (var key in http) {
		  if (http.hasOwnProperty(key)) https[key] = http[key];
		}

		https.request = function (params, cb) {
		  params = validateParams(params);
		  return http.request.call(this, params, cb)
		};

		https.get = function (params, cb) {
		  params = validateParams(params);
		  return http.get.call(this, params, cb)
		};

		function validateParams (params) {
		  if (typeof params === 'string') {
		    params = url.parse(params);
		  }
		  if (!params.protocol) {
		    params.protocol = 'https:';
		  }
		  if (params.protocol !== 'https:') {
		    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
		  }
		  return params
		}

		},{"http":539,"url":543}],399:[function(require,module,exports){

		/**
		 * Module dependencies.
		 */

		var util = require('util');
		var ms = require('ms');

		module.exports = function (t) {
		  if (typeof t === 'number') return t;
		  var r = ms(t);
		  if (r === undefined) {
		    var err = new Error(util.format('humanize-ms(%j) result undefined', t));
		    console.warn(err.stack);
		  }
		  return r;
		};

		},{"ms":432,"util":489}],400:[function(require,module,exports){
		/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
		exports.read = function (buffer, offset, isLE, mLen, nBytes) {
		  var e, m;
		  var eLen = (nBytes * 8) - mLen - 1;
		  var eMax = (1 << eLen) - 1;
		  var eBias = eMax >> 1;
		  var nBits = -7;
		  var i = isLE ? (nBytes - 1) : 0;
		  var d = isLE ? -1 : 1;
		  var s = buffer[offset + i];

		  i += d;

		  e = s & ((1 << (-nBits)) - 1);
		  s >>= (-nBits);
		  nBits += eLen;
		  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

		  m = e & ((1 << (-nBits)) - 1);
		  e >>= (-nBits);
		  nBits += mLen;
		  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

		  if (e === 0) {
		    e = 1 - eBias;
		  } else if (e === eMax) {
		    return m ? NaN : ((s ? -1 : 1) * Infinity)
		  } else {
		    m = m + Math.pow(2, mLen);
		    e = e - eBias;
		  }
		  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
		};

		exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
		  var e, m, c;
		  var eLen = (nBytes * 8) - mLen - 1;
		  var eMax = (1 << eLen) - 1;
		  var eBias = eMax >> 1;
		  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
		  var i = isLE ? 0 : (nBytes - 1);
		  var d = isLE ? 1 : -1;
		  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

		  value = Math.abs(value);

		  if (isNaN(value) || value === Infinity) {
		    m = isNaN(value) ? 1 : 0;
		    e = eMax;
		  } else {
		    e = Math.floor(Math.log(value) / Math.LN2);
		    if (value * (c = Math.pow(2, -e)) < 1) {
		      e--;
		      c *= 2;
		    }
		    if (e + eBias >= 1) {
		      value += rt / c;
		    } else {
		      value += rt * Math.pow(2, 1 - eBias);
		    }
		    if (value * c >= 2) {
		      e++;
		      c /= 2;
		    }

		    if (e + eBias >= eMax) {
		      m = 0;
		      e = eMax;
		    } else if (e + eBias >= 1) {
		      m = ((value * c) - 1) * Math.pow(2, mLen);
		      e = e + eBias;
		    } else {
		      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
		      e = 0;
		    }
		  }

		  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

		  e = (e << mLen) | m;
		  eLen += mLen;
		  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

		  buffer[offset + i - d] |= s * 128;
		};

		},{}],401:[function(require,module,exports){
		var types = [
		  require('./nextTick'),
		  require('./queueMicrotask'),
		  require('./mutation.js'),
		  require('./messageChannel'),
		  require('./stateChange'),
		  require('./timeout')
		];
		var draining;
		var currentQueue;
		var queueIndex = -1;
		var queue = [];
		var scheduled = false;
		function cleanUpNextTick() {
		  if (!draining || !currentQueue) {
		    return;
		  }
		  draining = false;
		  if (currentQueue.length) {
		    queue = currentQueue.concat(queue);
		  } else {
		    queueIndex = -1;
		  }
		  if (queue.length) {
		    nextTick();
		  }
		}

		//named nextTick for less confusing stack traces
		function nextTick() {
		  if (draining) {
		    return;
		  }
		  scheduled = false;
		  draining = true;
		  var len = queue.length;
		  var timeout = setTimeout(cleanUpNextTick);
		  while (len) {
		    currentQueue = queue;
		    queue = [];
		    while (currentQueue && ++queueIndex < len) {
		      currentQueue[queueIndex].run();
		    }
		    queueIndex = -1;
		    len = queue.length;
		  }
		  currentQueue = null;
		  queueIndex = -1;
		  draining = false;
		  clearTimeout(timeout);
		}
		var scheduleDrain;
		var i = -1;
		var len = types.length;
		while (++i < len) {
		  if (types[i] && types[i].test && types[i].test()) {
		    scheduleDrain = types[i].install(nextTick);
		    break;
		  }
		}
		// v8 likes predictible objects
		function Item(fun, array) {
		  this.fun = fun;
		  this.array = array;
		}
		Item.prototype.run = function () {
		  var fun = this.fun;
		  var array = this.array;
		  switch (array.length) {
		  case 0:
		    return fun();
		  case 1:
		    return fun(array[0]);
		  case 2:
		    return fun(array[0], array[1]);
		  case 3:
		    return fun(array[0], array[1], array[2]);
		  default:
		    return fun.apply(null, array);
		  }

		};
		module.exports = immediate;
		function immediate(task) {
		  var args = new Array(arguments.length - 1);
		  if (arguments.length > 1) {
		    for (var i = 1; i < arguments.length; i++) {
		      args[i - 1] = arguments[i];
		    }
		  }
		  queue.push(new Item(task, args));
		  if (!scheduled && !draining) {
		    scheduled = true;
		    scheduleDrain();
		  }
		}

		},{"./messageChannel":402,"./mutation.js":403,"./nextTick":102,"./queueMicrotask":404,"./stateChange":405,"./timeout":406}],402:[function(require,module,exports){
		(function (global){(function (){

		exports.test = function () {
		  if (global.setImmediate) {
		    // we can only get here in IE10
		    // which doesn't handel postMessage well
		    return false;
		  }
		  return typeof global.MessageChannel !== 'undefined';
		};

		exports.install = function (func) {
		  var channel = new global.MessageChannel();
		  channel.port1.onmessage = func;
		  return function () {
		    channel.port2.postMessage(0);
		  };
		};
		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],403:[function(require,module,exports){
		(function (global){(function (){
		//based off rsvp https://github.com/tildeio/rsvp.js
		//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
		//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

		var Mutation = global.MutationObserver || global.WebKitMutationObserver;

		exports.test = function () {
		  return Mutation;
		};

		exports.install = function (handle) {
		  var called = 0;
		  var observer = new Mutation(handle);
		  var element = global.document.createTextNode('');
		  observer.observe(element, {
		    characterData: true
		  });
		  return function () {
		    element.data = (called = ++called % 2);
		  };
		};
		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],404:[function(require,module,exports){
		(function (global){(function (){
		exports.test = function () {
		  return typeof global.queueMicrotask === 'function';
		};

		exports.install = function (func) {
		  return function () {
		    global.queueMicrotask(func);
		  };
		};

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],405:[function(require,module,exports){
		(function (global){(function (){

		exports.test = function () {
		  return 'document' in global && 'onreadystatechange' in global.document.createElement('script');
		};

		exports.install = function (handle) {
		  return function () {

		    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
		    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
		    var scriptEl = global.document.createElement('script');
		    scriptEl.onreadystatechange = function () {
		      handle();

		      scriptEl.onreadystatechange = null;
		      scriptEl.parentNode.removeChild(scriptEl);
		      scriptEl = null;
		    };
		    global.document.documentElement.appendChild(scriptEl);

		    return handle;
		  };
		};
		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],406:[function(require,module,exports){
		exports.test = function () {
		  return true;
		};

		exports.install = function (t) {
		  return function () {
		    setTimeout(t, 0);
		  };
		};
		},{}],407:[function(require,module,exports){
		if (typeof Object.create === 'function') {
		  // implementation from standard node.js 'util' module
		  module.exports = function inherits(ctor, superCtor) {
		    if (superCtor) {
		      ctor.super_ = superCtor;
		      ctor.prototype = Object.create(superCtor.prototype, {
		        constructor: {
		          value: ctor,
		          enumerable: false,
		          writable: true,
		          configurable: true
		        }
		      });
		    }
		  };
		} else {
		  // old school shim for old browsers
		  module.exports = function inherits(ctor, superCtor) {
		    if (superCtor) {
		      ctor.super_ = superCtor;
		      var TempCtor = function () {};
		      TempCtor.prototype = superCtor.prototype;
		      ctor.prototype = new TempCtor();
		      ctor.prototype.constructor = ctor;
		    }
		  };
		}

		},{}],408:[function(require,module,exports){

		var hasToStringTag = require('has-tostringtag/shams')();
		var callBound = require('call-bind/callBound');

		var $toString = callBound('Object.prototype.toString');

		var isStandardArguments = function isArguments(value) {
			if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
				return false;
			}
			return $toString(value) === '[object Arguments]';
		};

		var isLegacyArguments = function isArguments(value) {
			if (isStandardArguments(value)) {
				return true;
			}
			return value !== null &&
				typeof value === 'object' &&
				typeof value.length === 'number' &&
				value.length >= 0 &&
				$toString(value) !== '[object Array]' &&
				$toString(value.callee) === '[object Function]';
		};

		var supportsStandardArguments = (function () {
			return isStandardArguments(arguments);
		}());

		isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

		module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

		},{"call-bind/callBound":105,"has-tostringtag/shams":396}],409:[function(require,module,exports){
		/*!
		 * Determine if an object is a Buffer
		 *
		 * @author   Feross Aboukhadijeh <https://feross.org>
		 * @license  MIT
		 */

		// The _isBuffer check is for Safari 5-7 support, because it's missing
		// Object.prototype.constructor. Remove this eventually
		module.exports = function (obj) {
		  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
		};

		function isBuffer (obj) {
		  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
		}

		// For Node v0.10 support. Remove this eventually.
		function isSlowBuffer (obj) {
		  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
		}

		},{}],410:[function(require,module,exports){

		var fnToStr = Function.prototype.toString;
		var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
		var badArrayLike;
		var isCallableMarker;
		if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
			try {
				badArrayLike = Object.defineProperty({}, 'length', {
					get: function () {
						throw isCallableMarker;
					}
				});
				isCallableMarker = {};
				// eslint-disable-next-line no-throw-literal
				reflectApply(function () { throw 42; }, null, badArrayLike);
			} catch (_) {
				if (_ !== isCallableMarker) {
					reflectApply = null;
				}
			}
		} else {
			reflectApply = null;
		}

		var constructorRegex = /^\s*class\b/;
		var isES6ClassFn = function isES6ClassFunction(value) {
			try {
				var fnStr = fnToStr.call(value);
				return constructorRegex.test(fnStr);
			} catch (e) {
				return false; // not a function
			}
		};

		var tryFunctionObject = function tryFunctionToStr(value) {
			try {
				if (isES6ClassFn(value)) { return false; }
				fnToStr.call(value);
				return true;
			} catch (e) {
				return false;
			}
		};
		var toStr = Object.prototype.toString;
		var objectClass = '[object Object]';
		var fnClass = '[object Function]';
		var genClass = '[object GeneratorFunction]';
		var ddaClass = '[object HTMLAllCollection]'; // IE 11
		var ddaClass2 = '[object HTML document.all class]';
		var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
		var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

		var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

		var isDDA = function isDocumentDotAll() { return false; };
		if (typeof document === 'object') {
			// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
			var all = document.all;
			if (toStr.call(all) === toStr.call(document.all)) {
				isDDA = function isDocumentDotAll(value) {
					/* globals document: false */
					// in IE 6-8, typeof document.all is "object" and it's truthy
					if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
						try {
							var str = toStr.call(value);
							return (
								str === ddaClass
								|| str === ddaClass2
								|| str === ddaClass3 // opera 12.16
								|| str === objectClass // IE 6-8
							) && value('') == null; // eslint-disable-line eqeqeq
						} catch (e) { /**/ }
					}
					return false;
				};
			}
		}

		module.exports = reflectApply
			? function isCallable(value) {
				if (isDDA(value)) { return true; }
				if (!value) { return false; }
				if (typeof value !== 'function' && typeof value !== 'object') { return false; }
				try {
					reflectApply(value, null, badArrayLike);
				} catch (e) {
					if (e !== isCallableMarker) { return false; }
				}
				return !isES6ClassFn(value) && tryFunctionObject(value);
			}
			: function isCallable(value) {
				if (isDDA(value)) { return true; }
				if (!value) { return false; }
				if (typeof value !== 'function' && typeof value !== 'object') { return false; }
				if (hasToStringTag) { return tryFunctionObject(value); }
				if (isES6ClassFn(value)) { return false; }
				var strClass = toStr.call(value);
				if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
				return tryFunctionObject(value);
			};

		},{}],411:[function(require,module,exports){

		var toStr = Object.prototype.toString;
		var fnToStr = Function.prototype.toString;
		var isFnRegex = /^\s*(?:function)?\*/;
		var hasToStringTag = require('has-tostringtag/shams')();
		var getProto = Object.getPrototypeOf;
		var getGeneratorFunc = function () { // eslint-disable-line consistent-return
			if (!hasToStringTag) {
				return false;
			}
			try {
				return Function('return function*() {}')();
			} catch (e) {
			}
		};
		var GeneratorFunction;

		module.exports = function isGeneratorFunction(fn) {
			if (typeof fn !== 'function') {
				return false;
			}
			if (isFnRegex.test(fnToStr.call(fn))) {
				return true;
			}
			if (!hasToStringTag) {
				var str = toStr.call(fn);
				return str === '[object GeneratorFunction]';
			}
			if (!getProto) {
				return false;
			}
			if (typeof GeneratorFunction === 'undefined') {
				var generatorFunc = getGeneratorFunc();
				GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
			}
			return getProto(fn) === GeneratorFunction;
		};

		},{"has-tostringtag/shams":396}],412:[function(require,module,exports){

		var whichTypedArray = require('which-typed-array');

		module.exports = function isTypedArray(value) {
			return !!whichTypedArray(value);
		};

		},{"which-typed-array":490}],413:[function(require,module,exports){
		(function (global){(function (){
(function (global, factory) {
		    typeof exports === 'object' && typeof module !== 'undefined'
		        ? module.exports = factory(global)
		        : factory(global);
		}((
		    typeof self !== 'undefined' ? self
		        : typeof window !== 'undefined' ? window
		        : typeof global !== 'undefined' ? global
		: this
		), function(global) {
		    // existing version for noConflict()
		    global = global || {};
		    var _Base64 = global.Base64;
		    var version = "2.6.4";
		    // constants
		    var b64chars
		        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		    var b64tab = function(bin) {
		        var t = {};
		        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
		        return t;
		    }(b64chars);
		    var fromCharCode = String.fromCharCode;
		    // encoder stuff
		    var cb_utob = function(c) {
		        if (c.length < 2) {
		            var cc = c.charCodeAt(0);
		            return cc < 0x80 ? c
		                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
		                                + fromCharCode(0x80 | (cc & 0x3f)))
		                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
		                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
		                    + fromCharCode(0x80 | ( cc         & 0x3f)));
		        } else {
		            var cc = 0x10000
		                + (c.charCodeAt(0) - 0xD800) * 0x400
		                + (c.charCodeAt(1) - 0xDC00);
		            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
		                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
		                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
		                    + fromCharCode(0x80 | ( cc         & 0x3f)));
		        }
		    };
		    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
		    var utob = function(u) {
		        return u.replace(re_utob, cb_utob);
		    };
		    var cb_encode = function(ccc) {
		        var padlen = [0, 2, 1][ccc.length % 3],
		        ord = ccc.charCodeAt(0) << 16
		            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
		            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
		        chars = [
		            b64chars.charAt( ord >>> 18),
		            b64chars.charAt((ord >>> 12) & 63),
		            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
		            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
		        ];
		        return chars.join('');
		    };
		    var btoa = global.btoa && typeof global.btoa == 'function'
		        ? function(b){ return global.btoa(b) } : function(b) {
		        if (b.match(/[^\x00-\xFF]/)) throw new RangeError(
		            'The string contains invalid characters.'
		        );
		        return b.replace(/[\s\S]{1,3}/g, cb_encode);
		    };
		    var _encode = function(u) {
		        return btoa(utob(String(u)));
		    };
		    var mkUriSafe = function (b64) {
		        return b64.replace(/[+\/]/g, function(m0) {
		            return m0 == '+' ? '-' : '_';
		        }).replace(/=/g, '');
		    };
		    var encode = function(u, urisafe) {
		        return urisafe ? mkUriSafe(_encode(u)) : _encode(u);
		    };
		    var encodeURI = function(u) { return encode(u, true) };
		    var fromUint8Array;
		    if (global.Uint8Array) fromUint8Array = function(a, urisafe) {
		        // return btoa(fromCharCode.apply(null, a));
		        var b64 = '';
		        for (var i = 0, l = a.length; i < l; i += 3) {
		            var a0 = a[i], a1 = a[i+1], a2 = a[i+2];
		            var ord = a0 << 16 | a1 << 8 | a2;
		            b64 +=    b64chars.charAt( ord >>> 18)
		                +     b64chars.charAt((ord >>> 12) & 63)
		                + ( typeof a1 != 'undefined'
		                    ? b64chars.charAt((ord >>>  6) & 63) : '=')
		                + ( typeof a2 != 'undefined'
		                    ? b64chars.charAt( ord         & 63) : '=');
		        }
		        return urisafe ? mkUriSafe(b64) : b64;
		    };
		    // decoder stuff
		    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
		    var cb_btou = function(cccc) {
		        switch(cccc.length) {
		        case 4:
		            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
		                |    ((0x3f & cccc.charCodeAt(1)) << 12)
		                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
		                |     (0x3f & cccc.charCodeAt(3)),
		            offset = cp - 0x10000;
		            return (fromCharCode((offset  >>> 10) + 0xD800)
		                    + fromCharCode((offset & 0x3FF) + 0xDC00));
		        case 3:
		            return fromCharCode(
		                ((0x0f & cccc.charCodeAt(0)) << 12)
		                    | ((0x3f & cccc.charCodeAt(1)) << 6)
		                    |  (0x3f & cccc.charCodeAt(2))
		            );
		        default:
		            return  fromCharCode(
		                ((0x1f & cccc.charCodeAt(0)) << 6)
		                    |  (0x3f & cccc.charCodeAt(1))
		            );
		        }
		    };
		    var btou = function(b) {
		        return b.replace(re_btou, cb_btou);
		    };
		    var cb_decode = function(cccc) {
		        var len = cccc.length,
		        padlen = len % 4,
		        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
		            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
		            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
		            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
		        chars = [
		            fromCharCode( n >>> 16),
		            fromCharCode((n >>>  8) & 0xff),
		            fromCharCode( n         & 0xff)
		        ];
		        chars.length -= [0, 0, 2, 1][padlen];
		        return chars.join('');
		    };
		    var _atob = global.atob && typeof global.atob == 'function'
		        ? function(a){ return global.atob(a) } : function(a){
		        return a.replace(/\S{1,4}/g, cb_decode);
		    };
		    var atob = function(a) {
		        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
		    };
		    var _decode = function(a) { return btou(_atob(a)) };
		    var _fromURI = function(a) {
		        return String(a).replace(/[-_]/g, function(m0) {
		            return m0 == '-' ? '+' : '/'
		        }).replace(/[^A-Za-z0-9\+\/]/g, '');
		    };
		    var decode = function(a){
		        return _decode(_fromURI(a));
		    };
		    var toUint8Array;
		    if (global.Uint8Array) toUint8Array = function(a) {
		        return Uint8Array.from(atob(_fromURI(a)), function(c) {
		            return c.charCodeAt(0);
		        });
		    };
		    var noConflict = function() {
		        var Base64 = global.Base64;
		        global.Base64 = _Base64;
		        return Base64;
		    };
		    // export Base64
		    global.Base64 = {
		        VERSION: version,
		        atob: atob,
		        btoa: btoa,
		        fromBase64: decode,
		        toBase64: encode,
		        utob: utob,
		        encode: encode,
		        encodeURI: encodeURI,
		        btou: btou,
		        decode: decode,
		        noConflict: noConflict,
		        fromUint8Array: fromUint8Array,
		        toUint8Array: toUint8Array
		    };
		    // if ES5 is available, make Base64.extendString() available
		    if (typeof Object.defineProperty === 'function') {
		        var noEnum = function(v){
		            return {value:v,enumerable:false,writable:true,configurable:true};
		        };
		        global.Base64.extendString = function () {
		            Object.defineProperty(
		                String.prototype, 'fromBase64', noEnum(function () {
		                    return decode(this)
		                }));
		            Object.defineProperty(
		                String.prototype, 'toBase64', noEnum(function (urisafe) {
		                    return encode(this, urisafe)
		                }));
		            Object.defineProperty(
		                String.prototype, 'toBase64URI', noEnum(function () {
		                    return encode(this, true)
		                }));
		        };
		    }
		    //
		    // export Base64 to the namespace
		    //
		    if (global['Meteor']) { // Meteor.js
		        Base64 = global.Base64;
		    }
		    // module.exports and AMD are mutually exclusive.
		    // module.exports has precedence.
		    if (typeof module !== 'undefined' && module.exports) {
		        module.exports.Base64 = global.Base64;
		    }
		    // that's it!
		    return {Base64: global.Base64}
		}));

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],414:[function(require,module,exports){
		var root = require('./_root');

		/** Built-in value references. */
		var Symbol = root.Symbol;

		module.exports = Symbol;

		},{"./_root":421}],415:[function(require,module,exports){
		/**
		 * A specialized version of `_.map` for arrays without support for iteratee
		 * shorthands.
		 *
		 * @private
		 * @param {Array} [array] The array to iterate over.
		 * @param {Function} iteratee The function invoked per iteration.
		 * @returns {Array} Returns the new mapped array.
		 */
		function arrayMap(array, iteratee) {
		  var index = -1,
		      length = array == null ? 0 : array.length,
		      result = Array(length);

		  while (++index < length) {
		    result[index] = iteratee(array[index], index, array);
		  }
		  return result;
		}

		module.exports = arrayMap;

		},{}],416:[function(require,module,exports){
		var Symbol = require('./_Symbol'),
		    getRawTag = require('./_getRawTag'),
		    objectToString = require('./_objectToString');

		/** `Object#toString` result references. */
		var nullTag = '[object Null]',
		    undefinedTag = '[object Undefined]';

		/** Built-in value references. */
		var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

		/**
		 * The base implementation of `getTag` without fallbacks for buggy environments.
		 *
		 * @private
		 * @param {*} value The value to query.
		 * @returns {string} Returns the `toStringTag`.
		 */
		function baseGetTag(value) {
		  if (value == null) {
		    return value === undefined ? undefinedTag : nullTag;
		  }
		  return (symToStringTag && symToStringTag in Object(value))
		    ? getRawTag(value)
		    : objectToString(value);
		}

		module.exports = baseGetTag;

		},{"./_Symbol":414,"./_getRawTag":419,"./_objectToString":420}],417:[function(require,module,exports){
		var Symbol = require('./_Symbol'),
		    arrayMap = require('./_arrayMap'),
		    isArray = require('./isArray'),
		    isSymbol = require('./isSymbol');

		/** Used to convert symbols to primitives and strings. */
		var symbolProto = Symbol ? Symbol.prototype : undefined,
		    symbolToString = symbolProto ? symbolProto.toString : undefined;

		/**
		 * The base implementation of `_.toString` which doesn't convert nullish
		 * values to empty strings.
		 *
		 * @private
		 * @param {*} value The value to process.
		 * @returns {string} Returns the string.
		 */
		function baseToString(value) {
		  // Exit early for strings to avoid a performance hit in some environments.
		  if (typeof value == 'string') {
		    return value;
		  }
		  if (isArray(value)) {
		    // Recursively convert values (susceptible to call stack limits).
		    return arrayMap(value, baseToString) + '';
		  }
		  if (isSymbol(value)) {
		    return symbolToString ? symbolToString.call(value) : '';
		  }
		  var result = (value + '');
		  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
		}

		module.exports = baseToString;

		},{"./_Symbol":414,"./_arrayMap":415,"./isArray":422,"./isSymbol":426}],418:[function(require,module,exports){
		(function (global){(function (){
		/** Detect free variable `global` from Node.js. */
		var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

		module.exports = freeGlobal;

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],419:[function(require,module,exports){
		var Symbol = require('./_Symbol');

		/** Used for built-in method references. */
		var objectProto = Object.prototype;

		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;

		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var nativeObjectToString = objectProto.toString;

		/** Built-in value references. */
		var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

		/**
		 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
		 *
		 * @private
		 * @param {*} value The value to query.
		 * @returns {string} Returns the raw `toStringTag`.
		 */
		function getRawTag(value) {
		  var isOwn = hasOwnProperty.call(value, symToStringTag),
		      tag = value[symToStringTag];

		  try {
		    value[symToStringTag] = undefined;
		    var unmasked = true;
		  } catch (e) {}

		  var result = nativeObjectToString.call(value);
		  if (unmasked) {
		    if (isOwn) {
		      value[symToStringTag] = tag;
		    } else {
		      delete value[symToStringTag];
		    }
		  }
		  return result;
		}

		module.exports = getRawTag;

		},{"./_Symbol":414}],420:[function(require,module,exports){
		/** Used for built-in method references. */
		var objectProto = Object.prototype;

		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var nativeObjectToString = objectProto.toString;

		/**
		 * Converts `value` to a string using `Object.prototype.toString`.
		 *
		 * @private
		 * @param {*} value The value to convert.
		 * @returns {string} Returns the converted string.
		 */
		function objectToString(value) {
		  return nativeObjectToString.call(value);
		}

		module.exports = objectToString;

		},{}],421:[function(require,module,exports){
		var freeGlobal = require('./_freeGlobal');

		/** Detect free variable `self`. */
		var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

		/** Used as a reference to the global object. */
		var root = freeGlobal || freeSelf || Function('return this')();

		module.exports = root;

		},{"./_freeGlobal":418}],422:[function(require,module,exports){
		/**
		 * Checks if `value` is classified as an `Array` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
		 * @example
		 *
		 * _.isArray([1, 2, 3]);
		 * // => true
		 *
		 * _.isArray(document.body.children);
		 * // => false
		 *
		 * _.isArray('abc');
		 * // => false
		 *
		 * _.isArray(_.noop);
		 * // => false
		 */
		var isArray = Array.isArray;

		module.exports = isArray;

		},{}],423:[function(require,module,exports){
		/**
		 * Checks if `value` is the
		 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
		 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
		 * @example
		 *
		 * _.isObject({});
		 * // => true
		 *
		 * _.isObject([1, 2, 3]);
		 * // => true
		 *
		 * _.isObject(_.noop);
		 * // => true
		 *
		 * _.isObject(null);
		 * // => false
		 */
		function isObject(value) {
		  var type = typeof value;
		  return value != null && (type == 'object' || type == 'function');
		}

		module.exports = isObject;

		},{}],424:[function(require,module,exports){
		/**
		 * Checks if `value` is object-like. A value is object-like if it's not `null`
		 * and has a `typeof` result of "object".
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		 * @example
		 *
		 * _.isObjectLike({});
		 * // => true
		 *
		 * _.isObjectLike([1, 2, 3]);
		 * // => true
		 *
		 * _.isObjectLike(_.noop);
		 * // => false
		 *
		 * _.isObjectLike(null);
		 * // => false
		 */
		function isObjectLike(value) {
		  return value != null && typeof value == 'object';
		}

		module.exports = isObjectLike;

		},{}],425:[function(require,module,exports){
		var baseGetTag = require('./_baseGetTag'),
		    isArray = require('./isArray'),
		    isObjectLike = require('./isObjectLike');

		/** `Object#toString` result references. */
		var stringTag = '[object String]';

		/**
		 * Checks if `value` is classified as a `String` primitive or object.
		 *
		 * @static
		 * @since 0.1.0
		 * @memberOf _
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
		 * @example
		 *
		 * _.isString('abc');
		 * // => true
		 *
		 * _.isString(1);
		 * // => false
		 */
		function isString(value) {
		  return typeof value == 'string' ||
		    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
		}

		module.exports = isString;

		},{"./_baseGetTag":416,"./isArray":422,"./isObjectLike":424}],426:[function(require,module,exports){
		var baseGetTag = require('./_baseGetTag'),
		    isObjectLike = require('./isObjectLike');

		/** `Object#toString` result references. */
		var symbolTag = '[object Symbol]';

		/**
		 * Checks if `value` is classified as a `Symbol` primitive or object.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
		 * @example
		 *
		 * _.isSymbol(Symbol.iterator);
		 * // => true
		 *
		 * _.isSymbol('abc');
		 * // => false
		 */
		function isSymbol(value) {
		  return typeof value == 'symbol' ||
		    (isObjectLike(value) && baseGetTag(value) == symbolTag);
		}

		module.exports = isSymbol;

		},{"./_baseGetTag":416,"./isObjectLike":424}],427:[function(require,module,exports){
		var baseToString = require('./_baseToString');

		/**
		 * Converts `value` to a string. An empty string is returned for `null`
		 * and `undefined` values. The sign of `-0` is preserved.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to convert.
		 * @returns {string} Returns the converted string.
		 * @example
		 *
		 * _.toString(null);
		 * // => ''
		 *
		 * _.toString(-0);
		 * // => '-0'
		 *
		 * _.toString([1, 2, 3]);
		 * // => '1,2,3'
		 */
		function toString(value) {
		  return value == null ? '' : baseToString(value);
		}

		module.exports = toString;

		},{"./_baseToString":417}],428:[function(require,module,exports){

		/**
		 * Module exports.
		 * @public
		 */

		module.exports = merge;

		/**
		 * Module variables.
		 * @private
		 */

		var hasOwnProperty = Object.prototype.hasOwnProperty;

		/**
		 * Merge the property descriptors of `src` into `dest`
		 *
		 * @param {object} dest Object to add descriptors to
		 * @param {object} src Object to clone descriptors from
		 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
		 * @returns {object} Reference to dest
		 * @public
		 */

		function merge (dest, src, redefine) {
		  if (!dest) {
		    throw new TypeError('argument dest is required')
		  }

		  if (!src) {
		    throw new TypeError('argument src is required')
		  }

		  if (redefine === undefined) {
		    // Default to true
		    redefine = true;
		  }

		  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName (name) {
		    if (!redefine && hasOwnProperty.call(dest, name)) {
		      // Skip descriptor
		      return
		    }

		    // Copy descriptor
		    var descriptor = Object.getOwnPropertyDescriptor(src, name);
		    Object.defineProperty(dest, name, descriptor);
		  });

		  return dest
		}

		},{}],429:[function(require,module,exports){

		/**
		 * @param typeMap [Object] Map of MIME type -> Array[extensions]
		 * @param ...
		 */
		require("core-js/modules/es.array.map.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.replace.js");
		require("core-js/modules/es.regexp.constructor.js");
		require("core-js/modules/es.regexp.to-string.js");
		function Mime() {
		  this._types = Object.create(null);
		  this._extensions = Object.create(null);
		  for (var i = 0; i < arguments.length; i++) {
		    this.define(arguments[i]);
		  }
		  this.define = this.define.bind(this);
		  this.getType = this.getType.bind(this);
		  this.getExtension = this.getExtension.bind(this);
		}

		/**
		 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
		 * to an array of extensions associated with the type.  The first extension is
		 * used as the default extension for the type.
		 *
		 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
		 *
		 * If a type declares an extension that has already been defined, an error will
		 * be thrown.  To suppress this error and force the extension to be associated
		 * with the new type, pass `force`=true.  Alternatively, you may prefix the
		 * extension with "*" to map the type to extension, without mapping the
		 * extension to the type.
		 *
		 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
		 *
		 *
		 * @param map (Object) type definitions
		 * @param force (Boolean) if true, force overriding of existing definitions
		 */
		Mime.prototype.define = function (typeMap, force) {
		  for (var type in typeMap) {
		    var extensions = typeMap[type].map(function (t) {
		      return t.toLowerCase();
		    });
		    type = type.toLowerCase();
		    for (var i = 0; i < extensions.length; i++) {
		      var ext = extensions[i];

		      // '*' prefix = not the preferred type for this extension.  So fixup the
		      // extension, and skip it.
		      if (ext[0] === '*') {
		        continue;
		      }
		      if (!force && ext in this._types) {
		        throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
		      }
		      this._types[ext] = type;
		    }

		    // Use first extension as default
		    if (force || !this._extensions[type]) {
		      var _ext = extensions[0];
		      this._extensions[type] = _ext[0] !== '*' ? _ext : _ext.substr(1);
		    }
		  }
		};

		/**
		 * Lookup a mime type based on extension
		 */
		Mime.prototype.getType = function (path) {
		  path = String(path);
		  var last = path.replace(/^.*[/\\]/, '').toLowerCase();
		  var ext = last.replace(/^.*\./, '').toLowerCase();
		  var hasPath = last.length < path.length;
		  var hasDot = ext.length < last.length - 1;
		  return (hasDot || !hasPath) && this._types[ext] || null;
		};

		/**
		 * Return file extension associated with a mime type
		 */
		Mime.prototype.getExtension = function (type) {
		  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
		  return type && this._extensions[type.toLowerCase()] || null;
		};
		module.exports = Mime;

		},{"core-js/modules/es.array.map.js":318,"core-js/modules/es.regexp.constructor.js":337,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/es.string.replace.js":345}],430:[function(require,module,exports){

		var Mime = require('./Mime');
		module.exports = new Mime(require('./types/standard'));

		},{"./Mime":429,"./types/standard":431}],431:[function(require,module,exports){

		module.exports = {
		  "application/andrew-inset": ["ez"],
		  "application/applixware": ["aw"],
		  "application/atom+xml": ["atom"],
		  "application/atomcat+xml": ["atomcat"],
		  "application/atomdeleted+xml": ["atomdeleted"],
		  "application/atomsvc+xml": ["atomsvc"],
		  "application/atsc-dwd+xml": ["dwd"],
		  "application/atsc-held+xml": ["held"],
		  "application/atsc-rsat+xml": ["rsat"],
		  "application/bdoc": ["bdoc"],
		  "application/calendar+xml": ["xcs"],
		  "application/ccxml+xml": ["ccxml"],
		  "application/cdfx+xml": ["cdfx"],
		  "application/cdmi-capability": ["cdmia"],
		  "application/cdmi-container": ["cdmic"],
		  "application/cdmi-domain": ["cdmid"],
		  "application/cdmi-object": ["cdmio"],
		  "application/cdmi-queue": ["cdmiq"],
		  "application/cu-seeme": ["cu"],
		  "application/dash+xml": ["mpd"],
		  "application/davmount+xml": ["davmount"],
		  "application/docbook+xml": ["dbk"],
		  "application/dssc+der": ["dssc"],
		  "application/dssc+xml": ["xdssc"],
		  "application/ecmascript": ["es", "ecma"],
		  "application/emma+xml": ["emma"],
		  "application/emotionml+xml": ["emotionml"],
		  "application/epub+zip": ["epub"],
		  "application/exi": ["exi"],
		  "application/express": ["exp"],
		  "application/fdt+xml": ["fdt"],
		  "application/font-tdpfr": ["pfr"],
		  "application/geo+json": ["geojson"],
		  "application/gml+xml": ["gml"],
		  "application/gpx+xml": ["gpx"],
		  "application/gxf": ["gxf"],
		  "application/gzip": ["gz"],
		  "application/hjson": ["hjson"],
		  "application/hyperstudio": ["stk"],
		  "application/inkml+xml": ["ink", "inkml"],
		  "application/ipfix": ["ipfix"],
		  "application/its+xml": ["its"],
		  "application/java-archive": ["jar", "war", "ear"],
		  "application/java-serialized-object": ["ser"],
		  "application/java-vm": ["class"],
		  "application/javascript": ["js", "mjs"],
		  "application/json": ["json", "map"],
		  "application/json5": ["json5"],
		  "application/jsonml+json": ["jsonml"],
		  "application/ld+json": ["jsonld"],
		  "application/lgr+xml": ["lgr"],
		  "application/lost+xml": ["lostxml"],
		  "application/mac-binhex40": ["hqx"],
		  "application/mac-compactpro": ["cpt"],
		  "application/mads+xml": ["mads"],
		  "application/manifest+json": ["webmanifest"],
		  "application/marc": ["mrc"],
		  "application/marcxml+xml": ["mrcx"],
		  "application/mathematica": ["ma", "nb", "mb"],
		  "application/mathml+xml": ["mathml"],
		  "application/mbox": ["mbox"],
		  "application/mediaservercontrol+xml": ["mscml"],
		  "application/metalink+xml": ["metalink"],
		  "application/metalink4+xml": ["meta4"],
		  "application/mets+xml": ["mets"],
		  "application/mmt-aei+xml": ["maei"],
		  "application/mmt-usd+xml": ["musd"],
		  "application/mods+xml": ["mods"],
		  "application/mp21": ["m21", "mp21"],
		  "application/mp4": ["mp4s", "m4p"],
		  "application/msword": ["doc", "dot"],
		  "application/mxf": ["mxf"],
		  "application/n-quads": ["nq"],
		  "application/n-triples": ["nt"],
		  "application/node": ["cjs"],
		  "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"],
		  "application/oda": ["oda"],
		  "application/oebps-package+xml": ["opf"],
		  "application/ogg": ["ogx"],
		  "application/omdoc+xml": ["omdoc"],
		  "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
		  "application/oxps": ["oxps"],
		  "application/p2p-overlay+xml": ["relo"],
		  "application/patch-ops-error+xml": ["xer"],
		  "application/pdf": ["pdf"],
		  "application/pgp-encrypted": ["pgp"],
		  "application/pgp-signature": ["asc", "sig"],
		  "application/pics-rules": ["prf"],
		  "application/pkcs10": ["p10"],
		  "application/pkcs7-mime": ["p7m", "p7c"],
		  "application/pkcs7-signature": ["p7s"],
		  "application/pkcs8": ["p8"],
		  "application/pkix-attr-cert": ["ac"],
		  "application/pkix-cert": ["cer"],
		  "application/pkix-crl": ["crl"],
		  "application/pkix-pkipath": ["pkipath"],
		  "application/pkixcmp": ["pki"],
		  "application/pls+xml": ["pls"],
		  "application/postscript": ["ai", "eps", "ps"],
		  "application/provenance+xml": ["provx"],
		  "application/pskc+xml": ["pskcxml"],
		  "application/raml+yaml": ["raml"],
		  "application/rdf+xml": ["rdf", "owl"],
		  "application/reginfo+xml": ["rif"],
		  "application/relax-ng-compact-syntax": ["rnc"],
		  "application/resource-lists+xml": ["rl"],
		  "application/resource-lists-diff+xml": ["rld"],
		  "application/rls-services+xml": ["rs"],
		  "application/route-apd+xml": ["rapd"],
		  "application/route-s-tsid+xml": ["sls"],
		  "application/route-usd+xml": ["rusd"],
		  "application/rpki-ghostbusters": ["gbr"],
		  "application/rpki-manifest": ["mft"],
		  "application/rpki-roa": ["roa"],
		  "application/rsd+xml": ["rsd"],
		  "application/rss+xml": ["rss"],
		  "application/rtf": ["rtf"],
		  "application/sbml+xml": ["sbml"],
		  "application/scvp-cv-request": ["scq"],
		  "application/scvp-cv-response": ["scs"],
		  "application/scvp-vp-request": ["spq"],
		  "application/scvp-vp-response": ["spp"],
		  "application/sdp": ["sdp"],
		  "application/senml+xml": ["senmlx"],
		  "application/sensml+xml": ["sensmlx"],
		  "application/set-payment-initiation": ["setpay"],
		  "application/set-registration-initiation": ["setreg"],
		  "application/shf+xml": ["shf"],
		  "application/sieve": ["siv", "sieve"],
		  "application/smil+xml": ["smi", "smil"],
		  "application/sparql-query": ["rq"],
		  "application/sparql-results+xml": ["srx"],
		  "application/srgs": ["gram"],
		  "application/srgs+xml": ["grxml"],
		  "application/sru+xml": ["sru"],
		  "application/ssdl+xml": ["ssdl"],
		  "application/ssml+xml": ["ssml"],
		  "application/swid+xml": ["swidtag"],
		  "application/tei+xml": ["tei", "teicorpus"],
		  "application/thraud+xml": ["tfi"],
		  "application/timestamped-data": ["tsd"],
		  "application/toml": ["toml"],
		  "application/trig": ["trig"],
		  "application/ttml+xml": ["ttml"],
		  "application/ubjson": ["ubj"],
		  "application/urc-ressheet+xml": ["rsheet"],
		  "application/urc-targetdesc+xml": ["td"],
		  "application/voicexml+xml": ["vxml"],
		  "application/wasm": ["wasm"],
		  "application/widget": ["wgt"],
		  "application/winhlp": ["hlp"],
		  "application/wsdl+xml": ["wsdl"],
		  "application/wspolicy+xml": ["wspolicy"],
		  "application/xaml+xml": ["xaml"],
		  "application/xcap-att+xml": ["xav"],
		  "application/xcap-caps+xml": ["xca"],
		  "application/xcap-diff+xml": ["xdf"],
		  "application/xcap-el+xml": ["xel"],
		  "application/xcap-ns+xml": ["xns"],
		  "application/xenc+xml": ["xenc"],
		  "application/xhtml+xml": ["xhtml", "xht"],
		  "application/xliff+xml": ["xlf"],
		  "application/xml": ["xml", "xsl", "xsd", "rng"],
		  "application/xml-dtd": ["dtd"],
		  "application/xop+xml": ["xop"],
		  "application/xproc+xml": ["xpl"],
		  "application/xslt+xml": ["*xsl", "xslt"],
		  "application/xspf+xml": ["xspf"],
		  "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
		  "application/yang": ["yang"],
		  "application/yin+xml": ["yin"],
		  "application/zip": ["zip"],
		  "audio/3gpp": ["*3gpp"],
		  "audio/adpcm": ["adp"],
		  "audio/amr": ["amr"],
		  "audio/basic": ["au", "snd"],
		  "audio/midi": ["mid", "midi", "kar", "rmi"],
		  "audio/mobile-xmf": ["mxmf"],
		  "audio/mp3": ["*mp3"],
		  "audio/mp4": ["m4a", "mp4a"],
		  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
		  "audio/ogg": ["oga", "ogg", "spx", "opus"],
		  "audio/s3m": ["s3m"],
		  "audio/silk": ["sil"],
		  "audio/wav": ["wav"],
		  "audio/wave": ["*wav"],
		  "audio/webm": ["weba"],
		  "audio/xm": ["xm"],
		  "font/collection": ["ttc"],
		  "font/otf": ["otf"],
		  "font/ttf": ["ttf"],
		  "font/woff": ["woff"],
		  "font/woff2": ["woff2"],
		  "image/aces": ["exr"],
		  "image/apng": ["apng"],
		  "image/avif": ["avif"],
		  "image/bmp": ["bmp"],
		  "image/cgm": ["cgm"],
		  "image/dicom-rle": ["drle"],
		  "image/emf": ["emf"],
		  "image/fits": ["fits"],
		  "image/g3fax": ["g3"],
		  "image/gif": ["gif"],
		  "image/heic": ["heic"],
		  "image/heic-sequence": ["heics"],
		  "image/heif": ["heif"],
		  "image/heif-sequence": ["heifs"],
		  "image/hej2k": ["hej2"],
		  "image/hsj2": ["hsj2"],
		  "image/ief": ["ief"],
		  "image/jls": ["jls"],
		  "image/jp2": ["jp2", "jpg2"],
		  "image/jpeg": ["jpeg", "jpg", "jpe"],
		  "image/jph": ["jph"],
		  "image/jphc": ["jhc"],
		  "image/jpm": ["jpm"],
		  "image/jpx": ["jpx", "jpf"],
		  "image/jxr": ["jxr"],
		  "image/jxra": ["jxra"],
		  "image/jxrs": ["jxrs"],
		  "image/jxs": ["jxs"],
		  "image/jxsc": ["jxsc"],
		  "image/jxsi": ["jxsi"],
		  "image/jxss": ["jxss"],
		  "image/ktx": ["ktx"],
		  "image/ktx2": ["ktx2"],
		  "image/png": ["png"],
		  "image/sgi": ["sgi"],
		  "image/svg+xml": ["svg", "svgz"],
		  "image/t38": ["t38"],
		  "image/tiff": ["tif", "tiff"],
		  "image/tiff-fx": ["tfx"],
		  "image/webp": ["webp"],
		  "image/wmf": ["wmf"],
		  "message/disposition-notification": ["disposition-notification"],
		  "message/global": ["u8msg"],
		  "message/global-delivery-status": ["u8dsn"],
		  "message/global-disposition-notification": ["u8mdn"],
		  "message/global-headers": ["u8hdr"],
		  "message/rfc822": ["eml", "mime"],
		  "model/3mf": ["3mf"],
		  "model/gltf+json": ["gltf"],
		  "model/gltf-binary": ["glb"],
		  "model/iges": ["igs", "iges"],
		  "model/mesh": ["msh", "mesh", "silo"],
		  "model/mtl": ["mtl"],
		  "model/obj": ["obj"],
		  "model/step+xml": ["stpx"],
		  "model/step+zip": ["stpz"],
		  "model/step-xml+zip": ["stpxz"],
		  "model/stl": ["stl"],
		  "model/vrml": ["wrl", "vrml"],
		  "model/x3d+binary": ["*x3db", "x3dbz"],
		  "model/x3d+fastinfoset": ["x3db"],
		  "model/x3d+vrml": ["*x3dv", "x3dvz"],
		  "model/x3d+xml": ["x3d", "x3dz"],
		  "model/x3d-vrml": ["x3dv"],
		  "text/cache-manifest": ["appcache", "manifest"],
		  "text/calendar": ["ics", "ifb"],
		  "text/coffeescript": ["coffee", "litcoffee"],
		  "text/css": ["css"],
		  "text/csv": ["csv"],
		  "text/html": ["html", "htm", "shtml"],
		  "text/jade": ["jade"],
		  "text/jsx": ["jsx"],
		  "text/less": ["less"],
		  "text/markdown": ["markdown", "md"],
		  "text/mathml": ["mml"],
		  "text/mdx": ["mdx"],
		  "text/n3": ["n3"],
		  "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
		  "text/richtext": ["rtx"],
		  "text/rtf": ["*rtf"],
		  "text/sgml": ["sgml", "sgm"],
		  "text/shex": ["shex"],
		  "text/slim": ["slim", "slm"],
		  "text/spdx": ["spdx"],
		  "text/stylus": ["stylus", "styl"],
		  "text/tab-separated-values": ["tsv"],
		  "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
		  "text/turtle": ["ttl"],
		  "text/uri-list": ["uri", "uris", "urls"],
		  "text/vcard": ["vcard"],
		  "text/vtt": ["vtt"],
		  "text/xml": ["*xml"],
		  "text/yaml": ["yaml", "yml"],
		  "video/3gpp": ["3gp", "3gpp"],
		  "video/3gpp2": ["3g2"],
		  "video/h261": ["h261"],
		  "video/h263": ["h263"],
		  "video/h264": ["h264"],
		  "video/iso.segment": ["m4s"],
		  "video/jpeg": ["jpgv"],
		  "video/jpm": ["*jpm", "jpgm"],
		  "video/mj2": ["mj2", "mjp2"],
		  "video/mp2t": ["ts"],
		  "video/mp4": ["mp4", "mp4v", "mpg4"],
		  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
		  "video/ogg": ["ogv"],
		  "video/quicktime": ["qt", "mov"],
		  "video/webm": ["webm"]
		};

		},{}],432:[function(require,module,exports){
		/**
		 * Helpers.
		 */

		var s = 1000;
		var m = s * 60;
		var h = m * 60;
		var d = h * 24;
		var w = d * 7;
		var y = d * 365.25;

		/**
		 * Parse or format the given `val`.
		 *
		 * Options:
		 *
		 *  - `long` verbose formatting [false]
		 *
		 * @param {String|Number} val
		 * @param {Object} [options]
		 * @throws {Error} throw an error if val is not a non-empty string or a number
		 * @return {String|Number}
		 * @api public
		 */

		module.exports = function(val, options) {
		  options = options || {};
		  var type = typeof val;
		  if (type === 'string' && val.length > 0) {
		    return parse(val);
		  } else if (type === 'number' && isFinite(val)) {
		    return options.long ? fmtLong(val) : fmtShort(val);
		  }
		  throw new Error(
		    'val is not a non-empty string or a valid number. val=' +
		      JSON.stringify(val)
		  );
		};

		/**
		 * Parse the given `str` and return milliseconds.
		 *
		 * @param {String} str
		 * @return {Number}
		 * @api private
		 */

		function parse(str) {
		  str = String(str);
		  if (str.length > 100) {
		    return;
		  }
		  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
		    str
		  );
		  if (!match) {
		    return;
		  }
		  var n = parseFloat(match[1]);
		  var type = (match[2] || 'ms').toLowerCase();
		  switch (type) {
		    case 'years':
		    case 'year':
		    case 'yrs':
		    case 'yr':
		    case 'y':
		      return n * y;
		    case 'weeks':
		    case 'week':
		    case 'w':
		      return n * w;
		    case 'days':
		    case 'day':
		    case 'd':
		      return n * d;
		    case 'hours':
		    case 'hour':
		    case 'hrs':
		    case 'hr':
		    case 'h':
		      return n * h;
		    case 'minutes':
		    case 'minute':
		    case 'mins':
		    case 'min':
		    case 'm':
		      return n * m;
		    case 'seconds':
		    case 'second':
		    case 'secs':
		    case 'sec':
		    case 's':
		      return n * s;
		    case 'milliseconds':
		    case 'millisecond':
		    case 'msecs':
		    case 'msec':
		    case 'ms':
		      return n;
		    default:
		      return undefined;
		  }
		}

		/**
		 * Short format for `ms`.
		 *
		 * @param {Number} ms
		 * @return {String}
		 * @api private
		 */

		function fmtShort(ms) {
		  var msAbs = Math.abs(ms);
		  if (msAbs >= d) {
		    return Math.round(ms / d) + 'd';
		  }
		  if (msAbs >= h) {
		    return Math.round(ms / h) + 'h';
		  }
		  if (msAbs >= m) {
		    return Math.round(ms / m) + 'm';
		  }
		  if (msAbs >= s) {
		    return Math.round(ms / s) + 's';
		  }
		  return ms + 'ms';
		}

		/**
		 * Long format for `ms`.
		 *
		 * @param {Number} ms
		 * @return {String}
		 * @api private
		 */

		function fmtLong(ms) {
		  var msAbs = Math.abs(ms);
		  if (msAbs >= d) {
		    return plural(ms, msAbs, d, 'day');
		  }
		  if (msAbs >= h) {
		    return plural(ms, msAbs, h, 'hour');
		  }
		  if (msAbs >= m) {
		    return plural(ms, msAbs, m, 'minute');
		  }
		  if (msAbs >= s) {
		    return plural(ms, msAbs, s, 'second');
		  }
		  return ms + ' ms';
		}

		/**
		 * Pluralization helper.
		 */

		function plural(ms, msAbs, n, name) {
		  var isPlural = msAbs >= n * 1.5;
		  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
		}

		},{}],433:[function(require,module,exports){
		(function (global){(function (){
		var hasMap = typeof Map === 'function' && Map.prototype;
		var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
		var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
		var mapForEach = hasMap && Map.prototype.forEach;
		var hasSet = typeof Set === 'function' && Set.prototype;
		var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
		var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
		var setForEach = hasSet && Set.prototype.forEach;
		var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
		var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
		var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
		var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
		var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
		var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
		var booleanValueOf = Boolean.prototype.valueOf;
		var objectToString = Object.prototype.toString;
		var functionToString = Function.prototype.toString;
		var $match = String.prototype.match;
		var $slice = String.prototype.slice;
		var $replace = String.prototype.replace;
		var $toUpperCase = String.prototype.toUpperCase;
		var $toLowerCase = String.prototype.toLowerCase;
		var $test = RegExp.prototype.test;
		var $concat = Array.prototype.concat;
		var $join = Array.prototype.join;
		var $arrSlice = Array.prototype.slice;
		var $floor = Math.floor;
		var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
		var gOPS = Object.getOwnPropertySymbols;
		var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
		var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
		// ie, `has-tostringtag/shams
		var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
		    ? Symbol.toStringTag
		    : null;
		var isEnumerable = Object.prototype.propertyIsEnumerable;

		var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
		    [].__proto__ === Array.prototype // eslint-disable-line no-proto
		        ? function (O) {
		            return O.__proto__; // eslint-disable-line no-proto
		        }
		        : null
		);

		function addNumericSeparator(num, str) {
		    if (
		        num === Infinity
		        || num === -Infinity
		        || num !== num
		        || (num && num > -1e3 && num < 1000)
		        || $test.call(/e/, str)
		    ) {
		        return str;
		    }
		    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
		    if (typeof num === 'number') {
		        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
		        if (int !== num) {
		            var intStr = String(int);
		            var dec = $slice.call(str, intStr.length + 1);
		            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
		        }
		    }
		    return $replace.call(str, sepRegex, '$&_');
		}

		var utilInspect = require('./util.inspect');
		var inspectCustom = utilInspect.custom;
		var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

		module.exports = function inspect_(obj, options, depth, seen) {
		    var opts = options || {};

		    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
		        throw new TypeError('option "quoteStyle" must be "single" or "double"');
		    }
		    if (
		        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
		            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
		            : opts.maxStringLength !== null
		        )
		    ) {
		        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
		    }
		    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
		    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
		        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
		    }

		    if (
		        has(opts, 'indent')
		        && opts.indent !== null
		        && opts.indent !== '\t'
		        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
		    ) {
		        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
		    }
		    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
		        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
		    }
		    var numericSeparator = opts.numericSeparator;

		    if (typeof obj === 'undefined') {
		        return 'undefined';
		    }
		    if (obj === null) {
		        return 'null';
		    }
		    if (typeof obj === 'boolean') {
		        return obj ? 'true' : 'false';
		    }

		    if (typeof obj === 'string') {
		        return inspectString(obj, opts);
		    }
		    if (typeof obj === 'number') {
		        if (obj === 0) {
		            return Infinity / obj > 0 ? '0' : '-0';
		        }
		        var str = String(obj);
		        return numericSeparator ? addNumericSeparator(obj, str) : str;
		    }
		    if (typeof obj === 'bigint') {
		        var bigIntStr = String(obj) + 'n';
		        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
		    }

		    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
		    if (typeof depth === 'undefined') { depth = 0; }
		    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
		        return isArray(obj) ? '[Array]' : '[Object]';
		    }

		    var indent = getIndent(opts, depth);

		    if (typeof seen === 'undefined') {
		        seen = [];
		    } else if (indexOf(seen, obj) >= 0) {
		        return '[Circular]';
		    }

		    function inspect(value, from, noIndent) {
		        if (from) {
		            seen = $arrSlice.call(seen);
		            seen.push(from);
		        }
		        if (noIndent) {
		            var newOpts = {
		                depth: opts.depth
		            };
		            if (has(opts, 'quoteStyle')) {
		                newOpts.quoteStyle = opts.quoteStyle;
		            }
		            return inspect_(value, newOpts, depth + 1, seen);
		        }
		        return inspect_(value, opts, depth + 1, seen);
		    }

		    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
		        var name = nameOf(obj);
		        var keys = arrObjKeys(obj, inspect);
		        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
		    }
		    if (isSymbol(obj)) {
		        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
		        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
		    }
		    if (isElement(obj)) {
		        var s = '<' + $toLowerCase.call(String(obj.nodeName));
		        var attrs = obj.attributes || [];
		        for (var i = 0; i < attrs.length; i++) {
		            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
		        }
		        s += '>';
		        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
		        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
		        return s;
		    }
		    if (isArray(obj)) {
		        if (obj.length === 0) { return '[]'; }
		        var xs = arrObjKeys(obj, inspect);
		        if (indent && !singleLineValues(xs)) {
		            return '[' + indentedJoin(xs, indent) + ']';
		        }
		        return '[ ' + $join.call(xs, ', ') + ' ]';
		    }
		    if (isError(obj)) {
		        var parts = arrObjKeys(obj, inspect);
		        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
		            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
		        }
		        if (parts.length === 0) { return '[' + String(obj) + ']'; }
		        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
		    }
		    if (typeof obj === 'object' && customInspect) {
		        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
		            return utilInspect(obj, { depth: maxDepth - depth });
		        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
		            return obj.inspect();
		        }
		    }
		    if (isMap(obj)) {
		        var mapParts = [];
		        if (mapForEach) {
		            mapForEach.call(obj, function (value, key) {
		                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
		            });
		        }
		        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
		    }
		    if (isSet(obj)) {
		        var setParts = [];
		        if (setForEach) {
		            setForEach.call(obj, function (value) {
		                setParts.push(inspect(value, obj));
		            });
		        }
		        return collectionOf('Set', setSize.call(obj), setParts, indent);
		    }
		    if (isWeakMap(obj)) {
		        return weakCollectionOf('WeakMap');
		    }
		    if (isWeakSet(obj)) {
		        return weakCollectionOf('WeakSet');
		    }
		    if (isWeakRef(obj)) {
		        return weakCollectionOf('WeakRef');
		    }
		    if (isNumber(obj)) {
		        return markBoxed(inspect(Number(obj)));
		    }
		    if (isBigInt(obj)) {
		        return markBoxed(inspect(bigIntValueOf.call(obj)));
		    }
		    if (isBoolean(obj)) {
		        return markBoxed(booleanValueOf.call(obj));
		    }
		    if (isString(obj)) {
		        return markBoxed(inspect(String(obj)));
		    }
		    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
		    /* eslint-env browser */
		    if (typeof window !== 'undefined' && obj === window) {
		        return '{ [object Window] }';
		    }
		    if (obj === global) {
		        return '{ [object globalThis] }';
		    }
		    if (!isDate(obj) && !isRegExp(obj)) {
		        var ys = arrObjKeys(obj, inspect);
		        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
		        var protoTag = obj instanceof Object ? '' : 'null prototype';
		        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
		        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
		        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
		        if (ys.length === 0) { return tag + '{}'; }
		        if (indent) {
		            return tag + '{' + indentedJoin(ys, indent) + '}';
		        }
		        return tag + '{ ' + $join.call(ys, ', ') + ' }';
		    }
		    return String(obj);
		};

		function wrapQuotes(s, defaultStyle, opts) {
		    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
		    return quoteChar + s + quoteChar;
		}

		function quote(s) {
		    return $replace.call(String(s), /"/g, '&quot;');
		}

		function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
		function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
		function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
		function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
		function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
		function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
		function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

		// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
		function isSymbol(obj) {
		    if (hasShammedSymbols) {
		        return obj && typeof obj === 'object' && obj instanceof Symbol;
		    }
		    if (typeof obj === 'symbol') {
		        return true;
		    }
		    if (!obj || typeof obj !== 'object' || !symToString) {
		        return false;
		    }
		    try {
		        symToString.call(obj);
		        return true;
		    } catch (e) {}
		    return false;
		}

		function isBigInt(obj) {
		    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
		        return false;
		    }
		    try {
		        bigIntValueOf.call(obj);
		        return true;
		    } catch (e) {}
		    return false;
		}

		var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
		function has(obj, key) {
		    return hasOwn.call(obj, key);
		}

		function toStr(obj) {
		    return objectToString.call(obj);
		}

		function nameOf(f) {
		    if (f.name) { return f.name; }
		    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
		    if (m) { return m[1]; }
		    return null;
		}

		function indexOf(xs, x) {
		    if (xs.indexOf) { return xs.indexOf(x); }
		    for (var i = 0, l = xs.length; i < l; i++) {
		        if (xs[i] === x) { return i; }
		    }
		    return -1;
		}

		function isMap(x) {
		    if (!mapSize || !x || typeof x !== 'object') {
		        return false;
		    }
		    try {
		        mapSize.call(x);
		        try {
		            setSize.call(x);
		        } catch (s) {
		            return true;
		        }
		        return x instanceof Map; // core-js workaround, pre-v2.5.0
		    } catch (e) {}
		    return false;
		}

		function isWeakMap(x) {
		    if (!weakMapHas || !x || typeof x !== 'object') {
		        return false;
		    }
		    try {
		        weakMapHas.call(x, weakMapHas);
		        try {
		            weakSetHas.call(x, weakSetHas);
		        } catch (s) {
		            return true;
		        }
		        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
		    } catch (e) {}
		    return false;
		}

		function isWeakRef(x) {
		    if (!weakRefDeref || !x || typeof x !== 'object') {
		        return false;
		    }
		    try {
		        weakRefDeref.call(x);
		        return true;
		    } catch (e) {}
		    return false;
		}

		function isSet(x) {
		    if (!setSize || !x || typeof x !== 'object') {
		        return false;
		    }
		    try {
		        setSize.call(x);
		        try {
		            mapSize.call(x);
		        } catch (m) {
		            return true;
		        }
		        return x instanceof Set; // core-js workaround, pre-v2.5.0
		    } catch (e) {}
		    return false;
		}

		function isWeakSet(x) {
		    if (!weakSetHas || !x || typeof x !== 'object') {
		        return false;
		    }
		    try {
		        weakSetHas.call(x, weakSetHas);
		        try {
		            weakMapHas.call(x, weakMapHas);
		        } catch (s) {
		            return true;
		        }
		        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
		    } catch (e) {}
		    return false;
		}

		function isElement(x) {
		    if (!x || typeof x !== 'object') { return false; }
		    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
		        return true;
		    }
		    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
		}

		function inspectString(str, opts) {
		    if (str.length > opts.maxStringLength) {
		        var remaining = str.length - opts.maxStringLength;
		        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
		        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
		    }
		    // eslint-disable-next-line no-control-regex
		    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
		    return wrapQuotes(s, 'single', opts);
		}

		function lowbyte(c) {
		    var n = c.charCodeAt(0);
		    var x = {
		        8: 'b',
		        9: 't',
		        10: 'n',
		        12: 'f',
		        13: 'r'
		    }[n];
		    if (x) { return '\\' + x; }
		    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
		}

		function markBoxed(str) {
		    return 'Object(' + str + ')';
		}

		function weakCollectionOf(type) {
		    return type + ' { ? }';
		}

		function collectionOf(type, size, entries, indent) {
		    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
		    return type + ' (' + size + ') {' + joinedEntries + '}';
		}

		function singleLineValues(xs) {
		    for (var i = 0; i < xs.length; i++) {
		        if (indexOf(xs[i], '\n') >= 0) {
		            return false;
		        }
		    }
		    return true;
		}

		function getIndent(opts, depth) {
		    var baseIndent;
		    if (opts.indent === '\t') {
		        baseIndent = '\t';
		    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
		        baseIndent = $join.call(Array(opts.indent + 1), ' ');
		    } else {
		        return null;
		    }
		    return {
		        base: baseIndent,
		        prev: $join.call(Array(depth + 1), baseIndent)
		    };
		}

		function indentedJoin(xs, indent) {
		    if (xs.length === 0) { return ''; }
		    var lineJoiner = '\n' + indent.prev + indent.base;
		    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
		}

		function arrObjKeys(obj, inspect) {
		    var isArr = isArray(obj);
		    var xs = [];
		    if (isArr) {
		        xs.length = obj.length;
		        for (var i = 0; i < obj.length; i++) {
		            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
		        }
		    }
		    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
		    var symMap;
		    if (hasShammedSymbols) {
		        symMap = {};
		        for (var k = 0; k < syms.length; k++) {
		            symMap['$' + syms[k]] = syms[k];
		        }
		    }

		    for (var key in obj) { // eslint-disable-line no-restricted-syntax
		        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
		        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
		        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
		            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
		            continue; // eslint-disable-line no-restricted-syntax, no-continue
		        } else if ($test.call(/[^\w$]/, key)) {
		            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
		        } else {
		            xs.push(key + ': ' + inspect(obj[key], obj));
		        }
		    }
		    if (typeof gOPS === 'function') {
		        for (var j = 0; j < syms.length; j++) {
		            if (isEnumerable.call(obj, syms[j])) {
		                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
		            }
		        }
		    }
		    return xs;
		}

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{"./util.inspect":102}],434:[function(require,module,exports){

		var keysShim;
		if (!Object.keys) {
			// modified from https://github.com/es-shims/es5-shim
			var has = Object.prototype.hasOwnProperty;
			var toStr = Object.prototype.toString;
			var isArgs = require('./isArguments'); // eslint-disable-line global-require
			var isEnumerable = Object.prototype.propertyIsEnumerable;
			var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
			var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
			var dontEnums = [
				'toString',
				'toLocaleString',
				'valueOf',
				'hasOwnProperty',
				'isPrototypeOf',
				'propertyIsEnumerable',
				'constructor'
			];
			var equalsConstructorPrototype = function (o) {
				var ctor = o.constructor;
				return ctor && ctor.prototype === o;
			};
			var excludedKeys = {
				$applicationCache: true,
				$console: true,
				$external: true,
				$frame: true,
				$frameElement: true,
				$frames: true,
				$innerHeight: true,
				$innerWidth: true,
				$onmozfullscreenchange: true,
				$onmozfullscreenerror: true,
				$outerHeight: true,
				$outerWidth: true,
				$pageXOffset: true,
				$pageYOffset: true,
				$parent: true,
				$scrollLeft: true,
				$scrollTop: true,
				$scrollX: true,
				$scrollY: true,
				$self: true,
				$webkitIndexedDB: true,
				$webkitStorageInfo: true,
				$window: true
			};
			var hasAutomationEqualityBug = (function () {
				/* global window */
				if (typeof window === 'undefined') { return false; }
				for (var k in window) {
					try {
						if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
							try {
								equalsConstructorPrototype(window[k]);
							} catch (e) {
								return true;
							}
						}
					} catch (e) {
						return true;
					}
				}
				return false;
			}());
			var equalsConstructorPrototypeIfNotBuggy = function (o) {
				/* global window */
				if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
					return equalsConstructorPrototype(o);
				}
				try {
					return equalsConstructorPrototype(o);
				} catch (e) {
					return false;
				}
			};

			keysShim = function keys(object) {
				var isObject = object !== null && typeof object === 'object';
				var isFunction = toStr.call(object) === '[object Function]';
				var isArguments = isArgs(object);
				var isString = isObject && toStr.call(object) === '[object String]';
				var theKeys = [];

				if (!isObject && !isFunction && !isArguments) {
					throw new TypeError('Object.keys called on a non-object');
				}

				var skipProto = hasProtoEnumBug && isFunction;
				if (isString && object.length > 0 && !has.call(object, 0)) {
					for (var i = 0; i < object.length; ++i) {
						theKeys.push(String(i));
					}
				}

				if (isArguments && object.length > 0) {
					for (var j = 0; j < object.length; ++j) {
						theKeys.push(String(j));
					}
				} else {
					for (var name in object) {
						if (!(skipProto && name === 'prototype') && has.call(object, name)) {
							theKeys.push(String(name));
						}
					}
				}

				if (hasDontEnumBug) {
					var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

					for (var k = 0; k < dontEnums.length; ++k) {
						if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
							theKeys.push(dontEnums[k]);
						}
					}
				}
				return theKeys;
			};
		}
		module.exports = keysShim;

		},{"./isArguments":436}],435:[function(require,module,exports){

		var slice = Array.prototype.slice;
		var isArgs = require('./isArguments');

		var origKeys = Object.keys;
		var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');

		var originalKeys = Object.keys;

		keysShim.shim = function shimObjectKeys() {
			if (Object.keys) {
				var keysWorksWithArguments = (function () {
					// Safari 5.0 bug
					var args = Object.keys(arguments);
					return args && args.length === arguments.length;
				}(1, 2));
				if (!keysWorksWithArguments) {
					Object.keys = function keys(object) { // eslint-disable-line func-name-matching
						if (isArgs(object)) {
							return originalKeys(slice.call(object));
						}
						return originalKeys(object);
					};
				}
			} else {
				Object.keys = keysShim;
			}
			return Object.keys || keysShim;
		};

		module.exports = keysShim;

		},{"./implementation":434,"./isArguments":436}],436:[function(require,module,exports){

		var toStr = Object.prototype.toString;

		module.exports = function isArguments(value) {
			var str = toStr.call(value);
			var isArgs = str === '[object Arguments]';
			if (!isArgs) {
				isArgs = str !== '[object Array]' &&
					value !== null &&
					typeof value === 'object' &&
					typeof value.length === 'number' &&
					value.length >= 0 &&
					toStr.call(value.callee) === '[object Function]';
			}
			return isArgs;
		};

		},{}],437:[function(require,module,exports){

		// modified from https://github.com/es-shims/es6-shim
		var objectKeys = require('object-keys');
		var hasSymbols = require('has-symbols/shams')();
		var callBound = require('call-bind/callBound');
		var toObject = Object;
		var $push = callBound('Array.prototype.push');
		var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
		var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

		// eslint-disable-next-line no-unused-vars
		module.exports = function assign(target, source1) {
			if (target == null) { throw new TypeError('target must be an object'); }
			var to = toObject(target); // step 1
			if (arguments.length === 1) {
				return to; // step 2
			}
			for (var s = 1; s < arguments.length; ++s) {
				var from = toObject(arguments[s]); // step 3.a.i

				// step 3.a.ii:
				var keys = objectKeys(from);
				var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
				if (getSymbols) {
					var syms = getSymbols(from);
					for (var j = 0; j < syms.length; ++j) {
						var key = syms[j];
						if ($propIsEnumerable(from, key)) {
							$push(keys, key);
						}
					}
				}

				// step 3.a.iii:
				for (var i = 0; i < keys.length; ++i) {
					var nextKey = keys[i];
					if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
						var propValue = from[nextKey]; // step 3.a.iii.2.a
						to[nextKey] = propValue; // step 3.a.iii.2.b
					}
				}
			}

			return to; // step 4
		};

		},{"call-bind/callBound":105,"has-symbols/shams":395,"object-keys":435}],438:[function(require,module,exports){

		var implementation = require('./implementation');

		var lacksProperEnumerationOrder = function () {
			if (!Object.assign) {
				return false;
			}
			/*
			 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
			 * note: this does not detect the bug unless there's 20 characters
			 */
			var str = 'abcdefghijklmnopqrst';
			var letters = str.split('');
			var map = {};
			for (var i = 0; i < letters.length; ++i) {
				map[letters[i]] = letters[i];
			}
			var obj = Object.assign({}, map);
			var actual = '';
			for (var k in obj) {
				actual += k;
			}
			return str !== actual;
		};

		var assignHasPendingExceptions = function () {
			if (!Object.assign || !Object.preventExtensions) {
				return false;
			}
			/*
			 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
			 * which is 72% slower than our shim, and Firefox 40's native implementation.
			 */
			var thrower = Object.preventExtensions({ 1: 2 });
			try {
				Object.assign(thrower, 'xy');
			} catch (e) {
				return thrower[1] === 'y';
			}
			return false;
		};

		module.exports = function getPolyfill() {
			if (!Object.assign) {
				return implementation;
			}
			if (lacksProperEnumerationOrder()) {
				return implementation;
			}
			if (assignHasPendingExceptions()) {
				return implementation;
			}
			return Object.assign;
		};

		},{"./implementation":437}],439:[function(require,module,exports){
		(function (process){(function (){

		function assertPath(path) {
		  if (typeof path !== 'string') {
		    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
		  }
		}

		// Resolves . and .. elements in a path with directory names
		function normalizeStringPosix(path, allowAboveRoot) {
		  var res = '';
		  var lastSegmentLength = 0;
		  var lastSlash = -1;
		  var dots = 0;
		  var code;
		  for (var i = 0; i <= path.length; ++i) {
		    if (i < path.length)
		      code = path.charCodeAt(i);
		    else if (code === 47 /*/*/)
		      break;
		    else
		      code = 47 /*/*/;
		    if (code === 47 /*/*/) {
		      if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {
		        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
		          if (res.length > 2) {
		            var lastSlashIndex = res.lastIndexOf('/');
		            if (lastSlashIndex !== res.length - 1) {
		              if (lastSlashIndex === -1) {
		                res = '';
		                lastSegmentLength = 0;
		              } else {
		                res = res.slice(0, lastSlashIndex);
		                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
		              }
		              lastSlash = i;
		              dots = 0;
		              continue;
		            }
		          } else if (res.length === 2 || res.length === 1) {
		            res = '';
		            lastSegmentLength = 0;
		            lastSlash = i;
		            dots = 0;
		            continue;
		          }
		        }
		        if (allowAboveRoot) {
		          if (res.length > 0)
		            res += '/..';
		          else
		            res = '..';
		          lastSegmentLength = 2;
		        }
		      } else {
		        if (res.length > 0)
		          res += '/' + path.slice(lastSlash + 1, i);
		        else
		          res = path.slice(lastSlash + 1, i);
		        lastSegmentLength = i - lastSlash - 1;
		      }
		      lastSlash = i;
		      dots = 0;
		    } else if (code === 46 /*.*/ && dots !== -1) {
		      ++dots;
		    } else {
		      dots = -1;
		    }
		  }
		  return res;
		}

		function _format(sep, pathObject) {
		  var dir = pathObject.dir || pathObject.root;
		  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
		  if (!dir) {
		    return base;
		  }
		  if (dir === pathObject.root) {
		    return dir + base;
		  }
		  return dir + sep + base;
		}

		var posix = {
		  // path.resolve([from ...], to)
		  resolve: function resolve() {
		    var resolvedPath = '';
		    var resolvedAbsolute = false;
		    var cwd;

		    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
		      var path;
		      if (i >= 0)
		        path = arguments[i];
		      else {
		        if (cwd === undefined)
		          cwd = process.cwd();
		        path = cwd;
		      }

		      assertPath(path);

		      // Skip empty entries
		      if (path.length === 0) {
		        continue;
		      }

		      resolvedPath = path + '/' + resolvedPath;
		      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
		    }

		    // At this point the path should be resolved to a full absolute path, but
		    // handle relative paths to be safe (might happen when process.cwd() fails)

		    // Normalize the path
		    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

		    if (resolvedAbsolute) {
		      if (resolvedPath.length > 0)
		        return '/' + resolvedPath;
		      else
		        return '/';
		    } else if (resolvedPath.length > 0) {
		      return resolvedPath;
		    } else {
		      return '.';
		    }
		  },

		  normalize: function normalize(path) {
		    assertPath(path);

		    if (path.length === 0) return '.';

		    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
		    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

		    // Normalize the path
		    path = normalizeStringPosix(path, !isAbsolute);

		    if (path.length === 0 && !isAbsolute) path = '.';
		    if (path.length > 0 && trailingSeparator) path += '/';

		    if (isAbsolute) return '/' + path;
		    return path;
		  },

		  isAbsolute: function isAbsolute(path) {
		    assertPath(path);
		    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
		  },

		  join: function join() {
		    if (arguments.length === 0)
		      return '.';
		    var joined;
		    for (var i = 0; i < arguments.length; ++i) {
		      var arg = arguments[i];
		      assertPath(arg);
		      if (arg.length > 0) {
		        if (joined === undefined)
		          joined = arg;
		        else
		          joined += '/' + arg;
		      }
		    }
		    if (joined === undefined)
		      return '.';
		    return posix.normalize(joined);
		  },

		  relative: function relative(from, to) {
		    assertPath(from);
		    assertPath(to);

		    if (from === to) return '';

		    from = posix.resolve(from);
		    to = posix.resolve(to);

		    if (from === to) return '';

		    // Trim any leading backslashes
		    var fromStart = 1;
		    for (; fromStart < from.length; ++fromStart) {
		      if (from.charCodeAt(fromStart) !== 47 /*/*/)
		        break;
		    }
		    var fromEnd = from.length;
		    var fromLen = fromEnd - fromStart;

		    // Trim any leading backslashes
		    var toStart = 1;
		    for (; toStart < to.length; ++toStart) {
		      if (to.charCodeAt(toStart) !== 47 /*/*/)
		        break;
		    }
		    var toEnd = to.length;
		    var toLen = toEnd - toStart;

		    // Compare paths to find the longest common path from root
		    var length = fromLen < toLen ? fromLen : toLen;
		    var lastCommonSep = -1;
		    var i = 0;
		    for (; i <= length; ++i) {
		      if (i === length) {
		        if (toLen > length) {
		          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
		            // We get here if `from` is the exact base path for `to`.
		            // For example: from='/foo/bar'; to='/foo/bar/baz'
		            return to.slice(toStart + i + 1);
		          } else if (i === 0) {
		            // We get here if `from` is the root
		            // For example: from='/'; to='/foo'
		            return to.slice(toStart + i);
		          }
		        } else if (fromLen > length) {
		          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
		            // We get here if `to` is the exact base path for `from`.
		            // For example: from='/foo/bar/baz'; to='/foo/bar'
		            lastCommonSep = i;
		          } else if (i === 0) {
		            // We get here if `to` is the root.
		            // For example: from='/foo'; to='/'
		            lastCommonSep = 0;
		          }
		        }
		        break;
		      }
		      var fromCode = from.charCodeAt(fromStart + i);
		      var toCode = to.charCodeAt(toStart + i);
		      if (fromCode !== toCode)
		        break;
		      else if (fromCode === 47 /*/*/)
		        lastCommonSep = i;
		    }

		    var out = '';
		    // Generate the relative path based on the path difference between `to`
		    // and `from`
		    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
		      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
		        if (out.length === 0)
		          out += '..';
		        else
		          out += '/..';
		      }
		    }

		    // Lastly, append the rest of the destination (`to`) path that comes after
		    // the common path parts
		    if (out.length > 0)
		      return out + to.slice(toStart + lastCommonSep);
		    else {
		      toStart += lastCommonSep;
		      if (to.charCodeAt(toStart) === 47 /*/*/)
		        ++toStart;
		      return to.slice(toStart);
		    }
		  },

		  _makeLong: function _makeLong(path) {
		    return path;
		  },

		  dirname: function dirname(path) {
		    assertPath(path);
		    if (path.length === 0) return '.';
		    var code = path.charCodeAt(0);
		    var hasRoot = code === 47 /*/*/;
		    var end = -1;
		    var matchedSlash = true;
		    for (var i = path.length - 1; i >= 1; --i) {
		      code = path.charCodeAt(i);
		      if (code === 47 /*/*/) {
		          if (!matchedSlash) {
		            end = i;
		            break;
		          }
		        } else {
		        // We saw the first non-path separator
		        matchedSlash = false;
		      }
		    }

		    if (end === -1) return hasRoot ? '/' : '.';
		    if (hasRoot && end === 1) return '//';
		    return path.slice(0, end);
		  },

		  basename: function basename(path, ext) {
		    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
		    assertPath(path);

		    var start = 0;
		    var end = -1;
		    var matchedSlash = true;
		    var i;

		    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
		      if (ext.length === path.length && ext === path) return '';
		      var extIdx = ext.length - 1;
		      var firstNonSlashEnd = -1;
		      for (i = path.length - 1; i >= 0; --i) {
		        var code = path.charCodeAt(i);
		        if (code === 47 /*/*/) {
		            // If we reached a path separator that was not part of a set of path
		            // separators at the end of the string, stop now
		            if (!matchedSlash) {
		              start = i + 1;
		              break;
		            }
		          } else {
		          if (firstNonSlashEnd === -1) {
		            // We saw the first non-path separator, remember this index in case
		            // we need it if the extension ends up not matching
		            matchedSlash = false;
		            firstNonSlashEnd = i + 1;
		          }
		          if (extIdx >= 0) {
		            // Try to match the explicit extension
		            if (code === ext.charCodeAt(extIdx)) {
		              if (--extIdx === -1) {
		                // We matched the extension, so mark this as the end of our path
		                // component
		                end = i;
		              }
		            } else {
		              // Extension does not match, so our result is the entire path
		              // component
		              extIdx = -1;
		              end = firstNonSlashEnd;
		            }
		          }
		        }
		      }

		      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
		      return path.slice(start, end);
		    } else {
		      for (i = path.length - 1; i >= 0; --i) {
		        if (path.charCodeAt(i) === 47 /*/*/) {
		            // If we reached a path separator that was not part of a set of path
		            // separators at the end of the string, stop now
		            if (!matchedSlash) {
		              start = i + 1;
		              break;
		            }
		          } else if (end === -1) {
		          // We saw the first non-path separator, mark this as the end of our
		          // path component
		          matchedSlash = false;
		          end = i + 1;
		        }
		      }

		      if (end === -1) return '';
		      return path.slice(start, end);
		    }
		  },

		  extname: function extname(path) {
		    assertPath(path);
		    var startDot = -1;
		    var startPart = 0;
		    var end = -1;
		    var matchedSlash = true;
		    // Track the state of characters (if any) we see before our first dot and
		    // after any path separator we find
		    var preDotState = 0;
		    for (var i = path.length - 1; i >= 0; --i) {
		      var code = path.charCodeAt(i);
		      if (code === 47 /*/*/) {
		          // If we reached a path separator that was not part of a set of path
		          // separators at the end of the string, stop now
		          if (!matchedSlash) {
		            startPart = i + 1;
		            break;
		          }
		          continue;
		        }
		      if (end === -1) {
		        // We saw the first non-path separator, mark this as the end of our
		        // extension
		        matchedSlash = false;
		        end = i + 1;
		      }
		      if (code === 46 /*.*/) {
		          // If this is our first dot, mark it as the start of our extension
		          if (startDot === -1)
		            startDot = i;
		          else if (preDotState !== 1)
		            preDotState = 1;
		      } else if (startDot !== -1) {
		        // We saw a non-dot and non-path separator before our dot, so we should
		        // have a good chance at having a non-empty extension
		        preDotState = -1;
		      }
		    }

		    if (startDot === -1 || end === -1 ||
		        // We saw a non-dot character immediately before the dot
		        preDotState === 0 ||
		        // The (right-most) trimmed path component is exactly '..'
		        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
		      return '';
		    }
		    return path.slice(startDot, end);
		  },

		  format: function format(pathObject) {
		    if (pathObject === null || typeof pathObject !== 'object') {
		      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
		    }
		    return _format('/', pathObject);
		  },

		  parse: function parse(path) {
		    assertPath(path);

		    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
		    if (path.length === 0) return ret;
		    var code = path.charCodeAt(0);
		    var isAbsolute = code === 47 /*/*/;
		    var start;
		    if (isAbsolute) {
		      ret.root = '/';
		      start = 1;
		    } else {
		      start = 0;
		    }
		    var startDot = -1;
		    var startPart = 0;
		    var end = -1;
		    var matchedSlash = true;
		    var i = path.length - 1;

		    // Track the state of characters (if any) we see before our first dot and
		    // after any path separator we find
		    var preDotState = 0;

		    // Get non-dir info
		    for (; i >= start; --i) {
		      code = path.charCodeAt(i);
		      if (code === 47 /*/*/) {
		          // If we reached a path separator that was not part of a set of path
		          // separators at the end of the string, stop now
		          if (!matchedSlash) {
		            startPart = i + 1;
		            break;
		          }
		          continue;
		        }
		      if (end === -1) {
		        // We saw the first non-path separator, mark this as the end of our
		        // extension
		        matchedSlash = false;
		        end = i + 1;
		      }
		      if (code === 46 /*.*/) {
		          // If this is our first dot, mark it as the start of our extension
		          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
		        } else if (startDot !== -1) {
		        // We saw a non-dot and non-path separator before our dot, so we should
		        // have a good chance at having a non-empty extension
		        preDotState = -1;
		      }
		    }

		    if (startDot === -1 || end === -1 ||
		    // We saw a non-dot character immediately before the dot
		    preDotState === 0 ||
		    // The (right-most) trimmed path component is exactly '..'
		    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
		      if (end !== -1) {
		        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
		      }
		    } else {
		      if (startPart === 0 && isAbsolute) {
		        ret.name = path.slice(1, startDot);
		        ret.base = path.slice(1, end);
		      } else {
		        ret.name = path.slice(startPart, startDot);
		        ret.base = path.slice(startPart, end);
		      }
		      ret.ext = path.slice(startDot, end);
		    }

		    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

		    return ret;
		  },

		  sep: '/',
		  delimiter: ':',
		  win32: null,
		  posix: null
		};

		posix.posix = posix;

		module.exports = posix;

		}).call(this);}).call(this,require('_process'));
		},{"_process":538}],440:[function(require,module,exports){
		(function (global){(function (){
(function() {

		  /** Used to determine if values are of the language type `Object`. */
		  var objectTypes = {
		    'function': true,
		    'object': true
		  };

		  /** Used as a reference to the global object. */
		  var root = (objectTypes[typeof window] && window) || this;

		  /** Detect free variable `exports`. */
		  var freeExports = objectTypes[typeof exports] && exports;

		  /** Detect free variable `module`. */
		  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

		  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
		  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
		  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
		    root = freeGlobal;
		  }

		  /**
		   * Used as the maximum length of an array-like object.
		   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
		   * for more details.
		   */
		  var maxSafeInteger = Math.pow(2, 53) - 1;

		  /** Regular expression to detect Opera. */
		  var reOpera = /\bOpera/;

		  /** Used for native method references. */
		  var objectProto = Object.prototype;

		  /** Used to check for own properties of an object. */
		  var hasOwnProperty = objectProto.hasOwnProperty;

		  /** Used to resolve the internal `[[Class]]` of values. */
		  var toString = objectProto.toString;

		  /*--------------------------------------------------------------------------*/

		  /**
		   * Capitalizes a string value.
		   *
		   * @private
		   * @param {string} string The string to capitalize.
		   * @returns {string} The capitalized string.
		   */
		  function capitalize(string) {
		    string = String(string);
		    return string.charAt(0).toUpperCase() + string.slice(1);
		  }

		  /**
		   * A utility function to clean up the OS name.
		   *
		   * @private
		   * @param {string} os The OS name to clean up.
		   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
		   * @param {string} [label] A label for the OS.
		   */
		  function cleanupOS(os, pattern, label) {
		    // Platform tokens are defined at:
		    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
		    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
		    var data = {
		      '10.0': '10',
		      '6.4':  '10 Technical Preview',
		      '6.3':  '8.1',
		      '6.2':  '8',
		      '6.1':  'Server 2008 R2 / 7',
		      '6.0':  'Server 2008 / Vista',
		      '5.2':  'Server 2003 / XP 64-bit',
		      '5.1':  'XP',
		      '5.01': '2000 SP1',
		      '5.0':  '2000',
		      '4.0':  'NT',
		      '4.90': 'ME'
		    };
		    // Detect Windows version from platform tokens.
		    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) &&
		        (data = data[/[\d.]+$/.exec(os)])) {
		      os = 'Windows ' + data;
		    }
		    // Correct character case and cleanup string.
		    os = String(os);

		    if (pattern && label) {
		      os = os.replace(RegExp(pattern, 'i'), label);
		    }

		    os = format(
		      os.replace(/ ce$/i, ' CE')
		        .replace(/\bhpw/i, 'web')
		        .replace(/\bMacintosh\b/, 'Mac OS')
		        .replace(/_PowerPC\b/i, ' OS')
		        .replace(/\b(OS X) [^ \d]+/i, '$1')
		        .replace(/\bMac (OS X)\b/, '$1')
		        .replace(/\/(\d)/, ' $1')
		        .replace(/_/g, '.')
		        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
		        .replace(/\bx86\.64\b/gi, 'x86_64')
		        .replace(/\b(Windows Phone) OS\b/, '$1')
		        .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
		        .split(' on ')[0]
		    );

		    return os;
		  }

		  /**
		   * An iteration utility for arrays and objects.
		   *
		   * @private
		   * @param {Array|Object} object The object to iterate over.
		   * @param {Function} callback The function called per iteration.
		   */
		  function each(object, callback) {
		    var index = -1,
		        length = object ? object.length : 0;

		    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
		      while (++index < length) {
		        callback(object[index], index, object);
		      }
		    } else {
		      forOwn(object, callback);
		    }
		  }

		  /**
		   * Trim and conditionally capitalize string values.
		   *
		   * @private
		   * @param {string} string The string to format.
		   * @returns {string} The formatted string.
		   */
		  function format(string) {
		    string = trim(string);
		    return /^(?:webOS|i(?:OS|P))/.test(string)
		      ? string
		      : capitalize(string);
		  }

		  /**
		   * Iterates over an object's own properties, executing the `callback` for each.
		   *
		   * @private
		   * @param {Object} object The object to iterate over.
		   * @param {Function} callback The function executed per own property.
		   */
		  function forOwn(object, callback) {
		    for (var key in object) {
		      if (hasOwnProperty.call(object, key)) {
		        callback(object[key], key, object);
		      }
		    }
		  }

		  /**
		   * Gets the internal `[[Class]]` of a value.
		   *
		   * @private
		   * @param {*} value The value.
		   * @returns {string} The `[[Class]]`.
		   */
		  function getClassOf(value) {
		    return value == null
		      ? capitalize(value)
		      : toString.call(value).slice(8, -1);
		  }

		  /**
		   * Host objects can return type values that are different from their actual
		   * data type. The objects we are concerned with usually return non-primitive
		   * types of "object", "function", or "unknown".
		   *
		   * @private
		   * @param {*} object The owner of the property.
		   * @param {string} property The property to check.
		   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
		   */
		  function isHostType(object, property) {
		    var type = object != null ? typeof object[property] : 'number';
		    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
		      (type == 'object' ? !!object[property] : true);
		  }

		  /**
		   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
		   *
		   * @private
		   * @param {string} string The string to qualify.
		   * @returns {string} The qualified string.
		   */
		  function qualify(string) {
		    return String(string).replace(/([ -])(?!$)/g, '$1?');
		  }

		  /**
		   * A bare-bones `Array#reduce` like utility function.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} callback The function called per iteration.
		   * @returns {*} The accumulated result.
		   */
		  function reduce(array, callback) {
		    var accumulator = null;
		    each(array, function(value, index) {
		      accumulator = callback(accumulator, value, index, array);
		    });
		    return accumulator;
		  }

		  /**
		   * Removes leading and trailing whitespace from a string.
		   *
		   * @private
		   * @param {string} string The string to trim.
		   * @returns {string} The trimmed string.
		   */
		  function trim(string) {
		    return String(string).replace(/^ +| +$/g, '');
		  }

		  /*--------------------------------------------------------------------------*/

		  /**
		   * Creates a new platform object.
		   *
		   * @memberOf platform
		   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
		   *  context object.
		   * @returns {Object} A platform object.
		   */
		  function parse(ua) {

		    /** The environment context object. */
		    var context = root;

		    /** Used to flag when a custom context is provided. */
		    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

		    // Juggle arguments.
		    if (isCustomContext) {
		      context = ua;
		      ua = null;
		    }

		    /** Browser navigator object. */
		    var nav = context.navigator || {};

		    /** Browser user agent string. */
		    var userAgent = nav.userAgent || '';

		    ua || (ua = userAgent);

		    /** Used to detect if browser is like Chrome. */
		    var likeChrome = isCustomContext
		      ? !!nav.likeChrome
		      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

		    /** Internal `[[Class]]` value shortcuts. */
		    var objectClass = 'Object',
		        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
		        enviroClass = isCustomContext ? objectClass : 'Environment',
		        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
		        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

		    /** Detect Java environments. */
		    var java = /\bJava/.test(javaClass) && context.java;

		    /** Detect Rhino. */
		    var rhino = java && getClassOf(context.environment) == enviroClass;

		    /** A character to represent alpha. */
		    var alpha = java ? 'a' : '\u03b1';

		    /** A character to represent beta. */
		    var beta = java ? 'b' : '\u03b2';

		    /** Browser document object. */
		    var doc = context.document || {};

		    /**
		     * Detect Opera browser (Presto-based).
		     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
		     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
		     */
		    var opera = context.operamini || context.opera;

		    /** Opera `[[Class]]`. */
		    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
		      ? operaClass
		      : (opera = null);

		    /*------------------------------------------------------------------------*/

		    /** Temporary variable used over the script's lifetime. */
		    var data;

		    /** The CPU architecture. */
		    var arch = ua;

		    /** Platform description array. */
		    var description = [];

		    /** Platform alpha/beta indicator. */
		    var prerelease = null;

		    /** A flag to indicate that environment features should be used to resolve the platform. */
		    var useFeatures = ua == userAgent;

		    /** The browser/environment version. */
		    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

		    /** A flag to indicate if the OS ends with "/ Version" */
		    var isSpecialCasedOS;

		    /* Detectable layout engines (order is important). */
		    var layout = getLayout([
		      { 'label': 'EdgeHTML', 'pattern': 'Edge' },
		      'Trident',
		      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
		      'iCab',
		      'Presto',
		      'NetFront',
		      'Tasman',
		      'KHTML',
		      'Gecko'
		    ]);

		    /* Detectable browser names (order is important). */
		    var name = getName([
		      'Adobe AIR',
		      'Arora',
		      'Avant Browser',
		      'Breach',
		      'Camino',
		      'Electron',
		      'Epiphany',
		      'Fennec',
		      'Flock',
		      'Galeon',
		      'GreenBrowser',
		      'iCab',
		      'Iceweasel',
		      'K-Meleon',
		      'Konqueror',
		      'Lunascape',
		      'Maxthon',
		      { 'label': 'Microsoft Edge', 'pattern': '(?:Edge|Edg|EdgA|EdgiOS)' },
		      'Midori',
		      'Nook Browser',
		      'PaleMoon',
		      'PhantomJS',
		      'Raven',
		      'Rekonq',
		      'RockMelt',
		      { 'label': 'Samsung Internet', 'pattern': 'SamsungBrowser' },
		      'SeaMonkey',
		      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
		      'Sleipnir',
		      'SlimBrowser',
		      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
		      'Sunrise',
		      'Swiftfox',
		      'Vivaldi',
		      'Waterfox',
		      'WebPositive',
		      { 'label': 'Yandex Browser', 'pattern': 'YaBrowser' },
		      { 'label': 'UC Browser', 'pattern': 'UCBrowser' },
		      'Opera Mini',
		      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
		      'Opera',
		      { 'label': 'Opera', 'pattern': 'OPR' },
		      'Chromium',
		      'Chrome',
		      { 'label': 'Chrome', 'pattern': '(?:HeadlessChrome)' },
		      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
		      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
		      { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' },
		      { 'label': 'IE', 'pattern': 'IEMobile' },
		      { 'label': 'IE', 'pattern': 'MSIE' },
		      'Safari'
		    ]);

		    /* Detectable products (order is important). */
		    var product = getProduct([
		      { 'label': 'BlackBerry', 'pattern': 'BB10' },
		      'BlackBerry',
		      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
		      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
		      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
		      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
		      { 'label': 'Galaxy S5', 'pattern': 'SM-G900' },
		      { 'label': 'Galaxy S6', 'pattern': 'SM-G920' },
		      { 'label': 'Galaxy S6 Edge', 'pattern': 'SM-G925' },
		      { 'label': 'Galaxy S7', 'pattern': 'SM-G930' },
		      { 'label': 'Galaxy S7 Edge', 'pattern': 'SM-G935' },
		      'Google TV',
		      'Lumia',
		      'iPad',
		      'iPod',
		      'iPhone',
		      'Kindle',
		      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
		      'Nexus',
		      'Nook',
		      'PlayBook',
		      'PlayStation Vita',
		      'PlayStation',
		      'TouchPad',
		      'Transformer',
		      { 'label': 'Wii U', 'pattern': 'WiiU' },
		      'Wii',
		      'Xbox One',
		      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
		      'Xoom'
		    ]);

		    /* Detectable manufacturers. */
		    var manufacturer = getManufacturer({
		      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
		      'Alcatel': {},
		      'Archos': {},
		      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
		      'Asus': { 'Transformer': 1 },
		      'Barnes & Noble': { 'Nook': 1 },
		      'BlackBerry': { 'PlayBook': 1 },
		      'Google': { 'Google TV': 1, 'Nexus': 1 },
		      'HP': { 'TouchPad': 1 },
		      'HTC': {},
		      'Huawei': {},
		      'Lenovo': {},
		      'LG': {},
		      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
		      'Motorola': { 'Xoom': 1 },
		      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
		      'Nokia': { 'Lumia': 1 },
		      'Oppo': {},
		      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
		      'Sony': { 'PlayStation': 1, 'PlayStation Vita': 1 },
		      'Xiaomi': { 'Mi': 1, 'Redmi': 1 }
		    });

		    /* Detectable operating systems (order is important). */
		    var os = getOS([
		      'Windows Phone',
		      'KaiOS',
		      'Android',
		      'CentOS',
		      { 'label': 'Chrome OS', 'pattern': 'CrOS' },
		      'Debian',
		      { 'label': 'DragonFly BSD', 'pattern': 'DragonFly' },
		      'Fedora',
		      'FreeBSD',
		      'Gentoo',
		      'Haiku',
		      'Kubuntu',
		      'Linux Mint',
		      'OpenBSD',
		      'Red Hat',
		      'SuSE',
		      'Ubuntu',
		      'Xubuntu',
		      'Cygwin',
		      'Symbian OS',
		      'hpwOS',
		      'webOS ',
		      'webOS',
		      'Tablet OS',
		      'Tizen',
		      'Linux',
		      'Mac OS X',
		      'Macintosh',
		      'Mac',
		      'Windows 98;',
		      'Windows '
		    ]);

		    /*------------------------------------------------------------------------*/

		    /**
		     * Picks the layout engine from an array of guesses.
		     *
		     * @private
		     * @param {Array} guesses An array of guesses.
		     * @returns {null|string} The detected layout engine.
		     */
		    function getLayout(guesses) {
		      return reduce(guesses, function(result, guess) {
		        return result || RegExp('\\b' + (
		          guess.pattern || qualify(guess)
		        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
		      });
		    }

		    /**
		     * Picks the manufacturer from an array of guesses.
		     *
		     * @private
		     * @param {Array} guesses An object of guesses.
		     * @returns {null|string} The detected manufacturer.
		     */
		    function getManufacturer(guesses) {
		      return reduce(guesses, function(result, value, key) {
		        // Lookup the manufacturer by product or scan the UA for the manufacturer.
		        return result || (
		          value[product] ||
		          value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
		          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
		        ) && key;
		      });
		    }

		    /**
		     * Picks the browser name from an array of guesses.
		     *
		     * @private
		     * @param {Array} guesses An array of guesses.
		     * @returns {null|string} The detected browser name.
		     */
		    function getName(guesses) {
		      return reduce(guesses, function(result, guess) {
		        return result || RegExp('\\b' + (
		          guess.pattern || qualify(guess)
		        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
		      });
		    }

		    /**
		     * Picks the OS name from an array of guesses.
		     *
		     * @private
		     * @param {Array} guesses An array of guesses.
		     * @returns {null|string} The detected OS name.
		     */
		    function getOS(guesses) {
		      return reduce(guesses, function(result, guess) {
		        var pattern = guess.pattern || qualify(guess);
		        if (!result && (result =
		              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
		            )) {
		          result = cleanupOS(result, pattern, guess.label || guess);
		        }
		        return result;
		      });
		    }

		    /**
		     * Picks the product name from an array of guesses.
		     *
		     * @private
		     * @param {Array} guesses An array of guesses.
		     * @returns {null|string} The detected product name.
		     */
		    function getProduct(guesses) {
		      return reduce(guesses, function(result, guess) {
		        var pattern = guess.pattern || qualify(guess);
		        if (!result && (result =
		              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
		              RegExp('\\b' + pattern + ' *\\w+-[\\w]*', 'i').exec(ua) ||
		              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
		            )) {
		          // Split by forward slash and append product version if needed.
		          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
		            result[0] += ' ' + result[1];
		          }
		          // Correct character case and cleanup string.
		          guess = guess.label || guess;
		          result = format(result[0]
		            .replace(RegExp(pattern, 'i'), guess)
		            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
		            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
		        }
		        return result;
		      });
		    }

		    /**
		     * Resolves the version using an array of UA patterns.
		     *
		     * @private
		     * @param {Array} patterns An array of UA patterns.
		     * @returns {null|string} The detected version.
		     */
		    function getVersion(patterns) {
		      return reduce(patterns, function(result, pattern) {
		        return result || (RegExp(pattern +
		          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
		      });
		    }

		    /**
		     * Returns `platform.description` when the platform object is coerced to a string.
		     *
		     * @name toString
		     * @memberOf platform
		     * @returns {string} Returns `platform.description` if available, else an empty string.
		     */
		    function toStringPlatform() {
		      return this.description || '';
		    }

		    /*------------------------------------------------------------------------*/

		    // Convert layout to an array so we can add extra details.
		    layout && (layout = [layout]);

		    // Detect Android products.
		    // Browsers on Android devices typically provide their product IDS after "Android;"
		    // up to "Build" or ") AppleWebKit".
		    // Example:
		    // "Mozilla/5.0 (Linux; Android 8.1.0; Moto G (5) Plus) AppleWebKit/537.36
		    // (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36"
		    if (/\bAndroid\b/.test(os) && !product &&
		        (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))) {
		      product = trim(data[1])
		        // Replace any language codes (eg. "en-US").
		        .replace(/^[a-z]{2}-[a-z]{2};\s*/i, '')
		        || null;
		    }
		    // Detect product names that contain their manufacturer's name.
		    if (manufacturer && !product) {
		      product = getProduct([manufacturer]);
		    } else if (manufacturer && product) {
		      product = product
		        .replace(RegExp('^(' + qualify(manufacturer) + ')[-_.\\s]', 'i'), manufacturer + ' ')
		        .replace(RegExp('^(' + qualify(manufacturer) + ')[-_.]?(\\w)', 'i'), manufacturer + ' $2');
		    }
		    // Clean up Google TV.
		    if ((data = /\bGoogle TV\b/.exec(product))) {
		      product = data[0];
		    }
		    // Detect simulators.
		    if (/\bSimulator\b/i.test(ua)) {
		      product = (product ? product + ' ' : '') + 'Simulator';
		    }
		    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
		    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
		      description.push('running in Turbo/Uncompressed mode');
		    }
		    // Detect IE Mobile 11.
		    if (name == 'IE' && /\blike iPhone OS\b/.test(ua)) {
		      data = parse(ua.replace(/like iPhone OS/, ''));
		      manufacturer = data.manufacturer;
		      product = data.product;
		    }
		    // Detect iOS.
		    else if (/^iP/.test(product)) {
		      name || (name = 'Safari');
		      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
		        ? ' ' + data[1].replace(/_/g, '.')
		        : '');
		    }
		    // Detect Kubuntu.
		    else if (name == 'Konqueror' && /^Linux\b/i.test(os)) {
		      os = 'Kubuntu';
		    }
		    // Detect Android browsers.
		    else if ((manufacturer && manufacturer != 'Google' &&
		        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) ||
		        (/\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua))) {
		      name = 'Android Browser';
		      os = /\bAndroid\b/.test(os) ? os : 'Android';
		    }
		    // Detect Silk desktop/accelerated modes.
		    else if (name == 'Silk') {
		      if (!/\bMobi/i.test(ua)) {
		        os = 'Android';
		        description.unshift('desktop mode');
		      }
		      if (/Accelerated *= *true/i.test(ua)) {
		        description.unshift('accelerated');
		      }
		    }
		    // Detect UC Browser speed mode.
		    else if (name == 'UC Browser' && /\bUCWEB\b/.test(ua)) {
		      description.push('speed mode');
		    }
		    // Detect PaleMoon identifying as Firefox.
		    else if (name == 'PaleMoon' && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
		      description.push('identifying as Firefox ' + data[1]);
		    }
		    // Detect Firefox OS and products running Firefox.
		    else if (name == 'Firefox' && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
		      os || (os = 'Firefox OS');
		      product || (product = data[1]);
		    }
		    // Detect false positives for Firefox/Safari.
		    else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
		      // Escape the `/` for Firefox 1.
		      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
		        // Clear name of false positives.
		        name = null;
		      }
		      // Reassign a generic name.
		      if ((data = product || manufacturer || os) &&
		          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
		        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
		      }
		    }
		    // Add Chrome version to description for Electron.
		    else if (name == 'Electron' && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
		      description.push('Chromium ' + data);
		    }
		    // Detect non-Opera (Presto-based) versions (order is important).
		    if (!version) {
		      version = getVersion([
		        '(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)',
		        'Version',
		        qualify(name),
		        '(?:Firefox|Minefield|NetFront)'
		      ]);
		    }
		    // Detect stubborn layout engines.
		    if ((data =
		          layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' ||
		          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
		          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' ||
		          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') ||
		          layout == 'WebKit' && /\bPlayStation\b(?! Vita\b)/i.test(name) && 'NetFront'
		        )) {
		      layout = [data];
		    }
		    // Detect Windows Phone 7 desktop mode.
		    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
		      name += ' Mobile';
		      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
		      description.unshift('desktop mode');
		    }
		    // Detect Windows Phone 8.x desktop mode.
		    else if (/\bWPDesktop\b/i.test(ua)) {
		      name = 'IE Mobile';
		      os = 'Windows Phone 8.x';
		      description.unshift('desktop mode');
		      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
		    }
		    // Detect IE 11 identifying as other browsers.
		    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
		      if (name) {
		        description.push('identifying as ' + name + (version ? ' ' + version : ''));
		      }
		      name = 'IE';
		      version = data[1];
		    }
		    // Leverage environment features.
		    if (useFeatures) {
		      // Detect server-side environments.
		      // Rhino has a global function while others have a global object.
		      if (isHostType(context, 'global')) {
		        if (java) {
		          data = java.lang.System;
		          arch = data.getProperty('os.arch');
		          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
		        }
		        if (rhino) {
		          try {
		            version = context.require('ringo/engine').version.join('.');
		            name = 'RingoJS';
		          } catch(e) {
		            if ((data = context.system) && data.global.system == context.system) {
		              name = 'Narwhal';
		              os || (os = data[0].os || null);
		            }
		          }
		          if (!name) {
		            name = 'Rhino';
		          }
		        }
		        else if (
		          typeof context.process == 'object' && !context.process.browser &&
		          (data = context.process)
		        ) {
		          if (typeof data.versions == 'object') {
		            if (typeof data.versions.electron == 'string') {
		              description.push('Node ' + data.versions.node);
		              name = 'Electron';
		              version = data.versions.electron;
		            } else if (typeof data.versions.nw == 'string') {
		              description.push('Chromium ' + version, 'Node ' + data.versions.node);
		              name = 'NW.js';
		              version = data.versions.nw;
		            }
		          }
		          if (!name) {
		            name = 'Node.js';
		            arch = data.arch;
		            os = data.platform;
		            version = /[\d.]+/.exec(data.version);
		            version = version ? version[0] : null;
		          }
		        }
		      }
		      // Detect Adobe AIR.
		      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
		        name = 'Adobe AIR';
		        os = data.flash.system.Capabilities.os;
		      }
		      // Detect PhantomJS.
		      else if (getClassOf((data = context.phantom)) == phantomClass) {
		        name = 'PhantomJS';
		        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
		      }
		      // Detect IE compatibility modes.
		      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
		        // We're in compatibility mode when the Trident version + 4 doesn't
		        // equal the document mode.
		        version = [version, doc.documentMode];
		        if ((data = +data[1] + 4) != version[1]) {
		          description.push('IE ' + version[1] + ' mode');
		          layout && (layout[1] = '');
		          version[1] = data;
		        }
		        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
		      }
		      // Detect IE 11 masking as other browsers.
		      else if (typeof doc.documentMode == 'number' && /^(?:Chrome|Firefox)\b/.test(name)) {
		        description.push('masking as ' + name + ' ' + version);
		        name = 'IE';
		        version = '11.0';
		        layout = ['Trident'];
		        os = 'Windows';
		      }
		      os = os && format(os);
		    }
		    // Detect prerelease phases.
		    if (version && (data =
		          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
		          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
		          /\bMinefield\b/i.test(ua) && 'a'
		        )) {
		      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
		      version = version.replace(RegExp(data + '\\+?$'), '') +
		        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
		    }
		    // Detect Firefox Mobile.
		    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os)) {
		      name = 'Firefox Mobile';
		    }
		    // Obscure Maxthon's unreliable version.
		    else if (name == 'Maxthon' && version) {
		      version = version.replace(/\.[\d.]+/, '.x');
		    }
		    // Detect Xbox 360 and Xbox One.
		    else if (/\bXbox\b/i.test(product)) {
		      if (product == 'Xbox 360') {
		        os = null;
		      }
		      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
		        description.unshift('mobile mode');
		      }
		    }
		    // Add mobile postfix.
		    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
		        (os == 'Windows CE' || /Mobi/i.test(ua))) {
		      name += ' Mobile';
		    }
		    // Detect IE platform preview.
		    else if (name == 'IE' && useFeatures) {
		      try {
		        if (context.external === null) {
		          description.unshift('platform preview');
		        }
		      } catch(e) {
		        description.unshift('embedded');
		      }
		    }
		    // Detect BlackBerry OS version.
		    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
		    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
		          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
		          version
		        )) {
		      data = [data, /BB10/.test(ua)];
		      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
		      version = null;
		    }
		    // Detect Opera identifying/masking itself as another browser.
		    // http://www.opera.com/support/kb/view/843/
		    else if (this != forOwn && product != 'Wii' && (
		          (useFeatures && opera) ||
		          (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
		          (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
		          (name == 'IE' && (
		            (os && !/^Win/.test(os) && version > 5.5) ||
		            /\bWindows XP\b/.test(os) && version > 8 ||
		            version == 8 && !/\bTrident\b/.test(ua)
		          ))
		        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
		      // When "identifying", the UA contains both Opera and the other browser's name.
		      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
		      if (reOpera.test(name)) {
		        if (/\bIE\b/.test(data) && os == 'Mac OS') {
		          os = null;
		        }
		        data = 'identify' + data;
		      }
		      // When "masking", the UA contains only the other browser's name.
		      else {
		        data = 'mask' + data;
		        if (operaClass) {
		          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
		        } else {
		          name = 'Opera';
		        }
		        if (/\bIE\b/.test(data)) {
		          os = null;
		        }
		        if (!useFeatures) {
		          version = null;
		        }
		      }
		      layout = ['Presto'];
		      description.push(data);
		    }
		    // Detect WebKit Nightly and approximate Chrome/Safari versions.
		    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
		      // Correct build number for numeric comparison.
		      // (e.g. "532.5" becomes "532.05")
		      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
		      // Nightly builds are postfixed with a "+".
		      if (name == 'Safari' && data[1].slice(-1) == '+') {
		        name = 'WebKit Nightly';
		        prerelease = 'alpha';
		        version = data[1].slice(0, -1);
		      }
		      // Clear incorrect browser versions.
		      else if (version == data[1] ||
		          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
		        version = null;
		      }
		      // Use the full Chrome version when available.
		      data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
		      // Detect Blink layout engine.
		      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {
		        layout = ['Blink'];
		      }
		      // Detect JavaScriptCore.
		      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
		      if (!useFeatures || (!likeChrome && !data[1])) {
		        layout && (layout[1] = 'like Safari');
		        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : '12');
		      } else {
		        layout && (layout[1] = 'like Chrome');
		        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
		      }
		      // Add the postfix of ".x" or "+" for approximate versions.
		      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
		      // Obscure version for some Safari 1-2 releases.
		      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
		        version = data;
		      } else if (name == 'Chrome' && /\bHeadlessChrome/i.test(ua)) {
		        description.unshift('headless');
		      }
		    }
		    // Detect Opera desktop modes.
		    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
		      name += ' ';
		      description.unshift('desktop mode');
		      if (data == 'zvav') {
		        name += 'Mini';
		        version = null;
		      } else {
		        name += 'Mobile';
		      }
		      os = os.replace(RegExp(' *' + data + '$'), '');
		    }
		    // Detect Chrome desktop mode.
		    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
		      description.unshift('desktop mode');
		      name = 'Chrome Mobile';
		      version = null;

		      if (/\bOS X\b/.test(os)) {
		        manufacturer = 'Apple';
		        os = 'iOS 4.3+';
		      } else {
		        os = null;
		      }
		    }
		    // Newer versions of SRWare Iron uses the Chrome tag to indicate its version number.
		    else if (/\bSRWare Iron\b/.test(name) && !version) {
		      version = getVersion('Chrome');
		    }
		    // Strip incorrect OS versions.
		    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
		        ua.indexOf('/' + data + '-') > -1) {
		      os = trim(os.replace(data, ''));
		    }
		    // Ensure OS does not include the browser name.
		    if (os && os.indexOf(name) != -1 && !RegExp(name + ' OS').test(os)) {
		      os = os.replace(RegExp(' *' + qualify(name) + ' *'), '');
		    }
		    // Add layout engine.
		    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
		        /Browser|Lunascape|Maxthon/.test(name) ||
		        name != 'Safari' && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) ||
		        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name) && layout[1])) {
		      // Don't add layout details to description if they are falsey.
		      (data = layout[layout.length - 1]) && description.push(data);
		    }
		    // Combine contextual information.
		    if (description.length) {
		      description = ['(' + description.join('; ') + ')'];
		    }
		    // Append manufacturer to description.
		    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
		      description.push('on ' + manufacturer);
		    }
		    // Append product to description.
		    if (product) {
		      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
		    }
		    // Parse the OS into an object.
		    if (os) {
		      data = / ([\d.+]+)$/.exec(os);
		      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
		      os = {
		        'architecture': 32,
		        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
		        'version': data ? data[1] : null,
		        'toString': function() {
		          var version = this.version;
		          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
		        }
		      };
		    }
		    // Add browser/OS architecture.
		    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
		      if (os) {
		        os.architecture = 64;
		        os.family = os.family.replace(RegExp(' *' + data), '');
		      }
		      if (
		          name && (/\bWOW64\b/i.test(ua) ||
		          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
		      ) {
		        description.unshift('32-bit');
		      }
		    }
		    // Chrome 39 and above on OS X is always 64-bit.
		    else if (
		        os && /^OS X/.test(os.family) &&
		        name == 'Chrome' && parseFloat(version) >= 39
		    ) {
		      os.architecture = 64;
		    }

		    ua || (ua = null);

		    /*------------------------------------------------------------------------*/

		    /**
		     * The platform object.
		     *
		     * @name platform
		     * @type Object
		     */
		    var platform = {};

		    /**
		     * The platform description.
		     *
		     * @memberOf platform
		     * @type string|null
		     */
		    platform.description = ua;

		    /**
		     * The name of the browser's layout engine.
		     *
		     * The list of common layout engines include:
		     * "Blink", "EdgeHTML", "Gecko", "Trident" and "WebKit"
		     *
		     * @memberOf platform
		     * @type string|null
		     */
		    platform.layout = layout && layout[0];

		    /**
		     * The name of the product's manufacturer.
		     *
		     * The list of manufacturers include:
		     * "Apple", "Archos", "Amazon", "Asus", "Barnes & Noble", "BlackBerry",
		     * "Google", "HP", "HTC", "LG", "Microsoft", "Motorola", "Nintendo",
		     * "Nokia", "Samsung" and "Sony"
		     *
		     * @memberOf platform
		     * @type string|null
		     */
		    platform.manufacturer = manufacturer;

		    /**
		     * The name of the browser/environment.
		     *
		     * The list of common browser names include:
		     * "Chrome", "Electron", "Firefox", "Firefox for iOS", "IE",
		     * "Microsoft Edge", "PhantomJS", "Safari", "SeaMonkey", "Silk",
		     * "Opera Mini" and "Opera"
		     *
		     * Mobile versions of some browsers have "Mobile" appended to their name:
		     * eg. "Chrome Mobile", "Firefox Mobile", "IE Mobile" and "Opera Mobile"
		     *
		     * @memberOf platform
		     * @type string|null
		     */
		    platform.name = name;

		    /**
		     * The alpha/beta release indicator.
		     *
		     * @memberOf platform
		     * @type string|null
		     */
		    platform.prerelease = prerelease;

		    /**
		     * The name of the product hosting the browser.
		     *
		     * The list of common products include:
		     *
		     * "BlackBerry", "Galaxy S4", "Lumia", "iPad", "iPod", "iPhone", "Kindle",
		     * "Kindle Fire", "Nexus", "Nook", "PlayBook", "TouchPad" and "Transformer"
		     *
		     * @memberOf platform
		     * @type string|null
		     */
		    platform.product = product;

		    /**
		     * The browser's user agent string.
		     *
		     * @memberOf platform
		     * @type string|null
		     */
		    platform.ua = ua;

		    /**
		     * The browser/environment version.
		     *
		     * @memberOf platform
		     * @type string|null
		     */
		    platform.version = name && version;

		    /**
		     * The name of the operating system.
		     *
		     * @memberOf platform
		     * @type Object
		     */
		    platform.os = os || {

		      /**
		       * The CPU architecture the OS is built for.
		       *
		       * @memberOf platform.os
		       * @type number|null
		       */
		      'architecture': null,

		      /**
		       * The family of the OS.
		       *
		       * Common values include:
		       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
		       * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
		       * "SuSE", "Android", "iOS" and "Windows Phone"
		       *
		       * @memberOf platform.os
		       * @type string|null
		       */
		      'family': null,

		      /**
		       * The version of the OS.
		       *
		       * @memberOf platform.os
		       * @type string|null
		       */
		      'version': null,

		      /**
		       * Returns the OS string.
		       *
		       * @memberOf platform.os
		       * @returns {string} The OS string.
		       */
		      'toString': function() { return 'null'; }
		    };

		    platform.parse = parse;
		    platform.toString = toStringPlatform;

		    if (platform.version) {
		      description.unshift(version);
		    }
		    if (platform.name) {
		      description.unshift(name);
		    }
		    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
		      description.push(product ? '(' + os + ')' : 'on ' + os);
		    }
		    if (description.length) {
		      platform.description = description.join(' ');
		    }
		    return platform;
		  }

		  /*--------------------------------------------------------------------------*/

		  // Export platform.
		  var platform = parse();

		  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
		  if (freeExports && freeModule) {
		    // Export for CommonJS support.
		    forOwn(platform, function(value, key) {
		      freeExports[key] = value;
		    });
		  }
		  else {
		    // Export to the global object.
		    root.platform = platform;
		  }
		}.call(this));

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],441:[function(require,module,exports){
		(function (process){(function (){

		if (typeof process === 'undefined' ||
		    !process.version ||
		    process.version.indexOf('v0.') === 0 ||
		    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
		  module.exports = { nextTick: nextTick };
		} else {
		  module.exports = process;
		}

		function nextTick(fn, arg1, arg2, arg3) {
		  if (typeof fn !== 'function') {
		    throw new TypeError('"callback" argument must be a function');
		  }
		  var len = arguments.length;
		  var args, i;
		  switch (len) {
		  case 0:
		  case 1:
		    return process.nextTick(fn);
		  case 2:
		    return process.nextTick(function afterTickOne() {
		      fn.call(null, arg1);
		    });
		  case 3:
		    return process.nextTick(function afterTickTwo() {
		      fn.call(null, arg1, arg2);
		    });
		  case 4:
		    return process.nextTick(function afterTickThree() {
		      fn.call(null, arg1, arg2, arg3);
		    });
		  default:
		    args = new Array(len - 1);
		    i = 0;
		    while (i < args.length) {
		      args[i++] = arguments[i];
		    }
		    return process.nextTick(function afterTick() {
		      fn.apply(null, args);
		    });
		  }
		}


		}).call(this);}).call(this,require('_process'));
		},{"_process":538}],442:[function(require,module,exports){
		// shim for using process in browser
		var process = module.exports = {};

		// cached from whatever global is present so that test runners that stub it
		// don't break things.  But we need to wrap it in a try catch in case it is
		// wrapped in strict mode code which doesn't define any globals.  It's inside a
		// function because try/catches deoptimize in certain engines.

		var cachedSetTimeout;
		var cachedClearTimeout;

		function defaultSetTimout() {
		    throw new Error('setTimeout has not been defined');
		}
		function defaultClearTimeout () {
		    throw new Error('clearTimeout has not been defined');
		}
		(function () {
		    try {
		        if (typeof setTimeout === 'function') {
		            cachedSetTimeout = setTimeout;
		        } else {
		            cachedSetTimeout = defaultSetTimout;
		        }
		    } catch (e) {
		        cachedSetTimeout = defaultSetTimout;
		    }
		    try {
		        if (typeof clearTimeout === 'function') {
		            cachedClearTimeout = clearTimeout;
		        } else {
		            cachedClearTimeout = defaultClearTimeout;
		        }
		    } catch (e) {
		        cachedClearTimeout = defaultClearTimeout;
		    }
		} ());
		function runTimeout(fun) {
		    if (cachedSetTimeout === setTimeout) {
		        //normal enviroments in sane situations
		        return setTimeout(fun, 0);
		    }
		    // if setTimeout wasn't available but was latter defined
		    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
		        cachedSetTimeout = setTimeout;
		        return setTimeout(fun, 0);
		    }
		    try {
		        // when when somebody has screwed with setTimeout but no I.E. maddness
		        return cachedSetTimeout(fun, 0);
		    } catch(e){
		        try {
		            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
		            return cachedSetTimeout.call(null, fun, 0);
		        } catch(e){
		            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
		            return cachedSetTimeout.call(this, fun, 0);
		        }
		    }


		}
		function runClearTimeout(marker) {
		    if (cachedClearTimeout === clearTimeout) {
		        //normal enviroments in sane situations
		        return clearTimeout(marker);
		    }
		    // if clearTimeout wasn't available but was latter defined
		    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
		        cachedClearTimeout = clearTimeout;
		        return clearTimeout(marker);
		    }
		    try {
		        // when when somebody has screwed with setTimeout but no I.E. maddness
		        return cachedClearTimeout(marker);
		    } catch (e){
		        try {
		            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
		            return cachedClearTimeout.call(null, marker);
		        } catch (e){
		            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
		            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
		            return cachedClearTimeout.call(this, marker);
		        }
		    }



		}
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;

		function cleanUpNextTick() {
		    if (!draining || !currentQueue) {
		        return;
		    }
		    draining = false;
		    if (currentQueue.length) {
		        queue = currentQueue.concat(queue);
		    } else {
		        queueIndex = -1;
		    }
		    if (queue.length) {
		        drainQueue();
		    }
		}

		function drainQueue() {
		    if (draining) {
		        return;
		    }
		    var timeout = runTimeout(cleanUpNextTick);
		    draining = true;

		    var len = queue.length;
		    while(len) {
		        currentQueue = queue;
		        queue = [];
		        while (++queueIndex < len) {
		            if (currentQueue) {
		                currentQueue[queueIndex].run();
		            }
		        }
		        queueIndex = -1;
		        len = queue.length;
		    }
		    currentQueue = null;
		    draining = false;
		    runClearTimeout(timeout);
		}

		process.nextTick = function (fun) {
		    var args = new Array(arguments.length - 1);
		    if (arguments.length > 1) {
		        for (var i = 1; i < arguments.length; i++) {
		            args[i - 1] = arguments[i];
		        }
		    }
		    queue.push(new Item(fun, args));
		    if (queue.length === 1 && !draining) {
		        runTimeout(drainQueue);
		    }
		};

		// v8 likes predictible objects
		function Item(fun, array) {
		    this.fun = fun;
		    this.array = array;
		}
		Item.prototype.run = function () {
		    this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};

		function noop() {}

		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		process.prependListener = noop;
		process.prependOnceListener = noop;

		process.listeners = function (name) { return [] };

		process.binding = function (name) {
		    throw new Error('process.binding is not supported');
		};

		process.cwd = function () { return '/' };
		process.chdir = function (dir) {
		    throw new Error('process.chdir is not supported');
		};
		process.umask = function() { return 0; };

		},{}],443:[function(require,module,exports){
		(function (global){(function (){
(function(root) {

			/** Detect free variables */
			var freeExports = typeof exports == 'object' && exports &&
				!exports.nodeType && exports;
			var freeModule = typeof module == 'object' && module &&
				!module.nodeType && module;
			var freeGlobal = typeof global == 'object' && global;
			if (
				freeGlobal.global === freeGlobal ||
				freeGlobal.window === freeGlobal ||
				freeGlobal.self === freeGlobal
			) {
				root = freeGlobal;
			}

			/**
			 * The `punycode` object.
			 * @name punycode
			 * @type Object
			 */
			var punycode,

			/** Highest positive signed 32-bit float value */
			maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

			/** Bootstring parameters */
			base = 36,
			tMin = 1,
			tMax = 26,
			skew = 38,
			damp = 700,
			initialBias = 72,
			initialN = 128, // 0x80
			delimiter = '-', // '\x2D'

			/** Regular expressions */
			regexPunycode = /^xn--/,
			regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
			regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

			/** Error messages */
			errors = {
				'overflow': 'Overflow: input needs wider integers to process',
				'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
				'invalid-input': 'Invalid input'
			},

			/** Convenience shortcuts */
			baseMinusTMin = base - tMin,
			floor = Math.floor,
			stringFromCharCode = String.fromCharCode,

			/** Temporary variable */
			key;

			/*--------------------------------------------------------------------------*/

			/**
			 * A generic error utility function.
			 * @private
			 * @param {String} type The error type.
			 * @returns {Error} Throws a `RangeError` with the applicable error message.
			 */
			function error(type) {
				throw new RangeError(errors[type]);
			}

			/**
			 * A generic `Array#map` utility function.
			 * @private
			 * @param {Array} array The array to iterate over.
			 * @param {Function} callback The function that gets called for every array
			 * item.
			 * @returns {Array} A new array of values returned by the callback function.
			 */
			function map(array, fn) {
				var length = array.length;
				var result = [];
				while (length--) {
					result[length] = fn(array[length]);
				}
				return result;
			}

			/**
			 * A simple `Array#map`-like wrapper to work with domain name strings or email
			 * addresses.
			 * @private
			 * @param {String} domain The domain name or email address.
			 * @param {Function} callback The function that gets called for every
			 * character.
			 * @returns {Array} A new string of characters returned by the callback
			 * function.
			 */
			function mapDomain(string, fn) {
				var parts = string.split('@');
				var result = '';
				if (parts.length > 1) {
					// In email addresses, only the domain name should be punycoded. Leave
					// the local part (i.e. everything up to `@`) intact.
					result = parts[0] + '@';
					string = parts[1];
				}
				// Avoid `split(regex)` for IE8 compatibility. See #17.
				string = string.replace(regexSeparators, '\x2E');
				var labels = string.split('.');
				var encoded = map(labels, fn).join('.');
				return result + encoded;
			}

			/**
			 * Creates an array containing the numeric code points of each Unicode
			 * character in the string. While JavaScript uses UCS-2 internally,
			 * this function will convert a pair of surrogate halves (each of which
			 * UCS-2 exposes as separate characters) into a single code point,
			 * matching UTF-16.
			 * @see `punycode.ucs2.encode`
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode.ucs2
			 * @name decode
			 * @param {String} string The Unicode input string (UCS-2).
			 * @returns {Array} The new array of code points.
			 */
			function ucs2decode(string) {
				var output = [],
				    counter = 0,
				    length = string.length,
				    value,
				    extra;
				while (counter < length) {
					value = string.charCodeAt(counter++);
					if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
						// high surrogate, and there is a next character
						extra = string.charCodeAt(counter++);
						if ((extra & 0xFC00) == 0xDC00) { // low surrogate
							output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
						} else {
							// unmatched surrogate; only append this code unit, in case the next
							// code unit is the high surrogate of a surrogate pair
							output.push(value);
							counter--;
						}
					} else {
						output.push(value);
					}
				}
				return output;
			}

			/**
			 * Creates a string based on an array of numeric code points.
			 * @see `punycode.ucs2.decode`
			 * @memberOf punycode.ucs2
			 * @name encode
			 * @param {Array} codePoints The array of numeric code points.
			 * @returns {String} The new Unicode string (UCS-2).
			 */
			function ucs2encode(array) {
				return map(array, function(value) {
					var output = '';
					if (value > 0xFFFF) {
						value -= 0x10000;
						output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
						value = 0xDC00 | value & 0x3FF;
					}
					output += stringFromCharCode(value);
					return output;
				}).join('');
			}

			/**
			 * Converts a basic code point into a digit/integer.
			 * @see `digitToBasic()`
			 * @private
			 * @param {Number} codePoint The basic numeric code point value.
			 * @returns {Number} The numeric value of a basic code point (for use in
			 * representing integers) in the range `0` to `base - 1`, or `base` if
			 * the code point does not represent a value.
			 */
			function basicToDigit(codePoint) {
				if (codePoint - 48 < 10) {
					return codePoint - 22;
				}
				if (codePoint - 65 < 26) {
					return codePoint - 65;
				}
				if (codePoint - 97 < 26) {
					return codePoint - 97;
				}
				return base;
			}

			/**
			 * Converts a digit/integer into a basic code point.
			 * @see `basicToDigit()`
			 * @private
			 * @param {Number} digit The numeric value of a basic code point.
			 * @returns {Number} The basic code point whose value (when used for
			 * representing integers) is `digit`, which needs to be in the range
			 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
			 * used; else, the lowercase form is used. The behavior is undefined
			 * if `flag` is non-zero and `digit` has no uppercase form.
			 */
			function digitToBasic(digit, flag) {
				//  0..25 map to ASCII a..z or A..Z
				// 26..35 map to ASCII 0..9
				return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
			}

			/**
			 * Bias adaptation function as per section 3.4 of RFC 3492.
			 * https://tools.ietf.org/html/rfc3492#section-3.4
			 * @private
			 */
			function adapt(delta, numPoints, firstTime) {
				var k = 0;
				delta = firstTime ? floor(delta / damp) : delta >> 1;
				delta += floor(delta / numPoints);
				for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
					delta = floor(delta / baseMinusTMin);
				}
				return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
			}

			/**
			 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
			 * symbols.
			 * @memberOf punycode
			 * @param {String} input The Punycode string of ASCII-only symbols.
			 * @returns {String} The resulting string of Unicode symbols.
			 */
			function decode(input) {
				// Don't use UCS-2
				var output = [],
				    inputLength = input.length,
				    out,
				    i = 0,
				    n = initialN,
				    bias = initialBias,
				    basic,
				    j,
				    index,
				    oldi,
				    w,
				    k,
				    digit,
				    t,
				    /** Cached calculation results */
				    baseMinusT;

				// Handle the basic code points: let `basic` be the number of input code
				// points before the last delimiter, or `0` if there is none, then copy
				// the first basic code points to the output.

				basic = input.lastIndexOf(delimiter);
				if (basic < 0) {
					basic = 0;
				}

				for (j = 0; j < basic; ++j) {
					// if it's not a basic code point
					if (input.charCodeAt(j) >= 0x80) {
						error('not-basic');
					}
					output.push(input.charCodeAt(j));
				}

				// Main decoding loop: start just after the last delimiter if any basic code
				// points were copied; start at the beginning otherwise.

				for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

					// `index` is the index of the next character to be consumed.
					// Decode a generalized variable-length integer into `delta`,
					// which gets added to `i`. The overflow checking is easier
					// if we increase `i` as we go, then subtract off its starting
					// value at the end to obtain `delta`.
					for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

						if (index >= inputLength) {
							error('invalid-input');
						}

						digit = basicToDigit(input.charCodeAt(index++));

						if (digit >= base || digit > floor((maxInt - i) / w)) {
							error('overflow');
						}

						i += digit * w;
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

						if (digit < t) {
							break;
						}

						baseMinusT = base - t;
						if (w > floor(maxInt / baseMinusT)) {
							error('overflow');
						}

						w *= baseMinusT;

					}

					out = output.length + 1;
					bias = adapt(i - oldi, out, oldi == 0);

					// `i` was supposed to wrap around from `out` to `0`,
					// incrementing `n` each time, so we'll fix that now:
					if (floor(i / out) > maxInt - n) {
						error('overflow');
					}

					n += floor(i / out);
					i %= out;

					// Insert `n` at position `i` of the output
					output.splice(i++, 0, n);

				}

				return ucs2encode(output);
			}

			/**
			 * Converts a string of Unicode symbols (e.g. a domain name label) to a
			 * Punycode string of ASCII-only symbols.
			 * @memberOf punycode
			 * @param {String} input The string of Unicode symbols.
			 * @returns {String} The resulting Punycode string of ASCII-only symbols.
			 */
			function encode(input) {
				var n,
				    delta,
				    handledCPCount,
				    basicLength,
				    bias,
				    j,
				    m,
				    q,
				    k,
				    t,
				    currentValue,
				    output = [],
				    /** `inputLength` will hold the number of code points in `input`. */
				    inputLength,
				    /** Cached calculation results */
				    handledCPCountPlusOne,
				    baseMinusT,
				    qMinusT;

				// Convert the input in UCS-2 to Unicode
				input = ucs2decode(input);

				// Cache the length
				inputLength = input.length;

				// Initialize the state
				n = initialN;
				delta = 0;
				bias = initialBias;

				// Handle the basic code points
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue < 0x80) {
						output.push(stringFromCharCode(currentValue));
					}
				}

				handledCPCount = basicLength = output.length;

				// `handledCPCount` is the number of code points that have been handled;
				// `basicLength` is the number of basic code points.

				// Finish the basic string - if it is not empty - with a delimiter
				if (basicLength) {
					output.push(delimiter);
				}

				// Main encoding loop:
				while (handledCPCount < inputLength) {

					// All non-basic code points < n have been handled already. Find the next
					// larger one:
					for (m = maxInt, j = 0; j < inputLength; ++j) {
						currentValue = input[j];
						if (currentValue >= n && currentValue < m) {
							m = currentValue;
						}
					}

					// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
					// but guard against overflow
					handledCPCountPlusOne = handledCPCount + 1;
					if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
						error('overflow');
					}

					delta += (m - n) * handledCPCountPlusOne;
					n = m;

					for (j = 0; j < inputLength; ++j) {
						currentValue = input[j];

						if (currentValue < n && ++delta > maxInt) {
							error('overflow');
						}

						if (currentValue == n) {
							// Represent delta as a generalized variable-length integer
							for (q = delta, k = base; /* no condition */; k += base) {
								t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
								if (q < t) {
									break;
								}
								qMinusT = q - t;
								baseMinusT = base - t;
								output.push(
									stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
								);
								q = floor(qMinusT / baseMinusT);
							}

							output.push(stringFromCharCode(digitToBasic(q, 0)));
							bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
							delta = 0;
							++handledCPCount;
						}
					}

					++delta;
					++n;

				}
				return output.join('');
			}

			/**
			 * Converts a Punycode string representing a domain name or an email address
			 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
			 * it doesn't matter if you call it on a string that has already been
			 * converted to Unicode.
			 * @memberOf punycode
			 * @param {String} input The Punycoded domain name or email address to
			 * convert to Unicode.
			 * @returns {String} The Unicode representation of the given Punycode
			 * string.
			 */
			function toUnicode(input) {
				return mapDomain(input, function(string) {
					return regexPunycode.test(string)
						? decode(string.slice(4).toLowerCase())
						: string;
				});
			}

			/**
			 * Converts a Unicode string representing a domain name or an email address to
			 * Punycode. Only the non-ASCII parts of the domain name will be converted,
			 * i.e. it doesn't matter if you call it with a domain that's already in
			 * ASCII.
			 * @memberOf punycode
			 * @param {String} input The domain name or email address to convert, as a
			 * Unicode string.
			 * @returns {String} The Punycode representation of the given domain name or
			 * email address.
			 */
			function toASCII(input) {
				return mapDomain(input, function(string) {
					return regexNonASCII.test(string)
						? 'xn--' + encode(string)
						: string;
				});
			}

			/*--------------------------------------------------------------------------*/

			/** Define the public API */
			punycode = {
				/**
				 * A string representing the current Punycode.js version number.
				 * @memberOf punycode
				 * @type String
				 */
				'version': '1.4.1',
				/**
				 * An object of methods to convert from JavaScript's internal character
				 * representation (UCS-2) to Unicode code points, and back.
				 * @see <https://mathiasbynens.be/notes/javascript-encoding>
				 * @memberOf punycode
				 * @type Object
				 */
				'ucs2': {
					'decode': ucs2decode,
					'encode': ucs2encode
				},
				'decode': decode,
				'encode': encode,
				'toASCII': toASCII,
				'toUnicode': toUnicode
			};

			/** Expose `punycode` */
			// Some AMD build optimizers, like r.js, check for specific condition patterns
			// like the following:
			if (freeExports && freeModule) {
				if (module.exports == freeExports) {
					// in Node.js, io.js, or RingoJS v0.8.0+
					freeModule.exports = punycode;
				} else {
					// in Narwhal or RingoJS v0.7.0-
					for (key in punycode) {
						punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
					}
				}
			} else {
				// in Rhino or a web browser
				root.punycode = punycode;
			}

		}(this));

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],444:[function(require,module,exports){

		var replace = String.prototype.replace;
		var percentTwenties = /%20/g;

		var Format = {
		    RFC1738: 'RFC1738',
		    RFC3986: 'RFC3986'
		};

		module.exports = {
		    'default': Format.RFC3986,
		    formatters: {
		        RFC1738: function (value) {
		            return replace.call(value, percentTwenties, '+');
		        },
		        RFC3986: function (value) {
		            return String(value);
		        }
		    },
		    RFC1738: Format.RFC1738,
		    RFC3986: Format.RFC3986
		};

		},{}],445:[function(require,module,exports){

		var stringify = require('./stringify');
		var parse = require('./parse');
		var formats = require('./formats');

		module.exports = {
		    formats: formats,
		    parse: parse,
		    stringify: stringify
		};

		},{"./formats":444,"./parse":446,"./stringify":447}],446:[function(require,module,exports){

		var utils = require('./utils');

		var has = Object.prototype.hasOwnProperty;
		var isArray = Array.isArray;

		var defaults = {
		    allowDots: false,
		    allowPrototypes: false,
		    allowSparse: false,
		    arrayLimit: 20,
		    charset: 'utf-8',
		    charsetSentinel: false,
		    comma: false,
		    decoder: utils.decode,
		    delimiter: '&',
		    depth: 5,
		    ignoreQueryPrefix: false,
		    interpretNumericEntities: false,
		    parameterLimit: 1000,
		    parseArrays: true,
		    plainObjects: false,
		    strictNullHandling: false
		};

		var interpretNumericEntities = function (str) {
		    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
		        return String.fromCharCode(parseInt(numberStr, 10));
		    });
		};

		var parseArrayValue = function (val, options) {
		    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
		        return val.split(',');
		    }

		    return val;
		};

		// This is what browsers will submit when the ✓ character occurs in an
		// application/x-www-form-urlencoded body and the encoding of the page containing
		// the form is iso-8859-1, or when the submitted form has an accept-charset
		// attribute of iso-8859-1. Presumably also with other charsets that do not contain
		// the ✓ character, such as us-ascii.
		var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

		// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
		var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

		var parseValues = function parseQueryStringValues(str, options) {
		    var obj = { __proto__: null };

		    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
		    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
		    var parts = cleanStr.split(options.delimiter, limit);
		    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
		    var i;

		    var charset = options.charset;
		    if (options.charsetSentinel) {
		        for (i = 0; i < parts.length; ++i) {
		            if (parts[i].indexOf('utf8=') === 0) {
		                if (parts[i] === charsetSentinel) {
		                    charset = 'utf-8';
		                } else if (parts[i] === isoSentinel) {
		                    charset = 'iso-8859-1';
		                }
		                skipIndex = i;
		                i = parts.length; // The eslint settings do not allow break;
		            }
		        }
		    }

		    for (i = 0; i < parts.length; ++i) {
		        if (i === skipIndex) {
		            continue;
		        }
		        var part = parts[i];

		        var bracketEqualsPos = part.indexOf(']=');
		        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

		        var key, val;
		        if (pos === -1) {
		            key = options.decoder(part, defaults.decoder, charset, 'key');
		            val = options.strictNullHandling ? null : '';
		        } else {
		            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
		            val = utils.maybeMap(
		                parseArrayValue(part.slice(pos + 1), options),
		                function (encodedVal) {
		                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
		                }
		            );
		        }

		        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
		            val = interpretNumericEntities(val);
		        }

		        if (part.indexOf('[]=') > -1) {
		            val = isArray(val) ? [val] : val;
		        }

		        if (has.call(obj, key)) {
		            obj[key] = utils.combine(obj[key], val);
		        } else {
		            obj[key] = val;
		        }
		    }

		    return obj;
		};

		var parseObject = function (chain, val, options, valuesParsed) {
		    var leaf = valuesParsed ? val : parseArrayValue(val, options);

		    for (var i = chain.length - 1; i >= 0; --i) {
		        var obj;
		        var root = chain[i];

		        if (root === '[]' && options.parseArrays) {
		            obj = [].concat(leaf);
		        } else {
		            obj = options.plainObjects ? Object.create(null) : {};
		            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
		            var index = parseInt(cleanRoot, 10);
		            if (!options.parseArrays && cleanRoot === '') {
		                obj = { 0: leaf };
		            } else if (
		                !isNaN(index)
		                && root !== cleanRoot
		                && String(index) === cleanRoot
		                && index >= 0
		                && (options.parseArrays && index <= options.arrayLimit)
		            ) {
		                obj = [];
		                obj[index] = leaf;
		            } else if (cleanRoot !== '__proto__') {
		                obj[cleanRoot] = leaf;
		            }
		        }

		        leaf = obj;
		    }

		    return leaf;
		};

		var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
		    if (!givenKey) {
		        return;
		    }

		    // Transform dot notation to bracket notation
		    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

		    // The regex chunks

		    var brackets = /(\[[^[\]]*])/;
		    var child = /(\[[^[\]]*])/g;

		    // Get the parent

		    var segment = options.depth > 0 && brackets.exec(key);
		    var parent = segment ? key.slice(0, segment.index) : key;

		    // Stash the parent if it exists

		    var keys = [];
		    if (parent) {
		        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
		        if (!options.plainObjects && has.call(Object.prototype, parent)) {
		            if (!options.allowPrototypes) {
		                return;
		            }
		        }

		        keys.push(parent);
		    }

		    // Loop through children appending to the array until we hit depth

		    var i = 0;
		    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
		        i += 1;
		        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
		            if (!options.allowPrototypes) {
		                return;
		            }
		        }
		        keys.push(segment[1]);
		    }

		    // If there's a remainder, just add whatever is left

		    if (segment) {
		        keys.push('[' + key.slice(segment.index) + ']');
		    }

		    return parseObject(keys, val, options, valuesParsed);
		};

		var normalizeParseOptions = function normalizeParseOptions(opts) {
		    if (!opts) {
		        return defaults;
		    }

		    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
		        throw new TypeError('Decoder has to be a function.');
		    }

		    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
		        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
		    }
		    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

		    return {
		        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
		        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
		        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
		        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
		        charset: charset,
		        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
		        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
		        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
		        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
		        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
		        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
		        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
		        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
		        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
		        parseArrays: opts.parseArrays !== false,
		        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
		        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
		    };
		};

		module.exports = function (str, opts) {
		    var options = normalizeParseOptions(opts);

		    if (str === '' || str === null || typeof str === 'undefined') {
		        return options.plainObjects ? Object.create(null) : {};
		    }

		    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
		    var obj = options.plainObjects ? Object.create(null) : {};

		    // Iterate over the keys and setup the new object

		    var keys = Object.keys(tempObj);
		    for (var i = 0; i < keys.length; ++i) {
		        var key = keys[i];
		        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
		        obj = utils.merge(obj, newObj, options);
		    }

		    if (options.allowSparse === true) {
		        return obj;
		    }

		    return utils.compact(obj);
		};

		},{"./utils":448}],447:[function(require,module,exports){

		var getSideChannel = require('side-channel');
		var utils = require('./utils');
		var formats = require('./formats');
		var has = Object.prototype.hasOwnProperty;

		var arrayPrefixGenerators = {
		    brackets: function brackets(prefix) {
		        return prefix + '[]';
		    },
		    comma: 'comma',
		    indices: function indices(prefix, key) {
		        return prefix + '[' + key + ']';
		    },
		    repeat: function repeat(prefix) {
		        return prefix;
		    }
		};

		var isArray = Array.isArray;
		var push = Array.prototype.push;
		var pushToArray = function (arr, valueOrArray) {
		    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
		};

		var toISO = Date.prototype.toISOString;

		var defaultFormat = formats['default'];
		var defaults = {
		    addQueryPrefix: false,
		    allowDots: false,
		    charset: 'utf-8',
		    charsetSentinel: false,
		    delimiter: '&',
		    encode: true,
		    encoder: utils.encode,
		    encodeValuesOnly: false,
		    format: defaultFormat,
		    formatter: formats.formatters[defaultFormat],
		    // deprecated
		    indices: false,
		    serializeDate: function serializeDate(date) {
		        return toISO.call(date);
		    },
		    skipNulls: false,
		    strictNullHandling: false
		};

		var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
		    return typeof v === 'string'
		        || typeof v === 'number'
		        || typeof v === 'boolean'
		        || typeof v === 'symbol'
		        || typeof v === 'bigint';
		};

		var sentinel = {};

		var stringify = function stringify(
		    object,
		    prefix,
		    generateArrayPrefix,
		    commaRoundTrip,
		    strictNullHandling,
		    skipNulls,
		    encoder,
		    filter,
		    sort,
		    allowDots,
		    serializeDate,
		    format,
		    formatter,
		    encodeValuesOnly,
		    charset,
		    sideChannel
		) {
		    var obj = object;

		    var tmpSc = sideChannel;
		    var step = 0;
		    var findFlag = false;
		    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
		        // Where object last appeared in the ref tree
		        var pos = tmpSc.get(object);
		        step += 1;
		        if (typeof pos !== 'undefined') {
		            if (pos === step) {
		                throw new RangeError('Cyclic object value');
		            } else {
		                findFlag = true; // Break while
		            }
		        }
		        if (typeof tmpSc.get(sentinel) === 'undefined') {
		            step = 0;
		        }
		    }

		    if (typeof filter === 'function') {
		        obj = filter(prefix, obj);
		    } else if (obj instanceof Date) {
		        obj = serializeDate(obj);
		    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
		        obj = utils.maybeMap(obj, function (value) {
		            if (value instanceof Date) {
		                return serializeDate(value);
		            }
		            return value;
		        });
		    }

		    if (obj === null) {
		        if (strictNullHandling) {
		            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
		        }

		        obj = '';
		    }

		    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
		        if (encoder) {
		            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
		            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
		        }
		        return [formatter(prefix) + '=' + formatter(String(obj))];
		    }

		    var values = [];

		    if (typeof obj === 'undefined') {
		        return values;
		    }

		    var objKeys;
		    if (generateArrayPrefix === 'comma' && isArray(obj)) {
		        // we need to join elements in
		        if (encodeValuesOnly && encoder) {
		            obj = utils.maybeMap(obj, encoder);
		        }
		        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void 0 }];
		    } else if (isArray(filter)) {
		        objKeys = filter;
		    } else {
		        var keys = Object.keys(obj);
		        objKeys = sort ? keys.sort(sort) : keys;
		    }

		    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;

		    for (var j = 0; j < objKeys.length; ++j) {
		        var key = objKeys[j];
		        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

		        if (skipNulls && value === null) {
		            continue;
		        }

		        var keyPrefix = isArray(obj)
		            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix
		            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');

		        sideChannel.set(object, step);
		        var valueSideChannel = getSideChannel();
		        valueSideChannel.set(sentinel, sideChannel);
		        pushToArray(values, stringify(
		            value,
		            keyPrefix,
		            generateArrayPrefix,
		            commaRoundTrip,
		            strictNullHandling,
		            skipNulls,
		            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
		            filter,
		            sort,
		            allowDots,
		            serializeDate,
		            format,
		            formatter,
		            encodeValuesOnly,
		            charset,
		            valueSideChannel
		        ));
		    }

		    return values;
		};

		var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
		    if (!opts) {
		        return defaults;
		    }

		    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
		        throw new TypeError('Encoder has to be a function.');
		    }

		    var charset = opts.charset || defaults.charset;
		    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
		        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
		    }

		    var format = formats['default'];
		    if (typeof opts.format !== 'undefined') {
		        if (!has.call(formats.formatters, opts.format)) {
		            throw new TypeError('Unknown format option provided.');
		        }
		        format = opts.format;
		    }
		    var formatter = formats.formatters[format];

		    var filter = defaults.filter;
		    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
		        filter = opts.filter;
		    }

		    return {
		        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
		        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
		        charset: charset,
		        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
		        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
		        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
		        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
		        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
		        filter: filter,
		        format: format,
		        formatter: formatter,
		        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
		        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
		        sort: typeof opts.sort === 'function' ? opts.sort : null,
		        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
		    };
		};

		module.exports = function (object, opts) {
		    var obj = object;
		    var options = normalizeStringifyOptions(opts);

		    var objKeys;
		    var filter;

		    if (typeof options.filter === 'function') {
		        filter = options.filter;
		        obj = filter('', obj);
		    } else if (isArray(options.filter)) {
		        filter = options.filter;
		        objKeys = filter;
		    }

		    var keys = [];

		    if (typeof obj !== 'object' || obj === null) {
		        return '';
		    }

		    var arrayFormat;
		    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
		        arrayFormat = opts.arrayFormat;
		    } else if (opts && 'indices' in opts) {
		        arrayFormat = opts.indices ? 'indices' : 'repeat';
		    } else {
		        arrayFormat = 'indices';
		    }

		    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
		    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
		        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
		    }
		    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;

		    if (!objKeys) {
		        objKeys = Object.keys(obj);
		    }

		    if (options.sort) {
		        objKeys.sort(options.sort);
		    }

		    var sideChannel = getSideChannel();
		    for (var i = 0; i < objKeys.length; ++i) {
		        var key = objKeys[i];

		        if (options.skipNulls && obj[key] === null) {
		            continue;
		        }
		        pushToArray(keys, stringify(
		            obj[key],
		            key,
		            generateArrayPrefix,
		            commaRoundTrip,
		            options.strictNullHandling,
		            options.skipNulls,
		            options.encode ? options.encoder : null,
		            options.filter,
		            options.sort,
		            options.allowDots,
		            options.serializeDate,
		            options.format,
		            options.formatter,
		            options.encodeValuesOnly,
		            options.charset,
		            sideChannel
		        ));
		    }

		    var joined = keys.join(options.delimiter);
		    var prefix = options.addQueryPrefix === true ? '?' : '';

		    if (options.charsetSentinel) {
		        if (options.charset === 'iso-8859-1') {
		            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
		            prefix += 'utf8=%26%2310003%3B&';
		        } else {
		            // encodeURIComponent('✓')
		            prefix += 'utf8=%E2%9C%93&';
		        }
		    }

		    return joined.length > 0 ? prefix + joined : '';
		};

		},{"./formats":444,"./utils":448,"side-channel":467}],448:[function(require,module,exports){

		var formats = require('./formats');

		var has = Object.prototype.hasOwnProperty;
		var isArray = Array.isArray;

		var hexTable = (function () {
		    var array = [];
		    for (var i = 0; i < 256; ++i) {
		        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
		    }

		    return array;
		}());

		var compactQueue = function compactQueue(queue) {
		    while (queue.length > 1) {
		        var item = queue.pop();
		        var obj = item.obj[item.prop];

		        if (isArray(obj)) {
		            var compacted = [];

		            for (var j = 0; j < obj.length; ++j) {
		                if (typeof obj[j] !== 'undefined') {
		                    compacted.push(obj[j]);
		                }
		            }

		            item.obj[item.prop] = compacted;
		        }
		    }
		};

		var arrayToObject = function arrayToObject(source, options) {
		    var obj = options && options.plainObjects ? Object.create(null) : {};
		    for (var i = 0; i < source.length; ++i) {
		        if (typeof source[i] !== 'undefined') {
		            obj[i] = source[i];
		        }
		    }

		    return obj;
		};

		var merge = function merge(target, source, options) {
		    /* eslint no-param-reassign: 0 */
		    if (!source) {
		        return target;
		    }

		    if (typeof source !== 'object') {
		        if (isArray(target)) {
		            target.push(source);
		        } else if (target && typeof target === 'object') {
		            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
		                target[source] = true;
		            }
		        } else {
		            return [target, source];
		        }

		        return target;
		    }

		    if (!target || typeof target !== 'object') {
		        return [target].concat(source);
		    }

		    var mergeTarget = target;
		    if (isArray(target) && !isArray(source)) {
		        mergeTarget = arrayToObject(target, options);
		    }

		    if (isArray(target) && isArray(source)) {
		        source.forEach(function (item, i) {
		            if (has.call(target, i)) {
		                var targetItem = target[i];
		                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
		                    target[i] = merge(targetItem, item, options);
		                } else {
		                    target.push(item);
		                }
		            } else {
		                target[i] = item;
		            }
		        });
		        return target;
		    }

		    return Object.keys(source).reduce(function (acc, key) {
		        var value = source[key];

		        if (has.call(acc, key)) {
		            acc[key] = merge(acc[key], value, options);
		        } else {
		            acc[key] = value;
		        }
		        return acc;
		    }, mergeTarget);
		};

		var assign = function assignSingleSource(target, source) {
		    return Object.keys(source).reduce(function (acc, key) {
		        acc[key] = source[key];
		        return acc;
		    }, target);
		};

		var decode = function (str, decoder, charset) {
		    var strWithoutPlus = str.replace(/\+/g, ' ');
		    if (charset === 'iso-8859-1') {
		        // unescape never throws, no try...catch needed:
		        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
		    }
		    // utf-8
		    try {
		        return decodeURIComponent(strWithoutPlus);
		    } catch (e) {
		        return strWithoutPlus;
		    }
		};

		var encode = function encode(str, defaultEncoder, charset, kind, format) {
		    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
		    // It has been adapted here for stricter adherence to RFC 3986
		    if (str.length === 0) {
		        return str;
		    }

		    var string = str;
		    if (typeof str === 'symbol') {
		        string = Symbol.prototype.toString.call(str);
		    } else if (typeof str !== 'string') {
		        string = String(str);
		    }

		    if (charset === 'iso-8859-1') {
		        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
		            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
		        });
		    }

		    var out = '';
		    for (var i = 0; i < string.length; ++i) {
		        var c = string.charCodeAt(i);

		        if (
		            c === 0x2D // -
		            || c === 0x2E // .
		            || c === 0x5F // _
		            || c === 0x7E // ~
		            || (c >= 0x30 && c <= 0x39) // 0-9
		            || (c >= 0x41 && c <= 0x5A) // a-z
		            || (c >= 0x61 && c <= 0x7A) // A-Z
		            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
		        ) {
		            out += string.charAt(i);
		            continue;
		        }

		        if (c < 0x80) {
		            out = out + hexTable[c];
		            continue;
		        }

		        if (c < 0x800) {
		            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
		            continue;
		        }

		        if (c < 0xD800 || c >= 0xE000) {
		            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
		            continue;
		        }

		        i += 1;
		        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
		        /* eslint operator-linebreak: [2, "before"] */
		        out += hexTable[0xF0 | (c >> 18)]
		            + hexTable[0x80 | ((c >> 12) & 0x3F)]
		            + hexTable[0x80 | ((c >> 6) & 0x3F)]
		            + hexTable[0x80 | (c & 0x3F)];
		    }

		    return out;
		};

		var compact = function compact(value) {
		    var queue = [{ obj: { o: value }, prop: 'o' }];
		    var refs = [];

		    for (var i = 0; i < queue.length; ++i) {
		        var item = queue[i];
		        var obj = item.obj[item.prop];

		        var keys = Object.keys(obj);
		        for (var j = 0; j < keys.length; ++j) {
		            var key = keys[j];
		            var val = obj[key];
		            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
		                queue.push({ obj: obj, prop: key });
		                refs.push(val);
		            }
		        }
		    }

		    compactQueue(queue);

		    return value;
		};

		var isRegExp = function isRegExp(obj) {
		    return Object.prototype.toString.call(obj) === '[object RegExp]';
		};

		var isBuffer = function isBuffer(obj) {
		    if (!obj || typeof obj !== 'object') {
		        return false;
		    }

		    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
		};

		var combine = function combine(a, b) {
		    return [].concat(a, b);
		};

		var maybeMap = function maybeMap(val, fn) {
		    if (isArray(val)) {
		        var mapped = [];
		        for (var i = 0; i < val.length; i += 1) {
		            mapped.push(fn(val[i]));
		        }
		        return mapped;
		    }
		    return fn(val);
		};

		module.exports = {
		    arrayToObject: arrayToObject,
		    assign: assign,
		    combine: combine,
		    compact: compact,
		    decode: decode,
		    encode: encode,
		    isBuffer: isBuffer,
		    isRegExp: isRegExp,
		    maybeMap: maybeMap,
		    merge: merge
		};

		},{"./formats":444}],449:[function(require,module,exports){

		// If obj.hasOwnProperty has been overridden, then calling
		// obj.hasOwnProperty(prop) will break.
		// See: https://github.com/joyent/node/issues/1707
		function hasOwnProperty(obj, prop) {
		  return Object.prototype.hasOwnProperty.call(obj, prop);
		}

		module.exports = function(qs, sep, eq, options) {
		  sep = sep || '&';
		  eq = eq || '=';
		  var obj = {};

		  if (typeof qs !== 'string' || qs.length === 0) {
		    return obj;
		  }

		  var regexp = /\+/g;
		  qs = qs.split(sep);

		  var maxKeys = 1000;
		  if (options && typeof options.maxKeys === 'number') {
		    maxKeys = options.maxKeys;
		  }

		  var len = qs.length;
		  // maxKeys <= 0 means that we should not limit keys count
		  if (maxKeys > 0 && len > maxKeys) {
		    len = maxKeys;
		  }

		  for (var i = 0; i < len; ++i) {
		    var x = qs[i].replace(regexp, '%20'),
		        idx = x.indexOf(eq),
		        kstr, vstr, k, v;

		    if (idx >= 0) {
		      kstr = x.substr(0, idx);
		      vstr = x.substr(idx + 1);
		    } else {
		      kstr = x;
		      vstr = '';
		    }

		    k = decodeURIComponent(kstr);
		    v = decodeURIComponent(vstr);

		    if (!hasOwnProperty(obj, k)) {
		      obj[k] = v;
		    } else if (isArray(obj[k])) {
		      obj[k].push(v);
		    } else {
		      obj[k] = [obj[k], v];
		    }
		  }

		  return obj;
		};

		var isArray = Array.isArray || function (xs) {
		  return Object.prototype.toString.call(xs) === '[object Array]';
		};

		},{}],450:[function(require,module,exports){

		var stringifyPrimitive = function(v) {
		  switch (typeof v) {
		    case 'string':
		      return v;

		    case 'boolean':
		      return v ? 'true' : 'false';

		    case 'number':
		      return isFinite(v) ? v : '';

		    default:
		      return '';
		  }
		};

		module.exports = function(obj, sep, eq, name) {
		  sep = sep || '&';
		  eq = eq || '=';
		  if (obj === null) {
		    obj = undefined;
		  }

		  if (typeof obj === 'object') {
		    return map(objectKeys(obj), function(k) {
		      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
		      if (isArray(obj[k])) {
		        return map(obj[k], function(v) {
		          return ks + encodeURIComponent(stringifyPrimitive(v));
		        }).join(sep);
		      } else {
		        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
		      }
		    }).join(sep);

		  }

		  if (!name) return '';
		  return encodeURIComponent(stringifyPrimitive(name)) + eq +
		         encodeURIComponent(stringifyPrimitive(obj));
		};

		var isArray = Array.isArray || function (xs) {
		  return Object.prototype.toString.call(xs) === '[object Array]';
		};

		function map (xs, f) {
		  if (xs.map) return xs.map(f);
		  var res = [];
		  for (var i = 0; i < xs.length; i++) {
		    res.push(f(xs[i], i));
		  }
		  return res;
		}

		var objectKeys = Object.keys || function (obj) {
		  var res = [];
		  for (var key in obj) {
		    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
		  }
		  return res;
		};

		},{}],451:[function(require,module,exports){

		exports.decode = exports.parse = require('./decode');
		exports.encode = exports.stringify = require('./encode');

		},{"./decode":449,"./encode":450}],452:[function(require,module,exports){

		/*<replacement>*/

		var pna = require('process-nextick-args');
		/*</replacement>*/

		/*<replacement>*/
		var objectKeys = Object.keys || function (obj) {
		  var keys = [];
		  for (var key in obj) {
		    keys.push(key);
		  }return keys;
		};
		/*</replacement>*/

		module.exports = Duplex;

		/*<replacement>*/
		var util = Object.create(require('core-util-is'));
		util.inherits = require('inherits');
		/*</replacement>*/

		var Readable = require('./_stream_readable');
		var Writable = require('./_stream_writable');

		util.inherits(Duplex, Readable);

		{
		  // avoid scope creep, the keys array can then be collected
		  var keys = objectKeys(Writable.prototype);
		  for (var v = 0; v < keys.length; v++) {
		    var method = keys[v];
		    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
		  }
		}

		function Duplex(options) {
		  if (!(this instanceof Duplex)) return new Duplex(options);

		  Readable.call(this, options);
		  Writable.call(this, options);

		  if (options && options.readable === false) this.readable = false;

		  if (options && options.writable === false) this.writable = false;

		  this.allowHalfOpen = true;
		  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

		  this.once('end', onend);
		}

		Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function () {
		    return this._writableState.highWaterMark;
		  }
		});

		// the no-half-open enforcer
		function onend() {
		  // if we allow half-open state, or if the writable side ended,
		  // then we're ok.
		  if (this.allowHalfOpen || this._writableState.ended) return;

		  // no more data can be written.
		  // But allow more writes to happen in this tick.
		  pna.nextTick(onEndNT, this);
		}

		function onEndNT(self) {
		  self.end();
		}

		Object.defineProperty(Duplex.prototype, 'destroyed', {
		  get: function () {
		    if (this._readableState === undefined || this._writableState === undefined) {
		      return false;
		    }
		    return this._readableState.destroyed && this._writableState.destroyed;
		  },
		  set: function (value) {
		    // we ignore the value if the stream
		    // has not been initialized yet
		    if (this._readableState === undefined || this._writableState === undefined) {
		      return;
		    }

		    // backward compatibility, the user is explicitly
		    // managing destroyed
		    this._readableState.destroyed = value;
		    this._writableState.destroyed = value;
		  }
		});

		Duplex.prototype._destroy = function (err, cb) {
		  this.push(null);
		  this.end();

		  pna.nextTick(cb, err);
		};
		},{"./_stream_readable":454,"./_stream_writable":456,"core-util-is":382,"inherits":407,"process-nextick-args":441}],453:[function(require,module,exports){

		module.exports = PassThrough;

		var Transform = require('./_stream_transform');

		/*<replacement>*/
		var util = Object.create(require('core-util-is'));
		util.inherits = require('inherits');
		/*</replacement>*/

		util.inherits(PassThrough, Transform);

		function PassThrough(options) {
		  if (!(this instanceof PassThrough)) return new PassThrough(options);

		  Transform.call(this, options);
		}

		PassThrough.prototype._transform = function (chunk, encoding, cb) {
		  cb(null, chunk);
		};
		},{"./_stream_transform":455,"core-util-is":382,"inherits":407}],454:[function(require,module,exports){
		(function (process,global){(function (){

		/*<replacement>*/

		var pna = require('process-nextick-args');
		/*</replacement>*/

		module.exports = Readable;

		/*<replacement>*/
		var isArray = require('isarray');
		/*</replacement>*/

		/*<replacement>*/
		var Duplex;
		/*</replacement>*/

		Readable.ReadableState = ReadableState;

		/*<replacement>*/
		require('events').EventEmitter;

		var EElistenerCount = function (emitter, type) {
		  return emitter.listeners(type).length;
		};
		/*</replacement>*/

		/*<replacement>*/
		var Stream = require('./internal/streams/stream');
		/*</replacement>*/

		/*<replacement>*/

		var Buffer = require('safe-buffer').Buffer;
		var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
		function _uint8ArrayToBuffer(chunk) {
		  return Buffer.from(chunk);
		}
		function _isUint8Array(obj) {
		  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
		}

		/*</replacement>*/

		/*<replacement>*/
		var util = Object.create(require('core-util-is'));
		util.inherits = require('inherits');
		/*</replacement>*/

		/*<replacement>*/
		var debugUtil = require('util');
		var debug = void 0;
		if (debugUtil && debugUtil.debuglog) {
		  debug = debugUtil.debuglog('stream');
		} else {
		  debug = function () {};
		}
		/*</replacement>*/

		var BufferList = require('./internal/streams/BufferList');
		var destroyImpl = require('./internal/streams/destroy');
		var StringDecoder;

		util.inherits(Readable, Stream);

		var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

		function prependListener(emitter, event, fn) {
		  // Sadly this is not cacheable as some libraries bundle their own
		  // event emitter implementation with them.
		  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

		  // This is a hack to make sure that our error handler is attached before any
		  // userland ones.  NEVER DO THIS. This is here only because this code needs
		  // to continue to work with older versions of Node.js that do not include
		  // the prependListener() method. The goal is to eventually remove this hack.
		  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
		}

		function ReadableState(options, stream) {
		  Duplex = Duplex || require('./_stream_duplex');

		  options = options || {};

		  // Duplex streams are both readable and writable, but share
		  // the same options object.
		  // However, some cases require setting options to different
		  // values for the readable and the writable sides of the duplex stream.
		  // These options can be provided separately as readableXXX and writableXXX.
		  var isDuplex = stream instanceof Duplex;

		  // object stream flag. Used to make read(n) ignore n and to
		  // make all the buffer merging and length checks go away
		  this.objectMode = !!options.objectMode;

		  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

		  // the point at which it stops calling _read() to fill the buffer
		  // Note: 0 is a valid value, means "don't call _read preemptively ever"
		  var hwm = options.highWaterMark;
		  var readableHwm = options.readableHighWaterMark;
		  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

		  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

		  // cast to ints.
		  this.highWaterMark = Math.floor(this.highWaterMark);

		  // A linked list is used to store data chunks instead of an array because the
		  // linked list can remove elements from the beginning faster than
		  // array.shift()
		  this.buffer = new BufferList();
		  this.length = 0;
		  this.pipes = null;
		  this.pipesCount = 0;
		  this.flowing = null;
		  this.ended = false;
		  this.endEmitted = false;
		  this.reading = false;

		  // a flag to be able to tell if the event 'readable'/'data' is emitted
		  // immediately, or on a later tick.  We set this to true at first, because
		  // any actions that shouldn't happen until "later" should generally also
		  // not happen before the first read call.
		  this.sync = true;

		  // whenever we return null, then we set a flag to say
		  // that we're awaiting a 'readable' event emission.
		  this.needReadable = false;
		  this.emittedReadable = false;
		  this.readableListening = false;
		  this.resumeScheduled = false;

		  // has it been destroyed
		  this.destroyed = false;

		  // Crypto is kind of old and crusty.  Historically, its default string
		  // encoding is 'binary' so we have to make this configurable.
		  // Everything else in the universe uses 'utf8', though.
		  this.defaultEncoding = options.defaultEncoding || 'utf8';

		  // the number of writers that are awaiting a drain event in .pipe()s
		  this.awaitDrain = 0;

		  // if true, a maybeReadMore has been scheduled
		  this.readingMore = false;

		  this.decoder = null;
		  this.encoding = null;
		  if (options.encoding) {
		    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
		    this.decoder = new StringDecoder(options.encoding);
		    this.encoding = options.encoding;
		  }
		}

		function Readable(options) {
		  Duplex = Duplex || require('./_stream_duplex');

		  if (!(this instanceof Readable)) return new Readable(options);

		  this._readableState = new ReadableState(options, this);

		  // legacy
		  this.readable = true;

		  if (options) {
		    if (typeof options.read === 'function') this._read = options.read;

		    if (typeof options.destroy === 'function') this._destroy = options.destroy;
		  }

		  Stream.call(this);
		}

		Object.defineProperty(Readable.prototype, 'destroyed', {
		  get: function () {
		    if (this._readableState === undefined) {
		      return false;
		    }
		    return this._readableState.destroyed;
		  },
		  set: function (value) {
		    // we ignore the value if the stream
		    // has not been initialized yet
		    if (!this._readableState) {
		      return;
		    }

		    // backward compatibility, the user is explicitly
		    // managing destroyed
		    this._readableState.destroyed = value;
		  }
		});

		Readable.prototype.destroy = destroyImpl.destroy;
		Readable.prototype._undestroy = destroyImpl.undestroy;
		Readable.prototype._destroy = function (err, cb) {
		  this.push(null);
		  cb(err);
		};

		// Manually shove something into the read() buffer.
		// This returns true if the highWaterMark has not been hit yet,
		// similar to how Writable.write() returns true if you should
		// write() some more.
		Readable.prototype.push = function (chunk, encoding) {
		  var state = this._readableState;
		  var skipChunkCheck;

		  if (!state.objectMode) {
		    if (typeof chunk === 'string') {
		      encoding = encoding || state.defaultEncoding;
		      if (encoding !== state.encoding) {
		        chunk = Buffer.from(chunk, encoding);
		        encoding = '';
		      }
		      skipChunkCheck = true;
		    }
		  } else {
		    skipChunkCheck = true;
		  }

		  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
		};

		// Unshift should *always* be something directly out of read()
		Readable.prototype.unshift = function (chunk) {
		  return readableAddChunk(this, chunk, null, true, false);
		};

		function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
		  var state = stream._readableState;
		  if (chunk === null) {
		    state.reading = false;
		    onEofChunk(stream, state);
		  } else {
		    var er;
		    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
		    if (er) {
		      stream.emit('error', er);
		    } else if (state.objectMode || chunk && chunk.length > 0) {
		      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
		        chunk = _uint8ArrayToBuffer(chunk);
		      }

		      if (addToFront) {
		        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
		      } else if (state.ended) {
		        stream.emit('error', new Error('stream.push() after EOF'));
		      } else {
		        state.reading = false;
		        if (state.decoder && !encoding) {
		          chunk = state.decoder.write(chunk);
		          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
		        } else {
		          addChunk(stream, state, chunk, false);
		        }
		      }
		    } else if (!addToFront) {
		      state.reading = false;
		    }
		  }

		  return needMoreData(state);
		}

		function addChunk(stream, state, chunk, addToFront) {
		  if (state.flowing && state.length === 0 && !state.sync) {
		    stream.emit('data', chunk);
		    stream.read(0);
		  } else {
		    // update the buffer info.
		    state.length += state.objectMode ? 1 : chunk.length;
		    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

		    if (state.needReadable) emitReadable(stream);
		  }
		  maybeReadMore(stream, state);
		}

		function chunkInvalid(state, chunk) {
		  var er;
		  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
		    er = new TypeError('Invalid non-string/buffer chunk');
		  }
		  return er;
		}

		// if it's past the high water mark, we can push in some more.
		// Also, if we have no data yet, we can stand some
		// more bytes.  This is to work around cases where hwm=0,
		// such as the repl.  Also, if the push() triggered a
		// readable event, and the user called read(largeNumber) such that
		// needReadable was set, then we ought to push more, so that another
		// 'readable' event will be triggered.
		function needMoreData(state) {
		  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
		}

		Readable.prototype.isPaused = function () {
		  return this._readableState.flowing === false;
		};

		// backwards compatibility.
		Readable.prototype.setEncoding = function (enc) {
		  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
		  this._readableState.decoder = new StringDecoder(enc);
		  this._readableState.encoding = enc;
		  return this;
		};

		// Don't raise the hwm > 8MB
		var MAX_HWM = 0x800000;
		function computeNewHighWaterMark(n) {
		  if (n >= MAX_HWM) {
		    n = MAX_HWM;
		  } else {
		    // Get the next highest power of 2 to prevent increasing hwm excessively in
		    // tiny amounts
		    n--;
		    n |= n >>> 1;
		    n |= n >>> 2;
		    n |= n >>> 4;
		    n |= n >>> 8;
		    n |= n >>> 16;
		    n++;
		  }
		  return n;
		}

		// This function is designed to be inlinable, so please take care when making
		// changes to the function body.
		function howMuchToRead(n, state) {
		  if (n <= 0 || state.length === 0 && state.ended) return 0;
		  if (state.objectMode) return 1;
		  if (n !== n) {
		    // Only flow one buffer at a time
		    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
		  }
		  // If we're asking for more than the current hwm, then raise the hwm.
		  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
		  if (n <= state.length) return n;
		  // Don't have enough
		  if (!state.ended) {
		    state.needReadable = true;
		    return 0;
		  }
		  return state.length;
		}

		// you can override either this method, or the async _read(n) below.
		Readable.prototype.read = function (n) {
		  debug('read', n);
		  n = parseInt(n, 10);
		  var state = this._readableState;
		  var nOrig = n;

		  if (n !== 0) state.emittedReadable = false;

		  // if we're doing read(0) to trigger a readable event, but we
		  // already have a bunch of data in the buffer, then just trigger
		  // the 'readable' event and move on.
		  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
		    debug('read: emitReadable', state.length, state.ended);
		    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
		    return null;
		  }

		  n = howMuchToRead(n, state);

		  // if we've ended, and we're now clear, then finish it up.
		  if (n === 0 && state.ended) {
		    if (state.length === 0) endReadable(this);
		    return null;
		  }

		  // All the actual chunk generation logic needs to be
		  // *below* the call to _read.  The reason is that in certain
		  // synthetic stream cases, such as passthrough streams, _read
		  // may be a completely synchronous operation which may change
		  // the state of the read buffer, providing enough data when
		  // before there was *not* enough.
		  //
		  // So, the steps are:
		  // 1. Figure out what the state of things will be after we do
		  // a read from the buffer.
		  //
		  // 2. If that resulting state will trigger a _read, then call _read.
		  // Note that this may be asynchronous, or synchronous.  Yes, it is
		  // deeply ugly to write APIs this way, but that still doesn't mean
		  // that the Readable class should behave improperly, as streams are
		  // designed to be sync/async agnostic.
		  // Take note if the _read call is sync or async (ie, if the read call
		  // has returned yet), so that we know whether or not it's safe to emit
		  // 'readable' etc.
		  //
		  // 3. Actually pull the requested chunks out of the buffer and return.

		  // if we need a readable event, then we need to do some reading.
		  var doRead = state.needReadable;
		  debug('need readable', doRead);

		  // if we currently have less than the highWaterMark, then also read some
		  if (state.length === 0 || state.length - n < state.highWaterMark) {
		    doRead = true;
		    debug('length less than watermark', doRead);
		  }

		  // however, if we've ended, then there's no point, and if we're already
		  // reading, then it's unnecessary.
		  if (state.ended || state.reading) {
		    doRead = false;
		    debug('reading or ended', doRead);
		  } else if (doRead) {
		    debug('do read');
		    state.reading = true;
		    state.sync = true;
		    // if the length is currently zero, then we *need* a readable event.
		    if (state.length === 0) state.needReadable = true;
		    // call internal read method
		    this._read(state.highWaterMark);
		    state.sync = false;
		    // If _read pushed data synchronously, then `reading` will be false,
		    // and we need to re-evaluate how much data we can return to the user.
		    if (!state.reading) n = howMuchToRead(nOrig, state);
		  }

		  var ret;
		  if (n > 0) ret = fromList(n, state);else ret = null;

		  if (ret === null) {
		    state.needReadable = true;
		    n = 0;
		  } else {
		    state.length -= n;
		  }

		  if (state.length === 0) {
		    // If we have nothing in the buffer, then we want to know
		    // as soon as we *do* get something into the buffer.
		    if (!state.ended) state.needReadable = true;

		    // If we tried to read() past the EOF, then emit end on the next tick.
		    if (nOrig !== n && state.ended) endReadable(this);
		  }

		  if (ret !== null) this.emit('data', ret);

		  return ret;
		};

		function onEofChunk(stream, state) {
		  if (state.ended) return;
		  if (state.decoder) {
		    var chunk = state.decoder.end();
		    if (chunk && chunk.length) {
		      state.buffer.push(chunk);
		      state.length += state.objectMode ? 1 : chunk.length;
		    }
		  }
		  state.ended = true;

		  // emit 'readable' now to make sure it gets picked up.
		  emitReadable(stream);
		}

		// Don't emit readable right away in sync mode, because this can trigger
		// another read() call => stack overflow.  This way, it might trigger
		// a nextTick recursion warning, but that's not so bad.
		function emitReadable(stream) {
		  var state = stream._readableState;
		  state.needReadable = false;
		  if (!state.emittedReadable) {
		    debug('emitReadable', state.flowing);
		    state.emittedReadable = true;
		    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
		  }
		}

		function emitReadable_(stream) {
		  debug('emit readable');
		  stream.emit('readable');
		  flow(stream);
		}

		// at this point, the user has presumably seen the 'readable' event,
		// and called read() to consume some data.  that may have triggered
		// in turn another _read(n) call, in which case reading = true if
		// it's in progress.
		// However, if we're not ended, or reading, and the length < hwm,
		// then go ahead and try to read some more preemptively.
		function maybeReadMore(stream, state) {
		  if (!state.readingMore) {
		    state.readingMore = true;
		    pna.nextTick(maybeReadMore_, stream, state);
		  }
		}

		function maybeReadMore_(stream, state) {
		  var len = state.length;
		  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
		    debug('maybeReadMore read 0');
		    stream.read(0);
		    if (len === state.length)
		      // didn't get any data, stop spinning.
		      break;else len = state.length;
		  }
		  state.readingMore = false;
		}

		// abstract method.  to be overridden in specific implementation classes.
		// call cb(er, data) where data is <= n in length.
		// for virtual (non-string, non-buffer) streams, "length" is somewhat
		// arbitrary, and perhaps not very meaningful.
		Readable.prototype._read = function (n) {
		  this.emit('error', new Error('_read() is not implemented'));
		};

		Readable.prototype.pipe = function (dest, pipeOpts) {
		  var src = this;
		  var state = this._readableState;

		  switch (state.pipesCount) {
		    case 0:
		      state.pipes = dest;
		      break;
		    case 1:
		      state.pipes = [state.pipes, dest];
		      break;
		    default:
		      state.pipes.push(dest);
		      break;
		  }
		  state.pipesCount += 1;
		  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

		  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

		  var endFn = doEnd ? onend : unpipe;
		  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

		  dest.on('unpipe', onunpipe);
		  function onunpipe(readable, unpipeInfo) {
		    debug('onunpipe');
		    if (readable === src) {
		      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
		        unpipeInfo.hasUnpiped = true;
		        cleanup();
		      }
		    }
		  }

		  function onend() {
		    debug('onend');
		    dest.end();
		  }

		  // when the dest drains, it reduces the awaitDrain counter
		  // on the source.  This would be more elegant with a .once()
		  // handler in flow(), but adding and removing repeatedly is
		  // too slow.
		  var ondrain = pipeOnDrain(src);
		  dest.on('drain', ondrain);

		  var cleanedUp = false;
		  function cleanup() {
		    debug('cleanup');
		    // cleanup event handlers once the pipe is broken
		    dest.removeListener('close', onclose);
		    dest.removeListener('finish', onfinish);
		    dest.removeListener('drain', ondrain);
		    dest.removeListener('error', onerror);
		    dest.removeListener('unpipe', onunpipe);
		    src.removeListener('end', onend);
		    src.removeListener('end', unpipe);
		    src.removeListener('data', ondata);

		    cleanedUp = true;

		    // if the reader is waiting for a drain event from this
		    // specific writer, then it would cause it to never start
		    // flowing again.
		    // So, if this is awaiting a drain, then we just call it now.
		    // If we don't know, then assume that we are waiting for one.
		    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
		  }

		  // If the user pushes more data while we're writing to dest then we'll end up
		  // in ondata again. However, we only want to increase awaitDrain once because
		  // dest will only emit one 'drain' event for the multiple writes.
		  // => Introduce a guard on increasing awaitDrain.
		  var increasedAwaitDrain = false;
		  src.on('data', ondata);
		  function ondata(chunk) {
		    debug('ondata');
		    increasedAwaitDrain = false;
		    var ret = dest.write(chunk);
		    if (false === ret && !increasedAwaitDrain) {
		      // If the user unpiped during `dest.write()`, it is possible
		      // to get stuck in a permanently paused state if that write
		      // also returned false.
		      // => Check whether `dest` is still a piping destination.
		      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
		        debug('false write response, pause', state.awaitDrain);
		        state.awaitDrain++;
		        increasedAwaitDrain = true;
		      }
		      src.pause();
		    }
		  }

		  // if the dest has an error, then stop piping into it.
		  // however, don't suppress the throwing behavior for this.
		  function onerror(er) {
		    debug('onerror', er);
		    unpipe();
		    dest.removeListener('error', onerror);
		    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
		  }

		  // Make sure our error handler is attached before userland ones.
		  prependListener(dest, 'error', onerror);

		  // Both close and finish should trigger unpipe, but only once.
		  function onclose() {
		    dest.removeListener('finish', onfinish);
		    unpipe();
		  }
		  dest.once('close', onclose);
		  function onfinish() {
		    debug('onfinish');
		    dest.removeListener('close', onclose);
		    unpipe();
		  }
		  dest.once('finish', onfinish);

		  function unpipe() {
		    debug('unpipe');
		    src.unpipe(dest);
		  }

		  // tell the dest that it's being piped to
		  dest.emit('pipe', src);

		  // start the flow if it hasn't been started already.
		  if (!state.flowing) {
		    debug('pipe resume');
		    src.resume();
		  }

		  return dest;
		};

		function pipeOnDrain(src) {
		  return function () {
		    var state = src._readableState;
		    debug('pipeOnDrain', state.awaitDrain);
		    if (state.awaitDrain) state.awaitDrain--;
		    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
		      state.flowing = true;
		      flow(src);
		    }
		  };
		}

		Readable.prototype.unpipe = function (dest) {
		  var state = this._readableState;
		  var unpipeInfo = { hasUnpiped: false };

		  // if we're not piping anywhere, then do nothing.
		  if (state.pipesCount === 0) return this;

		  // just one destination.  most common case.
		  if (state.pipesCount === 1) {
		    // passed in one, but it's not the right one.
		    if (dest && dest !== state.pipes) return this;

		    if (!dest) dest = state.pipes;

		    // got a match.
		    state.pipes = null;
		    state.pipesCount = 0;
		    state.flowing = false;
		    if (dest) dest.emit('unpipe', this, unpipeInfo);
		    return this;
		  }

		  // slow case. multiple pipe destinations.

		  if (!dest) {
		    // remove all.
		    var dests = state.pipes;
		    var len = state.pipesCount;
		    state.pipes = null;
		    state.pipesCount = 0;
		    state.flowing = false;

		    for (var i = 0; i < len; i++) {
		      dests[i].emit('unpipe', this, { hasUnpiped: false });
		    }return this;
		  }

		  // try to find the right one.
		  var index = indexOf(state.pipes, dest);
		  if (index === -1) return this;

		  state.pipes.splice(index, 1);
		  state.pipesCount -= 1;
		  if (state.pipesCount === 1) state.pipes = state.pipes[0];

		  dest.emit('unpipe', this, unpipeInfo);

		  return this;
		};

		// set up data events if they are asked for
		// Ensure readable listeners eventually get something
		Readable.prototype.on = function (ev, fn) {
		  var res = Stream.prototype.on.call(this, ev, fn);

		  if (ev === 'data') {
		    // Start flowing on next tick if stream isn't explicitly paused
		    if (this._readableState.flowing !== false) this.resume();
		  } else if (ev === 'readable') {
		    var state = this._readableState;
		    if (!state.endEmitted && !state.readableListening) {
		      state.readableListening = state.needReadable = true;
		      state.emittedReadable = false;
		      if (!state.reading) {
		        pna.nextTick(nReadingNextTick, this);
		      } else if (state.length) {
		        emitReadable(this);
		      }
		    }
		  }

		  return res;
		};
		Readable.prototype.addListener = Readable.prototype.on;

		function nReadingNextTick(self) {
		  debug('readable nexttick read 0');
		  self.read(0);
		}

		// pause() and resume() are remnants of the legacy readable stream API
		// If the user uses them, then switch into old mode.
		Readable.prototype.resume = function () {
		  var state = this._readableState;
		  if (!state.flowing) {
		    debug('resume');
		    state.flowing = true;
		    resume(this, state);
		  }
		  return this;
		};

		function resume(stream, state) {
		  if (!state.resumeScheduled) {
		    state.resumeScheduled = true;
		    pna.nextTick(resume_, stream, state);
		  }
		}

		function resume_(stream, state) {
		  if (!state.reading) {
		    debug('resume read 0');
		    stream.read(0);
		  }

		  state.resumeScheduled = false;
		  state.awaitDrain = 0;
		  stream.emit('resume');
		  flow(stream);
		  if (state.flowing && !state.reading) stream.read(0);
		}

		Readable.prototype.pause = function () {
		  debug('call pause flowing=%j', this._readableState.flowing);
		  if (false !== this._readableState.flowing) {
		    debug('pause');
		    this._readableState.flowing = false;
		    this.emit('pause');
		  }
		  return this;
		};

		function flow(stream) {
		  var state = stream._readableState;
		  debug('flow', state.flowing);
		  while (state.flowing && stream.read() !== null) {}
		}

		// wrap an old-style stream as the async data source.
		// This is *not* part of the readable stream interface.
		// It is an ugly unfortunate mess of history.
		Readable.prototype.wrap = function (stream) {
		  var _this = this;

		  var state = this._readableState;
		  var paused = false;

		  stream.on('end', function () {
		    debug('wrapped end');
		    if (state.decoder && !state.ended) {
		      var chunk = state.decoder.end();
		      if (chunk && chunk.length) _this.push(chunk);
		    }

		    _this.push(null);
		  });

		  stream.on('data', function (chunk) {
		    debug('wrapped data');
		    if (state.decoder) chunk = state.decoder.write(chunk);

		    // don't skip over falsy values in objectMode
		    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

		    var ret = _this.push(chunk);
		    if (!ret) {
		      paused = true;
		      stream.pause();
		    }
		  });

		  // proxy all the other methods.
		  // important when wrapping filters and duplexes.
		  for (var i in stream) {
		    if (this[i] === undefined && typeof stream[i] === 'function') {
		      this[i] = function (method) {
		        return function () {
		          return stream[method].apply(stream, arguments);
		        };
		      }(i);
		    }
		  }

		  // proxy certain important events.
		  for (var n = 0; n < kProxyEvents.length; n++) {
		    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
		  }

		  // when we try to consume some more bytes, simply unpause the
		  // underlying stream.
		  this._read = function (n) {
		    debug('wrapped _read', n);
		    if (paused) {
		      paused = false;
		      stream.resume();
		    }
		  };

		  return this;
		};

		Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function () {
		    return this._readableState.highWaterMark;
		  }
		});

		// exposed for testing purposes only.
		Readable._fromList = fromList;

		// Pluck off n bytes from an array of buffers.
		// Length is the combined lengths of all the buffers in the list.
		// This function is designed to be inlinable, so please take care when making
		// changes to the function body.
		function fromList(n, state) {
		  // nothing buffered
		  if (state.length === 0) return null;

		  var ret;
		  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
		    // read it all, truncate the list
		    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
		    state.buffer.clear();
		  } else {
		    // read part of list
		    ret = fromListPartial(n, state.buffer, state.decoder);
		  }

		  return ret;
		}

		// Extracts only enough buffered data to satisfy the amount requested.
		// This function is designed to be inlinable, so please take care when making
		// changes to the function body.
		function fromListPartial(n, list, hasStrings) {
		  var ret;
		  if (n < list.head.data.length) {
		    // slice is the same for buffers and strings
		    ret = list.head.data.slice(0, n);
		    list.head.data = list.head.data.slice(n);
		  } else if (n === list.head.data.length) {
		    // first chunk is a perfect match
		    ret = list.shift();
		  } else {
		    // result spans more than one buffer
		    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
		  }
		  return ret;
		}

		// Copies a specified amount of characters from the list of buffered data
		// chunks.
		// This function is designed to be inlinable, so please take care when making
		// changes to the function body.
		function copyFromBufferString(n, list) {
		  var p = list.head;
		  var c = 1;
		  var ret = p.data;
		  n -= ret.length;
		  while (p = p.next) {
		    var str = p.data;
		    var nb = n > str.length ? str.length : n;
		    if (nb === str.length) ret += str;else ret += str.slice(0, n);
		    n -= nb;
		    if (n === 0) {
		      if (nb === str.length) {
		        ++c;
		        if (p.next) list.head = p.next;else list.head = list.tail = null;
		      } else {
		        list.head = p;
		        p.data = str.slice(nb);
		      }
		      break;
		    }
		    ++c;
		  }
		  list.length -= c;
		  return ret;
		}

		// Copies a specified amount of bytes from the list of buffered data chunks.
		// This function is designed to be inlinable, so please take care when making
		// changes to the function body.
		function copyFromBuffer(n, list) {
		  var ret = Buffer.allocUnsafe(n);
		  var p = list.head;
		  var c = 1;
		  p.data.copy(ret);
		  n -= p.data.length;
		  while (p = p.next) {
		    var buf = p.data;
		    var nb = n > buf.length ? buf.length : n;
		    buf.copy(ret, ret.length - n, 0, nb);
		    n -= nb;
		    if (n === 0) {
		      if (nb === buf.length) {
		        ++c;
		        if (p.next) list.head = p.next;else list.head = list.tail = null;
		      } else {
		        list.head = p;
		        p.data = buf.slice(nb);
		      }
		      break;
		    }
		    ++c;
		  }
		  list.length -= c;
		  return ret;
		}

		function endReadable(stream) {
		  var state = stream._readableState;

		  // If we get here before consuming all the bytes, then that is a
		  // bug in node.  Should never happen.
		  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

		  if (!state.endEmitted) {
		    state.ended = true;
		    pna.nextTick(endReadableNT, state, stream);
		  }
		}

		function endReadableNT(state, stream) {
		  // Check that we didn't get one last unshift.
		  if (!state.endEmitted && state.length === 0) {
		    state.endEmitted = true;
		    stream.readable = false;
		    stream.emit('end');
		  }
		}

		function indexOf(xs, x) {
		  for (var i = 0, l = xs.length; i < l; i++) {
		    if (xs[i] === x) return i;
		  }
		  return -1;
		}
		}).call(this);}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{"./_stream_duplex":452,"./internal/streams/BufferList":457,"./internal/streams/destroy":458,"./internal/streams/stream":459,"_process":538,"core-util-is":382,"events":386,"inherits":407,"isarray":460,"process-nextick-args":441,"safe-buffer":461,"string_decoder/":462,"util":102}],455:[function(require,module,exports){

		module.exports = Transform;

		var Duplex = require('./_stream_duplex');

		/*<replacement>*/
		var util = Object.create(require('core-util-is'));
		util.inherits = require('inherits');
		/*</replacement>*/

		util.inherits(Transform, Duplex);

		function afterTransform(er, data) {
		  var ts = this._transformState;
		  ts.transforming = false;

		  var cb = ts.writecb;

		  if (!cb) {
		    return this.emit('error', new Error('write callback called multiple times'));
		  }

		  ts.writechunk = null;
		  ts.writecb = null;

		  if (data != null) // single equals check for both `null` and `undefined`
		    this.push(data);

		  cb(er);

		  var rs = this._readableState;
		  rs.reading = false;
		  if (rs.needReadable || rs.length < rs.highWaterMark) {
		    this._read(rs.highWaterMark);
		  }
		}

		function Transform(options) {
		  if (!(this instanceof Transform)) return new Transform(options);

		  Duplex.call(this, options);

		  this._transformState = {
		    afterTransform: afterTransform.bind(this),
		    needTransform: false,
		    transforming: false,
		    writecb: null,
		    writechunk: null,
		    writeencoding: null
		  };

		  // start out asking for a readable event once data is transformed.
		  this._readableState.needReadable = true;

		  // we have implemented the _read method, and done the other things
		  // that Readable wants before the first _read call, so unset the
		  // sync guard flag.
		  this._readableState.sync = false;

		  if (options) {
		    if (typeof options.transform === 'function') this._transform = options.transform;

		    if (typeof options.flush === 'function') this._flush = options.flush;
		  }

		  // When the writable side finishes, then flush out anything remaining.
		  this.on('prefinish', prefinish);
		}

		function prefinish() {
		  var _this = this;

		  if (typeof this._flush === 'function') {
		    this._flush(function (er, data) {
		      done(_this, er, data);
		    });
		  } else {
		    done(this, null, null);
		  }
		}

		Transform.prototype.push = function (chunk, encoding) {
		  this._transformState.needTransform = false;
		  return Duplex.prototype.push.call(this, chunk, encoding);
		};

		// This is the part where you do stuff!
		// override this function in implementation classes.
		// 'chunk' is an input chunk.
		//
		// Call `push(newChunk)` to pass along transformed output
		// to the readable side.  You may call 'push' zero or more times.
		//
		// Call `cb(err)` when you are done with this chunk.  If you pass
		// an error, then that'll put the hurt on the whole operation.  If you
		// never call cb(), then you'll never get another chunk.
		Transform.prototype._transform = function (chunk, encoding, cb) {
		  throw new Error('_transform() is not implemented');
		};

		Transform.prototype._write = function (chunk, encoding, cb) {
		  var ts = this._transformState;
		  ts.writecb = cb;
		  ts.writechunk = chunk;
		  ts.writeencoding = encoding;
		  if (!ts.transforming) {
		    var rs = this._readableState;
		    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
		  }
		};

		// Doesn't matter what the args are here.
		// _transform does all the work.
		// That we got here means that the readable side wants more data.
		Transform.prototype._read = function (n) {
		  var ts = this._transformState;

		  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
		    ts.transforming = true;
		    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
		  } else {
		    // mark that we need a transform, so that any data that comes in
		    // will get processed, now that we've asked for it.
		    ts.needTransform = true;
		  }
		};

		Transform.prototype._destroy = function (err, cb) {
		  var _this2 = this;

		  Duplex.prototype._destroy.call(this, err, function (err2) {
		    cb(err2);
		    _this2.emit('close');
		  });
		};

		function done(stream, er, data) {
		  if (er) return stream.emit('error', er);

		  if (data != null) // single equals check for both `null` and `undefined`
		    stream.push(data);

		  // if there's nothing in the write buffer, then that means
		  // that nothing more will ever be provided
		  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

		  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

		  return stream.push(null);
		}
		},{"./_stream_duplex":452,"core-util-is":382,"inherits":407}],456:[function(require,module,exports){
		(function (process,global,setImmediate){(function (){

		/*<replacement>*/

		var pna = require('process-nextick-args');
		/*</replacement>*/

		module.exports = Writable;

		// It seems a linked list but it is not
		// there will be only 2 of these for each stream
		function CorkedRequest(state) {
		  var _this = this;

		  this.next = null;
		  this.entry = null;
		  this.finish = function () {
		    onCorkedFinish(_this, state);
		  };
		}
		/* </replacement> */

		/*<replacement>*/
		var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
		/*</replacement>*/

		/*<replacement>*/
		var Duplex;
		/*</replacement>*/

		Writable.WritableState = WritableState;

		/*<replacement>*/
		var util = Object.create(require('core-util-is'));
		util.inherits = require('inherits');
		/*</replacement>*/

		/*<replacement>*/
		var internalUtil = {
		  deprecate: require('util-deprecate')
		};
		/*</replacement>*/

		/*<replacement>*/
		var Stream = require('./internal/streams/stream');
		/*</replacement>*/

		/*<replacement>*/

		var Buffer = require('safe-buffer').Buffer;
		var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
		function _uint8ArrayToBuffer(chunk) {
		  return Buffer.from(chunk);
		}
		function _isUint8Array(obj) {
		  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
		}

		/*</replacement>*/

		var destroyImpl = require('./internal/streams/destroy');

		util.inherits(Writable, Stream);

		function nop() {}

		function WritableState(options, stream) {
		  Duplex = Duplex || require('./_stream_duplex');

		  options = options || {};

		  // Duplex streams are both readable and writable, but share
		  // the same options object.
		  // However, some cases require setting options to different
		  // values for the readable and the writable sides of the duplex stream.
		  // These options can be provided separately as readableXXX and writableXXX.
		  var isDuplex = stream instanceof Duplex;

		  // object stream flag to indicate whether or not this stream
		  // contains buffers or objects.
		  this.objectMode = !!options.objectMode;

		  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

		  // the point at which write() starts returning false
		  // Note: 0 is a valid value, means that we always return false if
		  // the entire buffer is not flushed immediately on write()
		  var hwm = options.highWaterMark;
		  var writableHwm = options.writableHighWaterMark;
		  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

		  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

		  // cast to ints.
		  this.highWaterMark = Math.floor(this.highWaterMark);

		  // if _final has been called
		  this.finalCalled = false;

		  // drain event flag.
		  this.needDrain = false;
		  // at the start of calling end()
		  this.ending = false;
		  // when end() has been called, and returned
		  this.ended = false;
		  // when 'finish' is emitted
		  this.finished = false;

		  // has it been destroyed
		  this.destroyed = false;

		  // should we decode strings into buffers before passing to _write?
		  // this is here so that some node-core streams can optimize string
		  // handling at a lower level.
		  var noDecode = options.decodeStrings === false;
		  this.decodeStrings = !noDecode;

		  // Crypto is kind of old and crusty.  Historically, its default string
		  // encoding is 'binary' so we have to make this configurable.
		  // Everything else in the universe uses 'utf8', though.
		  this.defaultEncoding = options.defaultEncoding || 'utf8';

		  // not an actual buffer we keep track of, but a measurement
		  // of how much we're waiting to get pushed to some underlying
		  // socket or file.
		  this.length = 0;

		  // a flag to see when we're in the middle of a write.
		  this.writing = false;

		  // when true all writes will be buffered until .uncork() call
		  this.corked = 0;

		  // a flag to be able to tell if the onwrite cb is called immediately,
		  // or on a later tick.  We set this to true at first, because any
		  // actions that shouldn't happen until "later" should generally also
		  // not happen before the first write call.
		  this.sync = true;

		  // a flag to know if we're processing previously buffered items, which
		  // may call the _write() callback in the same tick, so that we don't
		  // end up in an overlapped onwrite situation.
		  this.bufferProcessing = false;

		  // the callback that's passed to _write(chunk,cb)
		  this.onwrite = function (er) {
		    onwrite(stream, er);
		  };

		  // the callback that the user supplies to write(chunk,encoding,cb)
		  this.writecb = null;

		  // the amount that is being written when _write is called.
		  this.writelen = 0;

		  this.bufferedRequest = null;
		  this.lastBufferedRequest = null;

		  // number of pending user-supplied write callbacks
		  // this must be 0 before 'finish' can be emitted
		  this.pendingcb = 0;

		  // emit prefinish if the only thing we're waiting for is _write cbs
		  // This is relevant for synchronous Transform streams
		  this.prefinished = false;

		  // True if the error was already emitted and should not be thrown again
		  this.errorEmitted = false;

		  // count buffered requests
		  this.bufferedRequestCount = 0;

		  // allocate the first CorkedRequest, there is always
		  // one allocated and free to use, and we maintain at most two
		  this.corkedRequestsFree = new CorkedRequest(this);
		}

		WritableState.prototype.getBuffer = function getBuffer() {
		  var current = this.bufferedRequest;
		  var out = [];
		  while (current) {
		    out.push(current);
		    current = current.next;
		  }
		  return out;
		};

		(function () {
		  try {
		    Object.defineProperty(WritableState.prototype, 'buffer', {
		      get: internalUtil.deprecate(function () {
		        return this.getBuffer();
		      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
		    });
		  } catch (_) {}
		})();

		// Test _writableState for inheritance to account for Duplex streams,
		// whose prototype chain only points to Readable.
		var realHasInstance;
		if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
		  realHasInstance = Function.prototype[Symbol.hasInstance];
		  Object.defineProperty(Writable, Symbol.hasInstance, {
		    value: function (object) {
		      if (realHasInstance.call(this, object)) return true;
		      if (this !== Writable) return false;

		      return object && object._writableState instanceof WritableState;
		    }
		  });
		} else {
		  realHasInstance = function (object) {
		    return object instanceof this;
		  };
		}

		function Writable(options) {
		  Duplex = Duplex || require('./_stream_duplex');

		  // Writable ctor is applied to Duplexes, too.
		  // `realHasInstance` is necessary because using plain `instanceof`
		  // would return false, as no `_writableState` property is attached.

		  // Trying to use the custom `instanceof` for Writable here will also break the
		  // Node.js LazyTransform implementation, which has a non-trivial getter for
		  // `_writableState` that would lead to infinite recursion.
		  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
		    return new Writable(options);
		  }

		  this._writableState = new WritableState(options, this);

		  // legacy.
		  this.writable = true;

		  if (options) {
		    if (typeof options.write === 'function') this._write = options.write;

		    if (typeof options.writev === 'function') this._writev = options.writev;

		    if (typeof options.destroy === 'function') this._destroy = options.destroy;

		    if (typeof options.final === 'function') this._final = options.final;
		  }

		  Stream.call(this);
		}

		// Otherwise people can pipe Writable streams, which is just wrong.
		Writable.prototype.pipe = function () {
		  this.emit('error', new Error('Cannot pipe, not readable'));
		};

		function writeAfterEnd(stream, cb) {
		  var er = new Error('write after end');
		  // TODO: defer error events consistently everywhere, not just the cb
		  stream.emit('error', er);
		  pna.nextTick(cb, er);
		}

		// Checks that a user-supplied chunk is valid, especially for the particular
		// mode the stream is in. Currently this means that `null` is never accepted
		// and undefined/non-string values are only allowed in object mode.
		function validChunk(stream, state, chunk, cb) {
		  var valid = true;
		  var er = false;

		  if (chunk === null) {
		    er = new TypeError('May not write null values to stream');
		  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
		    er = new TypeError('Invalid non-string/buffer chunk');
		  }
		  if (er) {
		    stream.emit('error', er);
		    pna.nextTick(cb, er);
		    valid = false;
		  }
		  return valid;
		}

		Writable.prototype.write = function (chunk, encoding, cb) {
		  var state = this._writableState;
		  var ret = false;
		  var isBuf = !state.objectMode && _isUint8Array(chunk);

		  if (isBuf && !Buffer.isBuffer(chunk)) {
		    chunk = _uint8ArrayToBuffer(chunk);
		  }

		  if (typeof encoding === 'function') {
		    cb = encoding;
		    encoding = null;
		  }

		  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

		  if (typeof cb !== 'function') cb = nop;

		  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
		    state.pendingcb++;
		    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
		  }

		  return ret;
		};

		Writable.prototype.cork = function () {
		  var state = this._writableState;

		  state.corked++;
		};

		Writable.prototype.uncork = function () {
		  var state = this._writableState;

		  if (state.corked) {
		    state.corked--;

		    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
		  }
		};

		Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
		  // node::ParseEncoding() requires lower case.
		  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
		  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
		  this._writableState.defaultEncoding = encoding;
		  return this;
		};

		function decodeChunk(state, chunk, encoding) {
		  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
		    chunk = Buffer.from(chunk, encoding);
		  }
		  return chunk;
		}

		Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function () {
		    return this._writableState.highWaterMark;
		  }
		});

		// if we're already writing something, then just put this
		// in the queue, and wait our turn.  Otherwise, call _write
		// If we return false, then we need a drain event, so set that flag.
		function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
		  if (!isBuf) {
		    var newChunk = decodeChunk(state, chunk, encoding);
		    if (chunk !== newChunk) {
		      isBuf = true;
		      encoding = 'buffer';
		      chunk = newChunk;
		    }
		  }
		  var len = state.objectMode ? 1 : chunk.length;

		  state.length += len;

		  var ret = state.length < state.highWaterMark;
		  // we must ensure that previous needDrain will not be reset to false.
		  if (!ret) state.needDrain = true;

		  if (state.writing || state.corked) {
		    var last = state.lastBufferedRequest;
		    state.lastBufferedRequest = {
		      chunk: chunk,
		      encoding: encoding,
		      isBuf: isBuf,
		      callback: cb,
		      next: null
		    };
		    if (last) {
		      last.next = state.lastBufferedRequest;
		    } else {
		      state.bufferedRequest = state.lastBufferedRequest;
		    }
		    state.bufferedRequestCount += 1;
		  } else {
		    doWrite(stream, state, false, len, chunk, encoding, cb);
		  }

		  return ret;
		}

		function doWrite(stream, state, writev, len, chunk, encoding, cb) {
		  state.writelen = len;
		  state.writecb = cb;
		  state.writing = true;
		  state.sync = true;
		  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
		  state.sync = false;
		}

		function onwriteError(stream, state, sync, er, cb) {
		  --state.pendingcb;

		  if (sync) {
		    // defer the callback if we are being called synchronously
		    // to avoid piling up things on the stack
		    pna.nextTick(cb, er);
		    // this can emit finish, and it will always happen
		    // after error
		    pna.nextTick(finishMaybe, stream, state);
		    stream._writableState.errorEmitted = true;
		    stream.emit('error', er);
		  } else {
		    // the caller expect this to happen before if
		    // it is async
		    cb(er);
		    stream._writableState.errorEmitted = true;
		    stream.emit('error', er);
		    // this can emit finish, but finish must
		    // always follow error
		    finishMaybe(stream, state);
		  }
		}

		function onwriteStateUpdate(state) {
		  state.writing = false;
		  state.writecb = null;
		  state.length -= state.writelen;
		  state.writelen = 0;
		}

		function onwrite(stream, er) {
		  var state = stream._writableState;
		  var sync = state.sync;
		  var cb = state.writecb;

		  onwriteStateUpdate(state);

		  if (er) onwriteError(stream, state, sync, er, cb);else {
		    // Check if we're actually ready to finish, but don't emit yet
		    var finished = needFinish(state);

		    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
		      clearBuffer(stream, state);
		    }

		    if (sync) {
		      /*<replacement>*/
		      asyncWrite(afterWrite, stream, state, finished, cb);
		      /*</replacement>*/
		    } else {
		      afterWrite(stream, state, finished, cb);
		    }
		  }
		}

		function afterWrite(stream, state, finished, cb) {
		  if (!finished) onwriteDrain(stream, state);
		  state.pendingcb--;
		  cb();
		  finishMaybe(stream, state);
		}

		// Must force callback to be called on nextTick, so that we don't
		// emit 'drain' before the write() consumer gets the 'false' return
		// value, and has a chance to attach a 'drain' listener.
		function onwriteDrain(stream, state) {
		  if (state.length === 0 && state.needDrain) {
		    state.needDrain = false;
		    stream.emit('drain');
		  }
		}

		// if there's something in the buffer waiting, then process it
		function clearBuffer(stream, state) {
		  state.bufferProcessing = true;
		  var entry = state.bufferedRequest;

		  if (stream._writev && entry && entry.next) {
		    // Fast case, write everything using _writev()
		    var l = state.bufferedRequestCount;
		    var buffer = new Array(l);
		    var holder = state.corkedRequestsFree;
		    holder.entry = entry;

		    var count = 0;
		    var allBuffers = true;
		    while (entry) {
		      buffer[count] = entry;
		      if (!entry.isBuf) allBuffers = false;
		      entry = entry.next;
		      count += 1;
		    }
		    buffer.allBuffers = allBuffers;

		    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

		    // doWrite is almost always async, defer these to save a bit of time
		    // as the hot path ends with doWrite
		    state.pendingcb++;
		    state.lastBufferedRequest = null;
		    if (holder.next) {
		      state.corkedRequestsFree = holder.next;
		      holder.next = null;
		    } else {
		      state.corkedRequestsFree = new CorkedRequest(state);
		    }
		    state.bufferedRequestCount = 0;
		  } else {
		    // Slow case, write chunks one-by-one
		    while (entry) {
		      var chunk = entry.chunk;
		      var encoding = entry.encoding;
		      var cb = entry.callback;
		      var len = state.objectMode ? 1 : chunk.length;

		      doWrite(stream, state, false, len, chunk, encoding, cb);
		      entry = entry.next;
		      state.bufferedRequestCount--;
		      // if we didn't call the onwrite immediately, then
		      // it means that we need to wait until it does.
		      // also, that means that the chunk and cb are currently
		      // being processed, so move the buffer counter past them.
		      if (state.writing) {
		        break;
		      }
		    }

		    if (entry === null) state.lastBufferedRequest = null;
		  }

		  state.bufferedRequest = entry;
		  state.bufferProcessing = false;
		}

		Writable.prototype._write = function (chunk, encoding, cb) {
		  cb(new Error('_write() is not implemented'));
		};

		Writable.prototype._writev = null;

		Writable.prototype.end = function (chunk, encoding, cb) {
		  var state = this._writableState;

		  if (typeof chunk === 'function') {
		    cb = chunk;
		    chunk = null;
		    encoding = null;
		  } else if (typeof encoding === 'function') {
		    cb = encoding;
		    encoding = null;
		  }

		  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

		  // .end() fully uncorks
		  if (state.corked) {
		    state.corked = 1;
		    this.uncork();
		  }

		  // ignore unnecessary end() calls.
		  if (!state.ending) endWritable(this, state, cb);
		};

		function needFinish(state) {
		  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
		}
		function callFinal(stream, state) {
		  stream._final(function (err) {
		    state.pendingcb--;
		    if (err) {
		      stream.emit('error', err);
		    }
		    state.prefinished = true;
		    stream.emit('prefinish');
		    finishMaybe(stream, state);
		  });
		}
		function prefinish(stream, state) {
		  if (!state.prefinished && !state.finalCalled) {
		    if (typeof stream._final === 'function') {
		      state.pendingcb++;
		      state.finalCalled = true;
		      pna.nextTick(callFinal, stream, state);
		    } else {
		      state.prefinished = true;
		      stream.emit('prefinish');
		    }
		  }
		}

		function finishMaybe(stream, state) {
		  var need = needFinish(state);
		  if (need) {
		    prefinish(stream, state);
		    if (state.pendingcb === 0) {
		      state.finished = true;
		      stream.emit('finish');
		    }
		  }
		  return need;
		}

		function endWritable(stream, state, cb) {
		  state.ending = true;
		  finishMaybe(stream, state);
		  if (cb) {
		    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
		  }
		  state.ended = true;
		  stream.writable = false;
		}

		function onCorkedFinish(corkReq, state, err) {
		  var entry = corkReq.entry;
		  corkReq.entry = null;
		  while (entry) {
		    var cb = entry.callback;
		    state.pendingcb--;
		    cb(err);
		    entry = entry.next;
		  }

		  // reuse the free corkReq.
		  state.corkedRequestsFree.next = corkReq;
		}

		Object.defineProperty(Writable.prototype, 'destroyed', {
		  get: function () {
		    if (this._writableState === undefined) {
		      return false;
		    }
		    return this._writableState.destroyed;
		  },
		  set: function (value) {
		    // we ignore the value if the stream
		    // has not been initialized yet
		    if (!this._writableState) {
		      return;
		    }

		    // backward compatibility, the user is explicitly
		    // managing destroyed
		    this._writableState.destroyed = value;
		  }
		});

		Writable.prototype.destroy = destroyImpl.destroy;
		Writable.prototype._undestroy = destroyImpl.undestroy;
		Writable.prototype._destroy = function (err, cb) {
		  this.end();
		  cb(err);
		};
		}).call(this);}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate);
		},{"./_stream_duplex":452,"./internal/streams/destroy":458,"./internal/streams/stream":459,"_process":538,"core-util-is":382,"inherits":407,"process-nextick-args":441,"safe-buffer":461,"timers":484,"util-deprecate":486}],457:[function(require,module,exports){

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		var Buffer = require('safe-buffer').Buffer;
		var util = require('util');

		function copyBuffer(src, target, offset) {
		  src.copy(target, offset);
		}

		module.exports = function () {
		  function BufferList() {
		    _classCallCheck(this, BufferList);

		    this.head = null;
		    this.tail = null;
		    this.length = 0;
		  }

		  BufferList.prototype.push = function push(v) {
		    var entry = { data: v, next: null };
		    if (this.length > 0) this.tail.next = entry;else this.head = entry;
		    this.tail = entry;
		    ++this.length;
		  };

		  BufferList.prototype.unshift = function unshift(v) {
		    var entry = { data: v, next: this.head };
		    if (this.length === 0) this.tail = entry;
		    this.head = entry;
		    ++this.length;
		  };

		  BufferList.prototype.shift = function shift() {
		    if (this.length === 0) return;
		    var ret = this.head.data;
		    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
		    --this.length;
		    return ret;
		  };

		  BufferList.prototype.clear = function clear() {
		    this.head = this.tail = null;
		    this.length = 0;
		  };

		  BufferList.prototype.join = function join(s) {
		    if (this.length === 0) return '';
		    var p = this.head;
		    var ret = '' + p.data;
		    while (p = p.next) {
		      ret += s + p.data;
		    }return ret;
		  };

		  BufferList.prototype.concat = function concat(n) {
		    if (this.length === 0) return Buffer.alloc(0);
		    var ret = Buffer.allocUnsafe(n >>> 0);
		    var p = this.head;
		    var i = 0;
		    while (p) {
		      copyBuffer(p.data, ret, i);
		      i += p.data.length;
		      p = p.next;
		    }
		    return ret;
		  };

		  return BufferList;
		}();

		if (util && util.inspect && util.inspect.custom) {
		  module.exports.prototype[util.inspect.custom] = function () {
		    var obj = util.inspect({ length: this.length });
		    return this.constructor.name + ' ' + obj;
		  };
		}
		},{"safe-buffer":461,"util":102}],458:[function(require,module,exports){

		/*<replacement>*/

		var pna = require('process-nextick-args');
		/*</replacement>*/

		// undocumented cb() API, needed for core, not for public API
		function destroy(err, cb) {
		  var _this = this;

		  var readableDestroyed = this._readableState && this._readableState.destroyed;
		  var writableDestroyed = this._writableState && this._writableState.destroyed;

		  if (readableDestroyed || writableDestroyed) {
		    if (cb) {
		      cb(err);
		    } else if (err) {
		      if (!this._writableState) {
		        pna.nextTick(emitErrorNT, this, err);
		      } else if (!this._writableState.errorEmitted) {
		        this._writableState.errorEmitted = true;
		        pna.nextTick(emitErrorNT, this, err);
		      }
		    }

		    return this;
		  }

		  // we set destroyed to true before firing error callbacks in order
		  // to make it re-entrance safe in case destroy() is called within callbacks

		  if (this._readableState) {
		    this._readableState.destroyed = true;
		  }

		  // if this is a duplex stream mark the writable part as destroyed as well
		  if (this._writableState) {
		    this._writableState.destroyed = true;
		  }

		  this._destroy(err || null, function (err) {
		    if (!cb && err) {
		      if (!_this._writableState) {
		        pna.nextTick(emitErrorNT, _this, err);
		      } else if (!_this._writableState.errorEmitted) {
		        _this._writableState.errorEmitted = true;
		        pna.nextTick(emitErrorNT, _this, err);
		      }
		    } else if (cb) {
		      cb(err);
		    }
		  });

		  return this;
		}

		function undestroy() {
		  if (this._readableState) {
		    this._readableState.destroyed = false;
		    this._readableState.reading = false;
		    this._readableState.ended = false;
		    this._readableState.endEmitted = false;
		  }

		  if (this._writableState) {
		    this._writableState.destroyed = false;
		    this._writableState.ended = false;
		    this._writableState.ending = false;
		    this._writableState.finalCalled = false;
		    this._writableState.prefinished = false;
		    this._writableState.finished = false;
		    this._writableState.errorEmitted = false;
		  }
		}

		function emitErrorNT(self, err) {
		  self.emit('error', err);
		}

		module.exports = {
		  destroy: destroy,
		  undestroy: undestroy
		};
		},{"process-nextick-args":441}],459:[function(require,module,exports){
		module.exports = require('events').EventEmitter;

		},{"events":386}],460:[function(require,module,exports){
		var toString = {}.toString;

		module.exports = Array.isArray || function (arr) {
		  return toString.call(arr) == '[object Array]';
		};

		},{}],461:[function(require,module,exports){
		/* eslint-disable node/no-deprecated-api */
		var buffer = require('buffer');
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		};

		},{"buffer":103}],462:[function(require,module,exports){

		/*<replacement>*/

		var Buffer = require('safe-buffer').Buffer;
		/*</replacement>*/

		var isEncoding = Buffer.isEncoding || function (encoding) {
		  encoding = '' + encoding;
		  switch (encoding && encoding.toLowerCase()) {
		    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
		      return true;
		    default:
		      return false;
		  }
		};

		function _normalizeEncoding(enc) {
		  if (!enc) return 'utf8';
		  var retried;
		  while (true) {
		    switch (enc) {
		      case 'utf8':
		      case 'utf-8':
		        return 'utf8';
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return 'utf16le';
		      case 'latin1':
		      case 'binary':
		        return 'latin1';
		      case 'base64':
		      case 'ascii':
		      case 'hex':
		        return enc;
		      default:
		        if (retried) return; // undefined
		        enc = ('' + enc).toLowerCase();
		        retried = true;
		    }
		  }
		}
		// Do not cache `Buffer.isEncoding` when checking encoding names as some
		// modules monkey-patch it to support additional encodings
		function normalizeEncoding(enc) {
		  var nenc = _normalizeEncoding(enc);
		  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
		  return nenc || enc;
		}

		// StringDecoder provides an interface for efficiently splitting a series of
		// buffers into a series of JS strings without breaking apart multi-byte
		// characters.
		exports.StringDecoder = StringDecoder;
		function StringDecoder(encoding) {
		  this.encoding = normalizeEncoding(encoding);
		  var nb;
		  switch (this.encoding) {
		    case 'utf16le':
		      this.text = utf16Text;
		      this.end = utf16End;
		      nb = 4;
		      break;
		    case 'utf8':
		      this.fillLast = utf8FillLast;
		      nb = 4;
		      break;
		    case 'base64':
		      this.text = base64Text;
		      this.end = base64End;
		      nb = 3;
		      break;
		    default:
		      this.write = simpleWrite;
		      this.end = simpleEnd;
		      return;
		  }
		  this.lastNeed = 0;
		  this.lastTotal = 0;
		  this.lastChar = Buffer.allocUnsafe(nb);
		}

		StringDecoder.prototype.write = function (buf) {
		  if (buf.length === 0) return '';
		  var r;
		  var i;
		  if (this.lastNeed) {
		    r = this.fillLast(buf);
		    if (r === undefined) return '';
		    i = this.lastNeed;
		    this.lastNeed = 0;
		  } else {
		    i = 0;
		  }
		  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
		  return r || '';
		};

		StringDecoder.prototype.end = utf8End;

		// Returns only complete characters in a Buffer
		StringDecoder.prototype.text = utf8Text;

		// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
		StringDecoder.prototype.fillLast = function (buf) {
		  if (this.lastNeed <= buf.length) {
		    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
		    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		  }
		  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
		  this.lastNeed -= buf.length;
		};

		// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
		// continuation byte. If an invalid byte is detected, -2 is returned.
		function utf8CheckByte(byte) {
		  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
		  return byte >> 6 === 0x02 ? -1 : -2;
		}

		// Checks at most 3 bytes at the end of a Buffer in order to detect an
		// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
		// needed to complete the UTF-8 character (if applicable) are returned.
		function utf8CheckIncomplete(self, buf, i) {
		  var j = buf.length - 1;
		  if (j < i) return 0;
		  var nb = utf8CheckByte(buf[j]);
		  if (nb >= 0) {
		    if (nb > 0) self.lastNeed = nb - 1;
		    return nb;
		  }
		  if (--j < i || nb === -2) return 0;
		  nb = utf8CheckByte(buf[j]);
		  if (nb >= 0) {
		    if (nb > 0) self.lastNeed = nb - 2;
		    return nb;
		  }
		  if (--j < i || nb === -2) return 0;
		  nb = utf8CheckByte(buf[j]);
		  if (nb >= 0) {
		    if (nb > 0) {
		      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
		    }
		    return nb;
		  }
		  return 0;
		}

		// Validates as many continuation bytes for a multi-byte UTF-8 character as
		// needed or are available. If we see a non-continuation byte where we expect
		// one, we "replace" the validated continuation bytes we've seen so far with
		// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
		// behavior. The continuation byte check is included three times in the case
		// where all of the continuation bytes for a character exist in the same buffer.
		// It is also done this way as a slight performance increase instead of using a
		// loop.
		function utf8CheckExtraBytes(self, buf, p) {
		  if ((buf[0] & 0xC0) !== 0x80) {
		    self.lastNeed = 0;
		    return '\ufffd';
		  }
		  if (self.lastNeed > 1 && buf.length > 1) {
		    if ((buf[1] & 0xC0) !== 0x80) {
		      self.lastNeed = 1;
		      return '\ufffd';
		    }
		    if (self.lastNeed > 2 && buf.length > 2) {
		      if ((buf[2] & 0xC0) !== 0x80) {
		        self.lastNeed = 2;
		        return '\ufffd';
		      }
		    }
		  }
		}

		// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
		function utf8FillLast(buf) {
		  var p = this.lastTotal - this.lastNeed;
		  var r = utf8CheckExtraBytes(this, buf);
		  if (r !== undefined) return r;
		  if (this.lastNeed <= buf.length) {
		    buf.copy(this.lastChar, p, 0, this.lastNeed);
		    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		  }
		  buf.copy(this.lastChar, p, 0, buf.length);
		  this.lastNeed -= buf.length;
		}

		// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
		// partial character, the character's bytes are buffered until the required
		// number of bytes are available.
		function utf8Text(buf, i) {
		  var total = utf8CheckIncomplete(this, buf, i);
		  if (!this.lastNeed) return buf.toString('utf8', i);
		  this.lastTotal = total;
		  var end = buf.length - (total - this.lastNeed);
		  buf.copy(this.lastChar, 0, end);
		  return buf.toString('utf8', i, end);
		}

		// For UTF-8, a replacement character is added when ending on a partial
		// character.
		function utf8End(buf) {
		  var r = buf && buf.length ? this.write(buf) : '';
		  if (this.lastNeed) return r + '\ufffd';
		  return r;
		}

		// UTF-16LE typically needs two bytes per character, but even if we have an even
		// number of bytes available, we need to check if we end on a leading/high
		// surrogate. In that case, we need to wait for the next two bytes in order to
		// decode the last character properly.
		function utf16Text(buf, i) {
		  if ((buf.length - i) % 2 === 0) {
		    var r = buf.toString('utf16le', i);
		    if (r) {
		      var c = r.charCodeAt(r.length - 1);
		      if (c >= 0xD800 && c <= 0xDBFF) {
		        this.lastNeed = 2;
		        this.lastTotal = 4;
		        this.lastChar[0] = buf[buf.length - 2];
		        this.lastChar[1] = buf[buf.length - 1];
		        return r.slice(0, -1);
		      }
		    }
		    return r;
		  }
		  this.lastNeed = 1;
		  this.lastTotal = 2;
		  this.lastChar[0] = buf[buf.length - 1];
		  return buf.toString('utf16le', i, buf.length - 1);
		}

		// For UTF-16LE we do not explicitly append special replacement characters if we
		// end on a partial character, we simply let v8 handle that.
		function utf16End(buf) {
		  var r = buf && buf.length ? this.write(buf) : '';
		  if (this.lastNeed) {
		    var end = this.lastTotal - this.lastNeed;
		    return r + this.lastChar.toString('utf16le', 0, end);
		  }
		  return r;
		}

		function base64Text(buf, i) {
		  var n = (buf.length - i) % 3;
		  if (n === 0) return buf.toString('base64', i);
		  this.lastNeed = 3 - n;
		  this.lastTotal = 3;
		  if (n === 1) {
		    this.lastChar[0] = buf[buf.length - 1];
		  } else {
		    this.lastChar[0] = buf[buf.length - 2];
		    this.lastChar[1] = buf[buf.length - 1];
		  }
		  return buf.toString('base64', i, buf.length - n);
		}

		function base64End(buf) {
		  var r = buf && buf.length ? this.write(buf) : '';
		  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
		  return r;
		}

		// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
		function simpleWrite(buf) {
		  return buf.toString(this.encoding);
		}

		function simpleEnd(buf) {
		  return buf && buf.length ? this.write(buf) : '';
		}
		},{"safe-buffer":461}],463:[function(require,module,exports){
		exports = module.exports = require('./lib/_stream_readable.js');
		exports.Stream = exports;
		exports.Readable = exports;
		exports.Writable = require('./lib/_stream_writable.js');
		exports.Duplex = require('./lib/_stream_duplex.js');
		exports.Transform = require('./lib/_stream_transform.js');
		exports.PassThrough = require('./lib/_stream_passthrough.js');

		},{"./lib/_stream_duplex.js":452,"./lib/_stream_passthrough.js":453,"./lib/_stream_readable.js":454,"./lib/_stream_transform.js":455,"./lib/_stream_writable.js":456}],464:[function(require,module,exports){
		/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
		/* eslint-disable node/no-deprecated-api */
		var buffer = require('buffer');
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		};

		},{"buffer":103}],465:[function(require,module,exports){
		(function (Buffer){(function (){
(function (sax) { // wrapper for non-node envs
		  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) };
		  sax.SAXParser = SAXParser;
		  sax.SAXStream = SAXStream;
		  sax.createStream = createStream;

		  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
		  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
		  // since that's the earliest that a buffer overrun could occur.  This way, checks are
		  // as rare as required, but as often as necessary to ensure never crossing this bound.
		  // Furthermore, buffers are only tested at most once per write(), so passing a very
		  // large string into write() might have undesirable effects, but this is manageable by
		  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
		  // edge case, result in creating at most one complete copy of the string passed in.
		  // Set to Infinity to have unlimited buffers.
		  sax.MAX_BUFFER_LENGTH = 64 * 1024;

		  var buffers = [
		    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
		    'procInstName', 'procInstBody', 'entity', 'attribName',
		    'attribValue', 'cdata', 'script'
		  ];

		  sax.EVENTS = [
		    'text',
		    'processinginstruction',
		    'sgmldeclaration',
		    'doctype',
		    'comment',
		    'opentagstart',
		    'attribute',
		    'opentag',
		    'closetag',
		    'opencdata',
		    'cdata',
		    'closecdata',
		    'error',
		    'end',
		    'ready',
		    'script',
		    'opennamespace',
		    'closenamespace'
		  ];

		  function SAXParser (strict, opt) {
		    if (!(this instanceof SAXParser)) {
		      return new SAXParser(strict, opt)
		    }

		    var parser = this;
		    clearBuffers(parser);
		    parser.q = parser.c = '';
		    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
		    parser.opt = opt || {};
		    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
		    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
		    parser.tags = [];
		    parser.closed = parser.closedRoot = parser.sawRoot = false;
		    parser.tag = parser.error = null;
		    parser.strict = !!strict;
		    parser.noscript = !!(strict || parser.opt.noscript);
		    parser.state = S.BEGIN;
		    parser.strictEntities = parser.opt.strictEntities;
		    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
		    parser.attribList = [];

		    // namespaces form a prototype chain.
		    // it always points at the current tag,
		    // which protos to its parent tag.
		    if (parser.opt.xmlns) {
		      parser.ns = Object.create(rootNS);
		    }

		    // mostly just for error reporting
		    parser.trackPosition = parser.opt.position !== false;
		    if (parser.trackPosition) {
		      parser.position = parser.line = parser.column = 0;
		    }
		    emit(parser, 'onready');
		  }

		  if (!Object.create) {
		    Object.create = function (o) {
		      function F () {}
		      F.prototype = o;
		      var newf = new F();
		      return newf
		    };
		  }

		  if (!Object.keys) {
		    Object.keys = function (o) {
		      var a = [];
		      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
		      return a
		    };
		  }

		  function checkBufferLength (parser) {
		    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
		    var maxActual = 0;
		    for (var i = 0, l = buffers.length; i < l; i++) {
		      var len = parser[buffers[i]].length;
		      if (len > maxAllowed) {
		        // Text/cdata nodes can get big, and since they're buffered,
		        // we can get here under normal conditions.
		        // Avoid issues by emitting the text node now,
		        // so at least it won't get any bigger.
		        switch (buffers[i]) {
		          case 'textNode':
		            closeText(parser);
		            break

		          case 'cdata':
		            emitNode(parser, 'oncdata', parser.cdata);
		            parser.cdata = '';
		            break

		          case 'script':
		            emitNode(parser, 'onscript', parser.script);
		            parser.script = '';
		            break

		          default:
		            error(parser, 'Max buffer length exceeded: ' + buffers[i]);
		        }
		      }
		      maxActual = Math.max(maxActual, len);
		    }
		    // schedule the next check for the earliest possible buffer overrun.
		    var m = sax.MAX_BUFFER_LENGTH - maxActual;
		    parser.bufferCheckPosition = m + parser.position;
		  }

		  function clearBuffers (parser) {
		    for (var i = 0, l = buffers.length; i < l; i++) {
		      parser[buffers[i]] = '';
		    }
		  }

		  function flushBuffers (parser) {
		    closeText(parser);
		    if (parser.cdata !== '') {
		      emitNode(parser, 'oncdata', parser.cdata);
		      parser.cdata = '';
		    }
		    if (parser.script !== '') {
		      emitNode(parser, 'onscript', parser.script);
		      parser.script = '';
		    }
		  }

		  SAXParser.prototype = {
		    end: function () { end(this); },
		    write: write,
		    resume: function () { this.error = null; return this },
		    close: function () { return this.write(null) },
		    flush: function () { flushBuffers(this); }
		  };

		  var Stream;
		  try {
		    Stream = require('stream').Stream;
		  } catch (ex) {
		    Stream = function () {};
		  }
		  if (!Stream) Stream = function () {};

		  var streamWraps = sax.EVENTS.filter(function (ev) {
		    return ev !== 'error' && ev !== 'end'
		  });

		  function createStream (strict, opt) {
		    return new SAXStream(strict, opt)
		  }

		  function SAXStream (strict, opt) {
		    if (!(this instanceof SAXStream)) {
		      return new SAXStream(strict, opt)
		    }

		    Stream.apply(this);

		    this._parser = new SAXParser(strict, opt);
		    this.writable = true;
		    this.readable = true;

		    var me = this;

		    this._parser.onend = function () {
		      me.emit('end');
		    };

		    this._parser.onerror = function (er) {
		      me.emit('error', er);

		      // if didn't throw, then means error was handled.
		      // go ahead and clear error, so we can write again.
		      me._parser.error = null;
		    };

		    this._decoder = null;

		    streamWraps.forEach(function (ev) {
		      Object.defineProperty(me, 'on' + ev, {
		        get: function () {
		          return me._parser['on' + ev]
		        },
		        set: function (h) {
		          if (!h) {
		            me.removeAllListeners(ev);
		            me._parser['on' + ev] = h;
		            return h
		          }
		          me.on(ev, h);
		        },
		        enumerable: true,
		        configurable: false
		      });
		    });
		  }

		  SAXStream.prototype = Object.create(Stream.prototype, {
		    constructor: {
		      value: SAXStream
		    }
		  });

		  SAXStream.prototype.write = function (data) {
		    if (typeof Buffer === 'function' &&
		      typeof Buffer.isBuffer === 'function' &&
		      Buffer.isBuffer(data)) {
		      if (!this._decoder) {
		        var SD = require('string_decoder').StringDecoder;
		        this._decoder = new SD('utf8');
		      }
		      data = this._decoder.write(data);
		    }

		    this._parser.write(data.toString());
		    this.emit('data', data);
		    return true
		  };

		  SAXStream.prototype.end = function (chunk) {
		    if (chunk && chunk.length) {
		      this.write(chunk);
		    }
		    this._parser.end();
		    return true
		  };

		  SAXStream.prototype.on = function (ev, handler) {
		    var me = this;
		    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
		      me._parser['on' + ev] = function () {
		        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
		        args.splice(0, 0, ev);
		        me.emit.apply(me, args);
		      };
		    }

		    return Stream.prototype.on.call(me, ev, handler)
		  };

		  // this really needs to be replaced with character classes.
		  // XML allows all manner of ridiculous numbers and digits.
		  var CDATA = '[CDATA[';
		  var DOCTYPE = 'DOCTYPE';
		  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
		  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
		  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };

		  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
		  // This implementation works on strings, a single character at a time
		  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
		  // without a significant breaking change to either this  parser, or the
		  // JavaScript language.  Implementation of an emoji-capable xml parser
		  // is left as an exercise for the reader.
		  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

		  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

		  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
		  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

		  function isWhitespace (c) {
		    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
		  }

		  function isQuote (c) {
		    return c === '"' || c === '\''
		  }

		  function isAttribEnd (c) {
		    return c === '>' || isWhitespace(c)
		  }

		  function isMatch (regex, c) {
		    return regex.test(c)
		  }

		  function notMatch (regex, c) {
		    return !isMatch(regex, c)
		  }

		  var S = 0;
		  sax.STATE = {
		    BEGIN: S++, // leading byte order mark or whitespace
		    BEGIN_WHITESPACE: S++, // leading whitespace
		    TEXT: S++, // general stuff
		    TEXT_ENTITY: S++, // &amp and such.
		    OPEN_WAKA: S++, // <
		    SGML_DECL: S++, // <!BLARG
		    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
		    DOCTYPE: S++, // <!DOCTYPE
		    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
		    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
		    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
		    COMMENT_STARTING: S++, // <!-
		    COMMENT: S++, // <!--
		    COMMENT_ENDING: S++, // <!-- blah -
		    COMMENT_ENDED: S++, // <!-- blah --
		    CDATA: S++, // <![CDATA[ something
		    CDATA_ENDING: S++, // ]
		    CDATA_ENDING_2: S++, // ]]
		    PROC_INST: S++, // <?hi
		    PROC_INST_BODY: S++, // <?hi there
		    PROC_INST_ENDING: S++, // <?hi "there" ?
		    OPEN_TAG: S++, // <strong
		    OPEN_TAG_SLASH: S++, // <strong /
		    ATTRIB: S++, // <a
		    ATTRIB_NAME: S++, // <a foo
		    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
		    ATTRIB_VALUE: S++, // <a foo=
		    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
		    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
		    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
		    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
		    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
		    CLOSE_TAG: S++, // </a
		    CLOSE_TAG_SAW_WHITE: S++, // </a   >
		    SCRIPT: S++, // <script> ...
		    SCRIPT_ENDING: S++ // <script> ... <
		  };

		  sax.XML_ENTITIES = {
		    'amp': '&',
		    'gt': '>',
		    'lt': '<',
		    'quot': '"',
		    'apos': "'"
		  };

		  sax.ENTITIES = {
		    'amp': '&',
		    'gt': '>',
		    'lt': '<',
		    'quot': '"',
		    'apos': "'",
		    'AElig': 198,
		    'Aacute': 193,
		    'Acirc': 194,
		    'Agrave': 192,
		    'Aring': 197,
		    'Atilde': 195,
		    'Auml': 196,
		    'Ccedil': 199,
		    'ETH': 208,
		    'Eacute': 201,
		    'Ecirc': 202,
		    'Egrave': 200,
		    'Euml': 203,
		    'Iacute': 205,
		    'Icirc': 206,
		    'Igrave': 204,
		    'Iuml': 207,
		    'Ntilde': 209,
		    'Oacute': 211,
		    'Ocirc': 212,
		    'Ograve': 210,
		    'Oslash': 216,
		    'Otilde': 213,
		    'Ouml': 214,
		    'THORN': 222,
		    'Uacute': 218,
		    'Ucirc': 219,
		    'Ugrave': 217,
		    'Uuml': 220,
		    'Yacute': 221,
		    'aacute': 225,
		    'acirc': 226,
		    'aelig': 230,
		    'agrave': 224,
		    'aring': 229,
		    'atilde': 227,
		    'auml': 228,
		    'ccedil': 231,
		    'eacute': 233,
		    'ecirc': 234,
		    'egrave': 232,
		    'eth': 240,
		    'euml': 235,
		    'iacute': 237,
		    'icirc': 238,
		    'igrave': 236,
		    'iuml': 239,
		    'ntilde': 241,
		    'oacute': 243,
		    'ocirc': 244,
		    'ograve': 242,
		    'oslash': 248,
		    'otilde': 245,
		    'ouml': 246,
		    'szlig': 223,
		    'thorn': 254,
		    'uacute': 250,
		    'ucirc': 251,
		    'ugrave': 249,
		    'uuml': 252,
		    'yacute': 253,
		    'yuml': 255,
		    'copy': 169,
		    'reg': 174,
		    'nbsp': 160,
		    'iexcl': 161,
		    'cent': 162,
		    'pound': 163,
		    'curren': 164,
		    'yen': 165,
		    'brvbar': 166,
		    'sect': 167,
		    'uml': 168,
		    'ordf': 170,
		    'laquo': 171,
		    'not': 172,
		    'shy': 173,
		    'macr': 175,
		    'deg': 176,
		    'plusmn': 177,
		    'sup1': 185,
		    'sup2': 178,
		    'sup3': 179,
		    'acute': 180,
		    'micro': 181,
		    'para': 182,
		    'middot': 183,
		    'cedil': 184,
		    'ordm': 186,
		    'raquo': 187,
		    'frac14': 188,
		    'frac12': 189,
		    'frac34': 190,
		    'iquest': 191,
		    'times': 215,
		    'divide': 247,
		    'OElig': 338,
		    'oelig': 339,
		    'Scaron': 352,
		    'scaron': 353,
		    'Yuml': 376,
		    'fnof': 402,
		    'circ': 710,
		    'tilde': 732,
		    'Alpha': 913,
		    'Beta': 914,
		    'Gamma': 915,
		    'Delta': 916,
		    'Epsilon': 917,
		    'Zeta': 918,
		    'Eta': 919,
		    'Theta': 920,
		    'Iota': 921,
		    'Kappa': 922,
		    'Lambda': 923,
		    'Mu': 924,
		    'Nu': 925,
		    'Xi': 926,
		    'Omicron': 927,
		    'Pi': 928,
		    'Rho': 929,
		    'Sigma': 931,
		    'Tau': 932,
		    'Upsilon': 933,
		    'Phi': 934,
		    'Chi': 935,
		    'Psi': 936,
		    'Omega': 937,
		    'alpha': 945,
		    'beta': 946,
		    'gamma': 947,
		    'delta': 948,
		    'epsilon': 949,
		    'zeta': 950,
		    'eta': 951,
		    'theta': 952,
		    'iota': 953,
		    'kappa': 954,
		    'lambda': 955,
		    'mu': 956,
		    'nu': 957,
		    'xi': 958,
		    'omicron': 959,
		    'pi': 960,
		    'rho': 961,
		    'sigmaf': 962,
		    'sigma': 963,
		    'tau': 964,
		    'upsilon': 965,
		    'phi': 966,
		    'chi': 967,
		    'psi': 968,
		    'omega': 969,
		    'thetasym': 977,
		    'upsih': 978,
		    'piv': 982,
		    'ensp': 8194,
		    'emsp': 8195,
		    'thinsp': 8201,
		    'zwnj': 8204,
		    'zwj': 8205,
		    'lrm': 8206,
		    'rlm': 8207,
		    'ndash': 8211,
		    'mdash': 8212,
		    'lsquo': 8216,
		    'rsquo': 8217,
		    'sbquo': 8218,
		    'ldquo': 8220,
		    'rdquo': 8221,
		    'bdquo': 8222,
		    'dagger': 8224,
		    'Dagger': 8225,
		    'bull': 8226,
		    'hellip': 8230,
		    'permil': 8240,
		    'prime': 8242,
		    'Prime': 8243,
		    'lsaquo': 8249,
		    'rsaquo': 8250,
		    'oline': 8254,
		    'frasl': 8260,
		    'euro': 8364,
		    'image': 8465,
		    'weierp': 8472,
		    'real': 8476,
		    'trade': 8482,
		    'alefsym': 8501,
		    'larr': 8592,
		    'uarr': 8593,
		    'rarr': 8594,
		    'darr': 8595,
		    'harr': 8596,
		    'crarr': 8629,
		    'lArr': 8656,
		    'uArr': 8657,
		    'rArr': 8658,
		    'dArr': 8659,
		    'hArr': 8660,
		    'forall': 8704,
		    'part': 8706,
		    'exist': 8707,
		    'empty': 8709,
		    'nabla': 8711,
		    'isin': 8712,
		    'notin': 8713,
		    'ni': 8715,
		    'prod': 8719,
		    'sum': 8721,
		    'minus': 8722,
		    'lowast': 8727,
		    'radic': 8730,
		    'prop': 8733,
		    'infin': 8734,
		    'ang': 8736,
		    'and': 8743,
		    'or': 8744,
		    'cap': 8745,
		    'cup': 8746,
		    'int': 8747,
		    'there4': 8756,
		    'sim': 8764,
		    'cong': 8773,
		    'asymp': 8776,
		    'ne': 8800,
		    'equiv': 8801,
		    'le': 8804,
		    'ge': 8805,
		    'sub': 8834,
		    'sup': 8835,
		    'nsub': 8836,
		    'sube': 8838,
		    'supe': 8839,
		    'oplus': 8853,
		    'otimes': 8855,
		    'perp': 8869,
		    'sdot': 8901,
		    'lceil': 8968,
		    'rceil': 8969,
		    'lfloor': 8970,
		    'rfloor': 8971,
		    'lang': 9001,
		    'rang': 9002,
		    'loz': 9674,
		    'spades': 9824,
		    'clubs': 9827,
		    'hearts': 9829,
		    'diams': 9830
		  };

		  Object.keys(sax.ENTITIES).forEach(function (key) {
		    var e = sax.ENTITIES[key];
		    var s = typeof e === 'number' ? String.fromCharCode(e) : e;
		    sax.ENTITIES[key] = s;
		  });

		  for (var s in sax.STATE) {
		    sax.STATE[sax.STATE[s]] = s;
		  }

		  // shorthand
		  S = sax.STATE;

		  function emit (parser, event, data) {
		    parser[event] && parser[event](data);
		  }

		  function emitNode (parser, nodeType, data) {
		    if (parser.textNode) closeText(parser);
		    emit(parser, nodeType, data);
		  }

		  function closeText (parser) {
		    parser.textNode = textopts(parser.opt, parser.textNode);
		    if (parser.textNode) emit(parser, 'ontext', parser.textNode);
		    parser.textNode = '';
		  }

		  function textopts (opt, text) {
		    if (opt.trim) text = text.trim();
		    if (opt.normalize) text = text.replace(/\s+/g, ' ');
		    return text
		  }

		  function error (parser, er) {
		    closeText(parser);
		    if (parser.trackPosition) {
		      er += '\nLine: ' + parser.line +
		        '\nColumn: ' + parser.column +
		        '\nChar: ' + parser.c;
		    }
		    er = new Error(er);
		    parser.error = er;
		    emit(parser, 'onerror', er);
		    return parser
		  }

		  function end (parser) {
		    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
		    if ((parser.state !== S.BEGIN) &&
		      (parser.state !== S.BEGIN_WHITESPACE) &&
		      (parser.state !== S.TEXT)) {
		      error(parser, 'Unexpected end');
		    }
		    closeText(parser);
		    parser.c = '';
		    parser.closed = true;
		    emit(parser, 'onend');
		    SAXParser.call(parser, parser.strict, parser.opt);
		    return parser
		  }

		  function strictFail (parser, message) {
		    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
		      throw new Error('bad call to strictFail')
		    }
		    if (parser.strict) {
		      error(parser, message);
		    }
		  }

		  function newTag (parser) {
		    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
		    var parent = parser.tags[parser.tags.length - 1] || parser;
		    var tag = parser.tag = { name: parser.tagName, attributes: {} };

		    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
		    if (parser.opt.xmlns) {
		      tag.ns = parent.ns;
		    }
		    parser.attribList.length = 0;
		    emitNode(parser, 'onopentagstart', tag);
		  }

		  function qname (name, attribute) {
		    var i = name.indexOf(':');
		    var qualName = i < 0 ? [ '', name ] : name.split(':');
		    var prefix = qualName[0];
		    var local = qualName[1];

		    // <x "xmlns"="http://foo">
		    if (attribute && name === 'xmlns') {
		      prefix = 'xmlns';
		      local = '';
		    }

		    return { prefix: prefix, local: local }
		  }

		  function attrib (parser) {
		    if (!parser.strict) {
		      parser.attribName = parser.attribName[parser.looseCase]();
		    }

		    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
		      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
		      parser.attribName = parser.attribValue = '';
		      return
		    }

		    if (parser.opt.xmlns) {
		      var qn = qname(parser.attribName, true);
		      var prefix = qn.prefix;
		      var local = qn.local;

		      if (prefix === 'xmlns') {
		        // namespace binding attribute. push the binding into scope
		        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
		          strictFail(parser,
		            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
		            'Actual: ' + parser.attribValue);
		        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
		          strictFail(parser,
		            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
		            'Actual: ' + parser.attribValue);
		        } else {
		          var tag = parser.tag;
		          var parent = parser.tags[parser.tags.length - 1] || parser;
		          if (tag.ns === parent.ns) {
		            tag.ns = Object.create(parent.ns);
		          }
		          tag.ns[local] = parser.attribValue;
		        }
		      }

		      // defer onattribute events until all attributes have been seen
		      // so any new bindings can take effect. preserve attribute order
		      // so deferred events can be emitted in document order
		      parser.attribList.push([parser.attribName, parser.attribValue]);
		    } else {
		      // in non-xmlns mode, we can emit the event right away
		      parser.tag.attributes[parser.attribName] = parser.attribValue;
		      emitNode(parser, 'onattribute', {
		        name: parser.attribName,
		        value: parser.attribValue
		      });
		    }

		    parser.attribName = parser.attribValue = '';
		  }

		  function openTag (parser, selfClosing) {
		    if (parser.opt.xmlns) {
		      // emit namespace binding events
		      var tag = parser.tag;

		      // add namespace info to tag
		      var qn = qname(parser.tagName);
		      tag.prefix = qn.prefix;
		      tag.local = qn.local;
		      tag.uri = tag.ns[qn.prefix] || '';

		      if (tag.prefix && !tag.uri) {
		        strictFail(parser, 'Unbound namespace prefix: ' +
		          JSON.stringify(parser.tagName));
		        tag.uri = qn.prefix;
		      }

		      var parent = parser.tags[parser.tags.length - 1] || parser;
		      if (tag.ns && parent.ns !== tag.ns) {
		        Object.keys(tag.ns).forEach(function (p) {
		          emitNode(parser, 'onopennamespace', {
		            prefix: p,
		            uri: tag.ns[p]
		          });
		        });
		      }

		      // handle deferred onattribute events
		      // Note: do not apply default ns to attributes:
		      //   http://www.w3.org/TR/REC-xml-names/#defaulting
		      for (var i = 0, l = parser.attribList.length; i < l; i++) {
		        var nv = parser.attribList[i];
		        var name = nv[0];
		        var value = nv[1];
		        var qualName = qname(name, true);
		        var prefix = qualName.prefix;
		        var local = qualName.local;
		        var uri = prefix === '' ? '' : (tag.ns[prefix] || '');
		        var a = {
		          name: name,
		          value: value,
		          prefix: prefix,
		          local: local,
		          uri: uri
		        };

		        // if there's any attributes with an undefined namespace,
		        // then fail on them now.
		        if (prefix && prefix !== 'xmlns' && !uri) {
		          strictFail(parser, 'Unbound namespace prefix: ' +
		            JSON.stringify(prefix));
		          a.uri = prefix;
		        }
		        parser.tag.attributes[name] = a;
		        emitNode(parser, 'onattribute', a);
		      }
		      parser.attribList.length = 0;
		    }

		    parser.tag.isSelfClosing = !!selfClosing;

		    // process the tag
		    parser.sawRoot = true;
		    parser.tags.push(parser.tag);
		    emitNode(parser, 'onopentag', parser.tag);
		    if (!selfClosing) {
		      // special case for <script> in non-strict mode.
		      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
		        parser.state = S.SCRIPT;
		      } else {
		        parser.state = S.TEXT;
		      }
		      parser.tag = null;
		      parser.tagName = '';
		    }
		    parser.attribName = parser.attribValue = '';
		    parser.attribList.length = 0;
		  }

		  function closeTag (parser) {
		    if (!parser.tagName) {
		      strictFail(parser, 'Weird empty close tag.');
		      parser.textNode += '</>';
		      parser.state = S.TEXT;
		      return
		    }

		    if (parser.script) {
		      if (parser.tagName !== 'script') {
		        parser.script += '</' + parser.tagName + '>';
		        parser.tagName = '';
		        parser.state = S.SCRIPT;
		        return
		      }
		      emitNode(parser, 'onscript', parser.script);
		      parser.script = '';
		    }

		    // first make sure that the closing tag actually exists.
		    // <a><b></c></b></a> will close everything, otherwise.
		    var t = parser.tags.length;
		    var tagName = parser.tagName;
		    if (!parser.strict) {
		      tagName = tagName[parser.looseCase]();
		    }
		    var closeTo = tagName;
		    while (t--) {
		      var close = parser.tags[t];
		      if (close.name !== closeTo) {
		        // fail the first time in strict mode
		        strictFail(parser, 'Unexpected close tag');
		      } else {
		        break
		      }
		    }

		    // didn't find it.  we already failed for strict, so just abort.
		    if (t < 0) {
		      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
		      parser.textNode += '</' + parser.tagName + '>';
		      parser.state = S.TEXT;
		      return
		    }
		    parser.tagName = tagName;
		    var s = parser.tags.length;
		    while (s-- > t) {
		      var tag = parser.tag = parser.tags.pop();
		      parser.tagName = parser.tag.name;
		      emitNode(parser, 'onclosetag', parser.tagName);

		      var x = {};
		      for (var i in tag.ns) {
		        x[i] = tag.ns[i];
		      }

		      var parent = parser.tags[parser.tags.length - 1] || parser;
		      if (parser.opt.xmlns && tag.ns !== parent.ns) {
		        // remove namespace bindings introduced by tag
		        Object.keys(tag.ns).forEach(function (p) {
		          var n = tag.ns[p];
		          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
		        });
		      }
		    }
		    if (t === 0) parser.closedRoot = true;
		    parser.tagName = parser.attribValue = parser.attribName = '';
		    parser.attribList.length = 0;
		    parser.state = S.TEXT;
		  }

		  function parseEntity (parser) {
		    var entity = parser.entity;
		    var entityLC = entity.toLowerCase();
		    var num;
		    var numStr = '';

		    if (parser.ENTITIES[entity]) {
		      return parser.ENTITIES[entity]
		    }
		    if (parser.ENTITIES[entityLC]) {
		      return parser.ENTITIES[entityLC]
		    }
		    entity = entityLC;
		    if (entity.charAt(0) === '#') {
		      if (entity.charAt(1) === 'x') {
		        entity = entity.slice(2);
		        num = parseInt(entity, 16);
		        numStr = num.toString(16);
		      } else {
		        entity = entity.slice(1);
		        num = parseInt(entity, 10);
		        numStr = num.toString(10);
		      }
		    }
		    entity = entity.replace(/^0+/, '');
		    if (isNaN(num) || numStr.toLowerCase() !== entity) {
		      strictFail(parser, 'Invalid character entity');
		      return '&' + parser.entity + ';'
		    }

		    return String.fromCodePoint(num)
		  }

		  function beginWhiteSpace (parser, c) {
		    if (c === '<') {
		      parser.state = S.OPEN_WAKA;
		      parser.startTagPosition = parser.position;
		    } else if (!isWhitespace(c)) {
		      // have to process this as a text node.
		      // weird, but happens.
		      strictFail(parser, 'Non-whitespace before first tag.');
		      parser.textNode = c;
		      parser.state = S.TEXT;
		    }
		  }

		  function charAt (chunk, i) {
		    var result = '';
		    if (i < chunk.length) {
		      result = chunk.charAt(i);
		    }
		    return result
		  }

		  function write (chunk) {
		    var parser = this;
		    if (this.error) {
		      throw this.error
		    }
		    if (parser.closed) {
		      return error(parser,
		        'Cannot write after close. Assign an onready handler.')
		    }
		    if (chunk === null) {
		      return end(parser)
		    }
		    if (typeof chunk === 'object') {
		      chunk = chunk.toString();
		    }
		    var i = 0;
		    var c = '';
		    while (true) {
		      c = charAt(chunk, i++);
		      parser.c = c;

		      if (!c) {
		        break
		      }

		      if (parser.trackPosition) {
		        parser.position++;
		        if (c === '\n') {
		          parser.line++;
		          parser.column = 0;
		        } else {
		          parser.column++;
		        }
		      }

		      switch (parser.state) {
		        case S.BEGIN:
		          parser.state = S.BEGIN_WHITESPACE;
		          if (c === '\uFEFF') {
		            continue
		          }
		          beginWhiteSpace(parser, c);
		          continue

		        case S.BEGIN_WHITESPACE:
		          beginWhiteSpace(parser, c);
		          continue

		        case S.TEXT:
		          if (parser.sawRoot && !parser.closedRoot) {
		            var starti = i - 1;
		            while (c && c !== '<' && c !== '&') {
		              c = charAt(chunk, i++);
		              if (c && parser.trackPosition) {
		                parser.position++;
		                if (c === '\n') {
		                  parser.line++;
		                  parser.column = 0;
		                } else {
		                  parser.column++;
		                }
		              }
		            }
		            parser.textNode += chunk.substring(starti, i - 1);
		          }
		          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
		            parser.state = S.OPEN_WAKA;
		            parser.startTagPosition = parser.position;
		          } else {
		            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
		              strictFail(parser, 'Text data outside of root node.');
		            }
		            if (c === '&') {
		              parser.state = S.TEXT_ENTITY;
		            } else {
		              parser.textNode += c;
		            }
		          }
		          continue

		        case S.SCRIPT:
		          // only non-strict
		          if (c === '<') {
		            parser.state = S.SCRIPT_ENDING;
		          } else {
		            parser.script += c;
		          }
		          continue

		        case S.SCRIPT_ENDING:
		          if (c === '/') {
		            parser.state = S.CLOSE_TAG;
		          } else {
		            parser.script += '<' + c;
		            parser.state = S.SCRIPT;
		          }
		          continue

		        case S.OPEN_WAKA:
		          // either a /, ?, !, or text is coming next.
		          if (c === '!') {
		            parser.state = S.SGML_DECL;
		            parser.sgmlDecl = '';
		          } else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) {
		            parser.state = S.OPEN_TAG;
		            parser.tagName = c;
		          } else if (c === '/') {
		            parser.state = S.CLOSE_TAG;
		            parser.tagName = '';
		          } else if (c === '?') {
		            parser.state = S.PROC_INST;
		            parser.procInstName = parser.procInstBody = '';
		          } else {
		            strictFail(parser, 'Unencoded <');
		            // if there was some whitespace, then add that in.
		            if (parser.startTagPosition + 1 < parser.position) {
		              var pad = parser.position - parser.startTagPosition;
		              c = new Array(pad).join(' ') + c;
		            }
		            parser.textNode += '<' + c;
		            parser.state = S.TEXT;
		          }
		          continue

		        case S.SGML_DECL:
		          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
		            emitNode(parser, 'onopencdata');
		            parser.state = S.CDATA;
		            parser.sgmlDecl = '';
		            parser.cdata = '';
		          } else if (parser.sgmlDecl + c === '--') {
		            parser.state = S.COMMENT;
		            parser.comment = '';
		            parser.sgmlDecl = '';
		          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
		            parser.state = S.DOCTYPE;
		            if (parser.doctype || parser.sawRoot) {
		              strictFail(parser,
		                'Inappropriately located doctype declaration');
		            }
		            parser.doctype = '';
		            parser.sgmlDecl = '';
		          } else if (c === '>') {
		            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
		            parser.sgmlDecl = '';
		            parser.state = S.TEXT;
		          } else if (isQuote(c)) {
		            parser.state = S.SGML_DECL_QUOTED;
		            parser.sgmlDecl += c;
		          } else {
		            parser.sgmlDecl += c;
		          }
		          continue

		        case S.SGML_DECL_QUOTED:
		          if (c === parser.q) {
		            parser.state = S.SGML_DECL;
		            parser.q = '';
		          }
		          parser.sgmlDecl += c;
		          continue

		        case S.DOCTYPE:
		          if (c === '>') {
		            parser.state = S.TEXT;
		            emitNode(parser, 'ondoctype', parser.doctype);
		            parser.doctype = true; // just remember that we saw it.
		          } else {
		            parser.doctype += c;
		            if (c === '[') {
		              parser.state = S.DOCTYPE_DTD;
		            } else if (isQuote(c)) {
		              parser.state = S.DOCTYPE_QUOTED;
		              parser.q = c;
		            }
		          }
		          continue

		        case S.DOCTYPE_QUOTED:
		          parser.doctype += c;
		          if (c === parser.q) {
		            parser.q = '';
		            parser.state = S.DOCTYPE;
		          }
		          continue

		        case S.DOCTYPE_DTD:
		          parser.doctype += c;
		          if (c === ']') {
		            parser.state = S.DOCTYPE;
		          } else if (isQuote(c)) {
		            parser.state = S.DOCTYPE_DTD_QUOTED;
		            parser.q = c;
		          }
		          continue

		        case S.DOCTYPE_DTD_QUOTED:
		          parser.doctype += c;
		          if (c === parser.q) {
		            parser.state = S.DOCTYPE_DTD;
		            parser.q = '';
		          }
		          continue

		        case S.COMMENT:
		          if (c === '-') {
		            parser.state = S.COMMENT_ENDING;
		          } else {
		            parser.comment += c;
		          }
		          continue

		        case S.COMMENT_ENDING:
		          if (c === '-') {
		            parser.state = S.COMMENT_ENDED;
		            parser.comment = textopts(parser.opt, parser.comment);
		            if (parser.comment) {
		              emitNode(parser, 'oncomment', parser.comment);
		            }
		            parser.comment = '';
		          } else {
		            parser.comment += '-' + c;
		            parser.state = S.COMMENT;
		          }
		          continue

		        case S.COMMENT_ENDED:
		          if (c !== '>') {
		            strictFail(parser, 'Malformed comment');
		            // allow <!-- blah -- bloo --> in non-strict mode,
		            // which is a comment of " blah -- bloo "
		            parser.comment += '--' + c;
		            parser.state = S.COMMENT;
		          } else {
		            parser.state = S.TEXT;
		          }
		          continue

		        case S.CDATA:
		          if (c === ']') {
		            parser.state = S.CDATA_ENDING;
		          } else {
		            parser.cdata += c;
		          }
		          continue

		        case S.CDATA_ENDING:
		          if (c === ']') {
		            parser.state = S.CDATA_ENDING_2;
		          } else {
		            parser.cdata += ']' + c;
		            parser.state = S.CDATA;
		          }
		          continue

		        case S.CDATA_ENDING_2:
		          if (c === '>') {
		            if (parser.cdata) {
		              emitNode(parser, 'oncdata', parser.cdata);
		            }
		            emitNode(parser, 'onclosecdata');
		            parser.cdata = '';
		            parser.state = S.TEXT;
		          } else if (c === ']') {
		            parser.cdata += ']';
		          } else {
		            parser.cdata += ']]' + c;
		            parser.state = S.CDATA;
		          }
		          continue

		        case S.PROC_INST:
		          if (c === '?') {
		            parser.state = S.PROC_INST_ENDING;
		          } else if (isWhitespace(c)) {
		            parser.state = S.PROC_INST_BODY;
		          } else {
		            parser.procInstName += c;
		          }
		          continue

		        case S.PROC_INST_BODY:
		          if (!parser.procInstBody && isWhitespace(c)) {
		            continue
		          } else if (c === '?') {
		            parser.state = S.PROC_INST_ENDING;
		          } else {
		            parser.procInstBody += c;
		          }
		          continue

		        case S.PROC_INST_ENDING:
		          if (c === '>') {
		            emitNode(parser, 'onprocessinginstruction', {
		              name: parser.procInstName,
		              body: parser.procInstBody
		            });
		            parser.procInstName = parser.procInstBody = '';
		            parser.state = S.TEXT;
		          } else {
		            parser.procInstBody += '?' + c;
		            parser.state = S.PROC_INST_BODY;
		          }
		          continue

		        case S.OPEN_TAG:
		          if (isMatch(nameBody, c)) {
		            parser.tagName += c;
		          } else {
		            newTag(parser);
		            if (c === '>') {
		              openTag(parser);
		            } else if (c === '/') {
		              parser.state = S.OPEN_TAG_SLASH;
		            } else {
		              if (!isWhitespace(c)) {
		                strictFail(parser, 'Invalid character in tag name');
		              }
		              parser.state = S.ATTRIB;
		            }
		          }
		          continue

		        case S.OPEN_TAG_SLASH:
		          if (c === '>') {
		            openTag(parser, true);
		            closeTag(parser);
		          } else {
		            strictFail(parser, 'Forward-slash in opening tag not followed by >');
		            parser.state = S.ATTRIB;
		          }
		          continue

		        case S.ATTRIB:
		          // haven't read the attribute name yet.
		          if (isWhitespace(c)) {
		            continue
		          } else if (c === '>') {
		            openTag(parser);
		          } else if (c === '/') {
		            parser.state = S.OPEN_TAG_SLASH;
		          } else if (isMatch(nameStart, c)) {
		            parser.attribName = c;
		            parser.attribValue = '';
		            parser.state = S.ATTRIB_NAME;
		          } else {
		            strictFail(parser, 'Invalid attribute name');
		          }
		          continue

		        case S.ATTRIB_NAME:
		          if (c === '=') {
		            parser.state = S.ATTRIB_VALUE;
		          } else if (c === '>') {
		            strictFail(parser, 'Attribute without value');
		            parser.attribValue = parser.attribName;
		            attrib(parser);
		            openTag(parser);
		          } else if (isWhitespace(c)) {
		            parser.state = S.ATTRIB_NAME_SAW_WHITE;
		          } else if (isMatch(nameBody, c)) {
		            parser.attribName += c;
		          } else {
		            strictFail(parser, 'Invalid attribute name');
		          }
		          continue

		        case S.ATTRIB_NAME_SAW_WHITE:
		          if (c === '=') {
		            parser.state = S.ATTRIB_VALUE;
		          } else if (isWhitespace(c)) {
		            continue
		          } else {
		            strictFail(parser, 'Attribute without value');
		            parser.tag.attributes[parser.attribName] = '';
		            parser.attribValue = '';
		            emitNode(parser, 'onattribute', {
		              name: parser.attribName,
		              value: ''
		            });
		            parser.attribName = '';
		            if (c === '>') {
		              openTag(parser);
		            } else if (isMatch(nameStart, c)) {
		              parser.attribName = c;
		              parser.state = S.ATTRIB_NAME;
		            } else {
		              strictFail(parser, 'Invalid attribute name');
		              parser.state = S.ATTRIB;
		            }
		          }
		          continue

		        case S.ATTRIB_VALUE:
		          if (isWhitespace(c)) {
		            continue
		          } else if (isQuote(c)) {
		            parser.q = c;
		            parser.state = S.ATTRIB_VALUE_QUOTED;
		          } else {
		            strictFail(parser, 'Unquoted attribute value');
		            parser.state = S.ATTRIB_VALUE_UNQUOTED;
		            parser.attribValue = c;
		          }
		          continue

		        case S.ATTRIB_VALUE_QUOTED:
		          if (c !== parser.q) {
		            if (c === '&') {
		              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
		            } else {
		              parser.attribValue += c;
		            }
		            continue
		          }
		          attrib(parser);
		          parser.q = '';
		          parser.state = S.ATTRIB_VALUE_CLOSED;
		          continue

		        case S.ATTRIB_VALUE_CLOSED:
		          if (isWhitespace(c)) {
		            parser.state = S.ATTRIB;
		          } else if (c === '>') {
		            openTag(parser);
		          } else if (c === '/') {
		            parser.state = S.OPEN_TAG_SLASH;
		          } else if (isMatch(nameStart, c)) {
		            strictFail(parser, 'No whitespace between attributes');
		            parser.attribName = c;
		            parser.attribValue = '';
		            parser.state = S.ATTRIB_NAME;
		          } else {
		            strictFail(parser, 'Invalid attribute name');
		          }
		          continue

		        case S.ATTRIB_VALUE_UNQUOTED:
		          if (!isAttribEnd(c)) {
		            if (c === '&') {
		              parser.state = S.ATTRIB_VALUE_ENTITY_U;
		            } else {
		              parser.attribValue += c;
		            }
		            continue
		          }
		          attrib(parser);
		          if (c === '>') {
		            openTag(parser);
		          } else {
		            parser.state = S.ATTRIB;
		          }
		          continue

		        case S.CLOSE_TAG:
		          if (!parser.tagName) {
		            if (isWhitespace(c)) {
		              continue
		            } else if (notMatch(nameStart, c)) {
		              if (parser.script) {
		                parser.script += '</' + c;
		                parser.state = S.SCRIPT;
		              } else {
		                strictFail(parser, 'Invalid tagname in closing tag.');
		              }
		            } else {
		              parser.tagName = c;
		            }
		          } else if (c === '>') {
		            closeTag(parser);
		          } else if (isMatch(nameBody, c)) {
		            parser.tagName += c;
		          } else if (parser.script) {
		            parser.script += '</' + parser.tagName;
		            parser.tagName = '';
		            parser.state = S.SCRIPT;
		          } else {
		            if (!isWhitespace(c)) {
		              strictFail(parser, 'Invalid tagname in closing tag');
		            }
		            parser.state = S.CLOSE_TAG_SAW_WHITE;
		          }
		          continue

		        case S.CLOSE_TAG_SAW_WHITE:
		          if (isWhitespace(c)) {
		            continue
		          }
		          if (c === '>') {
		            closeTag(parser);
		          } else {
		            strictFail(parser, 'Invalid characters in closing tag');
		          }
		          continue

		        case S.TEXT_ENTITY:
		        case S.ATTRIB_VALUE_ENTITY_Q:
		        case S.ATTRIB_VALUE_ENTITY_U:
		          var returnState;
		          var buffer;
		          switch (parser.state) {
		            case S.TEXT_ENTITY:
		              returnState = S.TEXT;
		              buffer = 'textNode';
		              break

		            case S.ATTRIB_VALUE_ENTITY_Q:
		              returnState = S.ATTRIB_VALUE_QUOTED;
		              buffer = 'attribValue';
		              break

		            case S.ATTRIB_VALUE_ENTITY_U:
		              returnState = S.ATTRIB_VALUE_UNQUOTED;
		              buffer = 'attribValue';
		              break
		          }

		          if (c === ';') {
		            if (parser.opt.unparsedEntities) {
		              var parsedEntity = parseEntity(parser);
		              parser.entity = '';
		              parser.state = returnState;
		              parser.write(parsedEntity);
		            } else {
		              parser[buffer] += parseEntity(parser);
		              parser.entity = '';
		              parser.state = returnState;
		            }
		          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
		            parser.entity += c;
		          } else {
		            strictFail(parser, 'Invalid character in entity name');
		            parser[buffer] += '&' + parser.entity + c;
		            parser.entity = '';
		            parser.state = returnState;
		          }

		          continue

		        default: /* istanbul ignore next */ {
		          throw new Error(parser, 'Unknown state: ' + parser.state)
		        }
		      }
		    } // while

		    if (parser.position >= parser.bufferCheckPosition) {
		      checkBufferLength(parser);
		    }
		    return parser
		  }

		  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
		  /* istanbul ignore next */
		  if (!String.fromCodePoint) {
		    (function () {
		      var stringFromCharCode = String.fromCharCode;
		      var floor = Math.floor;
		      var fromCodePoint = function () {
		        var MAX_SIZE = 0x4000;
		        var codeUnits = [];
		        var highSurrogate;
		        var lowSurrogate;
		        var index = -1;
		        var length = arguments.length;
		        if (!length) {
		          return ''
		        }
		        var result = '';
		        while (++index < length) {
		          var codePoint = Number(arguments[index]);
		          if (
		            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
		            codePoint < 0 || // not a valid Unicode code point
		            codePoint > 0x10FFFF || // not a valid Unicode code point
		            floor(codePoint) !== codePoint // not an integer
		          ) {
		            throw RangeError('Invalid code point: ' + codePoint)
		          }
		          if (codePoint <= 0xFFFF) { // BMP code point
		            codeUnits.push(codePoint);
		          } else { // Astral code point; split in surrogate halves
		            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
		            codePoint -= 0x10000;
		            highSurrogate = (codePoint >> 10) + 0xD800;
		            lowSurrogate = (codePoint % 0x400) + 0xDC00;
		            codeUnits.push(highSurrogate, lowSurrogate);
		          }
		          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
		            result += stringFromCharCode.apply(null, codeUnits);
		            codeUnits.length = 0;
		          }
		        }
		        return result
		      };
		      /* istanbul ignore next */
		      if (Object.defineProperty) {
		        Object.defineProperty(String, 'fromCodePoint', {
		          value: fromCodePoint,
		          configurable: true,
		          writable: true
		        });
		      } else {
		        String.fromCodePoint = fromCodePoint;
		      }
		    }());
		  }
		})(typeof exports === 'undefined' ? this.sax = {} : exports);

		}).call(this);}).call(this,require("buffer").Buffer);
		},{"buffer":103,"stream":468,"string_decoder":483}],466:[function(require,module,exports){

		var GetIntrinsic = require('get-intrinsic');
		var define = require('define-data-property');
		var hasDescriptors = require('has-property-descriptors')();
		var gOPD = require('gopd');

		var $TypeError = GetIntrinsic('%TypeError%');
		var $floor = GetIntrinsic('%Math.floor%');

		/** @typedef {(...args: unknown[]) => unknown} Func */

		/** @type {<T extends Func = Func>(fn: T, length: number, loose?: boolean) => T} */
		module.exports = function setFunctionLength(fn, length) {
			if (typeof fn !== 'function') {
				throw new $TypeError('`fn` is not a function');
			}
			if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
				throw new $TypeError('`length` must be a positive 32-bit integer');
			}

			var loose = arguments.length > 2 && !!arguments[2];

			var functionLengthIsConfigurable = true;
			var functionLengthIsWritable = true;
			if ('length' in fn && gOPD) {
				var desc = gOPD(fn, 'length');
				if (desc && !desc.configurable) {
					functionLengthIsConfigurable = false;
				}
				if (desc && !desc.writable) {
					functionLengthIsWritable = false;
				}
			}

			if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
				if (hasDescriptors) {
					define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
				} else {
					define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
				}
			}
			return fn;
		};

		},{"define-data-property":384,"get-intrinsic":390,"gopd":391,"has-property-descriptors":392}],467:[function(require,module,exports){

		var GetIntrinsic = require('get-intrinsic');
		var callBound = require('call-bind/callBound');
		var inspect = require('object-inspect');

		var $TypeError = GetIntrinsic('%TypeError%');
		var $WeakMap = GetIntrinsic('%WeakMap%', true);
		var $Map = GetIntrinsic('%Map%', true);

		var $weakMapGet = callBound('WeakMap.prototype.get', true);
		var $weakMapSet = callBound('WeakMap.prototype.set', true);
		var $weakMapHas = callBound('WeakMap.prototype.has', true);
		var $mapGet = callBound('Map.prototype.get', true);
		var $mapSet = callBound('Map.prototype.set', true);
		var $mapHas = callBound('Map.prototype.has', true);

		/*
		 * This function traverses the list returning the node corresponding to the
		 * given key.
		 *
		 * That node is also moved to the head of the list, so that if it's accessed
		 * again we don't need to traverse the whole list. By doing so, all the recently
		 * used nodes can be accessed relatively quickly.
		 */
		var listGetNode = function (list, key) { // eslint-disable-line consistent-return
			for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
				if (curr.key === key) {
					prev.next = curr.next;
					curr.next = list.next;
					list.next = curr; // eslint-disable-line no-param-reassign
					return curr;
				}
			}
		};

		var listGet = function (objects, key) {
			var node = listGetNode(objects, key);
			return node && node.value;
		};
		var listSet = function (objects, key, value) {
			var node = listGetNode(objects, key);
			if (node) {
				node.value = value;
			} else {
				// Prepend the new node to the beginning of the list
				objects.next = { // eslint-disable-line no-param-reassign
					key: key,
					next: objects.next,
					value: value
				};
			}
		};
		var listHas = function (objects, key) {
			return !!listGetNode(objects, key);
		};

		module.exports = function getSideChannel() {
			var $wm;
			var $m;
			var $o;
			var channel = {
				assert: function (key) {
					if (!channel.has(key)) {
						throw new $TypeError('Side channel does not contain ' + inspect(key));
					}
				},
				get: function (key) { // eslint-disable-line consistent-return
					if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
						if ($wm) {
							return $weakMapGet($wm, key);
						}
					} else if ($Map) {
						if ($m) {
							return $mapGet($m, key);
						}
					} else {
						if ($o) { // eslint-disable-line no-lonely-if
							return listGet($o, key);
						}
					}
				},
				has: function (key) {
					if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
						if ($wm) {
							return $weakMapHas($wm, key);
						}
					} else if ($Map) {
						if ($m) {
							return $mapHas($m, key);
						}
					} else {
						if ($o) { // eslint-disable-line no-lonely-if
							return listHas($o, key);
						}
					}
					return false;
				},
				set: function (key, value) {
					if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
						if (!$wm) {
							$wm = new $WeakMap();
						}
						$weakMapSet($wm, key, value);
					} else if ($Map) {
						if (!$m) {
							$m = new $Map();
						}
						$mapSet($m, key, value);
					} else {
						if (!$o) {
							/*
							 * Initialize the linked list as an empty node, so that we don't have
							 * to special-case handling of the first node: we can always refer to
							 * it as (previous node).next, instead of something like (list).head
							 */
							$o = { key: {}, next: null };
						}
						listSet($o, key, value);
					}
				}
			};
			return channel;
		};

		},{"call-bind/callBound":105,"get-intrinsic":390,"object-inspect":433}],468:[function(require,module,exports){
		// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.

		module.exports = Stream;

		var EE = require('events').EventEmitter;
		var inherits = require('inherits');

		inherits(Stream, EE);
		Stream.Readable = require('readable-stream/lib/_stream_readable.js');
		Stream.Writable = require('readable-stream/lib/_stream_writable.js');
		Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
		Stream.Transform = require('readable-stream/lib/_stream_transform.js');
		Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
		Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js');
		Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js');

		// Backwards-compat with node 0.4.x
		Stream.Stream = Stream;



		// old-style streams.  Note that the pipe method (the only relevant
		// part of this class) is overridden in the Readable class.

		function Stream() {
		  EE.call(this);
		}

		Stream.prototype.pipe = function(dest, options) {
		  var source = this;

		  function ondata(chunk) {
		    if (dest.writable) {
		      if (false === dest.write(chunk) && source.pause) {
		        source.pause();
		      }
		    }
		  }

		  source.on('data', ondata);

		  function ondrain() {
		    if (source.readable && source.resume) {
		      source.resume();
		    }
		  }

		  dest.on('drain', ondrain);

		  // If the 'end' option is not supplied, dest.end() will be called when
		  // source gets the 'end' or 'close' events.  Only dest.end() once.
		  if (!dest._isStdio && (!options || options.end !== false)) {
		    source.on('end', onend);
		    source.on('close', onclose);
		  }

		  var didOnEnd = false;
		  function onend() {
		    if (didOnEnd) return;
		    didOnEnd = true;

		    dest.end();
		  }


		  function onclose() {
		    if (didOnEnd) return;
		    didOnEnd = true;

		    if (typeof dest.destroy === 'function') dest.destroy();
		  }

		  // don't leave dangling pipes when there are errors.
		  function onerror(er) {
		    cleanup();
		    if (EE.listenerCount(this, 'error') === 0) {
		      throw er; // Unhandled stream error in pipe.
		    }
		  }

		  source.on('error', onerror);
		  dest.on('error', onerror);

		  // remove all the event listeners that were added.
		  function cleanup() {
		    source.removeListener('data', ondata);
		    dest.removeListener('drain', ondrain);

		    source.removeListener('end', onend);
		    source.removeListener('close', onclose);

		    source.removeListener('error', onerror);
		    dest.removeListener('error', onerror);

		    source.removeListener('end', cleanup);
		    source.removeListener('close', cleanup);

		    dest.removeListener('close', cleanup);
		  }

		  source.on('end', cleanup);
		  source.on('close', cleanup);

		  dest.on('close', cleanup);

		  dest.emit('pipe', source);

		  // Allow for unix-like usage: A.pipe(B).pipe(C)
		  return dest;
		};

		},{"events":386,"inherits":407,"readable-stream/lib/_stream_duplex.js":470,"readable-stream/lib/_stream_passthrough.js":471,"readable-stream/lib/_stream_readable.js":472,"readable-stream/lib/_stream_transform.js":473,"readable-stream/lib/_stream_writable.js":474,"readable-stream/lib/internal/streams/end-of-stream.js":478,"readable-stream/lib/internal/streams/pipeline.js":480}],469:[function(require,module,exports){

		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

		var codes = {};

		function createErrorType(code, message, Base) {
		  if (!Base) {
		    Base = Error;
		  }

		  function getMessage(arg1, arg2, arg3) {
		    if (typeof message === 'string') {
		      return message;
		    } else {
		      return message(arg1, arg2, arg3);
		    }
		  }

		  var NodeError =
		  /*#__PURE__*/
		  function (_Base) {
		    _inheritsLoose(NodeError, _Base);

		    function NodeError(arg1, arg2, arg3) {
		      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
		    }

		    return NodeError;
		  }(Base);

		  NodeError.prototype.name = Base.name;
		  NodeError.prototype.code = code;
		  codes[code] = NodeError;
		} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


		function oneOf(expected, thing) {
		  if (Array.isArray(expected)) {
		    var len = expected.length;
		    expected = expected.map(function (i) {
		      return String(i);
		    });

		    if (len > 2) {
		      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
		    } else if (len === 2) {
		      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
		    } else {
		      return "of ".concat(thing, " ").concat(expected[0]);
		    }
		  } else {
		    return "of ".concat(thing, " ").concat(String(expected));
		  }
		} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


		function startsWith(str, search, pos) {
		  return str.substr(0 , search.length) === search;
		} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


		function endsWith(str, search, this_len) {
		  if (this_len === undefined || this_len > str.length) {
		    this_len = str.length;
		  }

		  return str.substring(this_len - search.length, this_len) === search;
		} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


		function includes(str, search, start) {
		  if (typeof start !== 'number') {
		    start = 0;
		  }

		  if (start + search.length > str.length) {
		    return false;
		  } else {
		    return str.indexOf(search, start) !== -1;
		  }
		}

		createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
		  return 'The value "' + value + '" is invalid for option "' + name + '"';
		}, TypeError);
		createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
		  // determiner: 'must be' or 'must not be'
		  var determiner;

		  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
		    determiner = 'must not be';
		    expected = expected.replace(/^not /, '');
		  } else {
		    determiner = 'must be';
		  }

		  var msg;

		  if (endsWith(name, ' argument')) {
		    // For cases like 'first argument'
		    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
		  } else {
		    var type = includes(name, '.') ? 'property' : 'argument';
		    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
		  }

		  msg += ". Received type ".concat(typeof actual);
		  return msg;
		}, TypeError);
		createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
		createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
		  return 'The ' + name + ' method is not implemented';
		});
		createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
		createErrorType('ERR_STREAM_DESTROYED', function (name) {
		  return 'Cannot call ' + name + ' after a stream was destroyed';
		});
		createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
		createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
		createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
		createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
		createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
		  return 'Unknown encoding: ' + arg;
		}, TypeError);
		createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
		module.exports.codes = codes;

		},{}],470:[function(require,module,exports){
		(function (process){(function (){

		/*<replacement>*/
		var objectKeys = Object.keys || function (obj) {
		  var keys = [];
		  for (var key in obj) keys.push(key);
		  return keys;
		};
		/*</replacement>*/

		module.exports = Duplex;
		var Readable = require('./_stream_readable');
		var Writable = require('./_stream_writable');
		require('inherits')(Duplex, Readable);
		{
		  // Allow the keys array to be GC'ed.
		  var keys = objectKeys(Writable.prototype);
		  for (var v = 0; v < keys.length; v++) {
		    var method = keys[v];
		    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
		  }
		}
		function Duplex(options) {
		  if (!(this instanceof Duplex)) return new Duplex(options);
		  Readable.call(this, options);
		  Writable.call(this, options);
		  this.allowHalfOpen = true;
		  if (options) {
		    if (options.readable === false) this.readable = false;
		    if (options.writable === false) this.writable = false;
		    if (options.allowHalfOpen === false) {
		      this.allowHalfOpen = false;
		      this.once('end', onend);
		    }
		  }
		}
		Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState.highWaterMark;
		  }
		});
		Object.defineProperty(Duplex.prototype, 'writableBuffer', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState && this._writableState.getBuffer();
		  }
		});
		Object.defineProperty(Duplex.prototype, 'writableLength', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState.length;
		  }
		});

		// the no-half-open enforcer
		function onend() {
		  // If the writable side ended, then we're ok.
		  if (this._writableState.ended) return;

		  // no more data can be written.
		  // But allow more writes to happen in this tick.
		  process.nextTick(onEndNT, this);
		}
		function onEndNT(self) {
		  self.end();
		}
		Object.defineProperty(Duplex.prototype, 'destroyed', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    if (this._readableState === undefined || this._writableState === undefined) {
		      return false;
		    }
		    return this._readableState.destroyed && this._writableState.destroyed;
		  },
		  set: function set(value) {
		    // we ignore the value if the stream
		    // has not been initialized yet
		    if (this._readableState === undefined || this._writableState === undefined) {
		      return;
		    }

		    // backward compatibility, the user is explicitly
		    // managing destroyed
		    this._readableState.destroyed = value;
		    this._writableState.destroyed = value;
		  }
		});
		}).call(this);}).call(this,require('_process'));
		},{"./_stream_readable":472,"./_stream_writable":474,"_process":538,"inherits":407}],471:[function(require,module,exports){

		module.exports = PassThrough;
		var Transform = require('./_stream_transform');
		require('inherits')(PassThrough, Transform);
		function PassThrough(options) {
		  if (!(this instanceof PassThrough)) return new PassThrough(options);
		  Transform.call(this, options);
		}
		PassThrough.prototype._transform = function (chunk, encoding, cb) {
		  cb(null, chunk);
		};
		},{"./_stream_transform":473,"inherits":407}],472:[function(require,module,exports){
		(function (process,global){(function (){

		module.exports = Readable;

		/*<replacement>*/
		var Duplex;
		/*</replacement>*/

		Readable.ReadableState = ReadableState;

		/*<replacement>*/
		require('events').EventEmitter;
		var EElistenerCount = function EElistenerCount(emitter, type) {
		  return emitter.listeners(type).length;
		};
		/*</replacement>*/

		/*<replacement>*/
		var Stream = require('./internal/streams/stream');
		/*</replacement>*/

		var Buffer = require('buffer').Buffer;
		var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
		function _uint8ArrayToBuffer(chunk) {
		  return Buffer.from(chunk);
		}
		function _isUint8Array(obj) {
		  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
		}

		/*<replacement>*/
		var debugUtil = require('util');
		var debug;
		if (debugUtil && debugUtil.debuglog) {
		  debug = debugUtil.debuglog('stream');
		} else {
		  debug = function debug() {};
		}
		/*</replacement>*/

		var BufferList = require('./internal/streams/buffer_list');
		var destroyImpl = require('./internal/streams/destroy');
		var _require = require('./internal/streams/state'),
		  getHighWaterMark = _require.getHighWaterMark;
		var _require$codes = require('../errors').codes,
		  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
		  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
		  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
		  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

		// Lazy loaded to improve the startup performance.
		var StringDecoder;
		var createReadableStreamAsyncIterator;
		var from;
		require('inherits')(Readable, Stream);
		var errorOrDestroy = destroyImpl.errorOrDestroy;
		var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
		function prependListener(emitter, event, fn) {
		  // Sadly this is not cacheable as some libraries bundle their own
		  // event emitter implementation with them.
		  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

		  // This is a hack to make sure that our error handler is attached before any
		  // userland ones.  NEVER DO THIS. This is here only because this code needs
		  // to continue to work with older versions of Node.js that do not include
		  // the prependListener() method. The goal is to eventually remove this hack.
		  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
		}
		function ReadableState(options, stream, isDuplex) {
		  Duplex = Duplex || require('./_stream_duplex');
		  options = options || {};

		  // Duplex streams are both readable and writable, but share
		  // the same options object.
		  // However, some cases require setting options to different
		  // values for the readable and the writable sides of the duplex stream.
		  // These options can be provided separately as readableXXX and writableXXX.
		  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

		  // object stream flag. Used to make read(n) ignore n and to
		  // make all the buffer merging and length checks go away
		  this.objectMode = !!options.objectMode;
		  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

		  // the point at which it stops calling _read() to fill the buffer
		  // Note: 0 is a valid value, means "don't call _read preemptively ever"
		  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

		  // A linked list is used to store data chunks instead of an array because the
		  // linked list can remove elements from the beginning faster than
		  // array.shift()
		  this.buffer = new BufferList();
		  this.length = 0;
		  this.pipes = null;
		  this.pipesCount = 0;
		  this.flowing = null;
		  this.ended = false;
		  this.endEmitted = false;
		  this.reading = false;

		  // a flag to be able to tell if the event 'readable'/'data' is emitted
		  // immediately, or on a later tick.  We set this to true at first, because
		  // any actions that shouldn't happen until "later" should generally also
		  // not happen before the first read call.
		  this.sync = true;

		  // whenever we return null, then we set a flag to say
		  // that we're awaiting a 'readable' event emission.
		  this.needReadable = false;
		  this.emittedReadable = false;
		  this.readableListening = false;
		  this.resumeScheduled = false;
		  this.paused = true;

		  // Should close be emitted on destroy. Defaults to true.
		  this.emitClose = options.emitClose !== false;

		  // Should .destroy() be called after 'end' (and potentially 'finish')
		  this.autoDestroy = !!options.autoDestroy;

		  // has it been destroyed
		  this.destroyed = false;

		  // Crypto is kind of old and crusty.  Historically, its default string
		  // encoding is 'binary' so we have to make this configurable.
		  // Everything else in the universe uses 'utf8', though.
		  this.defaultEncoding = options.defaultEncoding || 'utf8';

		  // the number of writers that are awaiting a drain event in .pipe()s
		  this.awaitDrain = 0;

		  // if true, a maybeReadMore has been scheduled
		  this.readingMore = false;
		  this.decoder = null;
		  this.encoding = null;
		  if (options.encoding) {
		    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
		    this.decoder = new StringDecoder(options.encoding);
		    this.encoding = options.encoding;
		  }
		}
		function Readable(options) {
		  Duplex = Duplex || require('./_stream_duplex');
		  if (!(this instanceof Readable)) return new Readable(options);

		  // Checking for a Stream.Duplex instance is faster here instead of inside
		  // the ReadableState constructor, at least with V8 6.5
		  var isDuplex = this instanceof Duplex;
		  this._readableState = new ReadableState(options, this, isDuplex);

		  // legacy
		  this.readable = true;
		  if (options) {
		    if (typeof options.read === 'function') this._read = options.read;
		    if (typeof options.destroy === 'function') this._destroy = options.destroy;
		  }
		  Stream.call(this);
		}
		Object.defineProperty(Readable.prototype, 'destroyed', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    if (this._readableState === undefined) {
		      return false;
		    }
		    return this._readableState.destroyed;
		  },
		  set: function set(value) {
		    // we ignore the value if the stream
		    // has not been initialized yet
		    if (!this._readableState) {
		      return;
		    }

		    // backward compatibility, the user is explicitly
		    // managing destroyed
		    this._readableState.destroyed = value;
		  }
		});
		Readable.prototype.destroy = destroyImpl.destroy;
		Readable.prototype._undestroy = destroyImpl.undestroy;
		Readable.prototype._destroy = function (err, cb) {
		  cb(err);
		};

		// Manually shove something into the read() buffer.
		// This returns true if the highWaterMark has not been hit yet,
		// similar to how Writable.write() returns true if you should
		// write() some more.
		Readable.prototype.push = function (chunk, encoding) {
		  var state = this._readableState;
		  var skipChunkCheck;
		  if (!state.objectMode) {
		    if (typeof chunk === 'string') {
		      encoding = encoding || state.defaultEncoding;
		      if (encoding !== state.encoding) {
		        chunk = Buffer.from(chunk, encoding);
		        encoding = '';
		      }
		      skipChunkCheck = true;
		    }
		  } else {
		    skipChunkCheck = true;
		  }
		  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
		};

		// Unshift should *always* be something directly out of read()
		Readable.prototype.unshift = function (chunk) {
		  return readableAddChunk(this, chunk, null, true, false);
		};
		function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
		  debug('readableAddChunk', chunk);
		  var state = stream._readableState;
		  if (chunk === null) {
		    state.reading = false;
		    onEofChunk(stream, state);
		  } else {
		    var er;
		    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
		    if (er) {
		      errorOrDestroy(stream, er);
		    } else if (state.objectMode || chunk && chunk.length > 0) {
		      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
		        chunk = _uint8ArrayToBuffer(chunk);
		      }
		      if (addToFront) {
		        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
		      } else if (state.ended) {
		        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
		      } else if (state.destroyed) {
		        return false;
		      } else {
		        state.reading = false;
		        if (state.decoder && !encoding) {
		          chunk = state.decoder.write(chunk);
		          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
		        } else {
		          addChunk(stream, state, chunk, false);
		        }
		      }
		    } else if (!addToFront) {
		      state.reading = false;
		      maybeReadMore(stream, state);
		    }
		  }

		  // We can push more data if we are below the highWaterMark.
		  // Also, if we have no data yet, we can stand some more bytes.
		  // This is to work around cases where hwm=0, such as the repl.
		  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
		}
		function addChunk(stream, state, chunk, addToFront) {
		  if (state.flowing && state.length === 0 && !state.sync) {
		    state.awaitDrain = 0;
		    stream.emit('data', chunk);
		  } else {
		    // update the buffer info.
		    state.length += state.objectMode ? 1 : chunk.length;
		    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
		    if (state.needReadable) emitReadable(stream);
		  }
		  maybeReadMore(stream, state);
		}
		function chunkInvalid(state, chunk) {
		  var er;
		  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
		    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
		  }
		  return er;
		}
		Readable.prototype.isPaused = function () {
		  return this._readableState.flowing === false;
		};

		// backwards compatibility.
		Readable.prototype.setEncoding = function (enc) {
		  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
		  var decoder = new StringDecoder(enc);
		  this._readableState.decoder = decoder;
		  // If setEncoding(null), decoder.encoding equals utf8
		  this._readableState.encoding = this._readableState.decoder.encoding;

		  // Iterate over current buffer to convert already stored Buffers:
		  var p = this._readableState.buffer.head;
		  var content = '';
		  while (p !== null) {
		    content += decoder.write(p.data);
		    p = p.next;
		  }
		  this._readableState.buffer.clear();
		  if (content !== '') this._readableState.buffer.push(content);
		  this._readableState.length = content.length;
		  return this;
		};

		// Don't raise the hwm > 1GB
		var MAX_HWM = 0x40000000;
		function computeNewHighWaterMark(n) {
		  if (n >= MAX_HWM) {
		    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
		    n = MAX_HWM;
		  } else {
		    // Get the next highest power of 2 to prevent increasing hwm excessively in
		    // tiny amounts
		    n--;
		    n |= n >>> 1;
		    n |= n >>> 2;
		    n |= n >>> 4;
		    n |= n >>> 8;
		    n |= n >>> 16;
		    n++;
		  }
		  return n;
		}

		// This function is designed to be inlinable, so please take care when making
		// changes to the function body.
		function howMuchToRead(n, state) {
		  if (n <= 0 || state.length === 0 && state.ended) return 0;
		  if (state.objectMode) return 1;
		  if (n !== n) {
		    // Only flow one buffer at a time
		    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
		  }
		  // If we're asking for more than the current hwm, then raise the hwm.
		  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
		  if (n <= state.length) return n;
		  // Don't have enough
		  if (!state.ended) {
		    state.needReadable = true;
		    return 0;
		  }
		  return state.length;
		}

		// you can override either this method, or the async _read(n) below.
		Readable.prototype.read = function (n) {
		  debug('read', n);
		  n = parseInt(n, 10);
		  var state = this._readableState;
		  var nOrig = n;
		  if (n !== 0) state.emittedReadable = false;

		  // if we're doing read(0) to trigger a readable event, but we
		  // already have a bunch of data in the buffer, then just trigger
		  // the 'readable' event and move on.
		  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
		    debug('read: emitReadable', state.length, state.ended);
		    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
		    return null;
		  }
		  n = howMuchToRead(n, state);

		  // if we've ended, and we're now clear, then finish it up.
		  if (n === 0 && state.ended) {
		    if (state.length === 0) endReadable(this);
		    return null;
		  }

		  // All the actual chunk generation logic needs to be
		  // *below* the call to _read.  The reason is that in certain
		  // synthetic stream cases, such as passthrough streams, _read
		  // may be a completely synchronous operation which may change
		  // the state of the read buffer, providing enough data when
		  // before there was *not* enough.
		  //
		  // So, the steps are:
		  // 1. Figure out what the state of things will be after we do
		  // a read from the buffer.
		  //
		  // 2. If that resulting state will trigger a _read, then call _read.
		  // Note that this may be asynchronous, or synchronous.  Yes, it is
		  // deeply ugly to write APIs this way, but that still doesn't mean
		  // that the Readable class should behave improperly, as streams are
		  // designed to be sync/async agnostic.
		  // Take note if the _read call is sync or async (ie, if the read call
		  // has returned yet), so that we know whether or not it's safe to emit
		  // 'readable' etc.
		  //
		  // 3. Actually pull the requested chunks out of the buffer and return.

		  // if we need a readable event, then we need to do some reading.
		  var doRead = state.needReadable;
		  debug('need readable', doRead);

		  // if we currently have less than the highWaterMark, then also read some
		  if (state.length === 0 || state.length - n < state.highWaterMark) {
		    doRead = true;
		    debug('length less than watermark', doRead);
		  }

		  // however, if we've ended, then there's no point, and if we're already
		  // reading, then it's unnecessary.
		  if (state.ended || state.reading) {
		    doRead = false;
		    debug('reading or ended', doRead);
		  } else if (doRead) {
		    debug('do read');
		    state.reading = true;
		    state.sync = true;
		    // if the length is currently zero, then we *need* a readable event.
		    if (state.length === 0) state.needReadable = true;
		    // call internal read method
		    this._read(state.highWaterMark);
		    state.sync = false;
		    // If _read pushed data synchronously, then `reading` will be false,
		    // and we need to re-evaluate how much data we can return to the user.
		    if (!state.reading) n = howMuchToRead(nOrig, state);
		  }
		  var ret;
		  if (n > 0) ret = fromList(n, state);else ret = null;
		  if (ret === null) {
		    state.needReadable = state.length <= state.highWaterMark;
		    n = 0;
		  } else {
		    state.length -= n;
		    state.awaitDrain = 0;
		  }
		  if (state.length === 0) {
		    // If we have nothing in the buffer, then we want to know
		    // as soon as we *do* get something into the buffer.
		    if (!state.ended) state.needReadable = true;

		    // If we tried to read() past the EOF, then emit end on the next tick.
		    if (nOrig !== n && state.ended) endReadable(this);
		  }
		  if (ret !== null) this.emit('data', ret);
		  return ret;
		};
		function onEofChunk(stream, state) {
		  debug('onEofChunk');
		  if (state.ended) return;
		  if (state.decoder) {
		    var chunk = state.decoder.end();
		    if (chunk && chunk.length) {
		      state.buffer.push(chunk);
		      state.length += state.objectMode ? 1 : chunk.length;
		    }
		  }
		  state.ended = true;
		  if (state.sync) {
		    // if we are sync, wait until next tick to emit the data.
		    // Otherwise we risk emitting data in the flow()
		    // the readable code triggers during a read() call
		    emitReadable(stream);
		  } else {
		    // emit 'readable' now to make sure it gets picked up.
		    state.needReadable = false;
		    if (!state.emittedReadable) {
		      state.emittedReadable = true;
		      emitReadable_(stream);
		    }
		  }
		}

		// Don't emit readable right away in sync mode, because this can trigger
		// another read() call => stack overflow.  This way, it might trigger
		// a nextTick recursion warning, but that's not so bad.
		function emitReadable(stream) {
		  var state = stream._readableState;
		  debug('emitReadable', state.needReadable, state.emittedReadable);
		  state.needReadable = false;
		  if (!state.emittedReadable) {
		    debug('emitReadable', state.flowing);
		    state.emittedReadable = true;
		    process.nextTick(emitReadable_, stream);
		  }
		}
		function emitReadable_(stream) {
		  var state = stream._readableState;
		  debug('emitReadable_', state.destroyed, state.length, state.ended);
		  if (!state.destroyed && (state.length || state.ended)) {
		    stream.emit('readable');
		    state.emittedReadable = false;
		  }

		  // The stream needs another readable event if
		  // 1. It is not flowing, as the flow mechanism will take
		  //    care of it.
		  // 2. It is not ended.
		  // 3. It is below the highWaterMark, so we can schedule
		  //    another readable later.
		  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
		  flow(stream);
		}

		// at this point, the user has presumably seen the 'readable' event,
		// and called read() to consume some data.  that may have triggered
		// in turn another _read(n) call, in which case reading = true if
		// it's in progress.
		// However, if we're not ended, or reading, and the length < hwm,
		// then go ahead and try to read some more preemptively.
		function maybeReadMore(stream, state) {
		  if (!state.readingMore) {
		    state.readingMore = true;
		    process.nextTick(maybeReadMore_, stream, state);
		  }
		}
		function maybeReadMore_(stream, state) {
		  // Attempt to read more data if we should.
		  //
		  // The conditions for reading more data are (one of):
		  // - Not enough data buffered (state.length < state.highWaterMark). The loop
		  //   is responsible for filling the buffer with enough data if such data
		  //   is available. If highWaterMark is 0 and we are not in the flowing mode
		  //   we should _not_ attempt to buffer any extra data. We'll get more data
		  //   when the stream consumer calls read() instead.
		  // - No data in the buffer, and the stream is in flowing mode. In this mode
		  //   the loop below is responsible for ensuring read() is called. Failing to
		  //   call read here would abort the flow and there's no other mechanism for
		  //   continuing the flow if the stream consumer has just subscribed to the
		  //   'data' event.
		  //
		  // In addition to the above conditions to keep reading data, the following
		  // conditions prevent the data from being read:
		  // - The stream has ended (state.ended).
		  // - There is already a pending 'read' operation (state.reading). This is a
		  //   case where the the stream has called the implementation defined _read()
		  //   method, but they are processing the call asynchronously and have _not_
		  //   called push() with new data. In this case we skip performing more
		  //   read()s. The execution ends in this method again after the _read() ends
		  //   up calling push() with more data.
		  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
		    var len = state.length;
		    debug('maybeReadMore read 0');
		    stream.read(0);
		    if (len === state.length)
		      // didn't get any data, stop spinning.
		      break;
		  }
		  state.readingMore = false;
		}

		// abstract method.  to be overridden in specific implementation classes.
		// call cb(er, data) where data is <= n in length.
		// for virtual (non-string, non-buffer) streams, "length" is somewhat
		// arbitrary, and perhaps not very meaningful.
		Readable.prototype._read = function (n) {
		  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
		};
		Readable.prototype.pipe = function (dest, pipeOpts) {
		  var src = this;
		  var state = this._readableState;
		  switch (state.pipesCount) {
		    case 0:
		      state.pipes = dest;
		      break;
		    case 1:
		      state.pipes = [state.pipes, dest];
		      break;
		    default:
		      state.pipes.push(dest);
		      break;
		  }
		  state.pipesCount += 1;
		  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
		  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
		  var endFn = doEnd ? onend : unpipe;
		  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
		  dest.on('unpipe', onunpipe);
		  function onunpipe(readable, unpipeInfo) {
		    debug('onunpipe');
		    if (readable === src) {
		      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
		        unpipeInfo.hasUnpiped = true;
		        cleanup();
		      }
		    }
		  }
		  function onend() {
		    debug('onend');
		    dest.end();
		  }

		  // when the dest drains, it reduces the awaitDrain counter
		  // on the source.  This would be more elegant with a .once()
		  // handler in flow(), but adding and removing repeatedly is
		  // too slow.
		  var ondrain = pipeOnDrain(src);
		  dest.on('drain', ondrain);
		  var cleanedUp = false;
		  function cleanup() {
		    debug('cleanup');
		    // cleanup event handlers once the pipe is broken
		    dest.removeListener('close', onclose);
		    dest.removeListener('finish', onfinish);
		    dest.removeListener('drain', ondrain);
		    dest.removeListener('error', onerror);
		    dest.removeListener('unpipe', onunpipe);
		    src.removeListener('end', onend);
		    src.removeListener('end', unpipe);
		    src.removeListener('data', ondata);
		    cleanedUp = true;

		    // if the reader is waiting for a drain event from this
		    // specific writer, then it would cause it to never start
		    // flowing again.
		    // So, if this is awaiting a drain, then we just call it now.
		    // If we don't know, then assume that we are waiting for one.
		    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
		  }
		  src.on('data', ondata);
		  function ondata(chunk) {
		    debug('ondata');
		    var ret = dest.write(chunk);
		    debug('dest.write', ret);
		    if (ret === false) {
		      // If the user unpiped during `dest.write()`, it is possible
		      // to get stuck in a permanently paused state if that write
		      // also returned false.
		      // => Check whether `dest` is still a piping destination.
		      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
		        debug('false write response, pause', state.awaitDrain);
		        state.awaitDrain++;
		      }
		      src.pause();
		    }
		  }

		  // if the dest has an error, then stop piping into it.
		  // however, don't suppress the throwing behavior for this.
		  function onerror(er) {
		    debug('onerror', er);
		    unpipe();
		    dest.removeListener('error', onerror);
		    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
		  }

		  // Make sure our error handler is attached before userland ones.
		  prependListener(dest, 'error', onerror);

		  // Both close and finish should trigger unpipe, but only once.
		  function onclose() {
		    dest.removeListener('finish', onfinish);
		    unpipe();
		  }
		  dest.once('close', onclose);
		  function onfinish() {
		    debug('onfinish');
		    dest.removeListener('close', onclose);
		    unpipe();
		  }
		  dest.once('finish', onfinish);
		  function unpipe() {
		    debug('unpipe');
		    src.unpipe(dest);
		  }

		  // tell the dest that it's being piped to
		  dest.emit('pipe', src);

		  // start the flow if it hasn't been started already.
		  if (!state.flowing) {
		    debug('pipe resume');
		    src.resume();
		  }
		  return dest;
		};
		function pipeOnDrain(src) {
		  return function pipeOnDrainFunctionResult() {
		    var state = src._readableState;
		    debug('pipeOnDrain', state.awaitDrain);
		    if (state.awaitDrain) state.awaitDrain--;
		    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
		      state.flowing = true;
		      flow(src);
		    }
		  };
		}
		Readable.prototype.unpipe = function (dest) {
		  var state = this._readableState;
		  var unpipeInfo = {
		    hasUnpiped: false
		  };

		  // if we're not piping anywhere, then do nothing.
		  if (state.pipesCount === 0) return this;

		  // just one destination.  most common case.
		  if (state.pipesCount === 1) {
		    // passed in one, but it's not the right one.
		    if (dest && dest !== state.pipes) return this;
		    if (!dest) dest = state.pipes;

		    // got a match.
		    state.pipes = null;
		    state.pipesCount = 0;
		    state.flowing = false;
		    if (dest) dest.emit('unpipe', this, unpipeInfo);
		    return this;
		  }

		  // slow case. multiple pipe destinations.

		  if (!dest) {
		    // remove all.
		    var dests = state.pipes;
		    var len = state.pipesCount;
		    state.pipes = null;
		    state.pipesCount = 0;
		    state.flowing = false;
		    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
		      hasUnpiped: false
		    });
		    return this;
		  }

		  // try to find the right one.
		  var index = indexOf(state.pipes, dest);
		  if (index === -1) return this;
		  state.pipes.splice(index, 1);
		  state.pipesCount -= 1;
		  if (state.pipesCount === 1) state.pipes = state.pipes[0];
		  dest.emit('unpipe', this, unpipeInfo);
		  return this;
		};

		// set up data events if they are asked for
		// Ensure readable listeners eventually get something
		Readable.prototype.on = function (ev, fn) {
		  var res = Stream.prototype.on.call(this, ev, fn);
		  var state = this._readableState;
		  if (ev === 'data') {
		    // update readableListening so that resume() may be a no-op
		    // a few lines down. This is needed to support once('readable').
		    state.readableListening = this.listenerCount('readable') > 0;

		    // Try start flowing on next tick if stream isn't explicitly paused
		    if (state.flowing !== false) this.resume();
		  } else if (ev === 'readable') {
		    if (!state.endEmitted && !state.readableListening) {
		      state.readableListening = state.needReadable = true;
		      state.flowing = false;
		      state.emittedReadable = false;
		      debug('on readable', state.length, state.reading);
		      if (state.length) {
		        emitReadable(this);
		      } else if (!state.reading) {
		        process.nextTick(nReadingNextTick, this);
		      }
		    }
		  }
		  return res;
		};
		Readable.prototype.addListener = Readable.prototype.on;
		Readable.prototype.removeListener = function (ev, fn) {
		  var res = Stream.prototype.removeListener.call(this, ev, fn);
		  if (ev === 'readable') {
		    // We need to check if there is someone still listening to
		    // readable and reset the state. However this needs to happen
		    // after readable has been emitted but before I/O (nextTick) to
		    // support once('readable', fn) cycles. This means that calling
		    // resume within the same tick will have no
		    // effect.
		    process.nextTick(updateReadableListening, this);
		  }
		  return res;
		};
		Readable.prototype.removeAllListeners = function (ev) {
		  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
		  if (ev === 'readable' || ev === undefined) {
		    // We need to check if there is someone still listening to
		    // readable and reset the state. However this needs to happen
		    // after readable has been emitted but before I/O (nextTick) to
		    // support once('readable', fn) cycles. This means that calling
		    // resume within the same tick will have no
		    // effect.
		    process.nextTick(updateReadableListening, this);
		  }
		  return res;
		};
		function updateReadableListening(self) {
		  var state = self._readableState;
		  state.readableListening = self.listenerCount('readable') > 0;
		  if (state.resumeScheduled && !state.paused) {
		    // flowing needs to be set to true now, otherwise
		    // the upcoming resume will not flow.
		    state.flowing = true;

		    // crude way to check if we should resume
		  } else if (self.listenerCount('data') > 0) {
		    self.resume();
		  }
		}
		function nReadingNextTick(self) {
		  debug('readable nexttick read 0');
		  self.read(0);
		}

		// pause() and resume() are remnants of the legacy readable stream API
		// If the user uses them, then switch into old mode.
		Readable.prototype.resume = function () {
		  var state = this._readableState;
		  if (!state.flowing) {
		    debug('resume');
		    // we flow only if there is no one listening
		    // for readable, but we still have to call
		    // resume()
		    state.flowing = !state.readableListening;
		    resume(this, state);
		  }
		  state.paused = false;
		  return this;
		};
		function resume(stream, state) {
		  if (!state.resumeScheduled) {
		    state.resumeScheduled = true;
		    process.nextTick(resume_, stream, state);
		  }
		}
		function resume_(stream, state) {
		  debug('resume', state.reading);
		  if (!state.reading) {
		    stream.read(0);
		  }
		  state.resumeScheduled = false;
		  stream.emit('resume');
		  flow(stream);
		  if (state.flowing && !state.reading) stream.read(0);
		}
		Readable.prototype.pause = function () {
		  debug('call pause flowing=%j', this._readableState.flowing);
		  if (this._readableState.flowing !== false) {
		    debug('pause');
		    this._readableState.flowing = false;
		    this.emit('pause');
		  }
		  this._readableState.paused = true;
		  return this;
		};
		function flow(stream) {
		  var state = stream._readableState;
		  debug('flow', state.flowing);
		  while (state.flowing && stream.read() !== null);
		}

		// wrap an old-style stream as the async data source.
		// This is *not* part of the readable stream interface.
		// It is an ugly unfortunate mess of history.
		Readable.prototype.wrap = function (stream) {
		  var _this = this;
		  var state = this._readableState;
		  var paused = false;
		  stream.on('end', function () {
		    debug('wrapped end');
		    if (state.decoder && !state.ended) {
		      var chunk = state.decoder.end();
		      if (chunk && chunk.length) _this.push(chunk);
		    }
		    _this.push(null);
		  });
		  stream.on('data', function (chunk) {
		    debug('wrapped data');
		    if (state.decoder) chunk = state.decoder.write(chunk);

		    // don't skip over falsy values in objectMode
		    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
		    var ret = _this.push(chunk);
		    if (!ret) {
		      paused = true;
		      stream.pause();
		    }
		  });

		  // proxy all the other methods.
		  // important when wrapping filters and duplexes.
		  for (var i in stream) {
		    if (this[i] === undefined && typeof stream[i] === 'function') {
		      this[i] = function methodWrap(method) {
		        return function methodWrapReturnFunction() {
		          return stream[method].apply(stream, arguments);
		        };
		      }(i);
		    }
		  }

		  // proxy certain important events.
		  for (var n = 0; n < kProxyEvents.length; n++) {
		    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
		  }

		  // when we try to consume some more bytes, simply unpause the
		  // underlying stream.
		  this._read = function (n) {
		    debug('wrapped _read', n);
		    if (paused) {
		      paused = false;
		      stream.resume();
		    }
		  };
		  return this;
		};
		if (typeof Symbol === 'function') {
		  Readable.prototype[Symbol.asyncIterator] = function () {
		    if (createReadableStreamAsyncIterator === undefined) {
		      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
		    }
		    return createReadableStreamAsyncIterator(this);
		  };
		}
		Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._readableState.highWaterMark;
		  }
		});
		Object.defineProperty(Readable.prototype, 'readableBuffer', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._readableState && this._readableState.buffer;
		  }
		});
		Object.defineProperty(Readable.prototype, 'readableFlowing', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._readableState.flowing;
		  },
		  set: function set(state) {
		    if (this._readableState) {
		      this._readableState.flowing = state;
		    }
		  }
		});

		// exposed for testing purposes only.
		Readable._fromList = fromList;
		Object.defineProperty(Readable.prototype, 'readableLength', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._readableState.length;
		  }
		});

		// Pluck off n bytes from an array of buffers.
		// Length is the combined lengths of all the buffers in the list.
		// This function is designed to be inlinable, so please take care when making
		// changes to the function body.
		function fromList(n, state) {
		  // nothing buffered
		  if (state.length === 0) return null;
		  var ret;
		  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
		    // read it all, truncate the list
		    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
		    state.buffer.clear();
		  } else {
		    // read part of list
		    ret = state.buffer.consume(n, state.decoder);
		  }
		  return ret;
		}
		function endReadable(stream) {
		  var state = stream._readableState;
		  debug('endReadable', state.endEmitted);
		  if (!state.endEmitted) {
		    state.ended = true;
		    process.nextTick(endReadableNT, state, stream);
		  }
		}
		function endReadableNT(state, stream) {
		  debug('endReadableNT', state.endEmitted, state.length);

		  // Check that we didn't get one last unshift.
		  if (!state.endEmitted && state.length === 0) {
		    state.endEmitted = true;
		    stream.readable = false;
		    stream.emit('end');
		    if (state.autoDestroy) {
		      // In case of duplex streams we need a way to detect
		      // if the writable side is ready for autoDestroy as well
		      var wState = stream._writableState;
		      if (!wState || wState.autoDestroy && wState.finished) {
		        stream.destroy();
		      }
		    }
		  }
		}
		if (typeof Symbol === 'function') {
		  Readable.from = function (iterable, opts) {
		    if (from === undefined) {
		      from = require('./internal/streams/from');
		    }
		    return from(Readable, iterable, opts);
		  };
		}
		function indexOf(xs, x) {
		  for (var i = 0, l = xs.length; i < l; i++) {
		    if (xs[i] === x) return i;
		  }
		  return -1;
		}
		}).call(this);}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{"../errors":469,"./_stream_duplex":470,"./internal/streams/async_iterator":475,"./internal/streams/buffer_list":476,"./internal/streams/destroy":477,"./internal/streams/from":479,"./internal/streams/state":481,"./internal/streams/stream":482,"_process":538,"buffer":103,"events":386,"inherits":407,"string_decoder/":483,"util":102}],473:[function(require,module,exports){

		module.exports = Transform;
		var _require$codes = require('../errors').codes,
		  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
		  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
		  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
		  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
		var Duplex = require('./_stream_duplex');
		require('inherits')(Transform, Duplex);
		function afterTransform(er, data) {
		  var ts = this._transformState;
		  ts.transforming = false;
		  var cb = ts.writecb;
		  if (cb === null) {
		    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
		  }
		  ts.writechunk = null;
		  ts.writecb = null;
		  if (data != null)
		    // single equals check for both `null` and `undefined`
		    this.push(data);
		  cb(er);
		  var rs = this._readableState;
		  rs.reading = false;
		  if (rs.needReadable || rs.length < rs.highWaterMark) {
		    this._read(rs.highWaterMark);
		  }
		}
		function Transform(options) {
		  if (!(this instanceof Transform)) return new Transform(options);
		  Duplex.call(this, options);
		  this._transformState = {
		    afterTransform: afterTransform.bind(this),
		    needTransform: false,
		    transforming: false,
		    writecb: null,
		    writechunk: null,
		    writeencoding: null
		  };

		  // start out asking for a readable event once data is transformed.
		  this._readableState.needReadable = true;

		  // we have implemented the _read method, and done the other things
		  // that Readable wants before the first _read call, so unset the
		  // sync guard flag.
		  this._readableState.sync = false;
		  if (options) {
		    if (typeof options.transform === 'function') this._transform = options.transform;
		    if (typeof options.flush === 'function') this._flush = options.flush;
		  }

		  // When the writable side finishes, then flush out anything remaining.
		  this.on('prefinish', prefinish);
		}
		function prefinish() {
		  var _this = this;
		  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
		    this._flush(function (er, data) {
		      done(_this, er, data);
		    });
		  } else {
		    done(this, null, null);
		  }
		}
		Transform.prototype.push = function (chunk, encoding) {
		  this._transformState.needTransform = false;
		  return Duplex.prototype.push.call(this, chunk, encoding);
		};

		// This is the part where you do stuff!
		// override this function in implementation classes.
		// 'chunk' is an input chunk.
		//
		// Call `push(newChunk)` to pass along transformed output
		// to the readable side.  You may call 'push' zero or more times.
		//
		// Call `cb(err)` when you are done with this chunk.  If you pass
		// an error, then that'll put the hurt on the whole operation.  If you
		// never call cb(), then you'll never get another chunk.
		Transform.prototype._transform = function (chunk, encoding, cb) {
		  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
		};
		Transform.prototype._write = function (chunk, encoding, cb) {
		  var ts = this._transformState;
		  ts.writecb = cb;
		  ts.writechunk = chunk;
		  ts.writeencoding = encoding;
		  if (!ts.transforming) {
		    var rs = this._readableState;
		    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
		  }
		};

		// Doesn't matter what the args are here.
		// _transform does all the work.
		// That we got here means that the readable side wants more data.
		Transform.prototype._read = function (n) {
		  var ts = this._transformState;
		  if (ts.writechunk !== null && !ts.transforming) {
		    ts.transforming = true;
		    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
		  } else {
		    // mark that we need a transform, so that any data that comes in
		    // will get processed, now that we've asked for it.
		    ts.needTransform = true;
		  }
		};
		Transform.prototype._destroy = function (err, cb) {
		  Duplex.prototype._destroy.call(this, err, function (err2) {
		    cb(err2);
		  });
		};
		function done(stream, er, data) {
		  if (er) return stream.emit('error', er);
		  if (data != null)
		    // single equals check for both `null` and `undefined`
		    stream.push(data);

		  // TODO(BridgeAR): Write a test for these two error cases
		  // if there's nothing in the write buffer, then that means
		  // that nothing more will ever be provided
		  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
		  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
		  return stream.push(null);
		}
		},{"../errors":469,"./_stream_duplex":470,"inherits":407}],474:[function(require,module,exports){
		(function (process,global){(function (){

		module.exports = Writable;

		// It seems a linked list but it is not
		// there will be only 2 of these for each stream
		function CorkedRequest(state) {
		  var _this = this;
		  this.next = null;
		  this.entry = null;
		  this.finish = function () {
		    onCorkedFinish(_this, state);
		  };
		}
		/* </replacement> */

		/*<replacement>*/
		var Duplex;
		/*</replacement>*/

		Writable.WritableState = WritableState;

		/*<replacement>*/
		var internalUtil = {
		  deprecate: require('util-deprecate')
		};
		/*</replacement>*/

		/*<replacement>*/
		var Stream = require('./internal/streams/stream');
		/*</replacement>*/

		var Buffer = require('buffer').Buffer;
		var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
		function _uint8ArrayToBuffer(chunk) {
		  return Buffer.from(chunk);
		}
		function _isUint8Array(obj) {
		  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
		}
		var destroyImpl = require('./internal/streams/destroy');
		var _require = require('./internal/streams/state'),
		  getHighWaterMark = _require.getHighWaterMark;
		var _require$codes = require('../errors').codes,
		  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
		  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
		  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
		  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
		  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
		  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
		  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
		  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
		var errorOrDestroy = destroyImpl.errorOrDestroy;
		require('inherits')(Writable, Stream);
		function nop() {}
		function WritableState(options, stream, isDuplex) {
		  Duplex = Duplex || require('./_stream_duplex');
		  options = options || {};

		  // Duplex streams are both readable and writable, but share
		  // the same options object.
		  // However, some cases require setting options to different
		  // values for the readable and the writable sides of the duplex stream,
		  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
		  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

		  // object stream flag to indicate whether or not this stream
		  // contains buffers or objects.
		  this.objectMode = !!options.objectMode;
		  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

		  // the point at which write() starts returning false
		  // Note: 0 is a valid value, means that we always return false if
		  // the entire buffer is not flushed immediately on write()
		  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

		  // if _final has been called
		  this.finalCalled = false;

		  // drain event flag.
		  this.needDrain = false;
		  // at the start of calling end()
		  this.ending = false;
		  // when end() has been called, and returned
		  this.ended = false;
		  // when 'finish' is emitted
		  this.finished = false;

		  // has it been destroyed
		  this.destroyed = false;

		  // should we decode strings into buffers before passing to _write?
		  // this is here so that some node-core streams can optimize string
		  // handling at a lower level.
		  var noDecode = options.decodeStrings === false;
		  this.decodeStrings = !noDecode;

		  // Crypto is kind of old and crusty.  Historically, its default string
		  // encoding is 'binary' so we have to make this configurable.
		  // Everything else in the universe uses 'utf8', though.
		  this.defaultEncoding = options.defaultEncoding || 'utf8';

		  // not an actual buffer we keep track of, but a measurement
		  // of how much we're waiting to get pushed to some underlying
		  // socket or file.
		  this.length = 0;

		  // a flag to see when we're in the middle of a write.
		  this.writing = false;

		  // when true all writes will be buffered until .uncork() call
		  this.corked = 0;

		  // a flag to be able to tell if the onwrite cb is called immediately,
		  // or on a later tick.  We set this to true at first, because any
		  // actions that shouldn't happen until "later" should generally also
		  // not happen before the first write call.
		  this.sync = true;

		  // a flag to know if we're processing previously buffered items, which
		  // may call the _write() callback in the same tick, so that we don't
		  // end up in an overlapped onwrite situation.
		  this.bufferProcessing = false;

		  // the callback that's passed to _write(chunk,cb)
		  this.onwrite = function (er) {
		    onwrite(stream, er);
		  };

		  // the callback that the user supplies to write(chunk,encoding,cb)
		  this.writecb = null;

		  // the amount that is being written when _write is called.
		  this.writelen = 0;
		  this.bufferedRequest = null;
		  this.lastBufferedRequest = null;

		  // number of pending user-supplied write callbacks
		  // this must be 0 before 'finish' can be emitted
		  this.pendingcb = 0;

		  // emit prefinish if the only thing we're waiting for is _write cbs
		  // This is relevant for synchronous Transform streams
		  this.prefinished = false;

		  // True if the error was already emitted and should not be thrown again
		  this.errorEmitted = false;

		  // Should close be emitted on destroy. Defaults to true.
		  this.emitClose = options.emitClose !== false;

		  // Should .destroy() be called after 'finish' (and potentially 'end')
		  this.autoDestroy = !!options.autoDestroy;

		  // count buffered requests
		  this.bufferedRequestCount = 0;

		  // allocate the first CorkedRequest, there is always
		  // one allocated and free to use, and we maintain at most two
		  this.corkedRequestsFree = new CorkedRequest(this);
		}
		WritableState.prototype.getBuffer = function getBuffer() {
		  var current = this.bufferedRequest;
		  var out = [];
		  while (current) {
		    out.push(current);
		    current = current.next;
		  }
		  return out;
		};
		(function () {
		  try {
		    Object.defineProperty(WritableState.prototype, 'buffer', {
		      get: internalUtil.deprecate(function writableStateBufferGetter() {
		        return this.getBuffer();
		      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
		    });
		  } catch (_) {}
		})();

		// Test _writableState for inheritance to account for Duplex streams,
		// whose prototype chain only points to Readable.
		var realHasInstance;
		if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
		  realHasInstance = Function.prototype[Symbol.hasInstance];
		  Object.defineProperty(Writable, Symbol.hasInstance, {
		    value: function value(object) {
		      if (realHasInstance.call(this, object)) return true;
		      if (this !== Writable) return false;
		      return object && object._writableState instanceof WritableState;
		    }
		  });
		} else {
		  realHasInstance = function realHasInstance(object) {
		    return object instanceof this;
		  };
		}
		function Writable(options) {
		  Duplex = Duplex || require('./_stream_duplex');

		  // Writable ctor is applied to Duplexes, too.
		  // `realHasInstance` is necessary because using plain `instanceof`
		  // would return false, as no `_writableState` property is attached.

		  // Trying to use the custom `instanceof` for Writable here will also break the
		  // Node.js LazyTransform implementation, which has a non-trivial getter for
		  // `_writableState` that would lead to infinite recursion.

		  // Checking for a Stream.Duplex instance is faster here instead of inside
		  // the WritableState constructor, at least with V8 6.5
		  var isDuplex = this instanceof Duplex;
		  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
		  this._writableState = new WritableState(options, this, isDuplex);

		  // legacy.
		  this.writable = true;
		  if (options) {
		    if (typeof options.write === 'function') this._write = options.write;
		    if (typeof options.writev === 'function') this._writev = options.writev;
		    if (typeof options.destroy === 'function') this._destroy = options.destroy;
		    if (typeof options.final === 'function') this._final = options.final;
		  }
		  Stream.call(this);
		}

		// Otherwise people can pipe Writable streams, which is just wrong.
		Writable.prototype.pipe = function () {
		  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
		};
		function writeAfterEnd(stream, cb) {
		  var er = new ERR_STREAM_WRITE_AFTER_END();
		  // TODO: defer error events consistently everywhere, not just the cb
		  errorOrDestroy(stream, er);
		  process.nextTick(cb, er);
		}

		// Checks that a user-supplied chunk is valid, especially for the particular
		// mode the stream is in. Currently this means that `null` is never accepted
		// and undefined/non-string values are only allowed in object mode.
		function validChunk(stream, state, chunk, cb) {
		  var er;
		  if (chunk === null) {
		    er = new ERR_STREAM_NULL_VALUES();
		  } else if (typeof chunk !== 'string' && !state.objectMode) {
		    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
		  }
		  if (er) {
		    errorOrDestroy(stream, er);
		    process.nextTick(cb, er);
		    return false;
		  }
		  return true;
		}
		Writable.prototype.write = function (chunk, encoding, cb) {
		  var state = this._writableState;
		  var ret = false;
		  var isBuf = !state.objectMode && _isUint8Array(chunk);
		  if (isBuf && !Buffer.isBuffer(chunk)) {
		    chunk = _uint8ArrayToBuffer(chunk);
		  }
		  if (typeof encoding === 'function') {
		    cb = encoding;
		    encoding = null;
		  }
		  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
		  if (typeof cb !== 'function') cb = nop;
		  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
		    state.pendingcb++;
		    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
		  }
		  return ret;
		};
		Writable.prototype.cork = function () {
		  this._writableState.corked++;
		};
		Writable.prototype.uncork = function () {
		  var state = this._writableState;
		  if (state.corked) {
		    state.corked--;
		    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
		  }
		};
		Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
		  // node::ParseEncoding() requires lower case.
		  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
		  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
		  this._writableState.defaultEncoding = encoding;
		  return this;
		};
		Object.defineProperty(Writable.prototype, 'writableBuffer', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState && this._writableState.getBuffer();
		  }
		});
		function decodeChunk(state, chunk, encoding) {
		  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
		    chunk = Buffer.from(chunk, encoding);
		  }
		  return chunk;
		}
		Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState.highWaterMark;
		  }
		});

		// if we're already writing something, then just put this
		// in the queue, and wait our turn.  Otherwise, call _write
		// If we return false, then we need a drain event, so set that flag.
		function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
		  if (!isBuf) {
		    var newChunk = decodeChunk(state, chunk, encoding);
		    if (chunk !== newChunk) {
		      isBuf = true;
		      encoding = 'buffer';
		      chunk = newChunk;
		    }
		  }
		  var len = state.objectMode ? 1 : chunk.length;
		  state.length += len;
		  var ret = state.length < state.highWaterMark;
		  // we must ensure that previous needDrain will not be reset to false.
		  if (!ret) state.needDrain = true;
		  if (state.writing || state.corked) {
		    var last = state.lastBufferedRequest;
		    state.lastBufferedRequest = {
		      chunk: chunk,
		      encoding: encoding,
		      isBuf: isBuf,
		      callback: cb,
		      next: null
		    };
		    if (last) {
		      last.next = state.lastBufferedRequest;
		    } else {
		      state.bufferedRequest = state.lastBufferedRequest;
		    }
		    state.bufferedRequestCount += 1;
		  } else {
		    doWrite(stream, state, false, len, chunk, encoding, cb);
		  }
		  return ret;
		}
		function doWrite(stream, state, writev, len, chunk, encoding, cb) {
		  state.writelen = len;
		  state.writecb = cb;
		  state.writing = true;
		  state.sync = true;
		  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
		  state.sync = false;
		}
		function onwriteError(stream, state, sync, er, cb) {
		  --state.pendingcb;
		  if (sync) {
		    // defer the callback if we are being called synchronously
		    // to avoid piling up things on the stack
		    process.nextTick(cb, er);
		    // this can emit finish, and it will always happen
		    // after error
		    process.nextTick(finishMaybe, stream, state);
		    stream._writableState.errorEmitted = true;
		    errorOrDestroy(stream, er);
		  } else {
		    // the caller expect this to happen before if
		    // it is async
		    cb(er);
		    stream._writableState.errorEmitted = true;
		    errorOrDestroy(stream, er);
		    // this can emit finish, but finish must
		    // always follow error
		    finishMaybe(stream, state);
		  }
		}
		function onwriteStateUpdate(state) {
		  state.writing = false;
		  state.writecb = null;
		  state.length -= state.writelen;
		  state.writelen = 0;
		}
		function onwrite(stream, er) {
		  var state = stream._writableState;
		  var sync = state.sync;
		  var cb = state.writecb;
		  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
		  onwriteStateUpdate(state);
		  if (er) onwriteError(stream, state, sync, er, cb);else {
		    // Check if we're actually ready to finish, but don't emit yet
		    var finished = needFinish(state) || stream.destroyed;
		    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
		      clearBuffer(stream, state);
		    }
		    if (sync) {
		      process.nextTick(afterWrite, stream, state, finished, cb);
		    } else {
		      afterWrite(stream, state, finished, cb);
		    }
		  }
		}
		function afterWrite(stream, state, finished, cb) {
		  if (!finished) onwriteDrain(stream, state);
		  state.pendingcb--;
		  cb();
		  finishMaybe(stream, state);
		}

		// Must force callback to be called on nextTick, so that we don't
		// emit 'drain' before the write() consumer gets the 'false' return
		// value, and has a chance to attach a 'drain' listener.
		function onwriteDrain(stream, state) {
		  if (state.length === 0 && state.needDrain) {
		    state.needDrain = false;
		    stream.emit('drain');
		  }
		}

		// if there's something in the buffer waiting, then process it
		function clearBuffer(stream, state) {
		  state.bufferProcessing = true;
		  var entry = state.bufferedRequest;
		  if (stream._writev && entry && entry.next) {
		    // Fast case, write everything using _writev()
		    var l = state.bufferedRequestCount;
		    var buffer = new Array(l);
		    var holder = state.corkedRequestsFree;
		    holder.entry = entry;
		    var count = 0;
		    var allBuffers = true;
		    while (entry) {
		      buffer[count] = entry;
		      if (!entry.isBuf) allBuffers = false;
		      entry = entry.next;
		      count += 1;
		    }
		    buffer.allBuffers = allBuffers;
		    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

		    // doWrite is almost always async, defer these to save a bit of time
		    // as the hot path ends with doWrite
		    state.pendingcb++;
		    state.lastBufferedRequest = null;
		    if (holder.next) {
		      state.corkedRequestsFree = holder.next;
		      holder.next = null;
		    } else {
		      state.corkedRequestsFree = new CorkedRequest(state);
		    }
		    state.bufferedRequestCount = 0;
		  } else {
		    // Slow case, write chunks one-by-one
		    while (entry) {
		      var chunk = entry.chunk;
		      var encoding = entry.encoding;
		      var cb = entry.callback;
		      var len = state.objectMode ? 1 : chunk.length;
		      doWrite(stream, state, false, len, chunk, encoding, cb);
		      entry = entry.next;
		      state.bufferedRequestCount--;
		      // if we didn't call the onwrite immediately, then
		      // it means that we need to wait until it does.
		      // also, that means that the chunk and cb are currently
		      // being processed, so move the buffer counter past them.
		      if (state.writing) {
		        break;
		      }
		    }
		    if (entry === null) state.lastBufferedRequest = null;
		  }
		  state.bufferedRequest = entry;
		  state.bufferProcessing = false;
		}
		Writable.prototype._write = function (chunk, encoding, cb) {
		  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
		};
		Writable.prototype._writev = null;
		Writable.prototype.end = function (chunk, encoding, cb) {
		  var state = this._writableState;
		  if (typeof chunk === 'function') {
		    cb = chunk;
		    chunk = null;
		    encoding = null;
		  } else if (typeof encoding === 'function') {
		    cb = encoding;
		    encoding = null;
		  }
		  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

		  // .end() fully uncorks
		  if (state.corked) {
		    state.corked = 1;
		    this.uncork();
		  }

		  // ignore unnecessary end() calls.
		  if (!state.ending) endWritable(this, state, cb);
		  return this;
		};
		Object.defineProperty(Writable.prototype, 'writableLength', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState.length;
		  }
		});
		function needFinish(state) {
		  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
		}
		function callFinal(stream, state) {
		  stream._final(function (err) {
		    state.pendingcb--;
		    if (err) {
		      errorOrDestroy(stream, err);
		    }
		    state.prefinished = true;
		    stream.emit('prefinish');
		    finishMaybe(stream, state);
		  });
		}
		function prefinish(stream, state) {
		  if (!state.prefinished && !state.finalCalled) {
		    if (typeof stream._final === 'function' && !state.destroyed) {
		      state.pendingcb++;
		      state.finalCalled = true;
		      process.nextTick(callFinal, stream, state);
		    } else {
		      state.prefinished = true;
		      stream.emit('prefinish');
		    }
		  }
		}
		function finishMaybe(stream, state) {
		  var need = needFinish(state);
		  if (need) {
		    prefinish(stream, state);
		    if (state.pendingcb === 0) {
		      state.finished = true;
		      stream.emit('finish');
		      if (state.autoDestroy) {
		        // In case of duplex streams we need a way to detect
		        // if the readable side is ready for autoDestroy as well
		        var rState = stream._readableState;
		        if (!rState || rState.autoDestroy && rState.endEmitted) {
		          stream.destroy();
		        }
		      }
		    }
		  }
		  return need;
		}
		function endWritable(stream, state, cb) {
		  state.ending = true;
		  finishMaybe(stream, state);
		  if (cb) {
		    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
		  }
		  state.ended = true;
		  stream.writable = false;
		}
		function onCorkedFinish(corkReq, state, err) {
		  var entry = corkReq.entry;
		  corkReq.entry = null;
		  while (entry) {
		    var cb = entry.callback;
		    state.pendingcb--;
		    cb(err);
		    entry = entry.next;
		  }

		  // reuse the free corkReq.
		  state.corkedRequestsFree.next = corkReq;
		}
		Object.defineProperty(Writable.prototype, 'destroyed', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    if (this._writableState === undefined) {
		      return false;
		    }
		    return this._writableState.destroyed;
		  },
		  set: function set(value) {
		    // we ignore the value if the stream
		    // has not been initialized yet
		    if (!this._writableState) {
		      return;
		    }

		    // backward compatibility, the user is explicitly
		    // managing destroyed
		    this._writableState.destroyed = value;
		  }
		});
		Writable.prototype.destroy = destroyImpl.destroy;
		Writable.prototype._undestroy = destroyImpl.undestroy;
		Writable.prototype._destroy = function (err, cb) {
		  cb(err);
		};
		}).call(this);}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{"../errors":469,"./_stream_duplex":470,"./internal/streams/destroy":477,"./internal/streams/state":481,"./internal/streams/stream":482,"_process":538,"buffer":103,"inherits":407,"util-deprecate":486}],475:[function(require,module,exports){
		(function (process){(function (){

		var _Object$setPrototypeO;
		function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
		function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
		var finished = require('./end-of-stream');
		var kLastResolve = Symbol('lastResolve');
		var kLastReject = Symbol('lastReject');
		var kError = Symbol('error');
		var kEnded = Symbol('ended');
		var kLastPromise = Symbol('lastPromise');
		var kHandlePromise = Symbol('handlePromise');
		var kStream = Symbol('stream');
		function createIterResult(value, done) {
		  return {
		    value: value,
		    done: done
		  };
		}
		function readAndResolve(iter) {
		  var resolve = iter[kLastResolve];
		  if (resolve !== null) {
		    var data = iter[kStream].read();
		    // we defer if data is null
		    // we can be expecting either 'end' or
		    // 'error'
		    if (data !== null) {
		      iter[kLastPromise] = null;
		      iter[kLastResolve] = null;
		      iter[kLastReject] = null;
		      resolve(createIterResult(data, false));
		    }
		  }
		}
		function onReadable(iter) {
		  // we wait for the next tick, because it might
		  // emit an error with process.nextTick
		  process.nextTick(readAndResolve, iter);
		}
		function wrapForNext(lastPromise, iter) {
		  return function (resolve, reject) {
		    lastPromise.then(function () {
		      if (iter[kEnded]) {
		        resolve(createIterResult(undefined, true));
		        return;
		      }
		      iter[kHandlePromise](resolve, reject);
		    }, reject);
		  };
		}
		var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
		var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
		  get stream() {
		    return this[kStream];
		  },
		  next: function next() {
		    var _this = this;
		    // if we have detected an error in the meanwhile
		    // reject straight away
		    var error = this[kError];
		    if (error !== null) {
		      return Promise.reject(error);
		    }
		    if (this[kEnded]) {
		      return Promise.resolve(createIterResult(undefined, true));
		    }
		    if (this[kStream].destroyed) {
		      // We need to defer via nextTick because if .destroy(err) is
		      // called, the error will be emitted via nextTick, and
		      // we cannot guarantee that there is no error lingering around
		      // waiting to be emitted.
		      return new Promise(function (resolve, reject) {
		        process.nextTick(function () {
		          if (_this[kError]) {
		            reject(_this[kError]);
		          } else {
		            resolve(createIterResult(undefined, true));
		          }
		        });
		      });
		    }

		    // if we have multiple next() calls
		    // we will wait for the previous Promise to finish
		    // this logic is optimized to support for await loops,
		    // where next() is only called once at a time
		    var lastPromise = this[kLastPromise];
		    var promise;
		    if (lastPromise) {
		      promise = new Promise(wrapForNext(lastPromise, this));
		    } else {
		      // fast path needed to support multiple this.push()
		      // without triggering the next() queue
		      var data = this[kStream].read();
		      if (data !== null) {
		        return Promise.resolve(createIterResult(data, false));
		      }
		      promise = new Promise(this[kHandlePromise]);
		    }
		    this[kLastPromise] = promise;
		    return promise;
		  }
		}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
		  return this;
		}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
		  var _this2 = this;
		  // destroy(err, cb) is a private API
		  // we can guarantee we have that here, because we control the
		  // Readable class this is attached to
		  return new Promise(function (resolve, reject) {
		    _this2[kStream].destroy(null, function (err) {
		      if (err) {
		        reject(err);
		        return;
		      }
		      resolve(createIterResult(undefined, true));
		    });
		  });
		}), _Object$setPrototypeO), AsyncIteratorPrototype);
		var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
		  var _Object$create;
		  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
		    value: stream,
		    writable: true
		  }), _defineProperty(_Object$create, kLastResolve, {
		    value: null,
		    writable: true
		  }), _defineProperty(_Object$create, kLastReject, {
		    value: null,
		    writable: true
		  }), _defineProperty(_Object$create, kError, {
		    value: null,
		    writable: true
		  }), _defineProperty(_Object$create, kEnded, {
		    value: stream._readableState.endEmitted,
		    writable: true
		  }), _defineProperty(_Object$create, kHandlePromise, {
		    value: function value(resolve, reject) {
		      var data = iterator[kStream].read();
		      if (data) {
		        iterator[kLastPromise] = null;
		        iterator[kLastResolve] = null;
		        iterator[kLastReject] = null;
		        resolve(createIterResult(data, false));
		      } else {
		        iterator[kLastResolve] = resolve;
		        iterator[kLastReject] = reject;
		      }
		    },
		    writable: true
		  }), _Object$create));
		  iterator[kLastPromise] = null;
		  finished(stream, function (err) {
		    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
		      var reject = iterator[kLastReject];
		      // reject if we are waiting for data in the Promise
		      // returned by next() and store the error
		      if (reject !== null) {
		        iterator[kLastPromise] = null;
		        iterator[kLastResolve] = null;
		        iterator[kLastReject] = null;
		        reject(err);
		      }
		      iterator[kError] = err;
		      return;
		    }
		    var resolve = iterator[kLastResolve];
		    if (resolve !== null) {
		      iterator[kLastPromise] = null;
		      iterator[kLastResolve] = null;
		      iterator[kLastReject] = null;
		      resolve(createIterResult(undefined, true));
		    }
		    iterator[kEnded] = true;
		  });
		  stream.on('readable', onReadable.bind(null, iterator));
		  return iterator;
		};
		module.exports = createReadableStreamAsyncIterator;
		}).call(this);}).call(this,require('_process'));
		},{"./end-of-stream":478,"_process":538}],476:[function(require,module,exports){

		function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
		function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
		function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
		function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(input); }
		var _require = require('buffer'),
		  Buffer = _require.Buffer;
		var _require2 = require('util'),
		  inspect = _require2.inspect;
		var custom = inspect && inspect.custom || 'inspect';
		function copyBuffer(src, target, offset) {
		  Buffer.prototype.copy.call(src, target, offset);
		}
		module.exports = /*#__PURE__*/function () {
		  function BufferList() {
		    _classCallCheck(this, BufferList);
		    this.head = null;
		    this.tail = null;
		    this.length = 0;
		  }
		  _createClass(BufferList, [{
		    key: "push",
		    value: function push(v) {
		      var entry = {
		        data: v,
		        next: null
		      };
		      if (this.length > 0) this.tail.next = entry;else this.head = entry;
		      this.tail = entry;
		      ++this.length;
		    }
		  }, {
		    key: "unshift",
		    value: function unshift(v) {
		      var entry = {
		        data: v,
		        next: this.head
		      };
		      if (this.length === 0) this.tail = entry;
		      this.head = entry;
		      ++this.length;
		    }
		  }, {
		    key: "shift",
		    value: function shift() {
		      if (this.length === 0) return;
		      var ret = this.head.data;
		      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
		      --this.length;
		      return ret;
		    }
		  }, {
		    key: "clear",
		    value: function clear() {
		      this.head = this.tail = null;
		      this.length = 0;
		    }
		  }, {
		    key: "join",
		    value: function join(s) {
		      if (this.length === 0) return '';
		      var p = this.head;
		      var ret = '' + p.data;
		      while (p = p.next) ret += s + p.data;
		      return ret;
		    }
		  }, {
		    key: "concat",
		    value: function concat(n) {
		      if (this.length === 0) return Buffer.alloc(0);
		      var ret = Buffer.allocUnsafe(n >>> 0);
		      var p = this.head;
		      var i = 0;
		      while (p) {
		        copyBuffer(p.data, ret, i);
		        i += p.data.length;
		        p = p.next;
		      }
		      return ret;
		    }

		    // Consumes a specified amount of bytes or characters from the buffered data.
		  }, {
		    key: "consume",
		    value: function consume(n, hasStrings) {
		      var ret;
		      if (n < this.head.data.length) {
		        // `slice` is the same for buffers and strings.
		        ret = this.head.data.slice(0, n);
		        this.head.data = this.head.data.slice(n);
		      } else if (n === this.head.data.length) {
		        // First chunk is a perfect match.
		        ret = this.shift();
		      } else {
		        // Result spans more than one buffer.
		        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
		      }
		      return ret;
		    }
		  }, {
		    key: "first",
		    value: function first() {
		      return this.head.data;
		    }

		    // Consumes a specified amount of characters from the buffered data.
		  }, {
		    key: "_getString",
		    value: function _getString(n) {
		      var p = this.head;
		      var c = 1;
		      var ret = p.data;
		      n -= ret.length;
		      while (p = p.next) {
		        var str = p.data;
		        var nb = n > str.length ? str.length : n;
		        if (nb === str.length) ret += str;else ret += str.slice(0, n);
		        n -= nb;
		        if (n === 0) {
		          if (nb === str.length) {
		            ++c;
		            if (p.next) this.head = p.next;else this.head = this.tail = null;
		          } else {
		            this.head = p;
		            p.data = str.slice(nb);
		          }
		          break;
		        }
		        ++c;
		      }
		      this.length -= c;
		      return ret;
		    }

		    // Consumes a specified amount of bytes from the buffered data.
		  }, {
		    key: "_getBuffer",
		    value: function _getBuffer(n) {
		      var ret = Buffer.allocUnsafe(n);
		      var p = this.head;
		      var c = 1;
		      p.data.copy(ret);
		      n -= p.data.length;
		      while (p = p.next) {
		        var buf = p.data;
		        var nb = n > buf.length ? buf.length : n;
		        buf.copy(ret, ret.length - n, 0, nb);
		        n -= nb;
		        if (n === 0) {
		          if (nb === buf.length) {
		            ++c;
		            if (p.next) this.head = p.next;else this.head = this.tail = null;
		          } else {
		            this.head = p;
		            p.data = buf.slice(nb);
		          }
		          break;
		        }
		        ++c;
		      }
		      this.length -= c;
		      return ret;
		    }

		    // Make sure the linked list only shows the minimal necessary information.
		  }, {
		    key: custom,
		    value: function value(_, options) {
		      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
		        // Only inspect one level.
		        depth: 0,
		        // It should not recurse.
		        customInspect: false
		      }));
		    }
		  }]);
		  return BufferList;
		}();
		},{"buffer":103,"util":102}],477:[function(require,module,exports){
		(function (process){(function (){

		// undocumented cb() API, needed for core, not for public API
		function destroy(err, cb) {
		  var _this = this;
		  var readableDestroyed = this._readableState && this._readableState.destroyed;
		  var writableDestroyed = this._writableState && this._writableState.destroyed;
		  if (readableDestroyed || writableDestroyed) {
		    if (cb) {
		      cb(err);
		    } else if (err) {
		      if (!this._writableState) {
		        process.nextTick(emitErrorNT, this, err);
		      } else if (!this._writableState.errorEmitted) {
		        this._writableState.errorEmitted = true;
		        process.nextTick(emitErrorNT, this, err);
		      }
		    }
		    return this;
		  }

		  // we set destroyed to true before firing error callbacks in order
		  // to make it re-entrance safe in case destroy() is called within callbacks

		  if (this._readableState) {
		    this._readableState.destroyed = true;
		  }

		  // if this is a duplex stream mark the writable part as destroyed as well
		  if (this._writableState) {
		    this._writableState.destroyed = true;
		  }
		  this._destroy(err || null, function (err) {
		    if (!cb && err) {
		      if (!_this._writableState) {
		        process.nextTick(emitErrorAndCloseNT, _this, err);
		      } else if (!_this._writableState.errorEmitted) {
		        _this._writableState.errorEmitted = true;
		        process.nextTick(emitErrorAndCloseNT, _this, err);
		      } else {
		        process.nextTick(emitCloseNT, _this);
		      }
		    } else if (cb) {
		      process.nextTick(emitCloseNT, _this);
		      cb(err);
		    } else {
		      process.nextTick(emitCloseNT, _this);
		    }
		  });
		  return this;
		}
		function emitErrorAndCloseNT(self, err) {
		  emitErrorNT(self, err);
		  emitCloseNT(self);
		}
		function emitCloseNT(self) {
		  if (self._writableState && !self._writableState.emitClose) return;
		  if (self._readableState && !self._readableState.emitClose) return;
		  self.emit('close');
		}
		function undestroy() {
		  if (this._readableState) {
		    this._readableState.destroyed = false;
		    this._readableState.reading = false;
		    this._readableState.ended = false;
		    this._readableState.endEmitted = false;
		  }
		  if (this._writableState) {
		    this._writableState.destroyed = false;
		    this._writableState.ended = false;
		    this._writableState.ending = false;
		    this._writableState.finalCalled = false;
		    this._writableState.prefinished = false;
		    this._writableState.finished = false;
		    this._writableState.errorEmitted = false;
		  }
		}
		function emitErrorNT(self, err) {
		  self.emit('error', err);
		}
		function errorOrDestroy(stream, err) {
		  // We have tests that rely on errors being emitted
		  // in the same tick, so changing this is semver major.
		  // For now when you opt-in to autoDestroy we allow
		  // the error to be emitted nextTick. In a future
		  // semver major update we should change the default to this.

		  var rState = stream._readableState;
		  var wState = stream._writableState;
		  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
		}
		module.exports = {
		  destroy: destroy,
		  undestroy: undestroy,
		  errorOrDestroy: errorOrDestroy
		};
		}).call(this);}).call(this,require('_process'));
		},{"_process":538}],478:[function(require,module,exports){

		var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
		function once(callback) {
		  var called = false;
		  return function () {
		    if (called) return;
		    called = true;
		    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }
		    callback.apply(this, args);
		  };
		}
		function noop() {}
		function isRequest(stream) {
		  return stream.setHeader && typeof stream.abort === 'function';
		}
		function eos(stream, opts, callback) {
		  if (typeof opts === 'function') return eos(stream, null, opts);
		  if (!opts) opts = {};
		  callback = once(callback || noop);
		  var readable = opts.readable || opts.readable !== false && stream.readable;
		  var writable = opts.writable || opts.writable !== false && stream.writable;
		  var onlegacyfinish = function onlegacyfinish() {
		    if (!stream.writable) onfinish();
		  };
		  var writableEnded = stream._writableState && stream._writableState.finished;
		  var onfinish = function onfinish() {
		    writable = false;
		    writableEnded = true;
		    if (!readable) callback.call(stream);
		  };
		  var readableEnded = stream._readableState && stream._readableState.endEmitted;
		  var onend = function onend() {
		    readable = false;
		    readableEnded = true;
		    if (!writable) callback.call(stream);
		  };
		  var onerror = function onerror(err) {
		    callback.call(stream, err);
		  };
		  var onclose = function onclose() {
		    var err;
		    if (readable && !readableEnded) {
		      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
		      return callback.call(stream, err);
		    }
		    if (writable && !writableEnded) {
		      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
		      return callback.call(stream, err);
		    }
		  };
		  var onrequest = function onrequest() {
		    stream.req.on('finish', onfinish);
		  };
		  if (isRequest(stream)) {
		    stream.on('complete', onfinish);
		    stream.on('abort', onclose);
		    if (stream.req) onrequest();else stream.on('request', onrequest);
		  } else if (writable && !stream._writableState) {
		    // legacy streams
		    stream.on('end', onlegacyfinish);
		    stream.on('close', onlegacyfinish);
		  }
		  stream.on('end', onend);
		  stream.on('finish', onfinish);
		  if (opts.error !== false) stream.on('error', onerror);
		  stream.on('close', onclose);
		  return function () {
		    stream.removeListener('complete', onfinish);
		    stream.removeListener('abort', onclose);
		    stream.removeListener('request', onrequest);
		    if (stream.req) stream.req.removeListener('finish', onfinish);
		    stream.removeListener('end', onlegacyfinish);
		    stream.removeListener('close', onlegacyfinish);
		    stream.removeListener('finish', onfinish);
		    stream.removeListener('end', onend);
		    stream.removeListener('error', onerror);
		    stream.removeListener('close', onclose);
		  };
		}
		module.exports = eos;
		},{"../../../errors":469}],479:[function(require,module,exports){
		module.exports = function () {
		  throw new Error('Readable.from is not available in the browser')
		};

		},{}],480:[function(require,module,exports){

		var eos;
		function once(callback) {
		  var called = false;
		  return function () {
		    if (called) return;
		    called = true;
		    callback.apply(void 0, arguments);
		  };
		}
		var _require$codes = require('../../../errors').codes,
		  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
		  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
		function noop(err) {
		  // Rethrow the error if it exists to avoid swallowing it
		  if (err) throw err;
		}
		function isRequest(stream) {
		  return stream.setHeader && typeof stream.abort === 'function';
		}
		function destroyer(stream, reading, writing, callback) {
		  callback = once(callback);
		  var closed = false;
		  stream.on('close', function () {
		    closed = true;
		  });
		  if (eos === undefined) eos = require('./end-of-stream');
		  eos(stream, {
		    readable: reading,
		    writable: writing
		  }, function (err) {
		    if (err) return callback(err);
		    closed = true;
		    callback();
		  });
		  var destroyed = false;
		  return function (err) {
		    if (closed) return;
		    if (destroyed) return;
		    destroyed = true;

		    // request.destroy just do .end - .abort is what we want
		    if (isRequest(stream)) return stream.abort();
		    if (typeof stream.destroy === 'function') return stream.destroy();
		    callback(err || new ERR_STREAM_DESTROYED('pipe'));
		  };
		}
		function call(fn) {
		  fn();
		}
		function pipe(from, to) {
		  return from.pipe(to);
		}
		function popCallback(streams) {
		  if (!streams.length) return noop;
		  if (typeof streams[streams.length - 1] !== 'function') return noop;
		  return streams.pop();
		}
		function pipeline() {
		  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
		    streams[_key] = arguments[_key];
		  }
		  var callback = popCallback(streams);
		  if (Array.isArray(streams[0])) streams = streams[0];
		  if (streams.length < 2) {
		    throw new ERR_MISSING_ARGS('streams');
		  }
		  var error;
		  var destroys = streams.map(function (stream, i) {
		    var reading = i < streams.length - 1;
		    var writing = i > 0;
		    return destroyer(stream, reading, writing, function (err) {
		      if (!error) error = err;
		      if (err) destroys.forEach(call);
		      if (reading) return;
		      destroys.forEach(call);
		      callback(error);
		    });
		  });
		  return streams.reduce(pipe);
		}
		module.exports = pipeline;
		},{"../../../errors":469,"./end-of-stream":478}],481:[function(require,module,exports){

		var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
		function highWaterMarkFrom(options, isDuplex, duplexKey) {
		  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
		}
		function getHighWaterMark(state, options, duplexKey, isDuplex) {
		  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
		  if (hwm != null) {
		    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
		      var name = isDuplex ? duplexKey : 'highWaterMark';
		      throw new ERR_INVALID_OPT_VALUE(name, hwm);
		    }
		    return Math.floor(hwm);
		  }

		  // Default value
		  return state.objectMode ? 16 : 16 * 1024;
		}
		module.exports = {
		  getHighWaterMark: getHighWaterMark
		};
		},{"../../../errors":469}],482:[function(require,module,exports){
		arguments[4][459][0].apply(exports,arguments);
		},{"dup":459,"events":386}],483:[function(require,module,exports){
		arguments[4][462][0].apply(exports,arguments);
		},{"dup":462,"safe-buffer":464}],484:[function(require,module,exports){
		(function (setImmediate,clearImmediate){(function (){
		var nextTick = require('process/browser.js').nextTick;
		var apply = Function.prototype.apply;
		var slice = Array.prototype.slice;
		var immediateIds = {};
		var nextImmediateId = 0;

		// DOM APIs, for completeness

		exports.setTimeout = function() {
		  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
		};
		exports.setInterval = function() {
		  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
		};
		exports.clearTimeout =
		exports.clearInterval = function(timeout) { timeout.close(); };

		function Timeout(id, clearFn) {
		  this._id = id;
		  this._clearFn = clearFn;
		}
		Timeout.prototype.unref = Timeout.prototype.ref = function() {};
		Timeout.prototype.close = function() {
		  this._clearFn.call(window, this._id);
		};

		// Does not start the time, just sets up the members needed.
		exports.enroll = function(item, msecs) {
		  clearTimeout(item._idleTimeoutId);
		  item._idleTimeout = msecs;
		};

		exports.unenroll = function(item) {
		  clearTimeout(item._idleTimeoutId);
		  item._idleTimeout = -1;
		};

		exports._unrefActive = exports.active = function(item) {
		  clearTimeout(item._idleTimeoutId);

		  var msecs = item._idleTimeout;
		  if (msecs >= 0) {
		    item._idleTimeoutId = setTimeout(function onTimeout() {
		      if (item._onTimeout)
		        item._onTimeout();
		    }, msecs);
		  }
		};

		// That's not how node.js implements it but the exposed api is the same.
		exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
		  var id = nextImmediateId++;
		  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

		  immediateIds[id] = true;

		  nextTick(function onNextTick() {
		    if (immediateIds[id]) {
		      // fn.call() is faster so we optimize for the common use-case
		      // @see http://jsperf.com/call-apply-segu
		      if (args) {
		        fn.apply(null, args);
		      } else {
		        fn.call(null);
		      }
		      // Prevent ids from leaking
		      exports.clearImmediate(id);
		    }
		  });

		  return id;
		};

		exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
		  delete immediateIds[id];
		};
		}).call(this);}).call(this,require("timers").setImmediate,require("timers").clearImmediate);
		},{"process/browser.js":442,"timers":484}],485:[function(require,module,exports){
		var Buffer = require('buffer').Buffer;

		module.exports = function (buf) {
			// If the buffer is backed by a Uint8Array, a faster version will work
			if (buf instanceof Uint8Array) {
				// If the buffer isn't a subarray, return the underlying ArrayBuffer
				if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
					return buf.buffer
				} else if (typeof buf.buffer.slice === 'function') {
					// Otherwise we need to get a proper copy
					return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
				}
			}

			if (Buffer.isBuffer(buf)) {
				// This is the slow version that will work with any Buffer
				// implementation (even in old browsers)
				var arrayCopy = new Uint8Array(buf.length);
				var len = buf.length;
				for (var i = 0; i < len; i++) {
					arrayCopy[i] = buf[i];
				}
				return arrayCopy.buffer
			} else {
				throw new Error('Argument must be a Buffer')
			}
		};

		},{"buffer":103}],486:[function(require,module,exports){
		(function (global){(function (){

		/**
		 * Module exports.
		 */

		module.exports = deprecate;

		/**
		 * Mark that a method should not be used.
		 * Returns a modified function which warns once by default.
		 *
		 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
		 *
		 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
		 * will throw an Error when invoked.
		 *
		 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
		 * will invoke `console.trace()` instead of `console.error()`.
		 *
		 * @param {Function} fn - the function to deprecate
		 * @param {String} msg - the string to print to the console when `fn` is invoked
		 * @returns {Function} a new "deprecated" version of `fn`
		 * @api public
		 */

		function deprecate (fn, msg) {
		  if (config('noDeprecation')) {
		    return fn;
		  }

		  var warned = false;
		  function deprecated() {
		    if (!warned) {
		      if (config('throwDeprecation')) {
		        throw new Error(msg);
		      } else if (config('traceDeprecation')) {
		        console.trace(msg);
		      } else {
		        console.warn(msg);
		      }
		      warned = true;
		    }
		    return fn.apply(this, arguments);
		  }

		  return deprecated;
		}

		/**
		 * Checks `localStorage` for boolean values for the given `name`.
		 *
		 * @param {String} name
		 * @returns {Boolean}
		 * @api private
		 */

		function config (name) {
		  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
		  try {
		    if (!global.localStorage) return false;
		  } catch (_) {
		    return false;
		  }
		  var val = global.localStorage[name];
		  if (null == val) return false;
		  return String(val).toLowerCase() === 'true';
		}

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{}],487:[function(require,module,exports){
		arguments[4][97][0].apply(exports,arguments);
		},{"dup":97}],488:[function(require,module,exports){

		var isArgumentsObject = require('is-arguments');
		var isGeneratorFunction = require('is-generator-function');
		var whichTypedArray = require('which-typed-array');
		var isTypedArray = require('is-typed-array');

		function uncurryThis(f) {
		  return f.call.bind(f);
		}

		var BigIntSupported = typeof BigInt !== 'undefined';
		var SymbolSupported = typeof Symbol !== 'undefined';

		var ObjectToString = uncurryThis(Object.prototype.toString);

		var numberValue = uncurryThis(Number.prototype.valueOf);
		var stringValue = uncurryThis(String.prototype.valueOf);
		var booleanValue = uncurryThis(Boolean.prototype.valueOf);

		if (BigIntSupported) {
		  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
		}

		if (SymbolSupported) {
		  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
		}

		function checkBoxedPrimitive(value, prototypeValueOf) {
		  if (typeof value !== 'object') {
		    return false;
		  }
		  try {
		    prototypeValueOf(value);
		    return true;
		  } catch(e) {
		    return false;
		  }
		}

		exports.isArgumentsObject = isArgumentsObject;
		exports.isGeneratorFunction = isGeneratorFunction;
		exports.isTypedArray = isTypedArray;

		// Taken from here and modified for better browser support
		// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
		function isPromise(input) {
			return (
				(
					typeof Promise !== 'undefined' &&
					input instanceof Promise
				) ||
				(
					input !== null &&
					typeof input === 'object' &&
					typeof input.then === 'function' &&
					typeof input.catch === 'function'
				)
			);
		}
		exports.isPromise = isPromise;

		function isArrayBufferView(value) {
		  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
		    return ArrayBuffer.isView(value);
		  }

		  return (
		    isTypedArray(value) ||
		    isDataView(value)
		  );
		}
		exports.isArrayBufferView = isArrayBufferView;


		function isUint8Array(value) {
		  return whichTypedArray(value) === 'Uint8Array';
		}
		exports.isUint8Array = isUint8Array;

		function isUint8ClampedArray(value) {
		  return whichTypedArray(value) === 'Uint8ClampedArray';
		}
		exports.isUint8ClampedArray = isUint8ClampedArray;

		function isUint16Array(value) {
		  return whichTypedArray(value) === 'Uint16Array';
		}
		exports.isUint16Array = isUint16Array;

		function isUint32Array(value) {
		  return whichTypedArray(value) === 'Uint32Array';
		}
		exports.isUint32Array = isUint32Array;

		function isInt8Array(value) {
		  return whichTypedArray(value) === 'Int8Array';
		}
		exports.isInt8Array = isInt8Array;

		function isInt16Array(value) {
		  return whichTypedArray(value) === 'Int16Array';
		}
		exports.isInt16Array = isInt16Array;

		function isInt32Array(value) {
		  return whichTypedArray(value) === 'Int32Array';
		}
		exports.isInt32Array = isInt32Array;

		function isFloat32Array(value) {
		  return whichTypedArray(value) === 'Float32Array';
		}
		exports.isFloat32Array = isFloat32Array;

		function isFloat64Array(value) {
		  return whichTypedArray(value) === 'Float64Array';
		}
		exports.isFloat64Array = isFloat64Array;

		function isBigInt64Array(value) {
		  return whichTypedArray(value) === 'BigInt64Array';
		}
		exports.isBigInt64Array = isBigInt64Array;

		function isBigUint64Array(value) {
		  return whichTypedArray(value) === 'BigUint64Array';
		}
		exports.isBigUint64Array = isBigUint64Array;

		function isMapToString(value) {
		  return ObjectToString(value) === '[object Map]';
		}
		isMapToString.working = (
		  typeof Map !== 'undefined' &&
		  isMapToString(new Map())
		);

		function isMap(value) {
		  if (typeof Map === 'undefined') {
		    return false;
		  }

		  return isMapToString.working
		    ? isMapToString(value)
		    : value instanceof Map;
		}
		exports.isMap = isMap;

		function isSetToString(value) {
		  return ObjectToString(value) === '[object Set]';
		}
		isSetToString.working = (
		  typeof Set !== 'undefined' &&
		  isSetToString(new Set())
		);
		function isSet(value) {
		  if (typeof Set === 'undefined') {
		    return false;
		  }

		  return isSetToString.working
		    ? isSetToString(value)
		    : value instanceof Set;
		}
		exports.isSet = isSet;

		function isWeakMapToString(value) {
		  return ObjectToString(value) === '[object WeakMap]';
		}
		isWeakMapToString.working = (
		  typeof WeakMap !== 'undefined' &&
		  isWeakMapToString(new WeakMap())
		);
		function isWeakMap(value) {
		  if (typeof WeakMap === 'undefined') {
		    return false;
		  }

		  return isWeakMapToString.working
		    ? isWeakMapToString(value)
		    : value instanceof WeakMap;
		}
		exports.isWeakMap = isWeakMap;

		function isWeakSetToString(value) {
		  return ObjectToString(value) === '[object WeakSet]';
		}
		isWeakSetToString.working = (
		  typeof WeakSet !== 'undefined' &&
		  isWeakSetToString(new WeakSet())
		);
		function isWeakSet(value) {
		  return isWeakSetToString(value);
		}
		exports.isWeakSet = isWeakSet;

		function isArrayBufferToString(value) {
		  return ObjectToString(value) === '[object ArrayBuffer]';
		}
		isArrayBufferToString.working = (
		  typeof ArrayBuffer !== 'undefined' &&
		  isArrayBufferToString(new ArrayBuffer())
		);
		function isArrayBuffer(value) {
		  if (typeof ArrayBuffer === 'undefined') {
		    return false;
		  }

		  return isArrayBufferToString.working
		    ? isArrayBufferToString(value)
		    : value instanceof ArrayBuffer;
		}
		exports.isArrayBuffer = isArrayBuffer;

		function isDataViewToString(value) {
		  return ObjectToString(value) === '[object DataView]';
		}
		isDataViewToString.working = (
		  typeof ArrayBuffer !== 'undefined' &&
		  typeof DataView !== 'undefined' &&
		  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
		);
		function isDataView(value) {
		  if (typeof DataView === 'undefined') {
		    return false;
		  }

		  return isDataViewToString.working
		    ? isDataViewToString(value)
		    : value instanceof DataView;
		}
		exports.isDataView = isDataView;

		// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
		var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
		function isSharedArrayBufferToString(value) {
		  return ObjectToString(value) === '[object SharedArrayBuffer]';
		}
		function isSharedArrayBuffer(value) {
		  if (typeof SharedArrayBufferCopy === 'undefined') {
		    return false;
		  }

		  if (typeof isSharedArrayBufferToString.working === 'undefined') {
		    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
		  }

		  return isSharedArrayBufferToString.working
		    ? isSharedArrayBufferToString(value)
		    : value instanceof SharedArrayBufferCopy;
		}
		exports.isSharedArrayBuffer = isSharedArrayBuffer;

		function isAsyncFunction(value) {
		  return ObjectToString(value) === '[object AsyncFunction]';
		}
		exports.isAsyncFunction = isAsyncFunction;

		function isMapIterator(value) {
		  return ObjectToString(value) === '[object Map Iterator]';
		}
		exports.isMapIterator = isMapIterator;

		function isSetIterator(value) {
		  return ObjectToString(value) === '[object Set Iterator]';
		}
		exports.isSetIterator = isSetIterator;

		function isGeneratorObject(value) {
		  return ObjectToString(value) === '[object Generator]';
		}
		exports.isGeneratorObject = isGeneratorObject;

		function isWebAssemblyCompiledModule(value) {
		  return ObjectToString(value) === '[object WebAssembly.Module]';
		}
		exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

		function isNumberObject(value) {
		  return checkBoxedPrimitive(value, numberValue);
		}
		exports.isNumberObject = isNumberObject;

		function isStringObject(value) {
		  return checkBoxedPrimitive(value, stringValue);
		}
		exports.isStringObject = isStringObject;

		function isBooleanObject(value) {
		  return checkBoxedPrimitive(value, booleanValue);
		}
		exports.isBooleanObject = isBooleanObject;

		function isBigIntObject(value) {
		  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
		}
		exports.isBigIntObject = isBigIntObject;

		function isSymbolObject(value) {
		  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
		}
		exports.isSymbolObject = isSymbolObject;

		function isBoxedPrimitive(value) {
		  return (
		    isNumberObject(value) ||
		    isStringObject(value) ||
		    isBooleanObject(value) ||
		    isBigIntObject(value) ||
		    isSymbolObject(value)
		  );
		}
		exports.isBoxedPrimitive = isBoxedPrimitive;

		function isAnyArrayBuffer(value) {
		  return typeof Uint8Array !== 'undefined' && (
		    isArrayBuffer(value) ||
		    isSharedArrayBuffer(value)
		  );
		}
		exports.isAnyArrayBuffer = isAnyArrayBuffer;

		['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
		  Object.defineProperty(exports, method, {
		    enumerable: false,
		    value: function() {
		      throw new Error(method + ' is not supported in userland');
		    }
		  });
		});

		},{"is-arguments":408,"is-generator-function":411,"is-typed-array":412,"which-typed-array":490}],489:[function(require,module,exports){
		(function (process){(function (){
		// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.

		var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
		  function getOwnPropertyDescriptors(obj) {
		    var keys = Object.keys(obj);
		    var descriptors = {};
		    for (var i = 0; i < keys.length; i++) {
		      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
		    }
		    return descriptors;
		  };

		var formatRegExp = /%[sdj%]/g;
		exports.format = function(f) {
		  if (!isString(f)) {
		    var objects = [];
		    for (var i = 0; i < arguments.length; i++) {
		      objects.push(inspect(arguments[i]));
		    }
		    return objects.join(' ');
		  }

		  var i = 1;
		  var args = arguments;
		  var len = args.length;
		  var str = String(f).replace(formatRegExp, function(x) {
		    if (x === '%%') return '%';
		    if (i >= len) return x;
		    switch (x) {
		      case '%s': return String(args[i++]);
		      case '%d': return Number(args[i++]);
		      case '%j':
		        try {
		          return JSON.stringify(args[i++]);
		        } catch (_) {
		          return '[Circular]';
		        }
		      default:
		        return x;
		    }
		  });
		  for (var x = args[i]; i < len; x = args[++i]) {
		    if (isNull(x) || !isObject(x)) {
		      str += ' ' + x;
		    } else {
		      str += ' ' + inspect(x);
		    }
		  }
		  return str;
		};


		// Mark that a method should not be used.
		// Returns a modified function which warns once by default.
		// If --no-deprecation is set, then it is a no-op.
		exports.deprecate = function(fn, msg) {
		  if (typeof process !== 'undefined' && process.noDeprecation === true) {
		    return fn;
		  }

		  // Allow for deprecating things in the process of starting up.
		  if (typeof process === 'undefined') {
		    return function() {
		      return exports.deprecate(fn, msg).apply(this, arguments);
		    };
		  }

		  var warned = false;
		  function deprecated() {
		    if (!warned) {
		      if (process.throwDeprecation) {
		        throw new Error(msg);
		      } else if (process.traceDeprecation) {
		        console.trace(msg);
		      } else {
		        console.error(msg);
		      }
		      warned = true;
		    }
		    return fn.apply(this, arguments);
		  }

		  return deprecated;
		};


		var debugs = {};
		var debugEnvRegex = /^$/;

		if (process.env.NODE_DEBUG) {
		  var debugEnv = process.env.NODE_DEBUG;
		  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
		    .replace(/\*/g, '.*')
		    .replace(/,/g, '$|^')
		    .toUpperCase();
		  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
		}
		exports.debuglog = function(set) {
		  set = set.toUpperCase();
		  if (!debugs[set]) {
		    if (debugEnvRegex.test(set)) {
		      var pid = process.pid;
		      debugs[set] = function() {
		        var msg = exports.format.apply(exports, arguments);
		        console.error('%s %d: %s', set, pid, msg);
		      };
		    } else {
		      debugs[set] = function() {};
		    }
		  }
		  return debugs[set];
		};


		/**
		 * Echos the value of a value. Trys to print the value out
		 * in the best way possible given the different types.
		 *
		 * @param {Object} obj The object to print out.
		 * @param {Object} opts Optional options object that alters the output.
		 */
		/* legacy: obj, showHidden, depth, colors*/
		function inspect(obj, opts) {
		  // default options
		  var ctx = {
		    seen: [],
		    stylize: stylizeNoColor
		  };
		  // legacy...
		  if (arguments.length >= 3) ctx.depth = arguments[2];
		  if (arguments.length >= 4) ctx.colors = arguments[3];
		  if (isBoolean(opts)) {
		    // legacy...
		    ctx.showHidden = opts;
		  } else if (opts) {
		    // got an "options" object
		    exports._extend(ctx, opts);
		  }
		  // set default options
		  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
		  if (isUndefined(ctx.depth)) ctx.depth = 2;
		  if (isUndefined(ctx.colors)) ctx.colors = false;
		  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
		  if (ctx.colors) ctx.stylize = stylizeWithColor;
		  return formatValue(ctx, obj, ctx.depth);
		}
		exports.inspect = inspect;


		// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
		inspect.colors = {
		  'bold' : [1, 22],
		  'italic' : [3, 23],
		  'underline' : [4, 24],
		  'inverse' : [7, 27],
		  'white' : [37, 39],
		  'grey' : [90, 39],
		  'black' : [30, 39],
		  'blue' : [34, 39],
		  'cyan' : [36, 39],
		  'green' : [32, 39],
		  'magenta' : [35, 39],
		  'red' : [31, 39],
		  'yellow' : [33, 39]
		};

		// Don't use 'blue' not visible on cmd.exe
		inspect.styles = {
		  'special': 'cyan',
		  'number': 'yellow',
		  'boolean': 'yellow',
		  'undefined': 'grey',
		  'null': 'bold',
		  'string': 'green',
		  'date': 'magenta',
		  // "name": intentionally not styling
		  'regexp': 'red'
		};


		function stylizeWithColor(str, styleType) {
		  var style = inspect.styles[styleType];

		  if (style) {
		    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
		           '\u001b[' + inspect.colors[style][1] + 'm';
		  } else {
		    return str;
		  }
		}


		function stylizeNoColor(str, styleType) {
		  return str;
		}


		function arrayToHash(array) {
		  var hash = {};

		  array.forEach(function(val, idx) {
		    hash[val] = true;
		  });

		  return hash;
		}


		function formatValue(ctx, value, recurseTimes) {
		  // Provide a hook for user-specified inspect functions.
		  // Check that value is an object with an inspect function on it
		  if (ctx.customInspect &&
		      value &&
		      isFunction(value.inspect) &&
		      // Filter out the util module, it's inspect function is special
		      value.inspect !== exports.inspect &&
		      // Also filter out any prototype objects using the circular check.
		      !(value.constructor && value.constructor.prototype === value)) {
		    var ret = value.inspect(recurseTimes, ctx);
		    if (!isString(ret)) {
		      ret = formatValue(ctx, ret, recurseTimes);
		    }
		    return ret;
		  }

		  // Primitive types cannot have properties
		  var primitive = formatPrimitive(ctx, value);
		  if (primitive) {
		    return primitive;
		  }

		  // Look up the keys of the object.
		  var keys = Object.keys(value);
		  var visibleKeys = arrayToHash(keys);

		  if (ctx.showHidden) {
		    keys = Object.getOwnPropertyNames(value);
		  }

		  // IE doesn't make error fields non-enumerable
		  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
		  if (isError(value)
		      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
		    return formatError(value);
		  }

		  // Some type of object without properties can be shortcutted.
		  if (keys.length === 0) {
		    if (isFunction(value)) {
		      var name = value.name ? ': ' + value.name : '';
		      return ctx.stylize('[Function' + name + ']', 'special');
		    }
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    }
		    if (isDate(value)) {
		      return ctx.stylize(Date.prototype.toString.call(value), 'date');
		    }
		    if (isError(value)) {
		      return formatError(value);
		    }
		  }

		  var base = '', array = false, braces = ['{', '}'];

		  // Make Array say that they are Array
		  if (isArray(value)) {
		    array = true;
		    braces = ['[', ']'];
		  }

		  // Make functions say that they are functions
		  if (isFunction(value)) {
		    var n = value.name ? ': ' + value.name : '';
		    base = ' [Function' + n + ']';
		  }

		  // Make RegExps say that they are RegExps
		  if (isRegExp(value)) {
		    base = ' ' + RegExp.prototype.toString.call(value);
		  }

		  // Make dates with properties first say the date
		  if (isDate(value)) {
		    base = ' ' + Date.prototype.toUTCString.call(value);
		  }

		  // Make error with message first say the error
		  if (isError(value)) {
		    base = ' ' + formatError(value);
		  }

		  if (keys.length === 0 && (!array || value.length == 0)) {
		    return braces[0] + base + braces[1];
		  }

		  if (recurseTimes < 0) {
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    } else {
		      return ctx.stylize('[Object]', 'special');
		    }
		  }

		  ctx.seen.push(value);

		  var output;
		  if (array) {
		    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
		  } else {
		    output = keys.map(function(key) {
		      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
		    });
		  }

		  ctx.seen.pop();

		  return reduceToSingleString(output, base, braces);
		}


		function formatPrimitive(ctx, value) {
		  if (isUndefined(value))
		    return ctx.stylize('undefined', 'undefined');
		  if (isString(value)) {
		    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
		                                             .replace(/'/g, "\\'")
		                                             .replace(/\\"/g, '"') + '\'';
		    return ctx.stylize(simple, 'string');
		  }
		  if (isNumber(value))
		    return ctx.stylize('' + value, 'number');
		  if (isBoolean(value))
		    return ctx.stylize('' + value, 'boolean');
		  // For some reason typeof null is "object", so special case here.
		  if (isNull(value))
		    return ctx.stylize('null', 'null');
		}


		function formatError(value) {
		  return '[' + Error.prototype.toString.call(value) + ']';
		}


		function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
		  var output = [];
		  for (var i = 0, l = value.length; i < l; ++i) {
		    if (hasOwnProperty(value, String(i))) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          String(i), true));
		    } else {
		      output.push('');
		    }
		  }
		  keys.forEach(function(key) {
		    if (!key.match(/^\d+$/)) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          key, true));
		    }
		  });
		  return output;
		}


		function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
		  var name, str, desc;
		  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
		  if (desc.get) {
		    if (desc.set) {
		      str = ctx.stylize('[Getter/Setter]', 'special');
		    } else {
		      str = ctx.stylize('[Getter]', 'special');
		    }
		  } else {
		    if (desc.set) {
		      str = ctx.stylize('[Setter]', 'special');
		    }
		  }
		  if (!hasOwnProperty(visibleKeys, key)) {
		    name = '[' + key + ']';
		  }
		  if (!str) {
		    if (ctx.seen.indexOf(desc.value) < 0) {
		      if (isNull(recurseTimes)) {
		        str = formatValue(ctx, desc.value, null);
		      } else {
		        str = formatValue(ctx, desc.value, recurseTimes - 1);
		      }
		      if (str.indexOf('\n') > -1) {
		        if (array) {
		          str = str.split('\n').map(function(line) {
		            return '  ' + line;
		          }).join('\n').slice(2);
		        } else {
		          str = '\n' + str.split('\n').map(function(line) {
		            return '   ' + line;
		          }).join('\n');
		        }
		      }
		    } else {
		      str = ctx.stylize('[Circular]', 'special');
		    }
		  }
		  if (isUndefined(name)) {
		    if (array && key.match(/^\d+$/)) {
		      return str;
		    }
		    name = JSON.stringify('' + key);
		    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
		      name = name.slice(1, -1);
		      name = ctx.stylize(name, 'name');
		    } else {
		      name = name.replace(/'/g, "\\'")
		                 .replace(/\\"/g, '"')
		                 .replace(/(^"|"$)/g, "'");
		      name = ctx.stylize(name, 'string');
		    }
		  }

		  return name + ': ' + str;
		}


		function reduceToSingleString(output, base, braces) {
		  var length = output.reduce(function(prev, cur) {
		    if (cur.indexOf('\n') >= 0) ;
		    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
		  }, 0);

		  if (length > 60) {
		    return braces[0] +
		           (base === '' ? '' : base + '\n ') +
		           ' ' +
		           output.join(',\n  ') +
		           ' ' +
		           braces[1];
		  }

		  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
		}


		// NOTE: These type checking functions intentionally don't use `instanceof`
		// because it is fragile and can be easily faked with `Object.create()`.
		exports.types = require('./support/types');

		function isArray(ar) {
		  return Array.isArray(ar);
		}
		exports.isArray = isArray;

		function isBoolean(arg) {
		  return typeof arg === 'boolean';
		}
		exports.isBoolean = isBoolean;

		function isNull(arg) {
		  return arg === null;
		}
		exports.isNull = isNull;

		function isNullOrUndefined(arg) {
		  return arg == null;
		}
		exports.isNullOrUndefined = isNullOrUndefined;

		function isNumber(arg) {
		  return typeof arg === 'number';
		}
		exports.isNumber = isNumber;

		function isString(arg) {
		  return typeof arg === 'string';
		}
		exports.isString = isString;

		function isSymbol(arg) {
		  return typeof arg === 'symbol';
		}
		exports.isSymbol = isSymbol;

		function isUndefined(arg) {
		  return arg === void 0;
		}
		exports.isUndefined = isUndefined;

		function isRegExp(re) {
		  return isObject(re) && objectToString(re) === '[object RegExp]';
		}
		exports.isRegExp = isRegExp;
		exports.types.isRegExp = isRegExp;

		function isObject(arg) {
		  return typeof arg === 'object' && arg !== null;
		}
		exports.isObject = isObject;

		function isDate(d) {
		  return isObject(d) && objectToString(d) === '[object Date]';
		}
		exports.isDate = isDate;
		exports.types.isDate = isDate;

		function isError(e) {
		  return isObject(e) &&
		      (objectToString(e) === '[object Error]' || e instanceof Error);
		}
		exports.isError = isError;
		exports.types.isNativeError = isError;

		function isFunction(arg) {
		  return typeof arg === 'function';
		}
		exports.isFunction = isFunction;

		function isPrimitive(arg) {
		  return arg === null ||
		         typeof arg === 'boolean' ||
		         typeof arg === 'number' ||
		         typeof arg === 'string' ||
		         typeof arg === 'symbol' ||  // ES6 symbol
		         typeof arg === 'undefined';
		}
		exports.isPrimitive = isPrimitive;

		exports.isBuffer = require('./support/isBuffer');

		function objectToString(o) {
		  return Object.prototype.toString.call(o);
		}


		function pad(n) {
		  return n < 10 ? '0' + n.toString(10) : n.toString(10);
		}


		var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
		              'Oct', 'Nov', 'Dec'];

		// 26 Feb 16:19:34
		function timestamp() {
		  var d = new Date();
		  var time = [pad(d.getHours()),
		              pad(d.getMinutes()),
		              pad(d.getSeconds())].join(':');
		  return [d.getDate(), months[d.getMonth()], time].join(' ');
		}


		// log is just a thin wrapper to console.log that prepends a timestamp
		exports.log = function() {
		  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
		};


		/**
		 * Inherit the prototype methods from one constructor into another.
		 *
		 * The Function.prototype.inherits from lang.js rewritten as a standalone
		 * function (not on Function.prototype). NOTE: If this file is to be loaded
		 * during bootstrapping this function needs to be rewritten using some native
		 * functions as prototype setup using normal JavaScript does not work as
		 * expected during bootstrapping (see mirror.js in r114903).
		 *
		 * @param {function} ctor Constructor function which needs to inherit the
		 *     prototype.
		 * @param {function} superCtor Constructor function to inherit prototype from.
		 */
		exports.inherits = require('inherits');

		exports._extend = function(origin, add) {
		  // Don't do anything if add isn't an object
		  if (!add || !isObject(add)) return origin;

		  var keys = Object.keys(add);
		  var i = keys.length;
		  while (i--) {
		    origin[keys[i]] = add[keys[i]];
		  }
		  return origin;
		};

		function hasOwnProperty(obj, prop) {
		  return Object.prototype.hasOwnProperty.call(obj, prop);
		}

		var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

		exports.promisify = function promisify(original) {
		  if (typeof original !== 'function')
		    throw new TypeError('The "original" argument must be of type Function');

		  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
		    var fn = original[kCustomPromisifiedSymbol];
		    if (typeof fn !== 'function') {
		      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
		    }
		    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
		      value: fn, enumerable: false, writable: false, configurable: true
		    });
		    return fn;
		  }

		  function fn() {
		    var promiseResolve, promiseReject;
		    var promise = new Promise(function (resolve, reject) {
		      promiseResolve = resolve;
		      promiseReject = reject;
		    });

		    var args = [];
		    for (var i = 0; i < arguments.length; i++) {
		      args.push(arguments[i]);
		    }
		    args.push(function (err, value) {
		      if (err) {
		        promiseReject(err);
		      } else {
		        promiseResolve(value);
		      }
		    });

		    try {
		      original.apply(this, args);
		    } catch (err) {
		      promiseReject(err);
		    }

		    return promise;
		  }

		  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

		  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
		    value: fn, enumerable: false, writable: false, configurable: true
		  });
		  return Object.defineProperties(
		    fn,
		    getOwnPropertyDescriptors(original)
		  );
		};

		exports.promisify.custom = kCustomPromisifiedSymbol;

		function callbackifyOnRejected(reason, cb) {
		  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
		  // Because `null` is a special error value in callbacks which means "no error
		  // occurred", we error-wrap so the callback consumer can distinguish between
		  // "the promise rejected with null" or "the promise fulfilled with undefined".
		  if (!reason) {
		    var newReason = new Error('Promise was rejected with a falsy value');
		    newReason.reason = reason;
		    reason = newReason;
		  }
		  return cb(reason);
		}

		function callbackify(original) {
		  if (typeof original !== 'function') {
		    throw new TypeError('The "original" argument must be of type Function');
		  }

		  // We DO NOT return the promise as it gives the user a false sense that
		  // the promise is actually somehow related to the callback's execution
		  // and that the callback throwing will reject the promise.
		  function callbackified() {
		    var args = [];
		    for (var i = 0; i < arguments.length; i++) {
		      args.push(arguments[i]);
		    }

		    var maybeCb = args.pop();
		    if (typeof maybeCb !== 'function') {
		      throw new TypeError('The last argument must be of type Function');
		    }
		    var self = this;
		    var cb = function() {
		      return maybeCb.apply(self, arguments);
		    };
		    // In true node style we process the callback on `nextTick` with all the
		    // implications (stack, `uncaughtException`, `async_hooks`)
		    original.apply(this, args)
		      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)); },
		            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
		  }

		  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
		  Object.defineProperties(callbackified,
		                          getOwnPropertyDescriptors(original));
		  return callbackified;
		}
		exports.callbackify = callbackify;

		}).call(this);}).call(this,require('_process'));
		},{"./support/isBuffer":487,"./support/types":488,"_process":538,"inherits":407}],490:[function(require,module,exports){
		(function (global){(function (){

		var forEach = require('for-each');
		var availableTypedArrays = require('available-typed-arrays');
		var callBind = require('call-bind');
		var callBound = require('call-bind/callBound');
		var gOPD = require('gopd');

		var $toString = callBound('Object.prototype.toString');
		var hasToStringTag = require('has-tostringtag/shams')();

		var g = typeof globalThis === 'undefined' ? global : globalThis;
		var typedArrays = availableTypedArrays();

		var $slice = callBound('String.prototype.slice');
		var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

		var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
			for (var i = 0; i < array.length; i += 1) {
				if (array[i] === value) {
					return i;
				}
			}
			return -1;
		};
		var cache = { __proto__: null };
		if (hasToStringTag && gOPD && getPrototypeOf) {
			forEach(typedArrays, function (typedArray) {
				var arr = new g[typedArray]();
				if (Symbol.toStringTag in arr) {
					var proto = getPrototypeOf(arr);
					var descriptor = gOPD(proto, Symbol.toStringTag);
					if (!descriptor) {
						var superProto = getPrototypeOf(proto);
						descriptor = gOPD(superProto, Symbol.toStringTag);
					}
					cache['$' + typedArray] = callBind(descriptor.get);
				}
			});
		} else {
			forEach(typedArrays, function (typedArray) {
				var arr = new g[typedArray]();
				var fn = arr.slice || arr.set;
				if (fn) {
					cache['$' + typedArray] = callBind(fn);
				}
			});
		}

		var tryTypedArrays = function tryAllTypedArrays(value) {
			var found = false;
			forEach(cache, function (getter, typedArray) {
				if (!found) {
					try {
						if ('$' + getter(value) === typedArray) {
							found = $slice(typedArray, 1);
						}
					} catch (e) { /**/ }
				}
			});
			return found;
		};

		var trySlices = function tryAllSlices(value) {
			var found = false;
			forEach(cache, function (getter, name) {
				if (!found) {
					try {
						getter(value);
						found = $slice(name, 1);
					} catch (e) { /**/ }
				}
			});
			return found;
		};

		module.exports = function whichTypedArray(value) {
			if (!value || typeof value !== 'object') { return false; }
			if (!hasToStringTag) {
				var tag = $slice($toString(value), 8, -1);
				if ($indexOf(typedArrays, tag) > -1) {
					return tag;
				}
				if (tag !== 'Object') {
					return false;
				}
				// node < 0.6 hits here on real Typed Arrays
				return trySlices(value);
			}
			if (!gOPD) { return null; } // unknown engine
			return tryTypedArrays(value);
		};

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{"available-typed-arrays":99,"call-bind":106,"call-bind/callBound":105,"for-each":387,"gopd":391,"has-tostringtag/shams":396}],491:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  exports.stripBOM = function(str) {
		    if (str[0] === '\uFEFF') {
		      return str.substring(1);
		    } else {
		      return str;
		    }
		  };

		}).call(this);

		},{}],492:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,
		    hasProp = {}.hasOwnProperty;

		  builder = require('xmlbuilder');

		  defaults = require('./defaults').defaults;

		  requiresCDATA = function(entry) {
		    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
		  };

		  wrapCDATA = function(entry) {
		    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
		  };

		  escapeCDATA = function(entry) {
		    return entry.replace(']]>', ']]]]><![CDATA[>');
		  };

		  exports.Builder = (function() {
		    function Builder(opts) {
		      var key, ref, value;
		      this.options = {};
		      ref = defaults["0.2"];
		      for (key in ref) {
		        if (!hasProp.call(ref, key)) continue;
		        value = ref[key];
		        this.options[key] = value;
		      }
		      for (key in opts) {
		        if (!hasProp.call(opts, key)) continue;
		        value = opts[key];
		        this.options[key] = value;
		      }
		    }

		    Builder.prototype.buildObject = function(rootObj) {
		      var attrkey, charkey, render, rootElement, rootName;
		      attrkey = this.options.attrkey;
		      charkey = this.options.charkey;
		      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
		        rootName = Object.keys(rootObj)[0];
		        rootObj = rootObj[rootName];
		      } else {
		        rootName = this.options.rootName;
		      }
		      render = (function(_this) {
		        return function(element, obj) {
		          var attr, child, entry, index, key, value;
		          if (typeof obj !== 'object') {
		            if (_this.options.cdata && requiresCDATA(obj)) {
		              element.raw(wrapCDATA(obj));
		            } else {
		              element.txt(obj);
		            }
		          } else if (Array.isArray(obj)) {
		            for (index in obj) {
		              if (!hasProp.call(obj, index)) continue;
		              child = obj[index];
		              for (key in child) {
		                entry = child[key];
		                element = render(element.ele(key), entry).up();
		              }
		            }
		          } else {
		            for (key in obj) {
		              if (!hasProp.call(obj, key)) continue;
		              child = obj[key];
		              if (key === attrkey) {
		                if (typeof child === "object") {
		                  for (attr in child) {
		                    value = child[attr];
		                    element = element.att(attr, value);
		                  }
		                }
		              } else if (key === charkey) {
		                if (_this.options.cdata && requiresCDATA(child)) {
		                  element = element.raw(wrapCDATA(child));
		                } else {
		                  element = element.txt(child);
		                }
		              } else if (Array.isArray(child)) {
		                for (index in child) {
		                  if (!hasProp.call(child, index)) continue;
		                  entry = child[index];
		                  if (typeof entry === 'string') {
		                    if (_this.options.cdata && requiresCDATA(entry)) {
		                      element = element.ele(key).raw(wrapCDATA(entry)).up();
		                    } else {
		                      element = element.ele(key, entry).up();
		                    }
		                  } else {
		                    element = render(element.ele(key), entry).up();
		                  }
		                }
		              } else if (typeof child === "object") {
		                element = render(element.ele(key), child).up();
		              } else {
		                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
		                  element = element.ele(key).raw(wrapCDATA(child)).up();
		                } else {
		                  if (child == null) {
		                    child = '';
		                  }
		                  element = element.ele(key, child.toString()).up();
		                }
		              }
		            }
		          }
		          return element;
		        };
		      })(this);
		      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
		        headless: this.options.headless,
		        allowSurrogateChars: this.options.allowSurrogateChars
		      });
		      return render(rootElement, rootObj).end(this.options.renderOpts);
		    };

		    return Builder;

		  })();

		}).call(this);

		},{"./defaults":493,"xmlbuilder":529}],493:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  exports.defaults = {
		    "0.1": {
		      explicitCharkey: false,
		      trim: true,
		      normalize: true,
		      normalizeTags: false,
		      attrkey: "@",
		      charkey: "#",
		      explicitArray: false,
		      ignoreAttrs: false,
		      mergeAttrs: false,
		      explicitRoot: false,
		      validator: null,
		      xmlns: false,
		      explicitChildren: false,
		      childkey: '@@',
		      charsAsChildren: false,
		      includeWhiteChars: false,
		      async: false,
		      strict: true,
		      attrNameProcessors: null,
		      attrValueProcessors: null,
		      tagNameProcessors: null,
		      valueProcessors: null,
		      emptyTag: ''
		    },
		    "0.2": {
		      explicitCharkey: false,
		      trim: false,
		      normalize: false,
		      normalizeTags: false,
		      attrkey: "$",
		      charkey: "_",
		      explicitArray: true,
		      ignoreAttrs: false,
		      mergeAttrs: false,
		      explicitRoot: true,
		      validator: null,
		      xmlns: false,
		      explicitChildren: false,
		      preserveChildrenOrder: false,
		      childkey: '$$',
		      charsAsChildren: false,
		      includeWhiteChars: false,
		      async: false,
		      strict: true,
		      attrNameProcessors: null,
		      attrValueProcessors: null,
		      tagNameProcessors: null,
		      valueProcessors: null,
		      rootName: 'root',
		      xmldec: {
		        'version': '1.0',
		        'encoding': 'UTF-8',
		        'standalone': true
		      },
		      doctype: null,
		      renderOpts: {
		        'pretty': true,
		        'indent': '  ',
		        'newline': '\n'
		      },
		      headless: false,
		      chunkSize: 10000,
		      emptyTag: '',
		      cdata: false
		    }
		  };

		}).call(this);

		},{}],494:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate,
		    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  sax = require('sax');

		  events = require('events');

		  bom = require('./bom');

		  processors = require('./processors');

		  setImmediate = require('timers').setImmediate;

		  defaults = require('./defaults').defaults;

		  isEmpty = function(thing) {
		    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
		  };

		  processItem = function(processors, item, key) {
		    var i, len, process;
		    for (i = 0, len = processors.length; i < len; i++) {
		      process = processors[i];
		      item = process(item, key);
		    }
		    return item;
		  };

		  defineProperty = function(obj, key, value) {
		    var descriptor;
		    descriptor = Object.create(null);
		    descriptor.value = value;
		    descriptor.writable = true;
		    descriptor.enumerable = true;
		    descriptor.configurable = true;
		    return Object.defineProperty(obj, key, descriptor);
		  };

		  exports.Parser = (function(superClass) {
		    extend(Parser, superClass);

		    function Parser(opts) {
		      this.parseStringPromise = bind(this.parseStringPromise, this);
		      this.parseString = bind(this.parseString, this);
		      this.reset = bind(this.reset, this);
		      this.assignOrPush = bind(this.assignOrPush, this);
		      this.processAsync = bind(this.processAsync, this);
		      var key, ref, value;
		      if (!(this instanceof exports.Parser)) {
		        return new exports.Parser(opts);
		      }
		      this.options = {};
		      ref = defaults["0.2"];
		      for (key in ref) {
		        if (!hasProp.call(ref, key)) continue;
		        value = ref[key];
		        this.options[key] = value;
		      }
		      for (key in opts) {
		        if (!hasProp.call(opts, key)) continue;
		        value = opts[key];
		        this.options[key] = value;
		      }
		      if (this.options.xmlns) {
		        this.options.xmlnskey = this.options.attrkey + "ns";
		      }
		      if (this.options.normalizeTags) {
		        if (!this.options.tagNameProcessors) {
		          this.options.tagNameProcessors = [];
		        }
		        this.options.tagNameProcessors.unshift(processors.normalize);
		      }
		      this.reset();
		    }

		    Parser.prototype.processAsync = function() {
		      var chunk, err;
		      try {
		        if (this.remaining.length <= this.options.chunkSize) {
		          chunk = this.remaining;
		          this.remaining = '';
		          this.saxParser = this.saxParser.write(chunk);
		          return this.saxParser.close();
		        } else {
		          chunk = this.remaining.substr(0, this.options.chunkSize);
		          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
		          this.saxParser = this.saxParser.write(chunk);
		          return setImmediate(this.processAsync);
		        }
		      } catch (error1) {
		        err = error1;
		        if (!this.saxParser.errThrown) {
		          this.saxParser.errThrown = true;
		          return this.emit(err);
		        }
		      }
		    };

		    Parser.prototype.assignOrPush = function(obj, key, newValue) {
		      if (!(key in obj)) {
		        if (!this.options.explicitArray) {
		          return defineProperty(obj, key, newValue);
		        } else {
		          return defineProperty(obj, key, [newValue]);
		        }
		      } else {
		        if (!(obj[key] instanceof Array)) {
		          defineProperty(obj, key, [obj[key]]);
		        }
		        return obj[key].push(newValue);
		      }
		    };

		    Parser.prototype.reset = function() {
		      var attrkey, charkey, ontext, stack;
		      this.removeAllListeners();
		      this.saxParser = sax.parser(this.options.strict, {
		        trim: false,
		        normalize: false,
		        xmlns: this.options.xmlns
		      });
		      this.saxParser.errThrown = false;
		      this.saxParser.onerror = (function(_this) {
		        return function(error) {
		          _this.saxParser.resume();
		          if (!_this.saxParser.errThrown) {
		            _this.saxParser.errThrown = true;
		            return _this.emit("error", error);
		          }
		        };
		      })(this);
		      this.saxParser.onend = (function(_this) {
		        return function() {
		          if (!_this.saxParser.ended) {
		            _this.saxParser.ended = true;
		            return _this.emit("end", _this.resultObject);
		          }
		        };
		      })(this);
		      this.saxParser.ended = false;
		      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
		      this.resultObject = null;
		      stack = [];
		      attrkey = this.options.attrkey;
		      charkey = this.options.charkey;
		      this.saxParser.onopentag = (function(_this) {
		        return function(node) {
		          var key, newValue, obj, processedKey, ref;
		          obj = {};
		          obj[charkey] = "";
		          if (!_this.options.ignoreAttrs) {
		            ref = node.attributes;
		            for (key in ref) {
		              if (!hasProp.call(ref, key)) continue;
		              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
		                obj[attrkey] = {};
		              }
		              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
		              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
		              if (_this.options.mergeAttrs) {
		                _this.assignOrPush(obj, processedKey, newValue);
		              } else {
		                defineProperty(obj[attrkey], processedKey, newValue);
		              }
		            }
		          }
		          obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
		          if (_this.options.xmlns) {
		            obj[_this.options.xmlnskey] = {
		              uri: node.uri,
		              local: node.local
		            };
		          }
		          return stack.push(obj);
		        };
		      })(this);
		      this.saxParser.onclosetag = (function(_this) {
		        return function() {
		          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
		          obj = stack.pop();
		          nodeName = obj["#name"];
		          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
		            delete obj["#name"];
		          }
		          if (obj.cdata === true) {
		            cdata = obj.cdata;
		            delete obj.cdata;
		          }
		          s = stack[stack.length - 1];
		          if (obj[charkey].match(/^\s*$/) && !cdata) {
		            emptyStr = obj[charkey];
		            delete obj[charkey];
		          } else {
		            if (_this.options.trim) {
		              obj[charkey] = obj[charkey].trim();
		            }
		            if (_this.options.normalize) {
		              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
		            }
		            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
		            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
		              obj = obj[charkey];
		            }
		          }
		          if (isEmpty(obj)) {
		            if (typeof _this.options.emptyTag === 'function') {
		              obj = _this.options.emptyTag();
		            } else {
		              obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
		            }
		          }
		          if (_this.options.validator != null) {
		            xpath = "/" + ((function() {
		              var i, len, results;
		              results = [];
		              for (i = 0, len = stack.length; i < len; i++) {
		                node = stack[i];
		                results.push(node["#name"]);
		              }
		              return results;
		            })()).concat(nodeName).join("/");
		            (function() {
		              var err;
		              try {
		                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
		              } catch (error1) {
		                err = error1;
		                return _this.emit("error", err);
		              }
		            })();
		          }
		          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
		            if (!_this.options.preserveChildrenOrder) {
		              node = {};
		              if (_this.options.attrkey in obj) {
		                node[_this.options.attrkey] = obj[_this.options.attrkey];
		                delete obj[_this.options.attrkey];
		              }
		              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
		                node[_this.options.charkey] = obj[_this.options.charkey];
		                delete obj[_this.options.charkey];
		              }
		              if (Object.getOwnPropertyNames(obj).length > 0) {
		                node[_this.options.childkey] = obj;
		              }
		              obj = node;
		            } else if (s) {
		              s[_this.options.childkey] = s[_this.options.childkey] || [];
		              objClone = {};
		              for (key in obj) {
		                if (!hasProp.call(obj, key)) continue;
		                defineProperty(objClone, key, obj[key]);
		              }
		              s[_this.options.childkey].push(objClone);
		              delete obj["#name"];
		              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
		                obj = obj[charkey];
		              }
		            }
		          }
		          if (stack.length > 0) {
		            return _this.assignOrPush(s, nodeName, obj);
		          } else {
		            if (_this.options.explicitRoot) {
		              old = obj;
		              obj = {};
		              defineProperty(obj, nodeName, old);
		            }
		            _this.resultObject = obj;
		            _this.saxParser.ended = true;
		            return _this.emit("end", _this.resultObject);
		          }
		        };
		      })(this);
		      ontext = (function(_this) {
		        return function(text) {
		          var charChild, s;
		          s = stack[stack.length - 1];
		          if (s) {
		            s[charkey] += text;
		            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
		              s[_this.options.childkey] = s[_this.options.childkey] || [];
		              charChild = {
		                '#name': '__text__'
		              };
		              charChild[charkey] = text;
		              if (_this.options.normalize) {
		                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
		              }
		              s[_this.options.childkey].push(charChild);
		            }
		            return s;
		          }
		        };
		      })(this);
		      this.saxParser.ontext = ontext;
		      return this.saxParser.oncdata = (function(_this) {
		        return function(text) {
		          var s;
		          s = ontext(text);
		          if (s) {
		            return s.cdata = true;
		          }
		        };
		      })();
		    };

		    Parser.prototype.parseString = function(str, cb) {
		      var err;
		      if ((cb != null) && typeof cb === "function") {
		        this.on("end", function(result) {
		          this.reset();
		          return cb(null, result);
		        });
		        this.on("error", function(err) {
		          this.reset();
		          return cb(err);
		        });
		      }
		      try {
		        str = str.toString();
		        if (str.trim() === '') {
		          this.emit("end", null);
		          return true;
		        }
		        str = bom.stripBOM(str);
		        if (this.options.async) {
		          this.remaining = str;
		          setImmediate(this.processAsync);
		          return this.saxParser;
		        }
		        return this.saxParser.write(str).close();
		      } catch (error1) {
		        err = error1;
		        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
		          this.emit('error', err);
		          return this.saxParser.errThrown = true;
		        } else if (this.saxParser.ended) {
		          throw err;
		        }
		      }
		    };

		    Parser.prototype.parseStringPromise = function(str) {
		      return new Promise((function(_this) {
		        return function(resolve, reject) {
		          return _this.parseString(str, function(err, value) {
		            if (err) {
		              return reject(err);
		            } else {
		              return resolve(value);
		            }
		          });
		        };
		      })(this));
		    };

		    return Parser;

		  })(events);

		  exports.parseString = function(str, a, b) {
		    var cb, options, parser;
		    if (b != null) {
		      if (typeof b === 'function') {
		        cb = b;
		      }
		      if (typeof a === 'object') {
		        options = a;
		      }
		    } else {
		      if (typeof a === 'function') {
		        cb = a;
		      }
		      options = {};
		    }
		    parser = new exports.Parser(options);
		    return parser.parseString(str, cb);
		  };

		  exports.parseStringPromise = function(str, a) {
		    var options, parser;
		    if (typeof a === 'object') {
		      options = a;
		    }
		    parser = new exports.Parser(options);
		    return parser.parseStringPromise(str);
		  };

		}).call(this);

		},{"./bom":491,"./defaults":493,"./processors":495,"events":386,"sax":465,"timers":484}],495:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var prefixMatch;

		  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

		  exports.normalize = function(str) {
		    return str.toLowerCase();
		  };

		  exports.firstCharLowerCase = function(str) {
		    return str.charAt(0).toLowerCase() + str.slice(1);
		  };

		  exports.stripPrefix = function(str) {
		    return str.replace(prefixMatch, '');
		  };

		  exports.parseNumbers = function(str) {
		    if (!isNaN(str)) {
		      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
		    }
		    return str;
		  };

		  exports.parseBooleans = function(str) {
		    if (/^(?:true|false)$/i.test(str)) {
		      str = str.toLowerCase() === 'true';
		    }
		    return str;
		  };

		}).call(this);

		},{}],496:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var builder, defaults, parser, processors,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  defaults = require('./defaults');

		  builder = require('./builder');

		  parser = require('./parser');

		  processors = require('./processors');

		  exports.defaults = defaults.defaults;

		  exports.processors = processors;

		  exports.ValidationError = (function(superClass) {
		    extend(ValidationError, superClass);

		    function ValidationError(message) {
		      this.message = message;
		    }

		    return ValidationError;

		  })(Error);

		  exports.Builder = builder.Builder;

		  exports.Parser = parser.Parser;

		  exports.parseString = parser.parseString;

		  exports.parseStringPromise = parser.parseStringPromise;

		}).call(this);

		},{"./builder":492,"./defaults":493,"./parser":494,"./processors":495}],497:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  module.exports = {
		    Disconnected: 1,
		    Preceding: 2,
		    Following: 4,
		    Contains: 8,
		    ContainedBy: 16,
		    ImplementationSpecific: 32
		  };

		}).call(this);

		},{}],498:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  module.exports = {
		    Element: 1,
		    Attribute: 2,
		    Text: 3,
		    CData: 4,
		    EntityReference: 5,
		    EntityDeclaration: 6,
		    ProcessingInstruction: 7,
		    Comment: 8,
		    Document: 9,
		    DocType: 10,
		    DocumentFragment: 11,
		    NotationDeclaration: 12,
		    Declaration: 201,
		    Raw: 202,
		    AttributeDeclaration: 203,
		    ElementDeclaration: 204,
		    Dummy: 205
		  };

		}).call(this);

		},{}],499:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject,
		    slice = [].slice,
		    hasProp = {}.hasOwnProperty;

		  assign = function() {
		    var i, key, len, source, sources, target;
		    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
		    if (isFunction(Object.assign)) {
		      Object.assign.apply(null, arguments);
		    } else {
		      for (i = 0, len = sources.length; i < len; i++) {
		        source = sources[i];
		        if (source != null) {
		          for (key in source) {
		            if (!hasProp.call(source, key)) continue;
		            target[key] = source[key];
		          }
		        }
		      }
		    }
		    return target;
		  };

		  isFunction = function(val) {
		    return !!val && Object.prototype.toString.call(val) === '[object Function]';
		  };

		  isObject = function(val) {
		    var ref;
		    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
		  };

		  isArray = function(val) {
		    if (isFunction(Array.isArray)) {
		      return Array.isArray(val);
		    } else {
		      return Object.prototype.toString.call(val) === '[object Array]';
		    }
		  };

		  isEmpty = function(val) {
		    var key;
		    if (isArray(val)) {
		      return !val.length;
		    } else {
		      for (key in val) {
		        if (!hasProp.call(val, key)) continue;
		        return false;
		      }
		      return true;
		    }
		  };

		  isPlainObject = function(val) {
		    var ctor, proto;
		    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
		  };

		  getValue = function(obj) {
		    if (isFunction(obj.valueOf)) {
		      return obj.valueOf();
		    } else {
		      return obj;
		    }
		  };

		  module.exports.assign = assign;

		  module.exports.isFunction = isFunction;

		  module.exports.isObject = isObject;

		  module.exports.isArray = isArray;

		  module.exports.isEmpty = isEmpty;

		  module.exports.isPlainObject = isPlainObject;

		  module.exports.getValue = getValue;

		}).call(this);

		},{}],500:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  module.exports = {
		    None: 0,
		    OpenTag: 1,
		    InsideTag: 2,
		    CloseTag: 3
		  };

		}).call(this);

		},{}],501:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType;

		  NodeType = require('./NodeType');

		  require('./XMLNode');

		  module.exports = (function() {
		    function XMLAttribute(parent, name, value) {
		      this.parent = parent;
		      if (this.parent) {
		        this.options = this.parent.options;
		        this.stringify = this.parent.stringify;
		      }
		      if (name == null) {
		        throw new Error("Missing attribute name. " + this.debugInfo(name));
		      }
		      this.name = this.stringify.name(name);
		      this.value = this.stringify.attValue(value);
		      this.type = NodeType.Attribute;
		      this.isId = false;
		      this.schemaTypeInfo = null;
		    }

		    Object.defineProperty(XMLAttribute.prototype, 'nodeType', {
		      get: function() {
		        return this.type;
		      }
		    });

		    Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {
		      get: function() {
		        return this.parent;
		      }
		    });

		    Object.defineProperty(XMLAttribute.prototype, 'textContent', {
		      get: function() {
		        return this.value;
		      },
		      set: function(value) {
		        return this.value = value || '';
		      }
		    });

		    Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {
		      get: function() {
		        return '';
		      }
		    });

		    Object.defineProperty(XMLAttribute.prototype, 'prefix', {
		      get: function() {
		        return '';
		      }
		    });

		    Object.defineProperty(XMLAttribute.prototype, 'localName', {
		      get: function() {
		        return this.name;
		      }
		    });

		    Object.defineProperty(XMLAttribute.prototype, 'specified', {
		      get: function() {
		        return true;
		      }
		    });

		    XMLAttribute.prototype.clone = function() {
		      return Object.create(this);
		    };

		    XMLAttribute.prototype.toString = function(options) {
		      return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
		    };

		    XMLAttribute.prototype.debugInfo = function(name) {
		      name = name || this.name;
		      if (name == null) {
		        return "parent: <" + this.parent.name + ">";
		      } else {
		        return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
		      }
		    };

		    XMLAttribute.prototype.isEqualNode = function(node) {
		      if (node.namespaceURI !== this.namespaceURI) {
		        return false;
		      }
		      if (node.prefix !== this.prefix) {
		        return false;
		      }
		      if (node.localName !== this.localName) {
		        return false;
		      }
		      if (node.value !== this.value) {
		        return false;
		      }
		      return true;
		    };

		    return XMLAttribute;

		  })();

		}).call(this);

		},{"./NodeType":498,"./XMLNode":520}],502:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLCharacterData,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  NodeType = require('./NodeType');

		  XMLCharacterData = require('./XMLCharacterData');

		  module.exports = (function(superClass) {
		    extend(XMLCData, superClass);

		    function XMLCData(parent, text) {
		      XMLCData.__super__.constructor.call(this, parent);
		      if (text == null) {
		        throw new Error("Missing CDATA text. " + this.debugInfo());
		      }
		      this.name = "#cdata-section";
		      this.type = NodeType.CData;
		      this.value = this.stringify.cdata(text);
		    }

		    XMLCData.prototype.clone = function() {
		      return Object.create(this);
		    };

		    XMLCData.prototype.toString = function(options) {
		      return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
		    };

		    return XMLCData;

		  })(XMLCharacterData);

		}).call(this);

		},{"./NodeType":498,"./XMLCharacterData":503}],503:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var XMLNode,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  XMLNode = require('./XMLNode');

		  module.exports = (function(superClass) {
		    extend(XMLCharacterData, superClass);

		    function XMLCharacterData(parent) {
		      XMLCharacterData.__super__.constructor.call(this, parent);
		      this.value = '';
		    }

		    Object.defineProperty(XMLCharacterData.prototype, 'data', {
		      get: function() {
		        return this.value;
		      },
		      set: function(value) {
		        return this.value = value || '';
		      }
		    });

		    Object.defineProperty(XMLCharacterData.prototype, 'length', {
		      get: function() {
		        return this.value.length;
		      }
		    });

		    Object.defineProperty(XMLCharacterData.prototype, 'textContent', {
		      get: function() {
		        return this.value;
		      },
		      set: function(value) {
		        return this.value = value || '';
		      }
		    });

		    XMLCharacterData.prototype.clone = function() {
		      return Object.create(this);
		    };

		    XMLCharacterData.prototype.substringData = function(offset, count) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLCharacterData.prototype.appendData = function(arg) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLCharacterData.prototype.insertData = function(offset, arg) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLCharacterData.prototype.deleteData = function(offset, count) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLCharacterData.prototype.replaceData = function(offset, count, arg) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLCharacterData.prototype.isEqualNode = function(node) {
		      if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
		        return false;
		      }
		      if (node.data !== this.data) {
		        return false;
		      }
		      return true;
		    };

		    return XMLCharacterData;

		  })(XMLNode);

		}).call(this);

		},{"./XMLNode":520}],504:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLCharacterData, extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  NodeType = require('./NodeType');

		  XMLCharacterData = require('./XMLCharacterData');

		  module.exports = (function(superClass) {
		    extend(XMLComment, superClass);

		    function XMLComment(parent, text) {
		      XMLComment.__super__.constructor.call(this, parent);
		      if (text == null) {
		        throw new Error("Missing comment text. " + this.debugInfo());
		      }
		      this.name = "#comment";
		      this.type = NodeType.Comment;
		      this.value = this.stringify.comment(text);
		    }

		    XMLComment.prototype.clone = function() {
		      return Object.create(this);
		    };

		    XMLComment.prototype.toString = function(options) {
		      return this.options.writer.comment(this, this.options.writer.filterOptions(options));
		    };

		    return XMLComment;

		  })(XMLCharacterData);

		}).call(this);

		},{"./NodeType":498,"./XMLCharacterData":503}],505:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var XMLDOMErrorHandler, XMLDOMStringList;

		  XMLDOMErrorHandler = require('./XMLDOMErrorHandler');

		  XMLDOMStringList = require('./XMLDOMStringList');

		  module.exports = (function() {
		    function XMLDOMConfiguration() {
		      this.defaultParams = {
		        "canonical-form": false,
		        "cdata-sections": false,
		        "comments": false,
		        "datatype-normalization": false,
		        "element-content-whitespace": true,
		        "entities": true,
		        "error-handler": new XMLDOMErrorHandler(),
		        "infoset": true,
		        "validate-if-schema": false,
		        "namespaces": true,
		        "namespace-declarations": true,
		        "normalize-characters": false,
		        "schema-location": '',
		        "schema-type": '',
		        "split-cdata-sections": true,
		        "validate": false,
		        "well-formed": true
		      };
		      this.params = Object.create(this.defaultParams);
		    }

		    Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {
		      get: function() {
		        return new XMLDOMStringList(Object.keys(this.defaultParams));
		      }
		    });

		    XMLDOMConfiguration.prototype.getParameter = function(name) {
		      if (this.params.hasOwnProperty(name)) {
		        return this.params[name];
		      } else {
		        return null;
		      }
		    };

		    XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {
		      return true;
		    };

		    XMLDOMConfiguration.prototype.setParameter = function(name, value) {
		      if (value != null) {
		        return this.params[name] = value;
		      } else {
		        return delete this.params[name];
		      }
		    };

		    return XMLDOMConfiguration;

		  })();

		}).call(this);

		},{"./XMLDOMErrorHandler":506,"./XMLDOMStringList":508}],506:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {

		  module.exports = (function() {
		    function XMLDOMErrorHandler() {}

		    XMLDOMErrorHandler.prototype.handleError = function(error) {
		      throw new Error(error);
		    };

		    return XMLDOMErrorHandler;

		  })();

		}).call(this);

		},{}],507:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {

		  module.exports = (function() {
		    function XMLDOMImplementation() {}

		    XMLDOMImplementation.prototype.hasFeature = function(feature, version) {
		      return true;
		    };

		    XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
		      throw new Error("This DOM method is not implemented.");
		    };

		    XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
		      throw new Error("This DOM method is not implemented.");
		    };

		    XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
		      throw new Error("This DOM method is not implemented.");
		    };

		    XMLDOMImplementation.prototype.getFeature = function(feature, version) {
		      throw new Error("This DOM method is not implemented.");
		    };

		    return XMLDOMImplementation;

		  })();

		}).call(this);

		},{}],508:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {

		  module.exports = (function() {
		    function XMLDOMStringList(arr) {
		      this.arr = arr || [];
		    }

		    Object.defineProperty(XMLDOMStringList.prototype, 'length', {
		      get: function() {
		        return this.arr.length;
		      }
		    });

		    XMLDOMStringList.prototype.item = function(index) {
		      return this.arr[index] || null;
		    };

		    XMLDOMStringList.prototype.contains = function(str) {
		      return this.arr.indexOf(str) !== -1;
		    };

		    return XMLDOMStringList;

		  })();

		}).call(this);

		},{}],509:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLNode,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  XMLNode = require('./XMLNode');

		  NodeType = require('./NodeType');

		  module.exports = (function(superClass) {
		    extend(XMLDTDAttList, superClass);

		    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
		      XMLDTDAttList.__super__.constructor.call(this, parent);
		      if (elementName == null) {
		        throw new Error("Missing DTD element name. " + this.debugInfo());
		      }
		      if (attributeName == null) {
		        throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
		      }
		      if (!attributeType) {
		        throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
		      }
		      if (!defaultValueType) {
		        throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
		      }
		      if (defaultValueType.indexOf('#') !== 0) {
		        defaultValueType = '#' + defaultValueType;
		      }
		      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
		        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
		      }
		      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
		        throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
		      }
		      this.elementName = this.stringify.name(elementName);
		      this.type = NodeType.AttributeDeclaration;
		      this.attributeName = this.stringify.name(attributeName);
		      this.attributeType = this.stringify.dtdAttType(attributeType);
		      if (defaultValue) {
		        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
		      }
		      this.defaultValueType = defaultValueType;
		    }

		    XMLDTDAttList.prototype.toString = function(options) {
		      return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
		    };

		    return XMLDTDAttList;

		  })(XMLNode);

		}).call(this);

		},{"./NodeType":498,"./XMLNode":520}],510:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLNode,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  XMLNode = require('./XMLNode');

		  NodeType = require('./NodeType');

		  module.exports = (function(superClass) {
		    extend(XMLDTDElement, superClass);

		    function XMLDTDElement(parent, name, value) {
		      XMLDTDElement.__super__.constructor.call(this, parent);
		      if (name == null) {
		        throw new Error("Missing DTD element name. " + this.debugInfo());
		      }
		      if (!value) {
		        value = '(#PCDATA)';
		      }
		      if (Array.isArray(value)) {
		        value = '(' + value.join(',') + ')';
		      }
		      this.name = this.stringify.name(name);
		      this.type = NodeType.ElementDeclaration;
		      this.value = this.stringify.dtdElementValue(value);
		    }

		    XMLDTDElement.prototype.toString = function(options) {
		      return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
		    };

		    return XMLDTDElement;

		  })(XMLNode);

		}).call(this);

		},{"./NodeType":498,"./XMLNode":520}],511:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLNode, isObject,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  isObject = require('./Utility').isObject;

		  XMLNode = require('./XMLNode');

		  NodeType = require('./NodeType');

		  module.exports = (function(superClass) {
		    extend(XMLDTDEntity, superClass);

		    function XMLDTDEntity(parent, pe, name, value) {
		      XMLDTDEntity.__super__.constructor.call(this, parent);
		      if (name == null) {
		        throw new Error("Missing DTD entity name. " + this.debugInfo(name));
		      }
		      if (value == null) {
		        throw new Error("Missing DTD entity value. " + this.debugInfo(name));
		      }
		      this.pe = !!pe;
		      this.name = this.stringify.name(name);
		      this.type = NodeType.EntityDeclaration;
		      if (!isObject(value)) {
		        this.value = this.stringify.dtdEntityValue(value);
		        this.internal = true;
		      } else {
		        if (!value.pubID && !value.sysID) {
		          throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
		        }
		        if (value.pubID && !value.sysID) {
		          throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
		        }
		        this.internal = false;
		        if (value.pubID != null) {
		          this.pubID = this.stringify.dtdPubID(value.pubID);
		        }
		        if (value.sysID != null) {
		          this.sysID = this.stringify.dtdSysID(value.sysID);
		        }
		        if (value.nData != null) {
		          this.nData = this.stringify.dtdNData(value.nData);
		        }
		        if (this.pe && this.nData) {
		          throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
		        }
		      }
		    }

		    Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {
		      get: function() {
		        return this.pubID;
		      }
		    });

		    Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {
		      get: function() {
		        return this.sysID;
		      }
		    });

		    Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {
		      get: function() {
		        return this.nData || null;
		      }
		    });

		    Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {
		      get: function() {
		        return null;
		      }
		    });

		    Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {
		      get: function() {
		        return null;
		      }
		    });

		    Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {
		      get: function() {
		        return null;
		      }
		    });

		    XMLDTDEntity.prototype.toString = function(options) {
		      return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
		    };

		    return XMLDTDEntity;

		  })(XMLNode);

		}).call(this);

		},{"./NodeType":498,"./Utility":499,"./XMLNode":520}],512:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLNode,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  XMLNode = require('./XMLNode');

		  NodeType = require('./NodeType');

		  module.exports = (function(superClass) {
		    extend(XMLDTDNotation, superClass);

		    function XMLDTDNotation(parent, name, value) {
		      XMLDTDNotation.__super__.constructor.call(this, parent);
		      if (name == null) {
		        throw new Error("Missing DTD notation name. " + this.debugInfo(name));
		      }
		      if (!value.pubID && !value.sysID) {
		        throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
		      }
		      this.name = this.stringify.name(name);
		      this.type = NodeType.NotationDeclaration;
		      if (value.pubID != null) {
		        this.pubID = this.stringify.dtdPubID(value.pubID);
		      }
		      if (value.sysID != null) {
		        this.sysID = this.stringify.dtdSysID(value.sysID);
		      }
		    }

		    Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {
		      get: function() {
		        return this.pubID;
		      }
		    });

		    Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {
		      get: function() {
		        return this.sysID;
		      }
		    });

		    XMLDTDNotation.prototype.toString = function(options) {
		      return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
		    };

		    return XMLDTDNotation;

		  })(XMLNode);

		}).call(this);

		},{"./NodeType":498,"./XMLNode":520}],513:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLNode, isObject,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  isObject = require('./Utility').isObject;

		  XMLNode = require('./XMLNode');

		  NodeType = require('./NodeType');

		  module.exports = (function(superClass) {
		    extend(XMLDeclaration, superClass);

		    function XMLDeclaration(parent, version, encoding, standalone) {
		      var ref;
		      XMLDeclaration.__super__.constructor.call(this, parent);
		      if (isObject(version)) {
		        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
		      }
		      if (!version) {
		        version = '1.0';
		      }
		      this.type = NodeType.Declaration;
		      this.version = this.stringify.xmlVersion(version);
		      if (encoding != null) {
		        this.encoding = this.stringify.xmlEncoding(encoding);
		      }
		      if (standalone != null) {
		        this.standalone = this.stringify.xmlStandalone(standalone);
		      }
		    }

		    XMLDeclaration.prototype.toString = function(options) {
		      return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
		    };

		    return XMLDeclaration;

		  })(XMLNode);

		}).call(this);

		},{"./NodeType":498,"./Utility":499,"./XMLNode":520}],514:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLNamedNodeMap, XMLNode, isObject,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  isObject = require('./Utility').isObject;

		  XMLNode = require('./XMLNode');

		  NodeType = require('./NodeType');

		  XMLDTDAttList = require('./XMLDTDAttList');

		  XMLDTDEntity = require('./XMLDTDEntity');

		  XMLDTDElement = require('./XMLDTDElement');

		  XMLDTDNotation = require('./XMLDTDNotation');

		  XMLNamedNodeMap = require('./XMLNamedNodeMap');

		  module.exports = (function(superClass) {
		    extend(XMLDocType, superClass);

		    function XMLDocType(parent, pubID, sysID) {
		      var child, i, len, ref, ref1, ref2;
		      XMLDocType.__super__.constructor.call(this, parent);
		      this.type = NodeType.DocType;
		      if (parent.children) {
		        ref = parent.children;
		        for (i = 0, len = ref.length; i < len; i++) {
		          child = ref[i];
		          if (child.type === NodeType.Element) {
		            this.name = child.name;
		            break;
		          }
		        }
		      }
		      this.documentObject = parent;
		      if (isObject(pubID)) {
		        ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
		      }
		      if (sysID == null) {
		        ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
		      }
		      if (pubID != null) {
		        this.pubID = this.stringify.dtdPubID(pubID);
		      }
		      if (sysID != null) {
		        this.sysID = this.stringify.dtdSysID(sysID);
		      }
		    }

		    Object.defineProperty(XMLDocType.prototype, 'entities', {
		      get: function() {
		        var child, i, len, nodes, ref;
		        nodes = {};
		        ref = this.children;
		        for (i = 0, len = ref.length; i < len; i++) {
		          child = ref[i];
		          if ((child.type === NodeType.EntityDeclaration) && !child.pe) {
		            nodes[child.name] = child;
		          }
		        }
		        return new XMLNamedNodeMap(nodes);
		      }
		    });

		    Object.defineProperty(XMLDocType.prototype, 'notations', {
		      get: function() {
		        var child, i, len, nodes, ref;
		        nodes = {};
		        ref = this.children;
		        for (i = 0, len = ref.length; i < len; i++) {
		          child = ref[i];
		          if (child.type === NodeType.NotationDeclaration) {
		            nodes[child.name] = child;
		          }
		        }
		        return new XMLNamedNodeMap(nodes);
		      }
		    });

		    Object.defineProperty(XMLDocType.prototype, 'publicId', {
		      get: function() {
		        return this.pubID;
		      }
		    });

		    Object.defineProperty(XMLDocType.prototype, 'systemId', {
		      get: function() {
		        return this.sysID;
		      }
		    });

		    Object.defineProperty(XMLDocType.prototype, 'internalSubset', {
		      get: function() {
		        throw new Error("This DOM method is not implemented." + this.debugInfo());
		      }
		    });

		    XMLDocType.prototype.element = function(name, value) {
		      var child;
		      child = new XMLDTDElement(this, name, value);
		      this.children.push(child);
		      return this;
		    };

		    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
		      var child;
		      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
		      this.children.push(child);
		      return this;
		    };

		    XMLDocType.prototype.entity = function(name, value) {
		      var child;
		      child = new XMLDTDEntity(this, false, name, value);
		      this.children.push(child);
		      return this;
		    };

		    XMLDocType.prototype.pEntity = function(name, value) {
		      var child;
		      child = new XMLDTDEntity(this, true, name, value);
		      this.children.push(child);
		      return this;
		    };

		    XMLDocType.prototype.notation = function(name, value) {
		      var child;
		      child = new XMLDTDNotation(this, name, value);
		      this.children.push(child);
		      return this;
		    };

		    XMLDocType.prototype.toString = function(options) {
		      return this.options.writer.docType(this, this.options.writer.filterOptions(options));
		    };

		    XMLDocType.prototype.ele = function(name, value) {
		      return this.element(name, value);
		    };

		    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
		      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
		    };

		    XMLDocType.prototype.ent = function(name, value) {
		      return this.entity(name, value);
		    };

		    XMLDocType.prototype.pent = function(name, value) {
		      return this.pEntity(name, value);
		    };

		    XMLDocType.prototype.not = function(name, value) {
		      return this.notation(name, value);
		    };

		    XMLDocType.prototype.up = function() {
		      return this.root() || this.documentObject;
		    };

		    XMLDocType.prototype.isEqualNode = function(node) {
		      if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
		        return false;
		      }
		      if (node.name !== this.name) {
		        return false;
		      }
		      if (node.publicId !== this.publicId) {
		        return false;
		      }
		      if (node.systemId !== this.systemId) {
		        return false;
		      }
		      return true;
		    };

		    return XMLDocType;

		  })(XMLNode);

		}).call(this);

		},{"./NodeType":498,"./Utility":499,"./XMLDTDAttList":509,"./XMLDTDElement":510,"./XMLDTDEntity":511,"./XMLDTDNotation":512,"./XMLNamedNodeMap":519,"./XMLNode":520}],515:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  isPlainObject = require('./Utility').isPlainObject;

		  XMLDOMImplementation = require('./XMLDOMImplementation');

		  XMLDOMConfiguration = require('./XMLDOMConfiguration');

		  XMLNode = require('./XMLNode');

		  NodeType = require('./NodeType');

		  XMLStringifier = require('./XMLStringifier');

		  XMLStringWriter = require('./XMLStringWriter');

		  module.exports = (function(superClass) {
		    extend(XMLDocument, superClass);

		    function XMLDocument(options) {
		      XMLDocument.__super__.constructor.call(this, null);
		      this.name = "#document";
		      this.type = NodeType.Document;
		      this.documentURI = null;
		      this.domConfig = new XMLDOMConfiguration();
		      options || (options = {});
		      if (!options.writer) {
		        options.writer = new XMLStringWriter();
		      }
		      this.options = options;
		      this.stringify = new XMLStringifier(options);
		    }

		    Object.defineProperty(XMLDocument.prototype, 'implementation', {
		      value: new XMLDOMImplementation()
		    });

		    Object.defineProperty(XMLDocument.prototype, 'doctype', {
		      get: function() {
		        var child, i, len, ref;
		        ref = this.children;
		        for (i = 0, len = ref.length; i < len; i++) {
		          child = ref[i];
		          if (child.type === NodeType.DocType) {
		            return child;
		          }
		        }
		        return null;
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'documentElement', {
		      get: function() {
		        return this.rootObject || null;
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {
		      get: function() {
		        return null;
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {
		      get: function() {
		        return false;
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {
		      get: function() {
		        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
		          return this.children[0].encoding;
		        } else {
		          return null;
		        }
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {
		      get: function() {
		        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
		          return this.children[0].standalone === 'yes';
		        } else {
		          return false;
		        }
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {
		      get: function() {
		        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
		          return this.children[0].version;
		        } else {
		          return "1.0";
		        }
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'URL', {
		      get: function() {
		        return this.documentURI;
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'origin', {
		      get: function() {
		        return null;
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'compatMode', {
		      get: function() {
		        return null;
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'characterSet', {
		      get: function() {
		        return null;
		      }
		    });

		    Object.defineProperty(XMLDocument.prototype, 'contentType', {
		      get: function() {
		        return null;
		      }
		    });

		    XMLDocument.prototype.end = function(writer) {
		      var writerOptions;
		      writerOptions = {};
		      if (!writer) {
		        writer = this.options.writer;
		      } else if (isPlainObject(writer)) {
		        writerOptions = writer;
		        writer = this.options.writer;
		      }
		      return writer.document(this, writer.filterOptions(writerOptions));
		    };

		    XMLDocument.prototype.toString = function(options) {
		      return this.options.writer.document(this, this.options.writer.filterOptions(options));
		    };

		    XMLDocument.prototype.createElement = function(tagName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createDocumentFragment = function() {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createTextNode = function(data) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createComment = function(data) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createCDATASection = function(data) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createProcessingInstruction = function(target, data) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createAttribute = function(name) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createEntityReference = function(name) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.getElementsByTagName = function(tagname) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.importNode = function(importedNode, deep) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.getElementById = function(elementId) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.adoptNode = function(source) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.normalizeDocument = function() {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.getElementsByClassName = function(classNames) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createEvent = function(eventInterface) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createRange = function() {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    return XMLDocument;

		  })(XMLNode);

		}).call(this);

		},{"./NodeType":498,"./Utility":499,"./XMLDOMConfiguration":505,"./XMLDOMImplementation":507,"./XMLNode":520,"./XMLStringWriter":525,"./XMLStringifier":526}],516:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref,
		    hasProp = {}.hasOwnProperty;

		  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;

		  NodeType = require('./NodeType');

		  XMLDocument = require('./XMLDocument');

		  XMLElement = require('./XMLElement');

		  XMLCData = require('./XMLCData');

		  XMLComment = require('./XMLComment');

		  XMLRaw = require('./XMLRaw');

		  XMLText = require('./XMLText');

		  XMLProcessingInstruction = require('./XMLProcessingInstruction');

		  XMLDeclaration = require('./XMLDeclaration');

		  XMLDocType = require('./XMLDocType');

		  XMLDTDAttList = require('./XMLDTDAttList');

		  XMLDTDEntity = require('./XMLDTDEntity');

		  XMLDTDElement = require('./XMLDTDElement');

		  XMLDTDNotation = require('./XMLDTDNotation');

		  XMLAttribute = require('./XMLAttribute');

		  XMLStringifier = require('./XMLStringifier');

		  XMLStringWriter = require('./XMLStringWriter');

		  WriterState = require('./WriterState');

		  module.exports = (function() {
		    function XMLDocumentCB(options, onData, onEnd) {
		      var writerOptions;
		      this.name = "?xml";
		      this.type = NodeType.Document;
		      options || (options = {});
		      writerOptions = {};
		      if (!options.writer) {
		        options.writer = new XMLStringWriter();
		      } else if (isPlainObject(options.writer)) {
		        writerOptions = options.writer;
		        options.writer = new XMLStringWriter();
		      }
		      this.options = options;
		      this.writer = options.writer;
		      this.writerOptions = this.writer.filterOptions(writerOptions);
		      this.stringify = new XMLStringifier(options);
		      this.onDataCallback = onData || function() {};
		      this.onEndCallback = onEnd || function() {};
		      this.currentNode = null;
		      this.currentLevel = -1;
		      this.openTags = {};
		      this.documentStarted = false;
		      this.documentCompleted = false;
		      this.root = null;
		    }

		    XMLDocumentCB.prototype.createChildNode = function(node) {
		      var att, attName, attributes, child, i, len, ref1, ref2;
		      switch (node.type) {
		        case NodeType.CData:
		          this.cdata(node.value);
		          break;
		        case NodeType.Comment:
		          this.comment(node.value);
		          break;
		        case NodeType.Element:
		          attributes = {};
		          ref1 = node.attribs;
		          for (attName in ref1) {
		            if (!hasProp.call(ref1, attName)) continue;
		            att = ref1[attName];
		            attributes[attName] = att.value;
		          }
		          this.node(node.name, attributes);
		          break;
		        case NodeType.Dummy:
		          this.dummy();
		          break;
		        case NodeType.Raw:
		          this.raw(node.value);
		          break;
		        case NodeType.Text:
		          this.text(node.value);
		          break;
		        case NodeType.ProcessingInstruction:
		          this.instruction(node.target, node.value);
		          break;
		        default:
		          throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
		      }
		      ref2 = node.children;
		      for (i = 0, len = ref2.length; i < len; i++) {
		        child = ref2[i];
		        this.createChildNode(child);
		        if (child.type === NodeType.Element) {
		          this.up();
		        }
		      }
		      return this;
		    };

		    XMLDocumentCB.prototype.dummy = function() {
		      return this;
		    };

		    XMLDocumentCB.prototype.node = function(name, attributes, text) {
		      var ref1;
		      if (name == null) {
		        throw new Error("Missing node name.");
		      }
		      if (this.root && this.currentLevel === -1) {
		        throw new Error("Document can only have one root node. " + this.debugInfo(name));
		      }
		      this.openCurrent();
		      name = getValue(name);
		      if (attributes == null) {
		        attributes = {};
		      }
		      attributes = getValue(attributes);
		      if (!isObject(attributes)) {
		        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
		      }
		      this.currentNode = new XMLElement(this, name, attributes);
		      this.currentNode.children = false;
		      this.currentLevel++;
		      this.openTags[this.currentLevel] = this.currentNode;
		      if (text != null) {
		        this.text(text);
		      }
		      return this;
		    };

		    XMLDocumentCB.prototype.element = function(name, attributes, text) {
		      var child, i, len, oldValidationFlag, ref1, root;
		      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
		        this.dtdElement.apply(this, arguments);
		      } else {
		        if (Array.isArray(name) || isObject(name) || isFunction(name)) {
		          oldValidationFlag = this.options.noValidation;
		          this.options.noValidation = true;
		          root = new XMLDocument(this.options).element('TEMP_ROOT');
		          root.element(name);
		          this.options.noValidation = oldValidationFlag;
		          ref1 = root.children;
		          for (i = 0, len = ref1.length; i < len; i++) {
		            child = ref1[i];
		            this.createChildNode(child);
		            if (child.type === NodeType.Element) {
		              this.up();
		            }
		          }
		        } else {
		          this.node(name, attributes, text);
		        }
		      }
		      return this;
		    };

		    XMLDocumentCB.prototype.attribute = function(name, value) {
		      var attName, attValue;
		      if (!this.currentNode || this.currentNode.children) {
		        throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
		      }
		      if (name != null) {
		        name = getValue(name);
		      }
		      if (isObject(name)) {
		        for (attName in name) {
		          if (!hasProp.call(name, attName)) continue;
		          attValue = name[attName];
		          this.attribute(attName, attValue);
		        }
		      } else {
		        if (isFunction(value)) {
		          value = value.apply();
		        }
		        if (this.options.keepNullAttributes && (value == null)) {
		          this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
		        } else if (value != null) {
		          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
		        }
		      }
		      return this;
		    };

		    XMLDocumentCB.prototype.text = function(value) {
		      var node;
		      this.openCurrent();
		      node = new XMLText(this, value);
		      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      return this;
		    };

		    XMLDocumentCB.prototype.cdata = function(value) {
		      var node;
		      this.openCurrent();
		      node = new XMLCData(this, value);
		      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      return this;
		    };

		    XMLDocumentCB.prototype.comment = function(value) {
		      var node;
		      this.openCurrent();
		      node = new XMLComment(this, value);
		      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      return this;
		    };

		    XMLDocumentCB.prototype.raw = function(value) {
		      var node;
		      this.openCurrent();
		      node = new XMLRaw(this, value);
		      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      return this;
		    };

		    XMLDocumentCB.prototype.instruction = function(target, value) {
		      var i, insTarget, insValue, len, node;
		      this.openCurrent();
		      if (target != null) {
		        target = getValue(target);
		      }
		      if (value != null) {
		        value = getValue(value);
		      }
		      if (Array.isArray(target)) {
		        for (i = 0, len = target.length; i < len; i++) {
		          insTarget = target[i];
		          this.instruction(insTarget);
		        }
		      } else if (isObject(target)) {
		        for (insTarget in target) {
		          if (!hasProp.call(target, insTarget)) continue;
		          insValue = target[insTarget];
		          this.instruction(insTarget, insValue);
		        }
		      } else {
		        if (isFunction(value)) {
		          value = value.apply();
		        }
		        node = new XMLProcessingInstruction(this, target, value);
		        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      }
		      return this;
		    };

		    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
		      var node;
		      this.openCurrent();
		      if (this.documentStarted) {
		        throw new Error("declaration() must be the first node.");
		      }
		      node = new XMLDeclaration(this, version, encoding, standalone);
		      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      return this;
		    };

		    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
		      this.openCurrent();
		      if (root == null) {
		        throw new Error("Missing root node name.");
		      }
		      if (this.root) {
		        throw new Error("dtd() must come before the root node.");
		      }
		      this.currentNode = new XMLDocType(this, pubID, sysID);
		      this.currentNode.rootNodeName = root;
		      this.currentNode.children = false;
		      this.currentLevel++;
		      this.openTags[this.currentLevel] = this.currentNode;
		      return this;
		    };

		    XMLDocumentCB.prototype.dtdElement = function(name, value) {
		      var node;
		      this.openCurrent();
		      node = new XMLDTDElement(this, name, value);
		      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      return this;
		    };

		    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
		      var node;
		      this.openCurrent();
		      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
		      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      return this;
		    };

		    XMLDocumentCB.prototype.entity = function(name, value) {
		      var node;
		      this.openCurrent();
		      node = new XMLDTDEntity(this, false, name, value);
		      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      return this;
		    };

		    XMLDocumentCB.prototype.pEntity = function(name, value) {
		      var node;
		      this.openCurrent();
		      node = new XMLDTDEntity(this, true, name, value);
		      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      return this;
		    };

		    XMLDocumentCB.prototype.notation = function(name, value) {
		      var node;
		      this.openCurrent();
		      node = new XMLDTDNotation(this, name, value);
		      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
		      return this;
		    };

		    XMLDocumentCB.prototype.up = function() {
		      if (this.currentLevel < 0) {
		        throw new Error("The document node has no parent.");
		      }
		      if (this.currentNode) {
		        if (this.currentNode.children) {
		          this.closeNode(this.currentNode);
		        } else {
		          this.openNode(this.currentNode);
		        }
		        this.currentNode = null;
		      } else {
		        this.closeNode(this.openTags[this.currentLevel]);
		      }
		      delete this.openTags[this.currentLevel];
		      this.currentLevel--;
		      return this;
		    };

		    XMLDocumentCB.prototype.end = function() {
		      while (this.currentLevel >= 0) {
		        this.up();
		      }
		      return this.onEnd();
		    };

		    XMLDocumentCB.prototype.openCurrent = function() {
		      if (this.currentNode) {
		        this.currentNode.children = true;
		        return this.openNode(this.currentNode);
		      }
		    };

		    XMLDocumentCB.prototype.openNode = function(node) {
		      var att, chunk, name, ref1;
		      if (!node.isOpen) {
		        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
		          this.root = node;
		        }
		        chunk = '';
		        if (node.type === NodeType.Element) {
		          this.writerOptions.state = WriterState.OpenTag;
		          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;
		          ref1 = node.attribs;
		          for (name in ref1) {
		            if (!hasProp.call(ref1, name)) continue;
		            att = ref1[name];
		            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
		          }
		          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);
		          this.writerOptions.state = WriterState.InsideTag;
		        } else {
		          this.writerOptions.state = WriterState.OpenTag;
		          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;
		          if (node.pubID && node.sysID) {
		            chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
		          } else if (node.sysID) {
		            chunk += ' SYSTEM "' + node.sysID + '"';
		          }
		          if (node.children) {
		            chunk += ' [';
		            this.writerOptions.state = WriterState.InsideTag;
		          } else {
		            this.writerOptions.state = WriterState.CloseTag;
		            chunk += '>';
		          }
		          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
		        }
		        this.onData(chunk, this.currentLevel);
		        return node.isOpen = true;
		      }
		    };

		    XMLDocumentCB.prototype.closeNode = function(node) {
		      var chunk;
		      if (!node.isClosed) {
		        chunk = '';
		        this.writerOptions.state = WriterState.CloseTag;
		        if (node.type === NodeType.Element) {
		          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
		        } else {
		          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
		        }
		        this.writerOptions.state = WriterState.None;
		        this.onData(chunk, this.currentLevel);
		        return node.isClosed = true;
		      }
		    };

		    XMLDocumentCB.prototype.onData = function(chunk, level) {
		      this.documentStarted = true;
		      return this.onDataCallback(chunk, level + 1);
		    };

		    XMLDocumentCB.prototype.onEnd = function() {
		      this.documentCompleted = true;
		      return this.onEndCallback();
		    };

		    XMLDocumentCB.prototype.debugInfo = function(name) {
		      if (name == null) {
		        return "";
		      } else {
		        return "node: <" + name + ">";
		      }
		    };

		    XMLDocumentCB.prototype.ele = function() {
		      return this.element.apply(this, arguments);
		    };

		    XMLDocumentCB.prototype.nod = function(name, attributes, text) {
		      return this.node(name, attributes, text);
		    };

		    XMLDocumentCB.prototype.txt = function(value) {
		      return this.text(value);
		    };

		    XMLDocumentCB.prototype.dat = function(value) {
		      return this.cdata(value);
		    };

		    XMLDocumentCB.prototype.com = function(value) {
		      return this.comment(value);
		    };

		    XMLDocumentCB.prototype.ins = function(target, value) {
		      return this.instruction(target, value);
		    };

		    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
		      return this.declaration(version, encoding, standalone);
		    };

		    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
		      return this.doctype(root, pubID, sysID);
		    };

		    XMLDocumentCB.prototype.e = function(name, attributes, text) {
		      return this.element(name, attributes, text);
		    };

		    XMLDocumentCB.prototype.n = function(name, attributes, text) {
		      return this.node(name, attributes, text);
		    };

		    XMLDocumentCB.prototype.t = function(value) {
		      return this.text(value);
		    };

		    XMLDocumentCB.prototype.d = function(value) {
		      return this.cdata(value);
		    };

		    XMLDocumentCB.prototype.c = function(value) {
		      return this.comment(value);
		    };

		    XMLDocumentCB.prototype.r = function(value) {
		      return this.raw(value);
		    };

		    XMLDocumentCB.prototype.i = function(target, value) {
		      return this.instruction(target, value);
		    };

		    XMLDocumentCB.prototype.att = function() {
		      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
		        return this.attList.apply(this, arguments);
		      } else {
		        return this.attribute.apply(this, arguments);
		      }
		    };

		    XMLDocumentCB.prototype.a = function() {
		      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
		        return this.attList.apply(this, arguments);
		      } else {
		        return this.attribute.apply(this, arguments);
		      }
		    };

		    XMLDocumentCB.prototype.ent = function(name, value) {
		      return this.entity(name, value);
		    };

		    XMLDocumentCB.prototype.pent = function(name, value) {
		      return this.pEntity(name, value);
		    };

		    XMLDocumentCB.prototype.not = function(name, value) {
		      return this.notation(name, value);
		    };

		    return XMLDocumentCB;

		  })();

		}).call(this);

		},{"./NodeType":498,"./Utility":499,"./WriterState":500,"./XMLAttribute":501,"./XMLCData":502,"./XMLComment":504,"./XMLDTDAttList":509,"./XMLDTDElement":510,"./XMLDTDEntity":511,"./XMLDTDNotation":512,"./XMLDeclaration":513,"./XMLDocType":514,"./XMLDocument":515,"./XMLElement":518,"./XMLProcessingInstruction":522,"./XMLRaw":523,"./XMLStringWriter":525,"./XMLStringifier":526,"./XMLText":527}],517:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLNode,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  XMLNode = require('./XMLNode');

		  NodeType = require('./NodeType');

		  module.exports = (function(superClass) {
		    extend(XMLDummy, superClass);

		    function XMLDummy(parent) {
		      XMLDummy.__super__.constructor.call(this, parent);
		      this.type = NodeType.Dummy;
		    }

		    XMLDummy.prototype.clone = function() {
		      return Object.create(this);
		    };

		    XMLDummy.prototype.toString = function(options) {
		      return '';
		    };

		    return XMLDummy;

		  })(XMLNode);

		}).call(this);

		},{"./NodeType":498,"./XMLNode":520}],518:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLAttribute, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;

		  XMLNode = require('./XMLNode');

		  NodeType = require('./NodeType');

		  XMLAttribute = require('./XMLAttribute');

		  XMLNamedNodeMap = require('./XMLNamedNodeMap');

		  module.exports = (function(superClass) {
		    extend(XMLElement, superClass);

		    function XMLElement(parent, name, attributes) {
		      var child, j, len, ref1;
		      XMLElement.__super__.constructor.call(this, parent);
		      if (name == null) {
		        throw new Error("Missing element name. " + this.debugInfo());
		      }
		      this.name = this.stringify.name(name);
		      this.type = NodeType.Element;
		      this.attribs = {};
		      this.schemaTypeInfo = null;
		      if (attributes != null) {
		        this.attribute(attributes);
		      }
		      if (parent.type === NodeType.Document) {
		        this.isRoot = true;
		        this.documentObject = parent;
		        parent.rootObject = this;
		        if (parent.children) {
		          ref1 = parent.children;
		          for (j = 0, len = ref1.length; j < len; j++) {
		            child = ref1[j];
		            if (child.type === NodeType.DocType) {
		              child.name = this.name;
		              break;
		            }
		          }
		        }
		      }
		    }

		    Object.defineProperty(XMLElement.prototype, 'tagName', {
		      get: function() {
		        return this.name;
		      }
		    });

		    Object.defineProperty(XMLElement.prototype, 'namespaceURI', {
		      get: function() {
		        return '';
		      }
		    });

		    Object.defineProperty(XMLElement.prototype, 'prefix', {
		      get: function() {
		        return '';
		      }
		    });

		    Object.defineProperty(XMLElement.prototype, 'localName', {
		      get: function() {
		        return this.name;
		      }
		    });

		    Object.defineProperty(XMLElement.prototype, 'id', {
		      get: function() {
		        throw new Error("This DOM method is not implemented." + this.debugInfo());
		      }
		    });

		    Object.defineProperty(XMLElement.prototype, 'className', {
		      get: function() {
		        throw new Error("This DOM method is not implemented." + this.debugInfo());
		      }
		    });

		    Object.defineProperty(XMLElement.prototype, 'classList', {
		      get: function() {
		        throw new Error("This DOM method is not implemented." + this.debugInfo());
		      }
		    });

		    Object.defineProperty(XMLElement.prototype, 'attributes', {
		      get: function() {
		        if (!this.attributeMap || !this.attributeMap.nodes) {
		          this.attributeMap = new XMLNamedNodeMap(this.attribs);
		        }
		        return this.attributeMap;
		      }
		    });

		    XMLElement.prototype.clone = function() {
		      var att, attName, clonedSelf, ref1;
		      clonedSelf = Object.create(this);
		      if (clonedSelf.isRoot) {
		        clonedSelf.documentObject = null;
		      }
		      clonedSelf.attribs = {};
		      ref1 = this.attribs;
		      for (attName in ref1) {
		        if (!hasProp.call(ref1, attName)) continue;
		        att = ref1[attName];
		        clonedSelf.attribs[attName] = att.clone();
		      }
		      clonedSelf.children = [];
		      this.children.forEach(function(child) {
		        var clonedChild;
		        clonedChild = child.clone();
		        clonedChild.parent = clonedSelf;
		        return clonedSelf.children.push(clonedChild);
		      });
		      return clonedSelf;
		    };

		    XMLElement.prototype.attribute = function(name, value) {
		      var attName, attValue;
		      if (name != null) {
		        name = getValue(name);
		      }
		      if (isObject(name)) {
		        for (attName in name) {
		          if (!hasProp.call(name, attName)) continue;
		          attValue = name[attName];
		          this.attribute(attName, attValue);
		        }
		      } else {
		        if (isFunction(value)) {
		          value = value.apply();
		        }
		        if (this.options.keepNullAttributes && (value == null)) {
		          this.attribs[name] = new XMLAttribute(this, name, "");
		        } else if (value != null) {
		          this.attribs[name] = new XMLAttribute(this, name, value);
		        }
		      }
		      return this;
		    };

		    XMLElement.prototype.removeAttribute = function(name) {
		      var attName, j, len;
		      if (name == null) {
		        throw new Error("Missing attribute name. " + this.debugInfo());
		      }
		      name = getValue(name);
		      if (Array.isArray(name)) {
		        for (j = 0, len = name.length; j < len; j++) {
		          attName = name[j];
		          delete this.attribs[attName];
		        }
		      } else {
		        delete this.attribs[name];
		      }
		      return this;
		    };

		    XMLElement.prototype.toString = function(options) {
		      return this.options.writer.element(this, this.options.writer.filterOptions(options));
		    };

		    XMLElement.prototype.att = function(name, value) {
		      return this.attribute(name, value);
		    };

		    XMLElement.prototype.a = function(name, value) {
		      return this.attribute(name, value);
		    };

		    XMLElement.prototype.getAttribute = function(name) {
		      if (this.attribs.hasOwnProperty(name)) {
		        return this.attribs[name].value;
		      } else {
		        return null;
		      }
		    };

		    XMLElement.prototype.setAttribute = function(name, value) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.getAttributeNode = function(name) {
		      if (this.attribs.hasOwnProperty(name)) {
		        return this.attribs[name];
		      } else {
		        return null;
		      }
		    };

		    XMLElement.prototype.setAttributeNode = function(newAttr) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.removeAttributeNode = function(oldAttr) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.getElementsByTagName = function(name) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.hasAttribute = function(name) {
		      return this.attribs.hasOwnProperty(name);
		    };

		    XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.setIdAttribute = function(name, isId) {
		      if (this.attribs.hasOwnProperty(name)) {
		        return this.attribs[name].isId;
		      } else {
		        return isId;
		      }
		    };

		    XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.getElementsByTagName = function(tagname) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.getElementsByClassName = function(classNames) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLElement.prototype.isEqualNode = function(node) {
		      var i, j, ref1;
		      if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
		        return false;
		      }
		      if (node.namespaceURI !== this.namespaceURI) {
		        return false;
		      }
		      if (node.prefix !== this.prefix) {
		        return false;
		      }
		      if (node.localName !== this.localName) {
		        return false;
		      }
		      if (node.attribs.length !== this.attribs.length) {
		        return false;
		      }
		      for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
		        if (!this.attribs[i].isEqualNode(node.attribs[i])) {
		          return false;
		        }
		      }
		      return true;
		    };

		    return XMLElement;

		  })(XMLNode);

		}).call(this);

		},{"./NodeType":498,"./Utility":499,"./XMLAttribute":501,"./XMLNamedNodeMap":519,"./XMLNode":520}],519:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {

		  module.exports = (function() {
		    function XMLNamedNodeMap(nodes) {
		      this.nodes = nodes;
		    }

		    Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {
		      get: function() {
		        return Object.keys(this.nodes).length || 0;
		      }
		    });

		    XMLNamedNodeMap.prototype.clone = function() {
		      return this.nodes = null;
		    };

		    XMLNamedNodeMap.prototype.getNamedItem = function(name) {
		      return this.nodes[name];
		    };

		    XMLNamedNodeMap.prototype.setNamedItem = function(node) {
		      var oldNode;
		      oldNode = this.nodes[node.nodeName];
		      this.nodes[node.nodeName] = node;
		      return oldNode || null;
		    };

		    XMLNamedNodeMap.prototype.removeNamedItem = function(name) {
		      var oldNode;
		      oldNode = this.nodes[name];
		      delete this.nodes[name];
		      return oldNode || null;
		    };

		    XMLNamedNodeMap.prototype.item = function(index) {
		      return this.nodes[Object.keys(this.nodes)[index]] || null;
		    };

		    XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
		      throw new Error("This DOM method is not implemented.");
		    };

		    XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {
		      throw new Error("This DOM method is not implemented.");
		    };

		    XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
		      throw new Error("This DOM method is not implemented.");
		    };

		    return XMLNamedNodeMap;

		  })();

		}).call(this);

		},{}],520:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1,
		    hasProp = {}.hasOwnProperty;

		  ref1 = require('./Utility'), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;

		  XMLElement = null;

		  XMLCData = null;

		  XMLComment = null;

		  XMLDeclaration = null;

		  XMLDocType = null;

		  XMLRaw = null;

		  XMLText = null;

		  XMLProcessingInstruction = null;

		  XMLDummy = null;

		  NodeType = null;

		  XMLNodeList = null;

		  DocumentPosition = null;

		  module.exports = (function() {
		    function XMLNode(parent1) {
		      this.parent = parent1;
		      if (this.parent) {
		        this.options = this.parent.options;
		        this.stringify = this.parent.stringify;
		      }
		      this.value = null;
		      this.children = [];
		      this.baseURI = null;
		      if (!XMLElement) {
		        XMLElement = require('./XMLElement');
		        XMLCData = require('./XMLCData');
		        XMLComment = require('./XMLComment');
		        XMLDeclaration = require('./XMLDeclaration');
		        XMLDocType = require('./XMLDocType');
		        XMLRaw = require('./XMLRaw');
		        XMLText = require('./XMLText');
		        XMLProcessingInstruction = require('./XMLProcessingInstruction');
		        XMLDummy = require('./XMLDummy');
		        NodeType = require('./NodeType');
		        XMLNodeList = require('./XMLNodeList');
		        require('./XMLNamedNodeMap');
		        DocumentPosition = require('./DocumentPosition');
		      }
		    }

		    Object.defineProperty(XMLNode.prototype, 'nodeName', {
		      get: function() {
		        return this.name;
		      }
		    });

		    Object.defineProperty(XMLNode.prototype, 'nodeType', {
		      get: function() {
		        return this.type;
		      }
		    });

		    Object.defineProperty(XMLNode.prototype, 'nodeValue', {
		      get: function() {
		        return this.value;
		      }
		    });

		    Object.defineProperty(XMLNode.prototype, 'parentNode', {
		      get: function() {
		        return this.parent;
		      }
		    });

		    Object.defineProperty(XMLNode.prototype, 'childNodes', {
		      get: function() {
		        if (!this.childNodeList || !this.childNodeList.nodes) {
		          this.childNodeList = new XMLNodeList(this.children);
		        }
		        return this.childNodeList;
		      }
		    });

		    Object.defineProperty(XMLNode.prototype, 'firstChild', {
		      get: function() {
		        return this.children[0] || null;
		      }
		    });

		    Object.defineProperty(XMLNode.prototype, 'lastChild', {
		      get: function() {
		        return this.children[this.children.length - 1] || null;
		      }
		    });

		    Object.defineProperty(XMLNode.prototype, 'previousSibling', {
		      get: function() {
		        var i;
		        i = this.parent.children.indexOf(this);
		        return this.parent.children[i - 1] || null;
		      }
		    });

		    Object.defineProperty(XMLNode.prototype, 'nextSibling', {
		      get: function() {
		        var i;
		        i = this.parent.children.indexOf(this);
		        return this.parent.children[i + 1] || null;
		      }
		    });

		    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {
		      get: function() {
		        return this.document() || null;
		      }
		    });

		    Object.defineProperty(XMLNode.prototype, 'textContent', {
		      get: function() {
		        var child, j, len, ref2, str;
		        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
		          str = '';
		          ref2 = this.children;
		          for (j = 0, len = ref2.length; j < len; j++) {
		            child = ref2[j];
		            if (child.textContent) {
		              str += child.textContent;
		            }
		          }
		          return str;
		        } else {
		          return null;
		        }
		      },
		      set: function(value) {
		        throw new Error("This DOM method is not implemented." + this.debugInfo());
		      }
		    });

		    XMLNode.prototype.setParent = function(parent) {
		      var child, j, len, ref2, results;
		      this.parent = parent;
		      if (parent) {
		        this.options = parent.options;
		        this.stringify = parent.stringify;
		      }
		      ref2 = this.children;
		      results = [];
		      for (j = 0, len = ref2.length; j < len; j++) {
		        child = ref2[j];
		        results.push(child.setParent(this));
		      }
		      return results;
		    };

		    XMLNode.prototype.element = function(name, attributes, text) {
		      var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
		      lastChild = null;
		      if (attributes === null && (text == null)) {
		        ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
		      }
		      if (attributes == null) {
		        attributes = {};
		      }
		      attributes = getValue(attributes);
		      if (!isObject(attributes)) {
		        ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
		      }
		      if (name != null) {
		        name = getValue(name);
		      }
		      if (Array.isArray(name)) {
		        for (j = 0, len = name.length; j < len; j++) {
		          item = name[j];
		          lastChild = this.element(item);
		        }
		      } else if (isFunction(name)) {
		        lastChild = this.element(name.apply());
		      } else if (isObject(name)) {
		        for (key in name) {
		          if (!hasProp.call(name, key)) continue;
		          val = name[key];
		          if (isFunction(val)) {
		            val = val.apply();
		          }
		          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
		            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
		          } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
		            lastChild = this.dummy();
		          } else if (isObject(val) && isEmpty(val)) {
		            lastChild = this.element(key);
		          } else if (!this.options.keepNullNodes && (val == null)) {
		            lastChild = this.dummy();
		          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
		            for (k = 0, len1 = val.length; k < len1; k++) {
		              item = val[k];
		              childNode = {};
		              childNode[key] = item;
		              lastChild = this.element(childNode);
		            }
		          } else if (isObject(val)) {
		            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
		              lastChild = this.element(val);
		            } else {
		              lastChild = this.element(key);
		              lastChild.element(val);
		            }
		          } else {
		            lastChild = this.element(key, val);
		          }
		        }
		      } else if (!this.options.keepNullNodes && text === null) {
		        lastChild = this.dummy();
		      } else {
		        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
		          lastChild = this.text(text);
		        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
		          lastChild = this.cdata(text);
		        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
		          lastChild = this.comment(text);
		        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
		          lastChild = this.raw(text);
		        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
		          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
		        } else {
		          lastChild = this.node(name, attributes, text);
		        }
		      }
		      if (lastChild == null) {
		        throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
		      }
		      return lastChild;
		    };

		    XMLNode.prototype.insertBefore = function(name, attributes, text) {
		      var child, i, newChild, refChild, removed;
		      if (name != null ? name.type : void 0) {
		        newChild = name;
		        refChild = attributes;
		        newChild.setParent(this);
		        if (refChild) {
		          i = children.indexOf(refChild);
		          removed = children.splice(i);
		          children.push(newChild);
		          Array.prototype.push.apply(children, removed);
		        } else {
		          children.push(newChild);
		        }
		        return newChild;
		      } else {
		        if (this.isRoot) {
		          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
		        }
		        i = this.parent.children.indexOf(this);
		        removed = this.parent.children.splice(i);
		        child = this.parent.element(name, attributes, text);
		        Array.prototype.push.apply(this.parent.children, removed);
		        return child;
		      }
		    };

		    XMLNode.prototype.insertAfter = function(name, attributes, text) {
		      var child, i, removed;
		      if (this.isRoot) {
		        throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
		      }
		      i = this.parent.children.indexOf(this);
		      removed = this.parent.children.splice(i + 1);
		      child = this.parent.element(name, attributes, text);
		      Array.prototype.push.apply(this.parent.children, removed);
		      return child;
		    };

		    XMLNode.prototype.remove = function() {
		      var i;
		      if (this.isRoot) {
		        throw new Error("Cannot remove the root element. " + this.debugInfo());
		      }
		      i = this.parent.children.indexOf(this);
		      [].splice.apply(this.parent.children, [i, i - i + 1].concat([]));
		      return this.parent;
		    };

		    XMLNode.prototype.node = function(name, attributes, text) {
		      var child, ref2;
		      if (name != null) {
		        name = getValue(name);
		      }
		      attributes || (attributes = {});
		      attributes = getValue(attributes);
		      if (!isObject(attributes)) {
		        ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
		      }
		      child = new XMLElement(this, name, attributes);
		      if (text != null) {
		        child.text(text);
		      }
		      this.children.push(child);
		      return child;
		    };

		    XMLNode.prototype.text = function(value) {
		      var child;
		      if (isObject(value)) {
		        this.element(value);
		      }
		      child = new XMLText(this, value);
		      this.children.push(child);
		      return this;
		    };

		    XMLNode.prototype.cdata = function(value) {
		      var child;
		      child = new XMLCData(this, value);
		      this.children.push(child);
		      return this;
		    };

		    XMLNode.prototype.comment = function(value) {
		      var child;
		      child = new XMLComment(this, value);
		      this.children.push(child);
		      return this;
		    };

		    XMLNode.prototype.commentBefore = function(value) {
		      var i, removed;
		      i = this.parent.children.indexOf(this);
		      removed = this.parent.children.splice(i);
		      this.parent.comment(value);
		      Array.prototype.push.apply(this.parent.children, removed);
		      return this;
		    };

		    XMLNode.prototype.commentAfter = function(value) {
		      var i, removed;
		      i = this.parent.children.indexOf(this);
		      removed = this.parent.children.splice(i + 1);
		      this.parent.comment(value);
		      Array.prototype.push.apply(this.parent.children, removed);
		      return this;
		    };

		    XMLNode.prototype.raw = function(value) {
		      var child;
		      child = new XMLRaw(this, value);
		      this.children.push(child);
		      return this;
		    };

		    XMLNode.prototype.dummy = function() {
		      var child;
		      child = new XMLDummy(this);
		      return child;
		    };

		    XMLNode.prototype.instruction = function(target, value) {
		      var insTarget, insValue, instruction, j, len;
		      if (target != null) {
		        target = getValue(target);
		      }
		      if (value != null) {
		        value = getValue(value);
		      }
		      if (Array.isArray(target)) {
		        for (j = 0, len = target.length; j < len; j++) {
		          insTarget = target[j];
		          this.instruction(insTarget);
		        }
		      } else if (isObject(target)) {
		        for (insTarget in target) {
		          if (!hasProp.call(target, insTarget)) continue;
		          insValue = target[insTarget];
		          this.instruction(insTarget, insValue);
		        }
		      } else {
		        if (isFunction(value)) {
		          value = value.apply();
		        }
		        instruction = new XMLProcessingInstruction(this, target, value);
		        this.children.push(instruction);
		      }
		      return this;
		    };

		    XMLNode.prototype.instructionBefore = function(target, value) {
		      var i, removed;
		      i = this.parent.children.indexOf(this);
		      removed = this.parent.children.splice(i);
		      this.parent.instruction(target, value);
		      Array.prototype.push.apply(this.parent.children, removed);
		      return this;
		    };

		    XMLNode.prototype.instructionAfter = function(target, value) {
		      var i, removed;
		      i = this.parent.children.indexOf(this);
		      removed = this.parent.children.splice(i + 1);
		      this.parent.instruction(target, value);
		      Array.prototype.push.apply(this.parent.children, removed);
		      return this;
		    };

		    XMLNode.prototype.declaration = function(version, encoding, standalone) {
		      var doc, xmldec;
		      doc = this.document();
		      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
		      if (doc.children.length === 0) {
		        doc.children.unshift(xmldec);
		      } else if (doc.children[0].type === NodeType.Declaration) {
		        doc.children[0] = xmldec;
		      } else {
		        doc.children.unshift(xmldec);
		      }
		      return doc.root() || doc;
		    };

		    XMLNode.prototype.dtd = function(pubID, sysID) {
		      var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
		      doc = this.document();
		      doctype = new XMLDocType(doc, pubID, sysID);
		      ref2 = doc.children;
		      for (i = j = 0, len = ref2.length; j < len; i = ++j) {
		        child = ref2[i];
		        if (child.type === NodeType.DocType) {
		          doc.children[i] = doctype;
		          return doctype;
		        }
		      }
		      ref3 = doc.children;
		      for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
		        child = ref3[i];
		        if (child.isRoot) {
		          doc.children.splice(i, 0, doctype);
		          return doctype;
		        }
		      }
		      doc.children.push(doctype);
		      return doctype;
		    };

		    XMLNode.prototype.up = function() {
		      if (this.isRoot) {
		        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
		      }
		      return this.parent;
		    };

		    XMLNode.prototype.root = function() {
		      var node;
		      node = this;
		      while (node) {
		        if (node.type === NodeType.Document) {
		          return node.rootObject;
		        } else if (node.isRoot) {
		          return node;
		        } else {
		          node = node.parent;
		        }
		      }
		    };

		    XMLNode.prototype.document = function() {
		      var node;
		      node = this;
		      while (node) {
		        if (node.type === NodeType.Document) {
		          return node;
		        } else {
		          node = node.parent;
		        }
		      }
		    };

		    XMLNode.prototype.end = function(options) {
		      return this.document().end(options);
		    };

		    XMLNode.prototype.prev = function() {
		      var i;
		      i = this.parent.children.indexOf(this);
		      if (i < 1) {
		        throw new Error("Already at the first node. " + this.debugInfo());
		      }
		      return this.parent.children[i - 1];
		    };

		    XMLNode.prototype.next = function() {
		      var i;
		      i = this.parent.children.indexOf(this);
		      if (i === -1 || i === this.parent.children.length - 1) {
		        throw new Error("Already at the last node. " + this.debugInfo());
		      }
		      return this.parent.children[i + 1];
		    };

		    XMLNode.prototype.importDocument = function(doc) {
		      var clonedRoot;
		      clonedRoot = doc.root().clone();
		      clonedRoot.parent = this;
		      clonedRoot.isRoot = false;
		      this.children.push(clonedRoot);
		      return this;
		    };

		    XMLNode.prototype.debugInfo = function(name) {
		      var ref2, ref3;
		      name = name || this.name;
		      if ((name == null) && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
		        return "";
		      } else if (name == null) {
		        return "parent: <" + this.parent.name + ">";
		      } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
		        return "node: <" + name + ">";
		      } else {
		        return "node: <" + name + ">, parent: <" + this.parent.name + ">";
		      }
		    };

		    XMLNode.prototype.ele = function(name, attributes, text) {
		      return this.element(name, attributes, text);
		    };

		    XMLNode.prototype.nod = function(name, attributes, text) {
		      return this.node(name, attributes, text);
		    };

		    XMLNode.prototype.txt = function(value) {
		      return this.text(value);
		    };

		    XMLNode.prototype.dat = function(value) {
		      return this.cdata(value);
		    };

		    XMLNode.prototype.com = function(value) {
		      return this.comment(value);
		    };

		    XMLNode.prototype.ins = function(target, value) {
		      return this.instruction(target, value);
		    };

		    XMLNode.prototype.doc = function() {
		      return this.document();
		    };

		    XMLNode.prototype.dec = function(version, encoding, standalone) {
		      return this.declaration(version, encoding, standalone);
		    };

		    XMLNode.prototype.e = function(name, attributes, text) {
		      return this.element(name, attributes, text);
		    };

		    XMLNode.prototype.n = function(name, attributes, text) {
		      return this.node(name, attributes, text);
		    };

		    XMLNode.prototype.t = function(value) {
		      return this.text(value);
		    };

		    XMLNode.prototype.d = function(value) {
		      return this.cdata(value);
		    };

		    XMLNode.prototype.c = function(value) {
		      return this.comment(value);
		    };

		    XMLNode.prototype.r = function(value) {
		      return this.raw(value);
		    };

		    XMLNode.prototype.i = function(target, value) {
		      return this.instruction(target, value);
		    };

		    XMLNode.prototype.u = function() {
		      return this.up();
		    };

		    XMLNode.prototype.importXMLBuilder = function(doc) {
		      return this.importDocument(doc);
		    };

		    XMLNode.prototype.replaceChild = function(newChild, oldChild) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.removeChild = function(oldChild) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.appendChild = function(newChild) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.hasChildNodes = function() {
		      return this.children.length !== 0;
		    };

		    XMLNode.prototype.cloneNode = function(deep) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.normalize = function() {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.isSupported = function(feature, version) {
		      return true;
		    };

		    XMLNode.prototype.hasAttributes = function() {
		      return this.attribs.length !== 0;
		    };

		    XMLNode.prototype.compareDocumentPosition = function(other) {
		      var ref, res;
		      ref = this;
		      if (ref === other) {
		        return 0;
		      } else if (this.document() !== other.document()) {
		        res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
		        if (Math.random() < 0.5) {
		          res |= DocumentPosition.Preceding;
		        } else {
		          res |= DocumentPosition.Following;
		        }
		        return res;
		      } else if (ref.isAncestor(other)) {
		        return DocumentPosition.Contains | DocumentPosition.Preceding;
		      } else if (ref.isDescendant(other)) {
		        return DocumentPosition.Contains | DocumentPosition.Following;
		      } else if (ref.isPreceding(other)) {
		        return DocumentPosition.Preceding;
		      } else {
		        return DocumentPosition.Following;
		      }
		    };

		    XMLNode.prototype.isSameNode = function(other) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.lookupPrefix = function(namespaceURI) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.lookupNamespaceURI = function(prefix) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.isEqualNode = function(node) {
		      var i, j, ref2;
		      if (node.nodeType !== this.nodeType) {
		        return false;
		      }
		      if (node.children.length !== this.children.length) {
		        return false;
		      }
		      for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
		        if (!this.children[i].isEqualNode(node.children[i])) {
		          return false;
		        }
		      }
		      return true;
		    };

		    XMLNode.prototype.getFeature = function(feature, version) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.setUserData = function(key, data, handler) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.getUserData = function(key) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLNode.prototype.contains = function(other) {
		      if (!other) {
		        return false;
		      }
		      return other === this || this.isDescendant(other);
		    };

		    XMLNode.prototype.isDescendant = function(node) {
		      var child, isDescendantChild, j, len, ref2;
		      ref2 = this.children;
		      for (j = 0, len = ref2.length; j < len; j++) {
		        child = ref2[j];
		        if (node === child) {
		          return true;
		        }
		        isDescendantChild = child.isDescendant(node);
		        if (isDescendantChild) {
		          return true;
		        }
		      }
		      return false;
		    };

		    XMLNode.prototype.isAncestor = function(node) {
		      return node.isDescendant(this);
		    };

		    XMLNode.prototype.isPreceding = function(node) {
		      var nodePos, thisPos;
		      nodePos = this.treePosition(node);
		      thisPos = this.treePosition(this);
		      if (nodePos === -1 || thisPos === -1) {
		        return false;
		      } else {
		        return nodePos < thisPos;
		      }
		    };

		    XMLNode.prototype.isFollowing = function(node) {
		      var nodePos, thisPos;
		      nodePos = this.treePosition(node);
		      thisPos = this.treePosition(this);
		      if (nodePos === -1 || thisPos === -1) {
		        return false;
		      } else {
		        return nodePos > thisPos;
		      }
		    };

		    XMLNode.prototype.treePosition = function(node) {
		      var found, pos;
		      pos = 0;
		      found = false;
		      this.foreachTreeNode(this.document(), function(childNode) {
		        pos++;
		        if (!found && childNode === node) {
		          return found = true;
		        }
		      });
		      if (found) {
		        return pos;
		      } else {
		        return -1;
		      }
		    };

		    XMLNode.prototype.foreachTreeNode = function(node, func) {
		      var child, j, len, ref2, res;
		      node || (node = this.document());
		      ref2 = node.children;
		      for (j = 0, len = ref2.length; j < len; j++) {
		        child = ref2[j];
		        if (res = func(child)) {
		          return res;
		        } else {
		          res = this.foreachTreeNode(child, func);
		          if (res) {
		            return res;
		          }
		        }
		      }
		    };

		    return XMLNode;

		  })();

		}).call(this);

		},{"./DocumentPosition":497,"./NodeType":498,"./Utility":499,"./XMLCData":502,"./XMLComment":504,"./XMLDeclaration":513,"./XMLDocType":514,"./XMLDummy":517,"./XMLElement":518,"./XMLNamedNodeMap":519,"./XMLNodeList":521,"./XMLProcessingInstruction":522,"./XMLRaw":523,"./XMLText":527}],521:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {

		  module.exports = (function() {
		    function XMLNodeList(nodes) {
		      this.nodes = nodes;
		    }

		    Object.defineProperty(XMLNodeList.prototype, 'length', {
		      get: function() {
		        return this.nodes.length || 0;
		      }
		    });

		    XMLNodeList.prototype.clone = function() {
		      return this.nodes = null;
		    };

		    XMLNodeList.prototype.item = function(index) {
		      return this.nodes[index] || null;
		    };

		    return XMLNodeList;

		  })();

		}).call(this);

		},{}],522:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLCharacterData, extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  NodeType = require('./NodeType');

		  XMLCharacterData = require('./XMLCharacterData');

		  module.exports = (function(superClass) {
		    extend(XMLProcessingInstruction, superClass);

		    function XMLProcessingInstruction(parent, target, value) {
		      XMLProcessingInstruction.__super__.constructor.call(this, parent);
		      if (target == null) {
		        throw new Error("Missing instruction target. " + this.debugInfo());
		      }
		      this.type = NodeType.ProcessingInstruction;
		      this.target = this.stringify.insTarget(target);
		      this.name = this.target;
		      if (value) {
		        this.value = this.stringify.insValue(value);
		      }
		    }

		    XMLProcessingInstruction.prototype.clone = function() {
		      return Object.create(this);
		    };

		    XMLProcessingInstruction.prototype.toString = function(options) {
		      return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
		    };

		    XMLProcessingInstruction.prototype.isEqualNode = function(node) {
		      if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
		        return false;
		      }
		      if (node.target !== this.target) {
		        return false;
		      }
		      return true;
		    };

		    return XMLProcessingInstruction;

		  })(XMLCharacterData);

		}).call(this);

		},{"./NodeType":498,"./XMLCharacterData":503}],523:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLNode, extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  NodeType = require('./NodeType');

		  XMLNode = require('./XMLNode');

		  module.exports = (function(superClass) {
		    extend(XMLRaw, superClass);

		    function XMLRaw(parent, text) {
		      XMLRaw.__super__.constructor.call(this, parent);
		      if (text == null) {
		        throw new Error("Missing raw text. " + this.debugInfo());
		      }
		      this.type = NodeType.Raw;
		      this.value = this.stringify.raw(text);
		    }

		    XMLRaw.prototype.clone = function() {
		      return Object.create(this);
		    };

		    XMLRaw.prototype.toString = function(options) {
		      return this.options.writer.raw(this, this.options.writer.filterOptions(options));
		    };

		    return XMLRaw;

		  })(XMLNode);

		}).call(this);

		},{"./NodeType":498,"./XMLNode":520}],524:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, WriterState, XMLWriterBase,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  NodeType = require('./NodeType');

		  XMLWriterBase = require('./XMLWriterBase');

		  WriterState = require('./WriterState');

		  module.exports = (function(superClass) {
		    extend(XMLStreamWriter, superClass);

		    function XMLStreamWriter(stream, options) {
		      this.stream = stream;
		      XMLStreamWriter.__super__.constructor.call(this, options);
		    }

		    XMLStreamWriter.prototype.endline = function(node, options, level) {
		      if (node.isLastRootNode && options.state === WriterState.CloseTag) {
		        return '';
		      } else {
		        return XMLStreamWriter.__super__.endline.call(this, node, options, level);
		      }
		    };

		    XMLStreamWriter.prototype.document = function(doc, options) {
		      var child, i, j, k, len, len1, ref, ref1, results;
		      ref = doc.children;
		      for (i = j = 0, len = ref.length; j < len; i = ++j) {
		        child = ref[i];
		        child.isLastRootNode = i === doc.children.length - 1;
		      }
		      options = this.filterOptions(options);
		      ref1 = doc.children;
		      results = [];
		      for (k = 0, len1 = ref1.length; k < len1; k++) {
		        child = ref1[k];
		        results.push(this.writeChildNode(child, options, 0));
		      }
		      return results;
		    };

		    XMLStreamWriter.prototype.attribute = function(att, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
		    };

		    XMLStreamWriter.prototype.cdata = function(node, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
		    };

		    XMLStreamWriter.prototype.comment = function(node, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
		    };

		    XMLStreamWriter.prototype.declaration = function(node, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
		    };

		    XMLStreamWriter.prototype.docType = function(node, options, level) {
		      var child, j, len, ref;
		      level || (level = 0);
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      this.stream.write(this.indent(node, options, level));
		      this.stream.write('<!DOCTYPE ' + node.root().name);
		      if (node.pubID && node.sysID) {
		        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
		      } else if (node.sysID) {
		        this.stream.write(' SYSTEM "' + node.sysID + '"');
		      }
		      if (node.children.length > 0) {
		        this.stream.write(' [');
		        this.stream.write(this.endline(node, options, level));
		        options.state = WriterState.InsideTag;
		        ref = node.children;
		        for (j = 0, len = ref.length; j < len; j++) {
		          child = ref[j];
		          this.writeChildNode(child, options, level + 1);
		        }
		        options.state = WriterState.CloseTag;
		        this.stream.write(']');
		      }
		      options.state = WriterState.CloseTag;
		      this.stream.write(options.spaceBeforeSlash + '>');
		      this.stream.write(this.endline(node, options, level));
		      options.state = WriterState.None;
		      return this.closeNode(node, options, level);
		    };

		    XMLStreamWriter.prototype.element = function(node, options, level) {
		      var att, child, childNodeCount, firstChildNode, j, len, name, ref, ref1;
		      level || (level = 0);
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      this.stream.write(this.indent(node, options, level) + '<' + node.name);
		      ref = node.attribs;
		      for (name in ref) {
		        if (!hasProp.call(ref, name)) continue;
		        att = ref[name];
		        this.attribute(att, options, level);
		      }
		      childNodeCount = node.children.length;
		      firstChildNode = childNodeCount === 0 ? null : node.children[0];
		      if (childNodeCount === 0 || node.children.every(function(e) {
		        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
		      })) {
		        if (options.allowEmpty) {
		          this.stream.write('>');
		          options.state = WriterState.CloseTag;
		          this.stream.write('</' + node.name + '>');
		        } else {
		          options.state = WriterState.CloseTag;
		          this.stream.write(options.spaceBeforeSlash + '/>');
		        }
		      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {
		        this.stream.write('>');
		        options.state = WriterState.InsideTag;
		        options.suppressPrettyCount++;
		        this.writeChildNode(firstChildNode, options, level + 1);
		        options.suppressPrettyCount--;
		        options.state = WriterState.CloseTag;
		        this.stream.write('</' + node.name + '>');
		      } else {
		        this.stream.write('>' + this.endline(node, options, level));
		        options.state = WriterState.InsideTag;
		        ref1 = node.children;
		        for (j = 0, len = ref1.length; j < len; j++) {
		          child = ref1[j];
		          this.writeChildNode(child, options, level + 1);
		        }
		        options.state = WriterState.CloseTag;
		        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');
		      }
		      this.stream.write(this.endline(node, options, level));
		      options.state = WriterState.None;
		      return this.closeNode(node, options, level);
		    };

		    XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
		    };

		    XMLStreamWriter.prototype.raw = function(node, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
		    };

		    XMLStreamWriter.prototype.text = function(node, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
		    };

		    XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
		    };

		    XMLStreamWriter.prototype.dtdElement = function(node, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
		    };

		    XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
		    };

		    XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {
		      return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
		    };

		    return XMLStreamWriter;

		  })(XMLWriterBase);

		}).call(this);

		},{"./NodeType":498,"./WriterState":500,"./XMLWriterBase":528}],525:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var XMLWriterBase,
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  XMLWriterBase = require('./XMLWriterBase');

		  module.exports = (function(superClass) {
		    extend(XMLStringWriter, superClass);

		    function XMLStringWriter(options) {
		      XMLStringWriter.__super__.constructor.call(this, options);
		    }

		    XMLStringWriter.prototype.document = function(doc, options) {
		      var child, i, len, r, ref;
		      options = this.filterOptions(options);
		      r = '';
		      ref = doc.children;
		      for (i = 0, len = ref.length; i < len; i++) {
		        child = ref[i];
		        r += this.writeChildNode(child, options, 0);
		      }
		      if (options.pretty && r.slice(-options.newline.length) === options.newline) {
		        r = r.slice(0, -options.newline.length);
		      }
		      return r;
		    };

		    return XMLStringWriter;

		  })(XMLWriterBase);

		}).call(this);

		},{"./XMLWriterBase":528}],526:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
		    hasProp = {}.hasOwnProperty;

		  module.exports = (function() {
		    function XMLStringifier(options) {
		      this.assertLegalName = bind(this.assertLegalName, this);
		      this.assertLegalChar = bind(this.assertLegalChar, this);
		      var key, ref, value;
		      options || (options = {});
		      this.options = options;
		      if (!this.options.version) {
		        this.options.version = '1.0';
		      }
		      ref = options.stringify || {};
		      for (key in ref) {
		        if (!hasProp.call(ref, key)) continue;
		        value = ref[key];
		        this[key] = value;
		      }
		    }

		    XMLStringifier.prototype.name = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalName('' + val || '');
		    };

		    XMLStringifier.prototype.text = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalChar(this.textEscape('' + val || ''));
		    };

		    XMLStringifier.prototype.cdata = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      val = '' + val || '';
		      val = val.replace(']]>', ']]]]><![CDATA[>');
		      return this.assertLegalChar(val);
		    };

		    XMLStringifier.prototype.comment = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      val = '' + val || '';
		      if (val.match(/--/)) {
		        throw new Error("Comment text cannot contain double-hypen: " + val);
		      }
		      return this.assertLegalChar(val);
		    };

		    XMLStringifier.prototype.raw = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return '' + val || '';
		    };

		    XMLStringifier.prototype.attValue = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalChar(this.attEscape(val = '' + val || ''));
		    };

		    XMLStringifier.prototype.insTarget = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalChar('' + val || '');
		    };

		    XMLStringifier.prototype.insValue = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      val = '' + val || '';
		      if (val.match(/\?>/)) {
		        throw new Error("Invalid processing instruction value: " + val);
		      }
		      return this.assertLegalChar(val);
		    };

		    XMLStringifier.prototype.xmlVersion = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      val = '' + val || '';
		      if (!val.match(/1\.[0-9]+/)) {
		        throw new Error("Invalid version number: " + val);
		      }
		      return val;
		    };

		    XMLStringifier.prototype.xmlEncoding = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      val = '' + val || '';
		      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
		        throw new Error("Invalid encoding: " + val);
		      }
		      return this.assertLegalChar(val);
		    };

		    XMLStringifier.prototype.xmlStandalone = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      if (val) {
		        return "yes";
		      } else {
		        return "no";
		      }
		    };

		    XMLStringifier.prototype.dtdPubID = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalChar('' + val || '');
		    };

		    XMLStringifier.prototype.dtdSysID = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalChar('' + val || '');
		    };

		    XMLStringifier.prototype.dtdElementValue = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalChar('' + val || '');
		    };

		    XMLStringifier.prototype.dtdAttType = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalChar('' + val || '');
		    };

		    XMLStringifier.prototype.dtdAttDefault = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalChar('' + val || '');
		    };

		    XMLStringifier.prototype.dtdEntityValue = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalChar('' + val || '');
		    };

		    XMLStringifier.prototype.dtdNData = function(val) {
		      if (this.options.noValidation) {
		        return val;
		      }
		      return this.assertLegalChar('' + val || '');
		    };

		    XMLStringifier.prototype.convertAttKey = '@';

		    XMLStringifier.prototype.convertPIKey = '?';

		    XMLStringifier.prototype.convertTextKey = '#text';

		    XMLStringifier.prototype.convertCDataKey = '#cdata';

		    XMLStringifier.prototype.convertCommentKey = '#comment';

		    XMLStringifier.prototype.convertRawKey = '#raw';

		    XMLStringifier.prototype.assertLegalChar = function(str) {
		      var regex, res;
		      if (this.options.noValidation) {
		        return str;
		      }
		      regex = '';
		      if (this.options.version === '1.0') {
		        regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
		        if (res = str.match(regex)) {
		          throw new Error("Invalid character in string: " + str + " at index " + res.index);
		        }
		      } else if (this.options.version === '1.1') {
		        regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
		        if (res = str.match(regex)) {
		          throw new Error("Invalid character in string: " + str + " at index " + res.index);
		        }
		      }
		      return str;
		    };

		    XMLStringifier.prototype.assertLegalName = function(str) {
		      var regex;
		      if (this.options.noValidation) {
		        return str;
		      }
		      this.assertLegalChar(str);
		      regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
		      if (!str.match(regex)) {
		        throw new Error("Invalid character in name");
		      }
		      return str;
		    };

		    XMLStringifier.prototype.textEscape = function(str) {
		      var ampregex;
		      if (this.options.noValidation) {
		        return str;
		      }
		      ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
		      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
		    };

		    XMLStringifier.prototype.attEscape = function(str) {
		      var ampregex;
		      if (this.options.noValidation) {
		        return str;
		      }
		      ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
		      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
		    };

		    return XMLStringifier;

		  })();

		}).call(this);

		},{}],527:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, XMLCharacterData, extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty;

		  NodeType = require('./NodeType');

		  XMLCharacterData = require('./XMLCharacterData');

		  module.exports = (function(superClass) {
		    extend(XMLText, superClass);

		    function XMLText(parent, text) {
		      XMLText.__super__.constructor.call(this, parent);
		      if (text == null) {
		        throw new Error("Missing element text. " + this.debugInfo());
		      }
		      this.name = "#text";
		      this.type = NodeType.Text;
		      this.value = this.stringify.text(text);
		    }

		    Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {
		      get: function() {
		        throw new Error("This DOM method is not implemented." + this.debugInfo());
		      }
		    });

		    Object.defineProperty(XMLText.prototype, 'wholeText', {
		      get: function() {
		        var next, prev, str;
		        str = '';
		        prev = this.previousSibling;
		        while (prev) {
		          str = prev.data + str;
		          prev = prev.previousSibling;
		        }
		        str += this.data;
		        next = this.nextSibling;
		        while (next) {
		          str = str + next.data;
		          next = next.nextSibling;
		        }
		        return str;
		      }
		    });

		    XMLText.prototype.clone = function() {
		      return Object.create(this);
		    };

		    XMLText.prototype.toString = function(options) {
		      return this.options.writer.text(this, this.options.writer.filterOptions(options));
		    };

		    XMLText.prototype.splitText = function(offset) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    XMLText.prototype.replaceWholeText = function(content) {
		      throw new Error("This DOM method is not implemented." + this.debugInfo());
		    };

		    return XMLText;

		  })(XMLCharacterData);

		}).call(this);

		},{"./NodeType":498,"./XMLCharacterData":503}],528:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, WriterState, assign,
		    hasProp = {}.hasOwnProperty;

		  assign = require('./Utility').assign;

		  NodeType = require('./NodeType');

		  require('./XMLDeclaration');

		  require('./XMLDocType');

		  require('./XMLCData');

		  require('./XMLComment');

		  require('./XMLElement');

		  require('./XMLRaw');

		  require('./XMLText');

		  require('./XMLProcessingInstruction');

		  require('./XMLDummy');

		  require('./XMLDTDAttList');

		  require('./XMLDTDElement');

		  require('./XMLDTDEntity');

		  require('./XMLDTDNotation');

		  WriterState = require('./WriterState');

		  module.exports = (function() {
		    function XMLWriterBase(options) {
		      var key, ref, value;
		      options || (options = {});
		      this.options = options;
		      ref = options.writer || {};
		      for (key in ref) {
		        if (!hasProp.call(ref, key)) continue;
		        value = ref[key];
		        this["_" + key] = this[key];
		        this[key] = value;
		      }
		    }

		    XMLWriterBase.prototype.filterOptions = function(options) {
		      var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
		      options || (options = {});
		      options = assign({}, this.options, options);
		      filteredOptions = {
		        writer: this
		      };
		      filteredOptions.pretty = options.pretty || false;
		      filteredOptions.allowEmpty = options.allowEmpty || false;
		      filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';
		      filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\n';
		      filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
		      filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
		      filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';
		      if (filteredOptions.spaceBeforeSlash === true) {
		        filteredOptions.spaceBeforeSlash = ' ';
		      }
		      filteredOptions.suppressPrettyCount = 0;
		      filteredOptions.user = {};
		      filteredOptions.state = WriterState.None;
		      return filteredOptions;
		    };

		    XMLWriterBase.prototype.indent = function(node, options, level) {
		      var indentLevel;
		      if (!options.pretty || options.suppressPrettyCount) {
		        return '';
		      } else if (options.pretty) {
		        indentLevel = (level || 0) + options.offset + 1;
		        if (indentLevel > 0) {
		          return new Array(indentLevel).join(options.indent);
		        }
		      }
		      return '';
		    };

		    XMLWriterBase.prototype.endline = function(node, options, level) {
		      if (!options.pretty || options.suppressPrettyCount) {
		        return '';
		      } else {
		        return options.newline;
		      }
		    };

		    XMLWriterBase.prototype.attribute = function(att, options, level) {
		      var r;
		      this.openAttribute(att, options, level);
		      r = ' ' + att.name + '="' + att.value + '"';
		      this.closeAttribute(att, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.cdata = function(node, options, level) {
		      var r;
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level) + '<![CDATA[';
		      options.state = WriterState.InsideTag;
		      r += node.value;
		      options.state = WriterState.CloseTag;
		      r += ']]>' + this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.comment = function(node, options, level) {
		      var r;
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level) + '<!-- ';
		      options.state = WriterState.InsideTag;
		      r += node.value;
		      options.state = WriterState.CloseTag;
		      r += ' -->' + this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.declaration = function(node, options, level) {
		      var r;
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level) + '<?xml';
		      options.state = WriterState.InsideTag;
		      r += ' version="' + node.version + '"';
		      if (node.encoding != null) {
		        r += ' encoding="' + node.encoding + '"';
		      }
		      if (node.standalone != null) {
		        r += ' standalone="' + node.standalone + '"';
		      }
		      options.state = WriterState.CloseTag;
		      r += options.spaceBeforeSlash + '?>';
		      r += this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.docType = function(node, options, level) {
		      var child, i, len, r, ref;
		      level || (level = 0);
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level);
		      r += '<!DOCTYPE ' + node.root().name;
		      if (node.pubID && node.sysID) {
		        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
		      } else if (node.sysID) {
		        r += ' SYSTEM "' + node.sysID + '"';
		      }
		      if (node.children.length > 0) {
		        r += ' [';
		        r += this.endline(node, options, level);
		        options.state = WriterState.InsideTag;
		        ref = node.children;
		        for (i = 0, len = ref.length; i < len; i++) {
		          child = ref[i];
		          r += this.writeChildNode(child, options, level + 1);
		        }
		        options.state = WriterState.CloseTag;
		        r += ']';
		      }
		      options.state = WriterState.CloseTag;
		      r += options.spaceBeforeSlash + '>';
		      r += this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.element = function(node, options, level) {
		      var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
		      level || (level = 0);
		      prettySuppressed = false;
		      r = '';
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r += this.indent(node, options, level) + '<' + node.name;
		      ref = node.attribs;
		      for (name in ref) {
		        if (!hasProp.call(ref, name)) continue;
		        att = ref[name];
		        r += this.attribute(att, options, level);
		      }
		      childNodeCount = node.children.length;
		      firstChildNode = childNodeCount === 0 ? null : node.children[0];
		      if (childNodeCount === 0 || node.children.every(function(e) {
		        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
		      })) {
		        if (options.allowEmpty) {
		          r += '>';
		          options.state = WriterState.CloseTag;
		          r += '</' + node.name + '>' + this.endline(node, options, level);
		        } else {
		          options.state = WriterState.CloseTag;
		          r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);
		        }
		      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {
		        r += '>';
		        options.state = WriterState.InsideTag;
		        options.suppressPrettyCount++;
		        prettySuppressed = true;
		        r += this.writeChildNode(firstChildNode, options, level + 1);
		        options.suppressPrettyCount--;
		        prettySuppressed = false;
		        options.state = WriterState.CloseTag;
		        r += '</' + node.name + '>' + this.endline(node, options, level);
		      } else {
		        if (options.dontPrettyTextNodes) {
		          ref1 = node.children;
		          for (i = 0, len = ref1.length; i < len; i++) {
		            child = ref1[i];
		            if ((child.type === NodeType.Text || child.type === NodeType.Raw) && (child.value != null)) {
		              options.suppressPrettyCount++;
		              prettySuppressed = true;
		              break;
		            }
		          }
		        }
		        r += '>' + this.endline(node, options, level);
		        options.state = WriterState.InsideTag;
		        ref2 = node.children;
		        for (j = 0, len1 = ref2.length; j < len1; j++) {
		          child = ref2[j];
		          r += this.writeChildNode(child, options, level + 1);
		        }
		        options.state = WriterState.CloseTag;
		        r += this.indent(node, options, level) + '</' + node.name + '>';
		        if (prettySuppressed) {
		          options.suppressPrettyCount--;
		        }
		        r += this.endline(node, options, level);
		        options.state = WriterState.None;
		      }
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.writeChildNode = function(node, options, level) {
		      switch (node.type) {
		        case NodeType.CData:
		          return this.cdata(node, options, level);
		        case NodeType.Comment:
		          return this.comment(node, options, level);
		        case NodeType.Element:
		          return this.element(node, options, level);
		        case NodeType.Raw:
		          return this.raw(node, options, level);
		        case NodeType.Text:
		          return this.text(node, options, level);
		        case NodeType.ProcessingInstruction:
		          return this.processingInstruction(node, options, level);
		        case NodeType.Dummy:
		          return '';
		        case NodeType.Declaration:
		          return this.declaration(node, options, level);
		        case NodeType.DocType:
		          return this.docType(node, options, level);
		        case NodeType.AttributeDeclaration:
		          return this.dtdAttList(node, options, level);
		        case NodeType.ElementDeclaration:
		          return this.dtdElement(node, options, level);
		        case NodeType.EntityDeclaration:
		          return this.dtdEntity(node, options, level);
		        case NodeType.NotationDeclaration:
		          return this.dtdNotation(node, options, level);
		        default:
		          throw new Error("Unknown XML node type: " + node.constructor.name);
		      }
		    };

		    XMLWriterBase.prototype.processingInstruction = function(node, options, level) {
		      var r;
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level) + '<?';
		      options.state = WriterState.InsideTag;
		      r += node.target;
		      if (node.value) {
		        r += ' ' + node.value;
		      }
		      options.state = WriterState.CloseTag;
		      r += options.spaceBeforeSlash + '?>';
		      r += this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.raw = function(node, options, level) {
		      var r;
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level);
		      options.state = WriterState.InsideTag;
		      r += node.value;
		      options.state = WriterState.CloseTag;
		      r += this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.text = function(node, options, level) {
		      var r;
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level);
		      options.state = WriterState.InsideTag;
		      r += node.value;
		      options.state = WriterState.CloseTag;
		      r += this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.dtdAttList = function(node, options, level) {
		      var r;
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level) + '<!ATTLIST';
		      options.state = WriterState.InsideTag;
		      r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
		      if (node.defaultValueType !== '#DEFAULT') {
		        r += ' ' + node.defaultValueType;
		      }
		      if (node.defaultValue) {
		        r += ' "' + node.defaultValue + '"';
		      }
		      options.state = WriterState.CloseTag;
		      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.dtdElement = function(node, options, level) {
		      var r;
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level) + '<!ELEMENT';
		      options.state = WriterState.InsideTag;
		      r += ' ' + node.name + ' ' + node.value;
		      options.state = WriterState.CloseTag;
		      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.dtdEntity = function(node, options, level) {
		      var r;
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level) + '<!ENTITY';
		      options.state = WriterState.InsideTag;
		      if (node.pe) {
		        r += ' %';
		      }
		      r += ' ' + node.name;
		      if (node.value) {
		        r += ' "' + node.value + '"';
		      } else {
		        if (node.pubID && node.sysID) {
		          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
		        } else if (node.sysID) {
		          r += ' SYSTEM "' + node.sysID + '"';
		        }
		        if (node.nData) {
		          r += ' NDATA ' + node.nData;
		        }
		      }
		      options.state = WriterState.CloseTag;
		      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.dtdNotation = function(node, options, level) {
		      var r;
		      this.openNode(node, options, level);
		      options.state = WriterState.OpenTag;
		      r = this.indent(node, options, level) + '<!NOTATION';
		      options.state = WriterState.InsideTag;
		      r += ' ' + node.name;
		      if (node.pubID && node.sysID) {
		        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
		      } else if (node.pubID) {
		        r += ' PUBLIC "' + node.pubID + '"';
		      } else if (node.sysID) {
		        r += ' SYSTEM "' + node.sysID + '"';
		      }
		      options.state = WriterState.CloseTag;
		      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
		      options.state = WriterState.None;
		      this.closeNode(node, options, level);
		      return r;
		    };

		    XMLWriterBase.prototype.openNode = function(node, options, level) {};

		    XMLWriterBase.prototype.closeNode = function(node, options, level) {};

		    XMLWriterBase.prototype.openAttribute = function(att, options, level) {};

		    XMLWriterBase.prototype.closeAttribute = function(att, options, level) {};

		    return XMLWriterBase;

		  })();

		}).call(this);

		},{"./NodeType":498,"./Utility":499,"./WriterState":500,"./XMLCData":502,"./XMLComment":504,"./XMLDTDAttList":509,"./XMLDTDElement":510,"./XMLDTDEntity":511,"./XMLDTDNotation":512,"./XMLDeclaration":513,"./XMLDocType":514,"./XMLDummy":517,"./XMLElement":518,"./XMLProcessingInstruction":522,"./XMLRaw":523,"./XMLText":527}],529:[function(require,module,exports){
		// Generated by CoffeeScript 1.12.7
		(function() {
		  var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;

		  ref = require('./Utility'), assign = ref.assign, isFunction = ref.isFunction;

		  XMLDOMImplementation = require('./XMLDOMImplementation');

		  XMLDocument = require('./XMLDocument');

		  XMLDocumentCB = require('./XMLDocumentCB');

		  XMLStringWriter = require('./XMLStringWriter');

		  XMLStreamWriter = require('./XMLStreamWriter');

		  NodeType = require('./NodeType');

		  WriterState = require('./WriterState');

		  module.exports.create = function(name, xmldec, doctype, options) {
		    var doc, root;
		    if (name == null) {
		      throw new Error("Root element needs a name.");
		    }
		    options = assign({}, xmldec, doctype, options);
		    doc = new XMLDocument(options);
		    root = doc.element(name);
		    if (!options.headless) {
		      doc.declaration(options);
		      if ((options.pubID != null) || (options.sysID != null)) {
		        doc.dtd(options);
		      }
		    }
		    return root;
		  };

		  module.exports.begin = function(options, onData, onEnd) {
		    var ref1;
		    if (isFunction(options)) {
		      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
		      options = {};
		    }
		    if (onData) {
		      return new XMLDocumentCB(options, onData, onEnd);
		    } else {
		      return new XMLDocument(options);
		    }
		  };

		  module.exports.stringWriter = function(options) {
		    return new XMLStringWriter(options);
		  };

		  module.exports.streamWriter = function(stream, options) {
		    return new XMLStreamWriter(stream, options);
		  };

		  module.exports.implementation = new XMLDOMImplementation();

		  module.exports.nodeType = NodeType;

		  module.exports.writerState = WriterState;

		}).call(this);

		},{"./NodeType":498,"./Utility":499,"./WriterState":500,"./XMLDOMImplementation":507,"./XMLDocument":515,"./XMLDocumentCB":516,"./XMLStreamWriter":524,"./XMLStringWriter":525}],530:[function(require,module,exports){
		module.exports = extend;

		var hasOwnProperty = Object.prototype.hasOwnProperty;

		function extend() {
		    var target = {};

		    for (var i = 0; i < arguments.length; i++) {
		        var source = arguments[i];

		        for (var key in source) {
		            if (hasOwnProperty.call(source, key)) {
		                target[key] = source[key];
		            }
		        }
		    }

		    return target
		}

		},{}],531:[function(require,module,exports){

		require("core-js/modules/es.array.fill.js");
		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		require("core-js/modules/es.array.join.js");
		require("core-js/modules/es.array.slice.js");
		var Buffer = require('buffer').Buffer;
		var sha = require('./sha');
		var sha256 = require('./sha256');
		var md5 = require('./md5');
		var algorithms = {
		  sha1: sha,
		  sha256: sha256,
		  md5: md5
		};
		var blocksize = 64;
		var zeroBuffer = Buffer.alloc(blocksize);
		zeroBuffer.fill(0);
		function hmac(fn, key, data) {
		  if (!Buffer.isBuffer(key)) key = Buffer.from(key);
		  if (!Buffer.isBuffer(data)) data = Buffer.from(data);
		  if (key.length > blocksize) {
		    key = fn(key);
		  } else if (key.length < blocksize) {
		    key = Buffer.concat([key, zeroBuffer], blocksize);
		  }
		  var ipad = Buffer.alloc(blocksize),
		    opad = Buffer.alloc(blocksize);
		  for (var i = 0; i < blocksize; i++) {
		    ipad[i] = key[i] ^ 0x36;
		    opad[i] = key[i] ^ 0x5c;
		  }
		  var hash = fn(Buffer.concat([ipad, data]));
		  return fn(Buffer.concat([opad, hash]));
		}
		function hash(alg, key) {
		  alg = alg || 'sha1';
		  var fn = algorithms[alg];
		  var bufs = [];
		  var length = 0;
		  if (!fn) error('algorithm:', alg, 'is not yet supported');
		  return {
		    update: function update(data) {
		      if (!Buffer.isBuffer(data)) data = Buffer.from(data);
		      bufs.push(data);
		      length += data.length;
		      return this;
		    },
		    digest: function digest(enc) {
		      var buf = Buffer.concat(bufs);
		      var r = key ? hmac(fn, key, buf) : fn(buf);
		      bufs = null;
		      return enc ? r.toString(enc) : r;
		    }
		  };
		}
		function error() {
		  var m = [].slice.call(arguments).join(' ');
		  throw new Error([m, 'we accept pull requests', 'http://github.com/dominictarr/crypto-browserify'].join('\n'));
		}
		exports.createHash = function (alg) {
		  return hash(alg);
		};
		exports.createHmac = function (alg, key) {
		  return hash(alg, key);
		};
		exports.createCredentials = function () {
		  error('sorry,createCredentials is not implemented yet');
		};
		exports.createCipher = function () {
		  error('sorry,createCipher is not implemented yet');
		};
		exports.createCipheriv = function () {
		  error('sorry,createCipheriv is not implemented yet');
		};
		exports.createDecipher = function () {
		  error('sorry,createDecipher is not implemented yet');
		};
		exports.createDecipheriv = function () {
		  error('sorry,createDecipheriv is not implemented yet');
		};
		exports.createSign = function () {
		  error('sorry,createSign is not implemented yet');
		};
		exports.createVerify = function () {
		  error('sorry,createVerify is not implemented yet');
		};
		exports.createDiffieHellman = function () {
		  error('sorry,createDiffieHellman is not implemented yet');
		};
		exports.pbkdf2 = function () {
		  error('sorry,pbkdf2 is not implemented yet');
		};

		},{"./md5":533,"./sha":534,"./sha256":535,"buffer":103,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.fill.js":311,"core-js/modules/es.array.join.js":317,"core-js/modules/es.array.slice.js":319,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.regexp.to-string.js":339}],532:[function(require,module,exports){

		require("core-js/modules/es.array.fill.js");
		require("core-js/modules/es.array.concat.js");
		var Buffer = require('buffer').Buffer;
		var intSize = 4;
		var zeroBuffer = Buffer.alloc(intSize);
		zeroBuffer.fill(0);
		var chrsz = 8;
		function toArray(buf, bigEndian) {
		  if (buf.length % intSize !== 0) {
		    var len = buf.length + (intSize - buf.length % intSize);
		    buf = Buffer.concat([buf, zeroBuffer], len);
		  }
		  var arr = [];
		  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
		  for (var i = 0; i < buf.length; i += intSize) {
		    arr.push(fn.call(buf, i));
		  }
		  return arr;
		}
		function toBuffer(arr, size, bigEndian) {
		  var buf = Buffer.alloc(size);
		  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
		  for (var i = 0; i < arr.length; i++) {
		    fn.call(buf, arr[i], i * 4, true);
		  }
		  return buf;
		}
		function hash(buf, fn, hashSize, bigEndian) {
		  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
		  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
		  return toBuffer(arr, hashSize, bigEndian);
		}
		module.exports = {
		  hash: hash
		};

		},{"buffer":103,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.fill.js":311}],533:[function(require,module,exports){

		/*
		 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
		 * Digest Algorithm, as defined in RFC 1321.
		 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
		 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
		 * Distributed under the BSD License
		 * See http://pajhome.org.uk/crypt/md5 for more info.
		 */

		var helpers = require('./helpers');

		/*
		 * Calculate the MD5 of an array of little-endian words, and a bit length
		 */
		function core_md5(x, len) {
		  /* append padding */
		  x[len >> 5] |= 0x80 << len % 32;
		  x[(len + 64 >>> 9 << 4) + 14] = len;
		  var a = 1732584193;
		  var b = -271733879;
		  var c = -1732584194;
		  var d = 271733878;
		  for (var i = 0; i < x.length; i += 16) {
		    var olda = a;
		    var oldb = b;
		    var oldc = c;
		    var oldd = d;
		    a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
		    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
		    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
		    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
		    a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
		    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
		    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
		    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
		    a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
		    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
		    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
		    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
		    a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
		    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
		    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
		    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
		    a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
		    d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
		    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
		    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
		    a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
		    d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
		    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
		    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
		    a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
		    d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
		    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
		    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
		    a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
		    d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
		    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
		    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
		    a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
		    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
		    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
		    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
		    a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
		    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
		    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
		    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
		    a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
		    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
		    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
		    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
		    a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
		    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
		    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
		    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
		    a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
		    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
		    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
		    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
		    a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
		    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
		    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
		    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
		    a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
		    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
		    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
		    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
		    a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
		    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
		    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
		    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
		    a = safe_add(a, olda);
		    b = safe_add(b, oldb);
		    c = safe_add(c, oldc);
		    d = safe_add(d, oldd);
		  }
		  return Array(a, b, c, d);
		}

		/*
		 * These functions implement the four basic operations the algorithm uses.
		 */
		function md5_cmn(q, a, b, x, s, t) {
		  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
		}
		function md5_ff(a, b, c, d, x, s, t) {
		  return md5_cmn(b & c | ~b & d, a, b, x, s, t);
		}
		function md5_gg(a, b, c, d, x, s, t) {
		  return md5_cmn(b & d | c & ~d, a, b, x, s, t);
		}
		function md5_hh(a, b, c, d, x, s, t) {
		  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
		}
		function md5_ii(a, b, c, d, x, s, t) {
		  return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
		}

		/*
		 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
		 * to work around bugs in some JS interpreters.
		 */
		function safe_add(x, y) {
		  var lsw = (x & 0xffff) + (y & 0xffff);
		  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		  return msw << 16 | lsw & 0xffff;
		}

		/*
		 * Bitwise rotate a 32-bit number to the left.
		 */
		function bit_rol(num, cnt) {
		  return num << cnt | num >>> 32 - cnt;
		}
		module.exports = function md5(buf) {
		  return helpers.hash(buf, core_md5, 16);
		};

		},{"./helpers":532}],534:[function(require,module,exports){

		/*
		 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
		 * in FIPS PUB 180-1
		 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
		 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
		 * Distributed under the BSD License
		 * See http://pajhome.org.uk/crypt/md5 for details.
		 */

		var helpers = require('./helpers');

		/*
		 * Calculate the SHA-1 of an array of big-endian words, and a bit length
		 */
		function core_sha1(x, len) {
		  /* append padding */
		  x[len >> 5] |= 0x80 << 24 - len % 32;
		  x[(len + 64 >> 9 << 4) + 15] = len;
		  var w = Array(80);
		  var a = 1732584193;
		  var b = -271733879;
		  var c = -1732584194;
		  var d = 271733878;
		  var e = -1009589776;
		  for (var i = 0; i < x.length; i += 16) {
		    var olda = a;
		    var oldb = b;
		    var oldc = c;
		    var oldd = d;
		    var olde = e;
		    for (var j = 0; j < 80; j++) {
		      if (j < 16) w[j] = x[i + j];else w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
		      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
		      e = d;
		      d = c;
		      c = rol(b, 30);
		      b = a;
		      a = t;
		    }
		    a = safe_add(a, olda);
		    b = safe_add(b, oldb);
		    c = safe_add(c, oldc);
		    d = safe_add(d, oldd);
		    e = safe_add(e, olde);
		  }
		  return Array(a, b, c, d, e);
		}

		/*
		 * Perform the appropriate triplet combination function for the current
		 * iteration
		 */
		function sha1_ft(t, b, c, d) {
		  if (t < 20) return b & c | ~b & d;
		  if (t < 40) return b ^ c ^ d;
		  if (t < 60) return b & c | b & d | c & d;
		  return b ^ c ^ d;
		}

		/*
		 * Determine the appropriate additive constant for the current iteration
		 */
		function sha1_kt(t) {
		  return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
		}

		/*
		 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
		 * to work around bugs in some JS interpreters.
		 */
		function safe_add(x, y) {
		  var lsw = (x & 0xffff) + (y & 0xffff);
		  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		  return msw << 16 | lsw & 0xffff;
		}

		/*
		 * Bitwise rotate a 32-bit number to the left.
		 */
		function rol(num, cnt) {
		  return num << cnt | num >>> 32 - cnt;
		}
		module.exports = function sha1(buf) {
		  return helpers.hash(buf, core_sha1, 20, true);
		};

		},{"./helpers":532}],535:[function(require,module,exports){

		/**
		 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
		 * in FIPS 180-2
		 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
		 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
		 *
		 */

		var helpers = require('./helpers');
		var safe_add = function safe_add(x, y) {
		  var lsw = (x & 0xffff) + (y & 0xffff);
		  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		  return msw << 16 | lsw & 0xffff;
		};
		var S = function S(X, n) {
		  return X >>> n | X << 32 - n;
		};
		var R = function R(X, n) {
		  return X >>> n;
		};
		var Ch = function Ch(x, y, z) {
		  return x & y ^ ~x & z;
		};
		var Maj = function Maj(x, y, z) {
		  return x & y ^ x & z ^ y & z;
		};
		var Sigma0256 = function Sigma0256(x) {
		  return S(x, 2) ^ S(x, 13) ^ S(x, 22);
		};
		var Sigma1256 = function Sigma1256(x) {
		  return S(x, 6) ^ S(x, 11) ^ S(x, 25);
		};
		var Gamma0256 = function Gamma0256(x) {
		  return S(x, 7) ^ S(x, 18) ^ R(x, 3);
		};
		var Gamma1256 = function Gamma1256(x) {
		  return S(x, 17) ^ S(x, 19) ^ R(x, 10);
		};
		var core_sha256 = function core_sha256(m, l) {
		  var K = new Array(0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2);
		  var HASH = new Array(0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19);
		  var W = new Array(64);
		  var a, b, c, d, e, f, g, h, i, j;
		  var T1, T2;
		  /* append padding */
		  m[l >> 5] |= 0x80 << 24 - l % 32;
		  m[(l + 64 >> 9 << 4) + 15] = l;
		  for (var i = 0; i < m.length; i += 16) {
		    a = HASH[0];
		    b = HASH[1];
		    c = HASH[2];
		    d = HASH[3];
		    e = HASH[4];
		    f = HASH[5];
		    g = HASH[6];
		    h = HASH[7];
		    for (var j = 0; j < 64; j++) {
		      if (j < 16) {
		        W[j] = m[j + i];
		      } else {
		        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
		      }
		      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
		      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
		      h = g;
		      g = f;
		      f = e;
		      e = safe_add(d, T1);
		      d = c;
		      c = b;
		      b = a;
		      a = safe_add(T1, T2);
		    }
		    HASH[0] = safe_add(a, HASH[0]);
		    HASH[1] = safe_add(b, HASH[1]);
		    HASH[2] = safe_add(c, HASH[2]);
		    HASH[3] = safe_add(d, HASH[3]);
		    HASH[4] = safe_add(e, HASH[4]);
		    HASH[5] = safe_add(f, HASH[5]);
		    HASH[6] = safe_add(g, HASH[6]);
		    HASH[7] = safe_add(h, HASH[7]);
		  }
		  return HASH;
		};
		module.exports = function sha256(buf) {
		  return helpers.hash(buf, core_sha256, 32, true);
		};

		},{"./helpers":532}],536:[function(require,module,exports){

		module.exports = function () {
		  return function () {};
		};

		},{}],537:[function(require,module,exports){
		(function (Buffer){(function (){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
		var _require = require('stream'),
		  Stream = _require.Stream;
		var _require2 = require('../lib/common/utils/isArray'),
		  isArray = _require2.isArray;
		module.exports.string = function isString(obj) {
		  return typeof obj === 'string';
		};
		module.exports.array = isArray;
		module.exports.buffer = Buffer.isBuffer;
		function isStream(obj) {
		  return obj instanceof Stream;
		}
		module.exports.writableStream = function isWritableStream(obj) {
		  return isStream(obj) && typeof obj._write === 'function' && (0, _typeof2.default)(obj._writableState) === 'object';
		};

		}).call(this);}).call(this,{"isBuffer":require("../node_modules/is-buffer/index.js")});
		},{"../lib/common/utils/isArray":67,"../node_modules/is-buffer/index.js":409,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/helpers/typeof":91,"stream":468}],538:[function(require,module,exports){

		var immediate = require('immediate');
		var process = module.exports = {};
		process.nextTick = immediate;
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};
		function noop() {}
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		process.prependListener = noop;
		process.prependOnceListener = noop;
		process.listeners = function (name) {
		  return [];
		};
		process.binding = function (name) {
		  throw new Error('process.binding is not supported');
		};
		process.cwd = function () {
		  return '/';
		};
		process.chdir = function (dir) {
		  throw new Error('process.chdir is not supported');
		};
		process.umask = function () {
		  return 0;
		};

		},{"immediate":401}],539:[function(require,module,exports){
		(function (global){(function (){

		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.search.js");
		//"version": "2.8.2",
		var ClientRequest = require('./lib/request');
		var response = require('./lib/response');
		var extend = require('xtend');
		var statusCodes = require('builtin-status-codes');
		var url = require('url');
		var http = exports;
		http.request = function (opts, cb) {
		  if (typeof opts === 'string') opts = url.parse(opts);else opts = extend(opts);

		  // Normally, the page is loaded from http or https, so not specifying a protocol
		  // will result in a (valid) protocol-relative url. However, this won't work if
		  // the protocol is something else, like 'file:'
		  var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';
		  var protocol = opts.protocol || defaultProtocol;
		  var host = opts.hostname || opts.host;
		  var port = opts.port;
		  var path = opts.path || '/';

		  // Necessary for IPv6 addresses
		  if (host && host.indexOf(':') !== -1) host = '[' + host + ']';

		  // This may be a relative url. The browser should always be able to interpret it correctly.
		  opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;
		  opts.method = (opts.method || 'GET').toUpperCase();
		  opts.headers = opts.headers || {};

		  // Also valid opts.auth, opts.mode

		  var req = new ClientRequest(opts);
		  if (cb) req.on('response', cb);
		  return req;
		};
		http.get = function get(opts, cb) {
		  var req = http.request(opts, cb);
		  req.end();
		  return req;
		};
		http.ClientRequest = ClientRequest;
		http.IncomingMessage = response.IncomingMessage;
		http.Agent = function () {};
		http.Agent.defaultMaxSockets = 4;
		http.globalAgent = new http.Agent();
		http.STATUS_CODES = statusCodes;
		http.METHODS = ['CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REPORT', 'SEARCH', 'SUBSCRIBE', 'TRACE', 'UNLOCK', 'UNSUBSCRIBE'];

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{"./lib/request":541,"./lib/response":542,"builtin-status-codes":104,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.search.js":346,"url":543,"xtend":530}],540:[function(require,module,exports){
		(function (global){(function (){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.promise.js");
		require("core-js/modules/es.array-buffer.constructor.js");
		require("core-js/modules/es.array-buffer.slice.js");
		require("core-js/modules/es.array.slice.js");
		exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);
		exports.writableStream = isFunction(global.WritableStream);
		exports.abortController = isFunction(global.AbortController);
		exports.blobConstructor = false;
		try {
		  new Blob([new ArrayBuffer(1)]);
		  exports.blobConstructor = true;
		} catch (e) {}

		// The xhr request to example.com may violate some restrictive CSP configurations,
		// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
		// and assume support for certain features below.
		var xhr;
		function getXHR() {
		  // Cache the xhr value
		  if (xhr !== undefined) return xhr;
		  if (global.XMLHttpRequest) {
		    xhr = new global.XMLHttpRequest();
		    // If XDomainRequest is available (ie only, where xhr might not work
		    // cross domain), use the page location. Otherwise use example.com
		    // Note: this doesn't actually make an http request.
		    try {
		      xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com');
		    } catch (e) {
		      xhr = null;
		    }
		  } else {
		    // Service workers don't have XHR
		    xhr = null;
		  }
		  return xhr;
		}
		function checkTypeSupport(type) {
		  var xhr = getXHR();
		  if (!xhr) return false;
		  try {
		    xhr.responseType = type;
		    return xhr.responseType === type;
		  } catch (e) {}
		  return false;
		}

		// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
		// Safari 7.1 appears to have fixed this bug.
		var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined';
		var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice);

		// If fetch is supported, then arraybuffer will be supported too. Skip calling
		// checkTypeSupport(), since that calls getXHR().
		exports.arraybuffer = exports.fetch || haveArrayBuffer && checkTypeSupport('arraybuffer');

		// These next two tests unavoidably show warnings in Chrome. Since fetch will always
		// be used if it's available, just return false for these to avoid the warnings.
		exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream');
		exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer && checkTypeSupport('moz-chunked-arraybuffer');

		// If fetch is supported, then overrideMimeType will be supported too. Skip calling
		// getXHR().
		exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);
		exports.vbArray = isFunction(global.VBArray);
		function isFunction(value) {
		  return typeof value === 'function';
		}
		xhr = null; // Help gc

		}).call(this);}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
		},{"core-js/modules/es.array-buffer.constructor.js":308,"core-js/modules/es.array-buffer.slice.js":309,"core-js/modules/es.array.slice.js":319,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.promise.js":333}],541:[function(require,module,exports){
		(function (process,global,Buffer){(function (){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.regexp.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.array.map.js");
		require("core-js/modules/es.function.name.js");
		require("core-js/modules/es.promise.js");
		var capability = require('./capability');
		var inherits = require('inherits');
		var response = require('./response');
		var stream = require('readable-stream');
		var toArrayBuffer = require('to-arraybuffer');
		var IncomingMessage = response.IncomingMessage;
		var rStates = response.readyStates;
		function decideMode(preferBinary, useFetch) {
		  if (capability.fetch && useFetch) {
		    return 'fetch';
		  } else if (capability.mozchunkedarraybuffer) {
		    return 'moz-chunked-arraybuffer';
		  } else if (capability.msstream) {
		    return 'ms-stream';
		  } else if (capability.arraybuffer && preferBinary) {
		    return 'arraybuffer';
		  } else if (capability.vbArray && preferBinary) {
		    return 'text:vbarray';
		  } else {
		    return 'text';
		  }
		}
		var ClientRequest = module.exports = function (opts) {
		  var self = this;
		  stream.Writable.call(self);
		  self._opts = opts;
		  self._body = [];
		  self._headers = {};
		  if (opts.auth) self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'));
		  Object.keys(opts.headers).forEach(function (name) {
		    self.setHeader(name, opts.headers[name]);
		  });
		  var preferBinary;
		  var useFetch = true;
		  if (opts.mode === 'disable-fetch' || 'requestTimeout' in opts && !capability.abortController) {
		    // If the use of XHR should be preferred. Not typically needed.
		    useFetch = false;
		    preferBinary = true;
		  } else if (opts.mode === 'prefer-streaming') {
		    // If streaming is a high priority but binary compatibility and
		    // the accuracy of the 'content-type' header aren't
		    preferBinary = false;
		  } else if (opts.mode === 'allow-wrong-content-type') {
		    // If streaming is more important than preserving the 'content-type' header
		    preferBinary = !capability.overrideMimeType;
		  } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		    // Use binary if text streaming may corrupt data or the content-type header, or for speed
		    preferBinary = true;
		  } else {
		    throw new Error('Invalid value for opts.mode');
		  }
		  self._mode = decideMode(preferBinary, useFetch);
		  self._fetchTimer = null;
		  self.on('finish', function () {
		    self._onFinish();
		  });
		};
		inherits(ClientRequest, stream.Writable);
		ClientRequest.prototype.setHeader = function (name, value) {
		  var self = this;
		  var lowerName = name.toLowerCase();
		  // This check is not necessary, but it prevents warnings from browsers about setting unsafe
		  // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
		  // http-browserify did it, so I will too.
		  if (unsafeHeaders.indexOf(lowerName) !== -1) return;
		  self._headers[lowerName] = {
		    name: name,
		    value: value
		  };
		};
		ClientRequest.prototype.getHeader = function (name) {
		  var header = this._headers[name.toLowerCase()];
		  if (header) return header.value;
		  return null;
		};
		ClientRequest.prototype.removeHeader = function (name) {
		  var self = this;
		  delete self._headers[name.toLowerCase()];
		};
		ClientRequest.prototype._onFinish = function () {
		  var self = this;
		  if (self._destroyed) return;
		  var opts = self._opts;
		  var headersObj = self._headers;
		  var body = null;
		  if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		    if (capability.arraybuffer) {
		      body = toArrayBuffer(Buffer.concat(self._body));
		    } else if (capability.blobConstructor) {
		      body = new global.Blob(self._body.map(function (buffer) {
		        return toArrayBuffer(buffer);
		      }), {
		        type: (headersObj['content-type'] || {}).value || ''
		      });
		    } else {
		      // get utf8 string
		      body = Buffer.concat(self._body).toString();
		    }
		  }

		  // create flattened list of headers
		  var headersList = [];
		  Object.keys(headersObj).forEach(function (keyName) {
		    var name = headersObj[keyName].name;
		    var value = headersObj[keyName].value;
		    if (Array.isArray(value)) {
		      value.forEach(function (v) {
		        headersList.push([name, v]);
		      });
		    } else {
		      headersList.push([name, value]);
		    }
		  });
		  if (self._mode === 'fetch') {
		    var signal = null;
		    if (capability.abortController) {
		      var controller = new AbortController();
		      signal = controller.signal;
		      self._fetchAbortController = controller;
		      if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
		        self._fetchTimer = global.setTimeout(function () {
		          self.emit('requestTimeout');
		          if (self._fetchAbortController) self._fetchAbortController.abort();
		        }, opts.requestTimeout);
		      }
		    }
		    global.fetch(self._opts.url, {
		      method: self._opts.method,
		      headers: headersList,
		      body: body || undefined,
		      mode: 'cors',
		      credentials: opts.withCredentials ? 'include' : 'same-origin',
		      signal: signal
		    }).then(function (response) {
		      self._fetchResponse = response;
		      self._connect();
		    }, function (reason) {
		      global.clearTimeout(self._fetchTimer);
		      if (!self._destroyed) self.emit('error', reason);
		    });
		  } else {
		    var xhr = self._xhr = new global.XMLHttpRequest();
		    try {
		      xhr.open(self._opts.method, self._opts.url, true);
		    } catch (err) {
		      process.nextTick(function () {
		        self.emit('error', err);
		      });
		      return;
		    }

		    // Can't set responseType on really old browsers
		    if ('responseType' in xhr) xhr.responseType = self._mode.split(':')[0];
		    if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;
		    if (self._mode === 'text' && 'overrideMimeType' in xhr) xhr.overrideMimeType('text/plain; charset=x-user-defined');
		    if ('requestTimeout' in opts) {
		      xhr.timeout = opts.requestTimeout;
		      xhr.ontimeout = function () {
		        self.emit('requestTimeout');
		      };
		    }
		    headersList.forEach(function (header) {
		      xhr.setRequestHeader(header[0], header[1]);
		    });
		    self._response = null;
		    xhr.onreadystatechange = function () {
		      switch (xhr.readyState) {
		        case rStates.LOADING:
		        case rStates.DONE:
		          self._onXHRProgress();
		          break;
		      }
		    };
		    // Necessary for streaming in Firefox, since xhr.response is ONLY defined
		    // in onprogress, not in onreadystatechange with xhr.readyState = 3
		    if (self._mode === 'moz-chunked-arraybuffer') {
		      xhr.onprogress = function () {
		        self._onXHRProgress();
		      };
		    }
		    xhr.onerror = function () {
		      if (self._destroyed) return;
		      self.emit('error', new Error('XHR error'));
		    };
		    try {
		      xhr.send(body);
		    } catch (err) {
		      process.nextTick(function () {
		        self.emit('error', err);
		      });
		      return;
		    }
		  }
		};

		/**
		 * Checks if xhr.status is readable and non-zero, indicating no error.
		 * Even though the spec says it should be available in readyState 3,
		 * accessing it throws an exception in IE8
		 */
		function statusValid(xhr) {
		  try {
		    var status = xhr.status;
		    return status !== null && status !== 0;
		  } catch (e) {
		    return false;
		  }
		}
		ClientRequest.prototype._onXHRProgress = function () {
		  var self = this;
		  if (!statusValid(self._xhr) || self._destroyed) return;
		  if (!self._response) self._connect();
		  self._response._onXHRProgress();
		};
		ClientRequest.prototype._connect = function () {
		  var self = this;
		  if (self._destroyed) return;
		  self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer);
		  self._response.on('error', function (err) {
		    self.emit('error', err);
		  });
		  self.emit('response', self._response);
		};
		ClientRequest.prototype._write = function (chunk, encoding, cb) {
		  var self = this;
		  self._body.push(chunk);
		  cb();
		};
		ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
		  var self = this;
		  self._destroyed = true;
		  global.clearTimeout(self._fetchTimer);
		  if (self._response) self._response._destroyed = true;
		  if (self._xhr) self._xhr.abort();else if (self._fetchAbortController) self._fetchAbortController.abort();
		};
		ClientRequest.prototype.end = function (data, encoding, cb) {
		  var self = this;
		  if (typeof data === 'function') {
		    cb = data;
		    data = undefined;
		  }
		  stream.Writable.prototype.end.call(self, data, encoding, cb);
		};
		ClientRequest.prototype.flushHeaders = function () {};
		ClientRequest.prototype.setTimeout = function () {};
		ClientRequest.prototype.setNoDelay = function () {};
		ClientRequest.prototype.setSocketKeepAlive = function () {};

		// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
		var unsafeHeaders = ['accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'user-agent', 'via'];

		}).call(this);}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer);
		},{"./capability":540,"./response":542,"_process":538,"buffer":103,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.map.js":318,"core-js/modules/es.function.name.js":322,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.promise.js":333,"core-js/modules/es.regexp.to-string.js":339,"core-js/modules/web.dom-collections.for-each.js":380,"inherits":407,"readable-stream":463,"to-arraybuffer":485}],542:[function(require,module,exports){
		(function (process,global,Buffer){(function (){

		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/web.dom-collections.for-each.js");
		require("core-js/modules/es.promise.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.split.js");
		require("core-js/modules/es.string.match.js");
		require("core-js/modules/es.array.iterator.js");
		require("core-js/modules/es.array-buffer.slice.js");
		require("core-js/modules/es.typed-array.uint8-array.js");
		require("core-js/modules/es.typed-array.copy-within.js");
		require("core-js/modules/es.typed-array.every.js");
		require("core-js/modules/es.typed-array.fill.js");
		require("core-js/modules/es.typed-array.filter.js");
		require("core-js/modules/es.typed-array.find.js");
		require("core-js/modules/es.typed-array.find-index.js");
		require("core-js/modules/es.typed-array.for-each.js");
		require("core-js/modules/es.typed-array.includes.js");
		require("core-js/modules/es.typed-array.index-of.js");
		require("core-js/modules/es.typed-array.iterator.js");
		require("core-js/modules/es.typed-array.join.js");
		require("core-js/modules/es.typed-array.last-index-of.js");
		require("core-js/modules/es.typed-array.map.js");
		require("core-js/modules/es.typed-array.reduce.js");
		require("core-js/modules/es.typed-array.reduce-right.js");
		require("core-js/modules/es.typed-array.reverse.js");
		require("core-js/modules/es.typed-array.set.js");
		require("core-js/modules/es.typed-array.slice.js");
		require("core-js/modules/es.typed-array.some.js");
		require("core-js/modules/es.typed-array.sort.js");
		require("core-js/modules/es.typed-array.subarray.js");
		require("core-js/modules/es.typed-array.to-locale-string.js");
		require("core-js/modules/es.typed-array.to-string.js");
		require("core-js/modules/es.array.slice.js");
		var capability = require('./capability');
		var inherits = require('inherits');
		var stream = require('readable-stream');
		var rStates = exports.readyStates = {
		  UNSENT: 0,
		  OPENED: 1,
		  HEADERS_RECEIVED: 2,
		  LOADING: 3,
		  DONE: 4
		};
		var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
		  var self = this;
		  stream.Readable.call(self);
		  self._mode = mode;
		  self.headers = {};
		  self.rawHeaders = [];
		  self.trailers = {};
		  self.rawTrailers = [];

		  // Fake the 'close' event, but only once 'end' fires
		  self.on('end', function () {
		    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		    process.nextTick(function () {
		      self.emit('close');
		    });
		  });
		  if (mode === 'fetch') {
		    var read = function read() {
		      reader.read().then(function (result) {
		        if (self._destroyed) return;
		        if (result.done) {
		          global.clearTimeout(fetchTimer);
		          self.push(null);
		          return;
		        }
		        self.push(new Buffer(result.value));
		        read();
		      }).catch(function (err) {
		        global.clearTimeout(fetchTimer);
		        if (!self._destroyed) self.emit('error', err);
		      });
		    };
		    self._fetchResponse = response;
		    self.url = response.url;
		    self.statusCode = response.status;
		    self.statusMessage = response.statusText;
		    response.headers.forEach(function (header, key) {
		      self.headers[key.toLowerCase()] = header;
		      self.rawHeaders.push(key, header);
		    });
		    if (capability.writableStream) {
		      var writable = new WritableStream({
		        write: function write(chunk) {
		          return new Promise(function (resolve, reject) {
		            if (self._destroyed) {
		              reject();
		            } else if (self.push(new Buffer(chunk))) {
		              resolve();
		            } else {
		              self._resumeFetch = resolve;
		            }
		          });
		        },
		        close: function close() {
		          global.clearTimeout(fetchTimer);
		          if (!self._destroyed) self.push(null);
		        },
		        abort: function abort(err) {
		          if (!self._destroyed) self.emit('error', err);
		        }
		      });
		      try {
		        response.body.pipeTo(writable).catch(function (err) {
		          global.clearTimeout(fetchTimer);
		          if (!self._destroyed) self.emit('error', err);
		        });
		        return;
		      } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		    }
		    // fallback for when writableStream or pipeTo aren't available
		    var reader = response.body.getReader();
		    read();
		  } else {
		    self._xhr = xhr;
		    self._pos = 0;
		    self.url = xhr.responseURL;
		    self.statusCode = xhr.status;
		    self.statusMessage = xhr.statusText;
		    var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
		    headers.forEach(function (header) {
		      var matches = header.match(/^([^:]+):\s*(.*)/);
		      if (matches) {
		        var key = matches[1].toLowerCase();
		        if (key === 'set-cookie') {
		          if (self.headers[key] === undefined) {
		            self.headers[key] = [];
		          }
		          self.headers[key].push(matches[2]);
		        } else if (self.headers[key] !== undefined) {
		          self.headers[key] += ', ' + matches[2];
		        } else {
		          self.headers[key] = matches[2];
		        }
		        self.rawHeaders.push(matches[1], matches[2]);
		      }
		    });
		    self._charset = 'x-user-defined';
		    if (!capability.overrideMimeType) {
		      var mimeType = self.rawHeaders['mime-type'];
		      if (mimeType) {
		        var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
		        if (charsetMatch) {
		          self._charset = charsetMatch[1].toLowerCase();
		        }
		      }
		      if (!self._charset) self._charset = 'utf-8'; // best guess
		    }
		  }
		};
		inherits(IncomingMessage, stream.Readable);
		IncomingMessage.prototype._read = function () {
		  var self = this;
		  var resolve = self._resumeFetch;
		  if (resolve) {
		    self._resumeFetch = null;
		    resolve();
		  }
		};
		IncomingMessage.prototype._onXHRProgress = function () {
		  var self = this;
		  var xhr = self._xhr;
		  var response = null;
		  switch (self._mode) {
		    case 'text:vbarray':
		      // For IE9
		      if (xhr.readyState !== rStates.DONE) break;
		      try {
		        // This fails in IE8
		        response = new global.VBArray(xhr.responseBody).toArray();
		      } catch (e) {}
		      if (response !== null) {
		        self.push(new Buffer(response));
		        break;
		      }
		    // Falls through in IE8
		    case 'text':
		      try {
		        // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
		        response = xhr.responseText;
		      } catch (e) {
		        self._mode = 'text:vbarray';
		        break;
		      }
		      if (response.length > self._pos) {
		        var newData = response.substr(self._pos);
		        if (self._charset === 'x-user-defined') {
		          var buffer = new Buffer(newData.length);
		          for (var i = 0; i < newData.length; i++) buffer[i] = newData.charCodeAt(i) & 0xff;
		          self.push(buffer);
		        } else {
		          self.push(newData, self._charset);
		        }
		        self._pos = response.length;
		      }
		      break;
		    case 'arraybuffer':
		      if (xhr.readyState !== rStates.DONE || !xhr.response) break;
		      response = xhr.response;
		      self.push(new Buffer(new Uint8Array(response)));
		      break;
		    case 'moz-chunked-arraybuffer':
		      // take whole
		      response = xhr.response;
		      if (xhr.readyState !== rStates.LOADING || !response) break;
		      self.push(new Buffer(new Uint8Array(response)));
		      break;
		    case 'ms-stream':
		      response = xhr.response;
		      if (xhr.readyState !== rStates.LOADING) break;
		      var reader = new global.MSStreamReader();
		      reader.onprogress = function () {
		        if (reader.result.byteLength > self._pos) {
		          self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));
		          self._pos = reader.result.byteLength;
		        }
		      };
		      reader.onload = function () {
		        self.push(null);
		      };
		      // reader.onerror = ??? // TODO: this
		      reader.readAsArrayBuffer(response);
		      break;
		  }

		  // The ms-stream case handles end separately in reader.onload()
		  if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		    self.push(null);
		  }
		};

		}).call(this);}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer);
		},{"./capability":540,"_process":538,"buffer":103,"core-js/modules/es.array-buffer.slice.js":309,"core-js/modules/es.array.iterator.js":316,"core-js/modules/es.array.slice.js":319,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.promise.js":333,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.match.js":344,"core-js/modules/es.string.split.js":347,"core-js/modules/es.typed-array.copy-within.js":356,"core-js/modules/es.typed-array.every.js":357,"core-js/modules/es.typed-array.fill.js":358,"core-js/modules/es.typed-array.filter.js":359,"core-js/modules/es.typed-array.find-index.js":360,"core-js/modules/es.typed-array.find.js":361,"core-js/modules/es.typed-array.for-each.js":362,"core-js/modules/es.typed-array.includes.js":363,"core-js/modules/es.typed-array.index-of.js":364,"core-js/modules/es.typed-array.iterator.js":365,"core-js/modules/es.typed-array.join.js":366,"core-js/modules/es.typed-array.last-index-of.js":367,"core-js/modules/es.typed-array.map.js":368,"core-js/modules/es.typed-array.reduce-right.js":369,"core-js/modules/es.typed-array.reduce.js":370,"core-js/modules/es.typed-array.reverse.js":371,"core-js/modules/es.typed-array.set.js":372,"core-js/modules/es.typed-array.slice.js":373,"core-js/modules/es.typed-array.some.js":374,"core-js/modules/es.typed-array.sort.js":375,"core-js/modules/es.typed-array.subarray.js":376,"core-js/modules/es.typed-array.to-locale-string.js":377,"core-js/modules/es.typed-array.to-string.js":378,"core-js/modules/es.typed-array.uint8-array.js":379,"core-js/modules/web.dom-collections.for-each.js":380,"inherits":407,"readable-stream":463}],543:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.string.search.js");
		require("core-js/modules/es.array.concat.js");
		require("core-js/modules/es.string.split.js");
		require("core-js/modules/es.string.replace.js");
		require("core-js/modules/es.array.join.js");
		require("core-js/modules/es.string.trim.js");
		require("core-js/modules/es.string.match.js");
		require("core-js/modules/es.array.slice.js");
		require("core-js/modules/es.object.keys.js");
		require("core-js/modules/es.array.splice.js");
		var punycode = require('punycode');
		var util = require('./util');
		exports.parse = urlParse;
		exports.resolve = urlResolve;
		exports.resolveObject = urlResolveObject;
		exports.format = urlFormat;
		exports.Url = Url;
		function Url() {
		  this.protocol = null;
		  this.slashes = null;
		  this.auth = null;
		  this.host = null;
		  this.port = null;
		  this.hostname = null;
		  this.hash = null;
		  this.search = null;
		  this.query = null;
		  this.pathname = null;
		  this.path = null;
		  this.href = null;
		}

		// Reference: RFC 3986, RFC 1808, RFC 2396

		// define these here so at least they only have to be
		// compiled once on the first module load.
		var protocolPattern = /^([a-z0-9.+-]+:)/i,
		  portPattern = /:[0-9]*$/,
		  // Special case for a simple path URL
		  simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
		  // RFC 2396: characters reserved for delimiting URLs.
		  // We actually just auto-escape these.
		  delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
		  // RFC 2396: characters not allowed for various reasons.
		  unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
		  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
		  autoEscape = ["'"].concat(unwise),
		  // Characters that are never ever allowed in a hostname.
		  // Note that any invalid chars are also handled, but these
		  // are the ones that are *expected* to be seen, so we fast-path
		  // them.
		  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
		  hostEndingChars = ['/', '?', '#'],
		  hostnameMaxLen = 255,
		  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
		  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
		  // protocols that can allow "unsafe" and "unwise" chars.
		  unsafeProtocol = {
		    javascript: true,
		    'javascript:': true
		  },
		  // protocols that never have a hostname.
		  hostlessProtocol = {
		    javascript: true,
		    'javascript:': true
		  },
		  // protocols that always contain a // bit.
		  slashedProtocol = {
		    http: true,
		    https: true,
		    ftp: true,
		    gopher: true,
		    file: true,
		    'http:': true,
		    'https:': true,
		    'ftp:': true,
		    'gopher:': true,
		    'file:': true
		  },
		  querystring = require('querystring');
		function urlParse(url, parseQueryString, slashesDenoteHost) {
		  if (url && util.isObject(url) && url instanceof Url) return url;
		  var u = new Url();
		  u.parse(url, parseQueryString, slashesDenoteHost);
		  return u;
		}
		Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
		  if (!util.isString(url)) {
		    throw new TypeError("Parameter 'url' must be a string, not " + (0, _typeof2.default)(url));
		  }

		  // Copy chrome, IE, opera backslash-handling behavior.
		  // Back slashes before the query string get converted to forward slashes
		  // See: https://code.google.com/p/chromium/issues/detail?id=25916
		  var queryIndex = url.indexOf('?'),
		    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
		    uSplit = url.split(splitter),
		    slashRegex = /\\/g;
		  uSplit[0] = uSplit[0].replace(slashRegex, '/');
		  url = uSplit.join(splitter);
		  var rest = url;

		  // trim before proceeding.
		  // This is to support parse stuff like "  http://foo.com  \n"
		  rest = rest.trim();
		  if (!slashesDenoteHost && url.split('#').length === 1) {
		    // Try fast path regexp
		    var simplePath = simplePathPattern.exec(rest);
		    if (simplePath) {
		      this.path = rest;
		      this.href = rest;
		      this.pathname = simplePath[1];
		      if (simplePath[2]) {
		        this.search = simplePath[2];
		        if (parseQueryString) {
		          this.query = querystring.parse(this.search.substr(1));
		        } else {
		          this.query = this.search.substr(1);
		        }
		      } else if (parseQueryString) {
		        this.search = '';
		        this.query = {};
		      }
		      return this;
		    }
		  }
		  var proto = protocolPattern.exec(rest);
		  if (proto) {
		    proto = proto[0];
		    var lowerProto = proto.toLowerCase();
		    this.protocol = lowerProto;
		    rest = rest.substr(proto.length);
		  }

		  // figure out if it's got a host
		  // user@server is *always* interpreted as a hostname, and url
		  // resolution will treat //foo/bar as host=foo,path=bar because that's
		  // how the browser resolves relative URLs.
		  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
		    var slashes = rest.substr(0, 2) === '//';
		    if (slashes && !(proto && hostlessProtocol[proto])) {
		      rest = rest.substr(2);
		      this.slashes = true;
		    }
		  }
		  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
		    // there's a hostname.
		    // the first instance of /, ?, ;, or # ends the host.
		    //
		    // If there is an @ in the hostname, then non-host chars *are* allowed
		    // to the left of the last @ sign, unless some host-ending character
		    // comes *before* the @-sign.
		    // URLs are obnoxious.
		    //
		    // ex:
		    // http://a@b@c/ => user:a@b host:c
		    // http://a@b?@c => user:a host:c path:/?@c

		    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
		    // Review our test case against browsers more comprehensively.

		    // find the first instance of any hostEndingChars
		    var hostEnd = -1;
		    for (var i = 0; i < hostEndingChars.length; i++) {
		      var hec = rest.indexOf(hostEndingChars[i]);
		      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
		    }

		    // at this point, either we have an explicit point where the
		    // auth portion cannot go past, or the last @ char is the decider.
		    var auth, atSign;
		    if (hostEnd === -1) {
		      // atSign can be anywhere.
		      atSign = rest.lastIndexOf('@');
		    } else {
		      // atSign must be in auth portion.
		      // http://a@b/c@d => host:b auth:a path:/c@d
		      atSign = rest.lastIndexOf('@', hostEnd);
		    }

		    // Now we have a portion which is definitely the auth.
		    // Pull that off.
		    if (atSign !== -1) {
		      auth = rest.slice(0, atSign);
		      rest = rest.slice(atSign + 1);
		      this.auth = decodeURIComponent(auth);
		    }

		    // the host is the remaining to the left of the first non-host char
		    hostEnd = -1;
		    for (var i = 0; i < nonHostChars.length; i++) {
		      var hec = rest.indexOf(nonHostChars[i]);
		      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
		    }
		    // if we still have not hit it, then the entire thing is a host.
		    if (hostEnd === -1) hostEnd = rest.length;
		    this.host = rest.slice(0, hostEnd);
		    rest = rest.slice(hostEnd);

		    // pull out port.
		    this.parseHost();

		    // we've indicated that there is a hostname,
		    // so even if it's empty, it has to be present.
		    this.hostname = this.hostname || '';

		    // if hostname begins with [ and ends with ]
		    // assume that it's an IPv6 address.
		    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

		    // validate a little.
		    if (!ipv6Hostname) {
		      var hostparts = this.hostname.split('.');
		      for (var i = 0, l = hostparts.length; i < l; i++) {
		        var part = hostparts[i];
		        if (!part) continue;
		        if (!part.match(hostnamePartPattern)) {
		          var newpart = '';
		          for (var j = 0, k = part.length; j < k; j++) {
		            if (part.charCodeAt(j) > 127) {
		              // we replace non-ASCII char with a temporary placeholder
		              // we need this to make sure size of hostname is not
		              // broken by replacing non-ASCII by nothing
		              newpart += 'x';
		            } else {
		              newpart += part[j];
		            }
		          }
		          // we test again with ASCII char only
		          if (!newpart.match(hostnamePartPattern)) {
		            var validParts = hostparts.slice(0, i);
		            var notHost = hostparts.slice(i + 1);
		            var bit = part.match(hostnamePartStart);
		            if (bit) {
		              validParts.push(bit[1]);
		              notHost.unshift(bit[2]);
		            }
		            if (notHost.length) {
		              rest = '/' + notHost.join('.') + rest;
		            }
		            this.hostname = validParts.join('.');
		            break;
		          }
		        }
		      }
		    }
		    if (this.hostname.length > hostnameMaxLen) {
		      this.hostname = '';
		    } else {
		      // hostnames are always lower case.
		      this.hostname = this.hostname.toLowerCase();
		    }
		    if (!ipv6Hostname) {
		      // IDNA Support: Returns a punycoded representation of "domain".
		      // It only converts parts of the domain name that
		      // have non-ASCII characters, i.e. it doesn't matter if
		      // you call it with a domain that already is ASCII-only.
		      this.hostname = punycode.toASCII(this.hostname);
		    }
		    var p = this.port ? ':' + this.port : '';
		    var h = this.hostname || '';
		    this.host = h + p;
		    this.href += this.host;

		    // strip [ and ] from the hostname
		    // the host field still retains them, though
		    if (ipv6Hostname) {
		      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
		      if (rest[0] !== '/') {
		        rest = '/' + rest;
		      }
		    }
		  }

		  // now rest is set to the post-host stuff.
		  // chop off any delim chars.
		  if (!unsafeProtocol[lowerProto]) {
		    // First, make 100% sure that any "autoEscape" chars get
		    // escaped, even if encodeURIComponent doesn't think they
		    // need to be.
		    for (var i = 0, l = autoEscape.length; i < l; i++) {
		      var ae = autoEscape[i];
		      if (rest.indexOf(ae) === -1) continue;
		      var esc = encodeURIComponent(ae);
		      if (esc === ae) {
		        esc = escape(ae);
		      }
		      rest = rest.split(ae).join(esc);
		    }
		  }

		  // chop off from the tail first.
		  var hash = rest.indexOf('#');
		  if (hash !== -1) {
		    // got a fragment string.
		    this.hash = rest.substr(hash);
		    rest = rest.slice(0, hash);
		  }
		  var qm = rest.indexOf('?');
		  if (qm !== -1) {
		    this.search = rest.substr(qm);
		    this.query = rest.substr(qm + 1);
		    if (parseQueryString) {
		      this.query = querystring.parse(this.query);
		    }
		    rest = rest.slice(0, qm);
		  } else if (parseQueryString) {
		    // no query string, but parseQueryString still requested
		    this.search = '';
		    this.query = {};
		  }
		  if (rest) this.pathname = rest;
		  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
		    this.pathname = '/';
		  }

		  //to support http.request
		  if (this.pathname || this.search) {
		    var p = this.pathname || '';
		    var s = this.search || '';
		    this.path = p + s;
		  }

		  // finally, reconstruct the href based on what has been validated.
		  this.href = this.format();
		  return this;
		};

		// format a parsed object into a url string
		function urlFormat(obj) {
		  // ensure it's an object, and not a string url.
		  // If it's an obj, this is a no-op.
		  // this way, you can call url_format() on strings
		  // to clean up potentially wonky urls.
		  if (util.isString(obj)) obj = urlParse(obj);
		  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
		  return obj.format();
		}
		Url.prototype.format = function () {
		  var auth = this.auth || '';
		  if (auth) {
		    auth = encodeURIComponent(auth);
		    auth = auth.replace(/%3A/i, ':');
		    auth += '@';
		  }
		  var protocol = this.protocol || '',
		    pathname = this.pathname || '',
		    hash = this.hash || '',
		    host = false,
		    query = '';
		  if (this.host) {
		    host = auth + this.host;
		  } else if (this.hostname) {
		    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
		    if (this.port) {
		      host += ':' + this.port;
		    }
		  }
		  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
		    query = querystring.stringify(this.query);
		  }
		  var search = this.search || query && '?' + query || '';
		  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

		  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
		  // unless they had them to begin with.
		  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
		    host = '//' + (host || '');
		    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
		  } else if (!host) {
		    host = '';
		  }
		  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
		  if (search && search.charAt(0) !== '?') search = '?' + search;
		  pathname = pathname.replace(/[?#]/g, function (match) {
		    return encodeURIComponent(match);
		  });
		  search = search.replace('#', '%23');
		  return protocol + host + pathname + search + hash;
		};
		function urlResolve(source, relative) {
		  return urlParse(source, false, true).resolve(relative);
		}
		Url.prototype.resolve = function (relative) {
		  return this.resolveObject(urlParse(relative, false, true)).format();
		};
		function urlResolveObject(source, relative) {
		  if (!source) return relative;
		  return urlParse(source, false, true).resolveObject(relative);
		}
		Url.prototype.resolveObject = function (relative) {
		  if (util.isString(relative)) {
		    var rel = new Url();
		    rel.parse(relative, false, true);
		    relative = rel;
		  }
		  var result = new Url();
		  var tkeys = Object.keys(this);
		  for (var tk = 0; tk < tkeys.length; tk++) {
		    var tkey = tkeys[tk];
		    result[tkey] = this[tkey];
		  }

		  // hash is always overridden, no matter what.
		  // even href="" will remove it.
		  result.hash = relative.hash;

		  // if the relative url is empty, then there's nothing left to do here.
		  if (relative.href === '') {
		    result.href = result.format();
		    return result;
		  }

		  // hrefs like //foo/bar always cut to the protocol.
		  if (relative.slashes && !relative.protocol) {
		    // take everything except the protocol from relative
		    var rkeys = Object.keys(relative);
		    for (var rk = 0; rk < rkeys.length; rk++) {
		      var rkey = rkeys[rk];
		      if (rkey !== 'protocol') result[rkey] = relative[rkey];
		    }

		    //urlParse appends trailing / to urls like http://www.example.com
		    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
		      result.path = result.pathname = '/';
		    }
		    result.href = result.format();
		    return result;
		  }
		  if (relative.protocol && relative.protocol !== result.protocol) {
		    // if it's a known url protocol, then changing
		    // the protocol does weird things
		    // first, if it's not file:, then we MUST have a host,
		    // and if there was a path
		    // to begin with, then we MUST have a path.
		    // if it is file:, then the host is dropped,
		    // because that's known to be hostless.
		    // anything else is assumed to be absolute.
		    if (!slashedProtocol[relative.protocol]) {
		      var keys = Object.keys(relative);
		      for (var v = 0; v < keys.length; v++) {
		        var k = keys[v];
		        result[k] = relative[k];
		      }
		      result.href = result.format();
		      return result;
		    }
		    result.protocol = relative.protocol;
		    if (!relative.host && !hostlessProtocol[relative.protocol]) {
		      var relPath = (relative.pathname || '').split('/');
		      while (relPath.length && !(relative.host = relPath.shift()));
		      if (!relative.host) relative.host = '';
		      if (!relative.hostname) relative.hostname = '';
		      if (relPath[0] !== '') relPath.unshift('');
		      if (relPath.length < 2) relPath.unshift('');
		      result.pathname = relPath.join('/');
		    } else {
		      result.pathname = relative.pathname;
		    }
		    result.search = relative.search;
		    result.query = relative.query;
		    result.host = relative.host || '';
		    result.auth = relative.auth;
		    result.hostname = relative.hostname || relative.host;
		    result.port = relative.port;
		    // to support http.request
		    if (result.pathname || result.search) {
		      var p = result.pathname || '';
		      var s = result.search || '';
		      result.path = p + s;
		    }
		    result.slashes = result.slashes || relative.slashes;
		    result.href = result.format();
		    return result;
		  }
		  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
		    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
		    mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
		    removeAllDots = mustEndAbs,
		    srcPath = result.pathname && result.pathname.split('/') || [],
		    relPath = relative.pathname && relative.pathname.split('/') || [],
		    psychotic = result.protocol && !slashedProtocol[result.protocol];

		  // if the url is a non-slashed url, then relative
		  // links like ../.. should be able
		  // to crawl up to the hostname, as well.  This is strange.
		  // result.protocol has already been set by now.
		  // Later on, put the first path part into the host field.
		  if (psychotic) {
		    result.hostname = '';
		    result.port = null;
		    if (result.host) {
		      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
		    }
		    result.host = '';
		    if (relative.protocol) {
		      relative.hostname = null;
		      relative.port = null;
		      if (relative.host) {
		        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
		      }
		      relative.host = null;
		    }
		    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
		  }
		  if (isRelAbs) {
		    // it's absolute.
		    result.host = relative.host || relative.host === '' ? relative.host : result.host;
		    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
		    result.search = relative.search;
		    result.query = relative.query;
		    srcPath = relPath;
		    // fall through to the dot-handling below.
		  } else if (relPath.length) {
		    // it's relative
		    // throw away the existing file, and take the new path instead.
		    if (!srcPath) srcPath = [];
		    srcPath.pop();
		    srcPath = srcPath.concat(relPath);
		    result.search = relative.search;
		    result.query = relative.query;
		  } else if (!util.isNullOrUndefined(relative.search)) {
		    // just pull out the search.
		    // like href='?foo'.
		    // Put this after the other two cases because it simplifies the booleans
		    if (psychotic) {
		      result.hostname = result.host = srcPath.shift();
		      //occationaly the auth can get stuck only in host
		      //this especially happens in cases like
		      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
		      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
		      if (authInHost) {
		        result.auth = authInHost.shift();
		        result.host = result.hostname = authInHost.shift();
		      }
		    }
		    result.search = relative.search;
		    result.query = relative.query;
		    //to support http.request
		    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
		      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
		    }
		    result.href = result.format();
		    return result;
		  }
		  if (!srcPath.length) {
		    // no path at all.  easy.
		    // we've already handled the other stuff above.
		    result.pathname = null;
		    //to support http.request
		    if (result.search) {
		      result.path = '/' + result.search;
		    } else {
		      result.path = null;
		    }
		    result.href = result.format();
		    return result;
		  }

		  // if a url ENDs in . or .., then it must get a trailing slash.
		  // however, if it ends in anything else non-slashy,
		  // then it must NOT get a trailing slash.
		  var last = srcPath.slice(-1)[0];
		  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

		  // strip single dots, resolve double dots to parent dir
		  // if the path tries to go above the root, `up` ends up > 0
		  var up = 0;
		  for (var i = srcPath.length; i >= 0; i--) {
		    last = srcPath[i];
		    if (last === '.') {
		      srcPath.splice(i, 1);
		    } else if (last === '..') {
		      srcPath.splice(i, 1);
		      up++;
		    } else if (up) {
		      srcPath.splice(i, 1);
		      up--;
		    }
		  }

		  // if the path is allowed to go above the root, restore leading ..s
		  if (!mustEndAbs && !removeAllDots) {
		    for (; up--; up) {
		      srcPath.unshift('..');
		    }
		  }
		  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
		    srcPath.unshift('');
		  }
		  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
		    srcPath.push('');
		  }
		  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

		  // put the host back
		  if (psychotic) {
		    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
		    //occationaly the auth can get stuck only in host
		    //this especially happens in cases like
		    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
		    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
		    if (authInHost) {
		      result.auth = authInHost.shift();
		      result.host = result.hostname = authInHost.shift();
		    }
		  }
		  mustEndAbs = mustEndAbs || result.host && srcPath.length;
		  if (mustEndAbs && !isAbsolute) {
		    srcPath.unshift('');
		  }
		  if (!srcPath.length) {
		    result.pathname = null;
		    result.path = null;
		  } else {
		    result.pathname = srcPath.join('/');
		  }

		  //to support request.http
		  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
		    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
		  }
		  result.auth = relative.auth || result.auth;
		  result.slashes = result.slashes || relative.slashes;
		  result.href = result.format();
		  return result;
		};
		Url.prototype.parseHost = function () {
		  var host = this.host;
		  var port = portPattern.exec(host);
		  if (port) {
		    port = port[0];
		    if (port !== ':') {
		      this.port = port.substr(1);
		    }
		    host = host.substr(0, host.length - port.length);
		  }
		  if (host) this.hostname = host;
		};

		},{"./util":544,"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/helpers/typeof":91,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.array.join.js":317,"core-js/modules/es.array.slice.js":319,"core-js/modules/es.array.splice.js":321,"core-js/modules/es.object.keys.js":328,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.match.js":344,"core-js/modules/es.string.replace.js":345,"core-js/modules/es.string.search.js":346,"core-js/modules/es.string.split.js":347,"core-js/modules/es.string.trim.js":349,"punycode":443,"querystring":451}],544:[function(require,module,exports){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
		module.exports = {
		  isString: function isString(arg) {
		    return typeof arg === 'string';
		  },
		  isObject: function isObject(arg) {
		    return (0, _typeof2.default)(arg) === 'object' && arg !== null;
		  },
		  isNull: function isNull(arg) {
		    return arg === null;
		  },
		  isNullOrUndefined: function isNullOrUndefined(arg) {
		    return arg == null;
		  }
		};

		},{"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/helpers/typeof":91}],545:[function(require,module,exports){

		require("core-js/modules/es.number.constructor.js");
		// copy from https://github.com/node-modules/utility for browser

		exports.encodeURIComponent = function (text) {
		  try {
		    return encodeURIComponent(text);
		  } catch (e) {
		    return text;
		  }
		};
		exports.escape = require('escape-html');
		exports.timestamp = function timestamp(t) {
		  if (t) {
		    var v = t;
		    if (typeof v === 'string') {
		      v = Number(v);
		    }
		    if (String(t).length === 10) {
		      v *= 1000;
		    }
		    return new Date(v);
		  }
		  return Math.round(Date.now() / 1000);
		};

		},{"core-js/modules/es.number.constructor.js":324,"escape-html":385}],546:[function(require,module,exports){
		(function (process,Buffer){(function (){

		var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
		var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
		require("core-js/modules/es.string.trim.js");
		require("core-js/modules/es.object.to-string.js");
		require("core-js/modules/es.promise.js");
		require("core-js/modules/es.regexp.exec.js");
		require("core-js/modules/es.function.name.js");
		require("core-js/modules/es.array.concat.js");
		var util = require('util');
		var urlutil = require('url');
		var http = require('http');
		var https = require('https');
		var debug = require('debug')('urllib');
		var ms = require('humanize-ms');
		var REQUEST_ID = 0;
		var MAX_VALUE = Math.pow(2, 31) - 10;
		var PROTO_RE = /^https?:\/\//i;
		function getAgent(agent, defaultAgent) {
		  return agent === undefined ? defaultAgent : agent;
		}
		function parseContentType(str) {
		  if (!str) {
		    return '';
		  }
		  return str.split(';')[0].trim().toLowerCase();
		}
		function makeCallback(resolve, reject) {
		  return function (err, data, res) {
		    if (err) {
		      return reject(err);
		    }
		    resolve({
		      data: data,
		      status: res.statusCode,
		      headers: res.headers,
		      res: res
		    });
		  };
		}

		// exports.TIMEOUT = ms('5s');
		exports.TIMEOUTS = [ms('300s'), ms('300s')];
		var TEXT_DATA_TYPES = ['json', 'text'];
		exports.request = function request(url, args, callback) {
		  // request(url, callback)
		  if (arguments.length === 2 && typeof args === 'function') {
		    callback = args;
		    args = null;
		  }
		  if (typeof callback === 'function') {
		    return exports.requestWithCallback(url, args, callback);
		  }
		  return new Promise(function (resolve, reject) {
		    exports.requestWithCallback(url, args, makeCallback(resolve, reject));
		  });
		};
		exports.requestWithCallback = function requestWithCallback(url, args, callback) {
		  if (!url || typeof url !== 'string' && (0, _typeof2.default)(url) !== 'object') {
		    var msg = util.format('expect request url to be a string or a http request options, but got' + ' %j', url);
		    throw new Error(msg);
		  }
		  if (arguments.length === 2 && typeof args === 'function') {
		    callback = args;
		    args = null;
		  }
		  args = args || {};
		  if (REQUEST_ID >= MAX_VALUE) {
		    REQUEST_ID = 0;
		  }
		  var reqId = ++REQUEST_ID;
		  args.requestUrls = args.requestUrls || [];
		  var reqMeta = {
		    requestId: reqId,
		    url: url,
		    args: args,
		    ctx: args.ctx
		  };
		  if (args.emitter) {
		    args.emitter.emit('request', reqMeta);
		  }
		  args.timeout = args.timeout || exports.TIMEOUTS;
		  args.maxRedirects = args.maxRedirects || 10;
		  args.streaming = args.streaming || args.customResponse;
		  var requestStartTime = Date.now();
		  var parsedUrl;
		  if (typeof url === 'string') {
		    if (!PROTO_RE.test(url)) {
		      // Support `request('www.server.com')`
		      url = 'https://' + url;
		    }
		    parsedUrl = urlutil.parse(url);
		  } else {
		    parsedUrl = url;
		  }
		  var method = (args.type || args.method || parsedUrl.method || 'GET').toUpperCase();
		  var port = parsedUrl.port || 80;
		  var httplib = http;
		  var agent = getAgent(args.agent, exports.agent);
		  var fixJSONCtlChars = args.fixJSONCtlChars;
		  if (parsedUrl.protocol === 'https:') {
		    httplib = https;
		    agent = getAgent(args.httpsAgent, exports.httpsAgent);
		    if (!parsedUrl.port) {
		      port = 443;
		    }
		  }

		  // request through proxy tunnel
		  // var proxyTunnelAgent = detectProxyAgent(parsedUrl, args);
		  // if (proxyTunnelAgent) {
		  //   agent = proxyTunnelAgent;
		  // }

		  var options = {
		    host: parsedUrl.hostname || parsedUrl.host || 'localhost',
		    path: parsedUrl.path || '/',
		    method: method,
		    port: port,
		    agent: agent,
		    headers: args.headers || {},
		    // default is dns.lookup
		    // https://github.com/nodejs/node/blob/master/lib/net.js#L986
		    // custom dnslookup require node >= 4.0.0
		    // https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/net.js#L952
		    lookup: args.lookup
		  };
		  if (Array.isArray(args.timeout)) {
		    options.requestTimeout = args.timeout[args.timeout.length - 1];
		  } else if (typeof args.timeout !== 'undefined') {
		    options.requestTimeout = args.timeout;
		  }

		  // const sslNames = [
		  //   'pfx',
		  //   'key',
		  //   'passphrase',
		  //   'cert',
		  //   'ca',
		  //   'ciphers',
		  //   'rejectUnauthorized',
		  //   'secureProtocol',
		  //   'secureOptions',
		  // ];
		  // for (let i = 0; i < sslNames.length; i++) {
		  //   const name = sslNames[i];
		  //   if (args.hasOwnProperty(name)) {
		  //     options[name] = args[name];
		  //   }
		  // }

		  // don't check ssl
		  // if (options.rejectUnauthorized === false && !options.hasOwnProperty('secureOptions')) {
		  //   options.secureOptions = require('constants').SSL_OP_NO_TLSv1_2;
		  // }

		  var auth = args.auth || parsedUrl.auth;
		  if (auth) {
		    options.auth = auth;
		  }

		  // content undefined  data 有值
		  var body = args.content || args.data;
		  var dataAsQueryString = method === 'GET' || method === 'HEAD' || args.dataAsQueryString;
		  if (!args.content) {
		    if (body && !(typeof body === 'string' || Buffer.isBuffer(body))) {
		      if (dataAsQueryString) {
		        // read: GET, HEAD, use query string
		        body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);
		      } else {
		        var contentType = options.headers['Content-Type'] || options.headers['content-type'];
		        // auto add application/x-www-form-urlencoded when using urlencode form request
		        if (!contentType) {
		          if (args.contentType === 'json') {
		            contentType = 'application/json';
		          } else {
		            contentType = 'application/x-www-form-urlencoded';
		          }
		          options.headers['Content-Type'] = contentType;
		        }
		        if (parseContentType(contentType) === 'application/json') {
		          body = JSON.stringify(body);
		        } else {
		          // 'application/x-www-form-urlencoded'
		          body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);
		        }
		      }
		    }
		  }

		  // if it's a GET or HEAD request, data should be sent as query string
		  if (dataAsQueryString && body) {
		    options.path += (parsedUrl.query ? '&' : '?') + body;
		    body = null;
		  }
		  var requestSize = 0;
		  if (body) {
		    var length = body.length;
		    if (!Buffer.isBuffer(body)) {
		      length = Buffer.byteLength(body);
		    }
		    requestSize = options.headers['Content-Length'] = length;
		  }
		  if (args.dataType === 'json') {
		    options.headers.Accept = 'application/json';
		  }
		  if (typeof args.beforeRequest === 'function') {
		    // you can use this hook to change every thing.
		    args.beforeRequest(options);
		  }
		  var connectTimer = null;
		  var responseTimer = null;
		  var __err = null;
		  var connected = false; // socket connected or not
		  var keepAliveSocket = false; // request with keepalive socket
		  var responseSize = 0;
		  var statusCode = -1;
		  var responseAborted = false;
		  var remoteAddress = '';
		  var remotePort = '';
		  var timing = null;
		  if (args.timing) {
		    timing = {
		      // socket assigned
		      queuing: 0,
		      // dns lookup time
		      dnslookup: 0,
		      // socket connected
		      connected: 0,
		      // request sent
		      requestSent: 0,
		      // Time to first byte (TTFB)
		      waiting: 0,
		      contentDownload: 0
		    };
		  }
		  function cancelConnectTimer() {
		    if (connectTimer) {
		      clearTimeout(connectTimer);
		      connectTimer = null;
		    }
		  }
		  function cancelResponseTimer() {
		    if (responseTimer) {
		      clearTimeout(responseTimer);
		      responseTimer = null;
		    }
		  }
		  function done(err, data, res) {
		    cancelResponseTimer();
		    if (!callback) {
		      console.warn('[urllib:warn] [%s] [%s] [worker:%s] %s %s callback twice!!!', Date(), reqId, process.pid, options.method, url);
		      // https://github.com/node-modules/urllib/pull/30
		      if (err) {
		        console.warn('[urllib:warn] [%s] [%s] [worker:%s] %s: %s\nstack: %s', Date(), reqId, process.pid, err.name, err.message, err.stack);
		      }
		      return;
		    }
		    var cb = callback;
		    callback = null;
		    var headers = {};
		    if (res) {
		      statusCode = res.statusCode;
		      headers = res.headers;
		    }

		    // handle digest auth
		    // if (statusCode === 401 && headers['www-authenticate']
		    //   && (!args.headers || !args.headers.Authorization) && args.digestAuth) {
		    //   const authenticate = headers['www-authenticate'];
		    //   if (authenticate.indexOf('Digest ') >= 0) {
		    //     debug('Request#%d %s: got digest auth header WWW-Authenticate: %s', reqId, url, authenticate);
		    //     args.headers = args.headers || {};
		    //     args.headers.Authorization = digestAuthHeader(options.method, options.path, authenticate, args.digestAuth);
		    //     debug('Request#%d %s: auth with digest header: %s', reqId, url, args.headers.Authorization);
		    //     if (res.headers['set-cookie']) {
		    //       args.headers.Cookie = res.headers['set-cookie'].join(';');
		    //     }
		    //     return exports.requestWithCallback(url, args, cb);
		    //   }
		    // }

		    var requestUseTime = Date.now() - requestStartTime;
		    if (timing) {
		      timing.contentDownload = requestUseTime;
		    }
		    debug('[%sms] done, %s bytes HTTP %s %s %s %s, keepAliveSocket: %s, timing: %j', requestUseTime, responseSize, statusCode, options.method, options.host, options.path, keepAliveSocket, timing);
		    var response = {
		      status: statusCode,
		      statusCode: statusCode,
		      headers: headers,
		      size: responseSize,
		      aborted: responseAborted,
		      rt: requestUseTime,
		      keepAliveSocket: keepAliveSocket,
		      data: data,
		      requestUrls: args.requestUrls,
		      timing: timing,
		      remoteAddress: remoteAddress,
		      remotePort: remotePort
		    };
		    if (err) {
		      var agentStatus = '';
		      if (agent && typeof agent.getCurrentStatus === 'function') {
		        // add current agent status to error message for logging and debug
		        agentStatus = ', agent status: ' + JSON.stringify(agent.getCurrentStatus());
		      }
		      err.message += ', ' + options.method + ' ' + url + ' ' + statusCode + ' (connected: ' + connected + ', keepalive socket: ' + keepAliveSocket + agentStatus + ')' + '\nheaders: ' + JSON.stringify(headers);
		      err.data = data;
		      err.path = options.path;
		      err.status = statusCode;
		      err.headers = headers;
		      err.res = response;
		    }
		    cb(err, data, args.streaming ? res : response);
		    if (args.emitter) {
		      // keep to use the same reqMeta object on request event before
		      reqMeta.url = url;
		      reqMeta.socket = req && req.connection;
		      reqMeta.options = options;
		      reqMeta.size = requestSize;
		      args.emitter.emit('response', {
		        requestId: reqId,
		        error: err,
		        ctx: args.ctx,
		        req: reqMeta,
		        res: response
		      });
		    }
		  }
		  function handleRedirect(res) {
		    var err = null;
		    if (args.followRedirect && statuses.redirect[res.statusCode]) {
		      // handle redirect
		      args._followRedirectCount = (args._followRedirectCount || 0) + 1;
		      var location = res.headers.location;
		      if (!location) {
		        err = new Error('Got statusCode ' + res.statusCode + ' but cannot resolve next location from headers');
		        err.name = 'FollowRedirectError';
		      } else if (args._followRedirectCount > args.maxRedirects) {
		        err = new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + url);
		        err.name = 'MaxRedirectError';
		      } else {
		        var newUrl = args.formatRedirectUrl ? args.formatRedirectUrl(url, location) : urlutil.resolve(url, location);
		        debug('Request#%d %s: `redirected` from %s to %s', reqId, options.path, url, newUrl);
		        // make sure timer stop
		        cancelResponseTimer();
		        // should clean up headers.Host on `location: http://other-domain/url`
		        if (args.headers && args.headers.Host && PROTO_RE.test(location)) {
		          args.headers.Host = null;
		        }
		        // avoid done will be execute in the future change.
		        var cb = callback;
		        callback = null;
		        exports.requestWithCallback(newUrl, args, cb);
		        return {
		          redirect: true,
		          error: null
		        };
		      }
		    }
		    return {
		      redirect: false,
		      error: err
		    };
		  }
		  if (args.gzip) {
		    if (!options.headers['Accept-Encoding'] && !options.headers['accept-encoding']) {
		      options.headers['Accept-Encoding'] = 'gzip';
		    }
		  }
		  function decodeContent(res, body, cb) {
		    var encoding = res.headers['content-encoding'];
		    // if (body.length === 0) {
		    //   return cb(null, body, encoding);
		    // }

		    // if (!encoding || encoding.toLowerCase() !== 'gzip') {
		    return cb(null, body, encoding);
		    // }

		    // debug('gunzip %d length body', body.length);
		    // zlib.gunzip(body, cb);
		  }
		  var writeStream = args.writeStream;
		  debug('Request#%d %s %s with headers %j, options.path: %s', reqId, method, url, options.headers, options.path);
		  args.requestUrls.push(url);
		  function onResponse(res) {
		    if (timing) {
		      timing.waiting = Date.now() - requestStartTime;
		    }
		    debug('Request#%d %s `req response` event emit: status %d, headers: %j', reqId, url, res.statusCode, res.headers);
		    if (args.streaming) {
		      var result = handleRedirect(res);
		      if (result.redirect) {
		        res.resume();
		        return;
		      }
		      if (result.error) {
		        res.resume();
		        return done(result.error, null, res);
		      }
		      return done(null, null, res);
		    }
		    res.on('close', function () {
		      debug('Request#%d %s: `res close` event emit, total size %d', reqId, url, responseSize);
		    });
		    res.on('error', function () {
		      debug('Request#%d %s: `res error` event emit, total size %d', reqId, url, responseSize);
		    });
		    res.on('aborted', function () {
		      responseAborted = true;
		      debug('Request#%d %s: `res aborted` event emit, total size %d', reqId, url, responseSize);
		    });
		    if (writeStream) {
		      // If there's a writable stream to recieve the response data, just pipe the
		      // response stream to that writable stream and call the callback when it has
		      // finished writing.
		      //
		      // NOTE that when the response stream `res` emits an 'end' event it just
		      // means that it has finished piping data to another stream. In the
		      // meanwhile that writable stream may still writing data to the disk until
		      // it emits a 'close' event.
		      //
		      // That means that we should not apply callback until the 'close' of the
		      // writable stream is emited.
		      //
		      // See also:
		      // - https://github.com/TBEDP/urllib/commit/959ac3365821e0e028c231a5e8efca6af410eabb
		      // - http://nodejs.org/api/stream.html#stream_event_end
		      // - http://nodejs.org/api/stream.html#stream_event_close_1
		      var _result = handleRedirect(res);
		      if (_result.redirect) {
		        res.resume();
		        return;
		      }
		      if (_result.error) {
		        res.resume();
		        // end ths stream first
		        writeStream.end();
		        return done(_result.error, null, res);
		      }
		      // you can set consumeWriteStream false that only wait response end
		      if (args.consumeWriteStream === false) {
		        res.on('end', done.bind(null, null, null, res));
		      } else {
		        // node 0.10, 0.12: only emit res aborted, writeStream close not fired
		        // if (isNode010 || isNode012) {
		        //   first([
		        //     [ writeStream, 'close' ],
		        //     [ res, 'aborted' ],
		        //   ], function(_, stream, event) {
		        //     debug('Request#%d %s: writeStream or res %s event emitted', reqId, url, event);
		        //     done(__err || null, null, res);
		        //   });
		        {
		          writeStream.on('close', function () {
		            debug('Request#%d %s: writeStream close event emitted', reqId, url);
		            done(__err || null, null, res);
		          });
		        }
		      }
		      return res.pipe(writeStream);
		    }

		    // Otherwise, just concat those buffers.
		    //
		    // NOTE that the `chunk` is not a String but a Buffer. It means that if
		    // you simply concat two chunk with `+` you're actually converting both
		    // Buffers into Strings before concating them. It'll cause problems when
		    // dealing with multi-byte characters.
		    //
		    // The solution is to store each chunk in an array and concat them with
		    // 'buffer-concat' when all chunks is recieved.
		    //
		    // See also:
		    // http://cnodejs.org/topic/4faf65852e8fb5bc65113403

		    var chunks = [];
		    res.on('data', function (chunk) {
		      debug('Request#%d %s: `res data` event emit, size %d', reqId, url, chunk.length);
		      responseSize += chunk.length;
		      chunks.push(chunk);
		    });
		    res.on('end', function () {
		      var body = Buffer.concat(chunks, responseSize);
		      debug('Request#%d %s: `res end` event emit, total size %d, _dumped: %s', reqId, url, responseSize, res._dumped);
		      if (__err) {
		        // req.abort() after `res data` event emit.
		        return done(__err, body, res);
		      }
		      var result = handleRedirect(res);
		      if (result.error) {
		        return done(result.error, body, res);
		      }
		      if (result.redirect) {
		        return;
		      }
		      decodeContent(res, body, function (err, data, encoding) {
		        if (err) {
		          return done(err, body, res);
		        }
		        // if body not decode, dont touch it
		        if (!encoding && TEXT_DATA_TYPES.indexOf(args.dataType) >= 0) {
		          // try to decode charset
		          try {
		            data = decodeBodyByCharset(data, res);
		          } catch (e) {
		            debug('decodeBodyByCharset error: %s', e);
		            // if error, dont touch it
		            return done(null, data, res);
		          }
		          if (args.dataType === 'json') {
		            if (responseSize === 0) {
		              data = null;
		            } else {
		              var r = parseJSON(data, fixJSONCtlChars);
		              if (r.error) {
		                err = r.error;
		              } else {
		                data = r.data;
		              }
		            }
		          }
		        }
		        if (responseAborted) {
		          // err = new Error('Remote socket was terminated before `response.end()` was called');
		          // err.name = 'RemoteSocketClosedError';
		          debug('Request#%d %s: Remote socket was terminated before `response.end()` was called', reqId, url);
		        }
		        done(err, data, res);
		      });
		    });
		  }
		  var connectTimeout, responseTimeout;
		  if (Array.isArray(args.timeout)) {
		    connectTimeout = ms(args.timeout[0]);
		    responseTimeout = ms(args.timeout[1]);
		  } else {
		    // set both timeout equal
		    connectTimeout = responseTimeout = ms(args.timeout);
		  }
		  debug('ConnectTimeout: %d, ResponseTimeout: %d', connectTimeout, responseTimeout);
		  function startConnectTimer() {
		    debug('Connect timer ticking, timeout: %d', connectTimeout);
		    connectTimer = setTimeout(function () {
		      connectTimer = null;
		      if (statusCode === -1) {
		        statusCode = -2;
		      }
		      var msg = 'Connect timeout for ' + connectTimeout + 'ms';
		      var errorName = 'ConnectionTimeoutError';
		      if (!req.socket) {
		        errorName = 'SocketAssignTimeoutError';
		        msg += ', working sockets is full';
		      }
		      __err = new Error(msg);
		      __err.name = errorName;
		      __err.requestId = reqId;
		      debug('ConnectTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);
		      abortRequest();
		    }, connectTimeout);
		  }
		  function startResposneTimer() {
		    debug('Response timer ticking, timeout: %d', responseTimeout);
		    responseTimer = setTimeout(function () {
		      responseTimer = null;
		      var msg = 'Response timeout for ' + responseTimeout + 'ms';
		      var errorName = 'ResponseTimeoutError';
		      __err = new Error(msg);
		      __err.name = errorName;
		      __err.requestId = reqId;
		      debug('ResponseTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);
		      abortRequest();
		    }, responseTimeout);
		  }
		  var req;
		  // request headers checker will throw error
		  options.mode = args.mode ? args.mode : '';
		  try {
		    req = httplib.request(options, onResponse);
		  } catch (err) {
		    return done(err);
		  }

		  // environment detection: browser or nodejs
		  if (typeof window === 'undefined') {
		    // start connect timer just after `request` return, and just in nodejs environment
		    startConnectTimer();
		  } else {
		    req.on('requestTimeout', function () {
		      if (statusCode === -1) {
		        statusCode = -2;
		      }
		      var msg = 'Connect timeout for ' + connectTimeout + 'ms';
		      var errorName = 'ConnectionTimeoutError';
		      __err = new Error(msg);
		      __err.name = errorName;
		      __err.requestId = reqId;
		      abortRequest();
		    });
		  }
		  function abortRequest() {
		    debug('Request#%d %s abort, connected: %s', reqId, url, connected);
		    // it wont case error event when req haven't been assigned a socket yet.
		    if (!req.socket) {
		      __err.noSocket = true;
		      done(__err);
		    }
		    req.abort();
		  }
		  if (timing) {
		    // request sent
		    req.on('finish', function () {
		      timing.requestSent = Date.now() - requestStartTime;
		    });
		  }
		  req.once('socket', function (socket) {
		    if (timing) {
		      // socket queuing time
		      timing.queuing = Date.now() - requestStartTime;
		    }

		    // https://github.com/nodejs/node/blob/master/lib/net.js#L377
		    // https://github.com/nodejs/node/blob/v0.10.40-release/lib/net.js#L352
		    // should use socket.socket on 0.10.x
		    // if (isNode010 && socket.socket) {
		    //   socket = socket.socket;
		    // }

		    var readyState = socket.readyState;
		    if (readyState === 'opening') {
		      socket.once('lookup', function (err, ip, addressType) {
		        debug('Request#%d %s lookup: %s, %s, %s', reqId, url, err, ip, addressType);
		        if (timing) {
		          timing.dnslookup = Date.now() - requestStartTime;
		        }
		        if (ip) {
		          remoteAddress = ip;
		        }
		      });
		      socket.once('connect', function () {
		        if (timing) {
		          // socket connected
		          timing.connected = Date.now() - requestStartTime;
		        }

		        // cancel socket timer at first and start tick for TTFB
		        cancelConnectTimer();
		        startResposneTimer();
		        debug('Request#%d %s new socket connected', reqId, url);
		        connected = true;
		        if (!remoteAddress) {
		          remoteAddress = socket.remoteAddress;
		        }
		        remotePort = socket.remotePort;
		      });
		      return;
		    }
		    debug('Request#%d %s reuse socket connected, readyState: %s', reqId, url, readyState);
		    connected = true;
		    keepAliveSocket = true;
		    if (!remoteAddress) {
		      remoteAddress = socket.remoteAddress;
		    }
		    remotePort = socket.remotePort;

		    // reuse socket, timer should be canceled.
		    cancelConnectTimer();
		    startResposneTimer();
		  });
		  req.on('error', function (err) {
		    //TypeError for browser fetch api, Error for browser xmlhttprequest api
		    if (err.name === 'Error' || err.name === 'TypeError') {
		      err.name = connected ? 'ResponseError' : 'RequestError';
		    }
		    err.message += ' (req "error")';
		    debug('Request#%d %s `req error` event emit, %s: %s', reqId, url, err.name, err.message);
		    done(__err || err);
		  });
		  if (writeStream) {
		    writeStream.once('error', function (err) {
		      err.message += ' (writeStream "error")';
		      __err = err;
		      debug('Request#%d %s `writeStream error` event emit, %s: %s', reqId, url, err.name, err.message);
		      abortRequest();
		    });
		  }
		  if (args.stream) {
		    args.stream.pipe(req);
		    args.stream.once('error', function (err) {
		      err.message += ' (stream "error")';
		      __err = err;
		      debug('Request#%d %s `readStream error` event emit, %s: %s', reqId, url, err.name, err.message);
		      abortRequest();
		    });
		  } else {
		    req.end(body);
		  }
		  req.requestId = reqId;
		  return req;
		};

		}).call(this);}).call(this,require('_process'),require("buffer").Buffer);
		},{"@babel/runtime/helpers/interopRequireDefault":86,"@babel/runtime/helpers/typeof":91,"_process":538,"buffer":103,"core-js/modules/es.array.concat.js":310,"core-js/modules/es.function.name.js":322,"core-js/modules/es.object.to-string.js":329,"core-js/modules/es.promise.js":333,"core-js/modules/es.regexp.exec.js":338,"core-js/modules/es.string.trim.js":349,"debug":536,"http":539,"https":398,"humanize-ms":399,"url":543,"util":489}]},{},[1])(1)
		});
		})(window); 
	} (aliyunOssSdk));
	return aliyunOssSdk.exports;
}

var aliyunOssSdkExports = requireAliyunOssSdk();
var OSS = /*@__PURE__*/getDefaultExportFromCjs(aliyunOssSdkExports);

var __defProp$o = Object.defineProperty;
var __defNormalProp$o = (obj, key, value) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$o = (obj, key, value) => __defNormalProp$o(obj, typeof key !== "symbol" ? key + "" : key, value);
class OssApi {
  constructor(options) {
    // 客户端
    __publicField$o(this, "client");
    // 配置
    __publicField$o(this, "options");
    // 是否初始化
    __publicField$o(this, "isInit", false);
    __publicField$o(this, "credentials");
    this.options = Object.assign({}, options);
  }
  /**
   * 创建 OSS 实例
   * @param options
   */
  static async create(options) {
    return new Promise(async (resolve) => {
      const ossApi = new OssApi(options);
      await ossApi.initClient();
      resolve(ossApi);
    });
  }
  /**
   * 获取凭证
   */
  async getCredentials() {
    const response = await fetch(`${this.options.server}/oss`, {
      method: "GET"
    });
    const resJson = await response.json();
    this.credentials = resJson.data;
    return this.credentials;
  }
  /**
   * 初始化客户端
   */
  async initClient() {
    if (this.isInit) {
      return;
    }
    await this.getCredentials();
    this.client = new OSS({
      // yourRegion填写Bucket所在地域。以华东1（杭州）为例，Region填写为oss-cn-hangzhou。
      region: this.options.region,
      // 从STS服务获取的临时访问密钥（AccessKey ID和AccessKey Secret）。
      accessKeyId: this.credentials.AccessKeyId,
      accessKeySecret: this.credentials.AccessKeySecret,
      // 从STS服务获取的安全令牌（SecurityToken）。
      stsToken: this.credentials.SecurityToken,
      refreshSTSToken: async () => {
        const info = await this.getCredentials();
        return {
          accessKeyId: info.AccessKeyId,
          accessKeySecret: info.AccessKeySecret,
          stsToken: info.SecurityToken
        };
      },
      // 刷新临时访问凭证的时间间隔，单位为毫秒。
      refreshSTSTokenInterval: 3e5,
      // 填写Bucket名称。
      bucket: this.options.bucket
    });
    this.isInit = true;
  }
  /**
   * 判断临时凭证是否到期。
   **/
  isCredentialsExpired() {
    if (!this.credentials) {
      return true;
    }
    const expireDate = new Date(this.credentials.Expiration);
    const now = /* @__PURE__ */ new Date();
    return expireDate.getTime() - now.getTime() <= 6e4;
  }
  /**
   * 上传文件
   */
  async put(name, file, options) {
    return await this.client.put(name, file, options);
  }
  /**
   * 创建目录
   */
  async mkdir(name) {
    return await this.client.put(name, new Blob([]));
  }
  /**
   * 删除目录
   */
  async deleteDir(prefix) {
    const handleDel = async (name) => {
      try {
        await this.client.delete(name);
      } catch (error) {
        return error;
      }
    };
    const list = await this.client.list({
      prefix
    });
    list.objects = list.objects || [];
    const result = await Promise.all(
      list.objects.map((v) => handleDel(v.name))
    );
    console.log(result);
    return result;
  }
  /**
   * 获取文件
   */
  async get(name, file, options) {
    return await this.client.get(name, file, options);
  }
  /**
   * 获取文件夹
   * @param prefix
   * @param delimiter
   */
  async list(prefix, delimiter) {
    return await this.client.list({
      prefix,
      delimiter,
      "max-keys": 1e3
    }, { timeout: 1e4 });
  }
  /**
   * 对象是否存在
   */
  async head(name, options) {
    return await this.client.head(name, options);
  }
  /**
   * 获取对象
   */
  async getObject(name, options) {
    const url = this.signatureUrl(name, options);
    return await fetch(url).then((res) => res.blob());
  }
  /**
   * 获取对象链接
   */
  signatureUrl(name, options) {
    return this.client.signatureUrl(name, options);
  }
}

class Edges {
  constructor({
    explicitGeometry
  }) {
    let threshold = 15;
    let memoizedGeometry = void 0;
    let memoizedThreshold = 0;
    let parent;
    let geometry = explicitGeometry ?? parent?.geometry;
    if (!geometry) return;
    let cached = memoizedGeometry === geometry && memoizedThreshold === threshold;
    if (cached) return;
    memoizedGeometry = geometry;
    memoizedThreshold = threshold;
    let points = new THREE$2.EdgesGeometry(geometry, threshold).attributes.position.array;
    let lineSegments2 = new LineSegments2();
    lineSegments2.geometry.setPositions(points);
    lineSegments2.geometry.attributes.instanceStart.needsUpdate = true;
    lineSegments2.geometry.attributes.instanceEnd.needsUpdate = true;
    lineSegments2.computeLineDistances();
  }
}

var __defProp$n = Object.defineProperty;
var __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$n = (obj, key, value) => __defNormalProp$n(obj, typeof key !== "symbol" ? key + "" : key, value);
const GridMaterial = shaderMaterial(
  {
    cellSize: 0.5,
    sectionSize: 1,
    fadeDistance: 100,
    fadeStrength: 1,
    fadeFrom: 1,
    cellThickness: 0.5,
    sectionThickness: 1,
    cellColor: /* @__PURE__ */ new THREE$2.Color(),
    sectionColor: /* @__PURE__ */ new THREE$2.Color(),
    infiniteGrid: false,
    followCamera: false,
    worldCamProjPosition: /* @__PURE__ */ new THREE$2.Vector3(),
    worldPlanePosition: /* @__PURE__ */ new THREE$2.Vector3()
  },
  /* glsl */
  `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform vec3 worldPlanePosition;
    uniform float fadeDistance;
    uniform bool infiniteGrid;
    uniform bool followCamera;

    void main() {
      localPosition = position.xzy;
      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;
      
      worldPosition = modelMatrix * vec4(localPosition, 1.0);
      if (followCamera) {
        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
        localPosition = (inverse(modelMatrix) * worldPosition).xyz;
      }

      gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
  `,
  /* glsl */
  `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform float cellSize;
    uniform float sectionSize;
    uniform vec3 cellColor;
    uniform vec3 sectionColor;
    uniform float fadeDistance;
    uniform float fadeStrength;
    uniform float fadeFrom;
    uniform float cellThickness;
    uniform float sectionThickness;

    float getGrid(float size, float thickness) {
      vec2 r = localPosition.xz / size;
      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
      float line = min(grid.x, grid.y) + 1.0 - thickness;
      return 1.0 - min(line, 1.0);
    }

    void main() {
      float g1 = getGrid(cellSize, cellThickness);
      float g2 = getGrid(sectionSize, sectionThickness);

      vec3 from = worldCamProjPosition*vec3(fadeFrom);
      float dist = distance(from, worldPosition.xyz);
      float d = 1.0 - min(dist / fadeDistance, 1.0);
      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
      if (gl_FragColor.a <= 0.0) discard;

      #include <tonemapping_fragment>
      #include <${version >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
    }
  `
);
class Grid extends THREE$2.Mesh {
  constructor({
    args,
    cellColor = new THREE$2.Color("#6f6f6f"),
    sectionColor = new THREE$2.Color("#9d4b4b"),
    cellSize = 0.5,
    sectionSize = 1,
    followCamera = false,
    infiniteGrid = false,
    fadeDistance = 100,
    fadeStrength = 1,
    fadeFrom = 1,
    cellThickness = 0.5,
    sectionThickness = 1,
    side = THREE$2.BackSide
  }) {
    const uniforms1 = { cellSize, sectionSize, cellColor, sectionColor, cellThickness, sectionThickness };
    const uniforms2 = { fadeDistance, fadeStrength, fadeFrom, infiniteGrid, followCamera };
    const geometry = new THREE$2.PlaneGeometry(100, 100, 1, 1);
    const material = new GridMaterial();
    material.side = side;
    material.transparent = true;
    Object.assign(material, uniforms1);
    Object.assign(material, uniforms2);
    super(geometry, material);
    __publicField$n(this, "plane", new THREE$2.Plane());
    __publicField$n(this, "upVector", new THREE$2.Vector3(0, 1, 0));
    __publicField$n(this, "zeroVector", new THREE$2.Vector3(0, 0, 0));
    this.frustumCulled = false;
  }
  // 更新
  tick(camera) {
    this.plane.setFromNormalAndCoplanarPoint(this.upVector, this.zeroVector).applyMatrix4(this.matrixWorld);
    const gridMaterial = this.material;
    const worldCamProjPosition = gridMaterial.uniforms.worldCamProjPosition;
    const worldPlanePosition = gridMaterial.uniforms.worldPlanePosition;
    this.plane.projectPoint(camera.position, worldCamProjPosition.value);
    worldPlanePosition.value.set(0, 0, 0).applyMatrix4(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}

var __defProp$m = Object.defineProperty;
var __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$m = (obj, key, value) => __defNormalProp$m(obj, typeof key !== "symbol" ? key + "" : key, value);
const material = /* @__PURE__ */ shaderMaterial(
  {
    screenspace: false,
    color: /* @__PURE__ */ new THREE$2.Color("black"),
    opacity: 1,
    thickness: 0.05,
    size: /* @__PURE__ */ new THREE$2.Vector2()
  },
  `#include <common>
   #include <morphtarget_pars_vertex>
   #include <skinning_pars_vertex>
   uniform float thickness;
   uniform bool screenspace;
   uniform vec2 size;
   void main() {
     #if defined (USE_SKINNING)
	     #include <beginnormal_vertex>
       #include <morphnormal_vertex>
       #include <skinbase_vertex>
       #include <skinnormal_vertex>
       #include <defaultnormal_vertex>
     #endif
     #include <begin_vertex>
	   #include <morphtarget_vertex>
	   #include <skinning_vertex>
     #include <project_vertex>
     vec4 tNormal = vec4(normal, 0.0);
     vec4 tPosition = vec4(transformed, 1.0);
     #ifdef USE_INSTANCING
       tNormal = instanceMatrix * tNormal;
       tPosition = instanceMatrix * tPosition;
     #endif
     if (screenspace) {
       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); 
     } else {
       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
       clipPosition.xy += offset;
       gl_Position = clipPosition;
     }
   }`,
  `uniform vec3 color;
   uniform float opacity;
   void main(){
     gl_FragColor = vec4(color, opacity);
     #include <tonemapping_fragment>
     #include <${version >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
   }`
);
class Outlines extends THREE$2.Group {
  constructor() {
    super();
    __publicField$m(this, "oldAngle", 0);
    __publicField$m(this, "oldGeometry");
  }
  init({
    color = new THREE$2.Color("skyblue"),
    opacity = 1,
    transparent = false,
    screenspace = false,
    toneMapped = true,
    polygonOffset = false,
    polygonOffsetFactor = 0,
    renderOrder = 0,
    thickness = 0.05,
    angle = Math.PI,
    ...props
  }) {
    const parent = this.parent;
    if (parent && parent.geometry) {
      if (this.oldAngle !== angle || this.oldGeometry !== parent.geometry) {
        this.oldAngle = angle;
        this.oldGeometry = parent.geometry;
        let mesh = this.children?.[0];
        if (mesh) {
          if (angle) {
            mesh.geometry.dispose();
          }
          this.remove(mesh);
        }
        if (parent.skeleton) {
          mesh = new THREE$2.SkinnedMesh();
          mesh.material = material;
          mesh.bind(parent.skeleton, parent.bindMatrix);
          this.add(mesh);
        } else if (parent.isInstancedMesh) {
          mesh = new THREE$2.InstancedMesh(parent.geometry, material, parent.count);
          mesh.instanceMatrix = parent.instanceMatrix;
          this.add(mesh);
        } else {
          mesh = new THREE$2.Mesh();
          mesh.material = material;
          this.add(mesh);
        }
        mesh.geometry = angle ? toCreasedNormals(parent.geometry, angle) : parent.geometry;
      }
    }
  }
  update({
    color = new THREE$2.Color("skyblue"),
    opacity = 1,
    transparent = false,
    screenspace = false,
    toneMapped = true,
    polygonOffset = false,
    polygonOffsetFactor = 0,
    renderOrder = 0,
    thickness = 0.05,
    angle = Math.PI,
    size = new THREE$2.Vector2()
  }) {
    const mesh = this.children[0];
    if (mesh) {
      mesh.renderOrder = renderOrder;
      Object.assign(mesh.material, {
        transparent,
        thickness,
        color,
        opacity,
        size,
        screenspace,
        toneMapped,
        polygonOffset,
        polygonOffsetFactor
      });
    }
  }
  // 更新
  tick() {
  }
}

// github.com/shawn0326/three.path

/**
 * PathPoint
 */
class PathPoint {

	constructor() {
		this.pos = new THREE$2.Vector3();
		this.dir = new THREE$2.Vector3();
		this.right = new THREE$2.Vector3();
		this.up = new THREE$2.Vector3(); // normal
		this.dist = 0; // distance from start
		this.widthScale = 1; // for corner
		this.sharp = false; // marks as sharp corner
	}

	lerpPathPoints(p1, p2, alpha) {
		this.pos.lerpVectors(p1.pos, p2.pos, alpha);
		this.dir.lerpVectors(p1.dir, p2.dir, alpha);
		this.up.lerpVectors(p1.up, p2.up, alpha);
		this.right.lerpVectors(p1.right, p2.right, alpha);
		this.dist = (p2.dist - p1.dist) * alpha + p1.dist;
		this.widthScale = (p2.widthScale - p1.widthScale) * alpha + p1.widthScale;
	}

	copy(source) {
		this.pos.copy(source.pos);
		this.dir.copy(source.dir);
		this.up.copy(source.up);
		this.right.copy(source.right);
		this.dist = source.dist;
		this.widthScale = source.widthScale;
	}

}

const helpVec3_1 = new THREE$2.Vector3();
const helpVec3_2 = new THREE$2.Vector3();
const helpVec3_3 = new THREE$2.Vector3();
const helpMat4 = new THREE$2.Matrix4();
const helpCurve = new THREE$2.QuadraticBezierCurve3();

function _getCornerBezierCurve(last, current, next, cornerRadius, firstCorner, out) {
	const lastDir = helpVec3_1.subVectors(current, last);
	const nextDir = helpVec3_2.subVectors(next, current);

	const lastDirLength = lastDir.length();
	const nextDirLength = nextDir.length();

	lastDir.normalize();
	nextDir.normalize();

	// cornerRadius can not bigger then lineDistance / 2, auto fix this
	const v0Dist = Math.min((firstCorner ? lastDirLength / 2 : lastDirLength) * 0.999999, cornerRadius);
	out.v0.copy(current).sub(lastDir.multiplyScalar(v0Dist));

	out.v1.copy(current);

	const v2Dist = Math.min(nextDirLength / 2 * 0.999999, cornerRadius);
	out.v2.copy(current).add(nextDir.multiplyScalar(v2Dist));

	return out;
}

/**
 * PathPointList
 * input points to generate a PathPoint list
 */
class PathPointList {

	constructor() {
		this.array = []; // path point array
		this.count = 0;
	}

	/**
	 * Set points
	 * @param {THREE.Vector3[]} points key points array
	 * @param {number} cornerRadius? the corner radius. set 0 to disable round corner. default is 0.1
	 * @param {number} cornerSplit? the corner split. default is 10.
	 * @param {number} up? force up. default is auto up (calculate by tangent).
	 * @param {boolean} close? close path. default is false.
	 */
	set(points, cornerRadius = 0.1, cornerSplit = 10, up = null, close = false) {
		points = points.slice(0);

		if (points.length < 2) {
			console.warn("PathPointList: points length less than 2.");
			this.count = 0;
			return;
		}

		// Auto close
		if (close && !points[0].equals(points[points.length - 1])) {
			points.push(new THREE$2.Vector3().copy(points[0]));
		}

		// Generate path point list
		for (let i = 0, l = points.length; i < l; i++) {
			if (i === 0) {
				this._start(points[i], points[i + 1], up);
			} else if (i === l - 1) {
				if (close) {
					// Connect end point and start point
					this._corner(points[i], points[1], cornerRadius, cornerSplit, up);

					// Fix start point
					const dist = this.array[0].dist; // should not copy dist
					this.array[0].copy(this.array[this.count - 1]);
					this.array[0].dist = dist;
				} else {
					this._end(points[i]);
				}
			} else {
				this._corner(points[i], points[i + 1], cornerRadius, cornerSplit, up);
			}
		}
	}

	/**
	 * Get distance of this path
	 * @return {number}
	 */
	distance() {
		if (this.count > 0) {
			return this.array[this.count - 1].dist;
		}
		return 0;
	}

	_getByIndex(index) {
		if (!this.array[index]) {
			this.array[index] = new PathPoint();
		}
		return this.array[index];
	}

	_start(current, next, up) {
		this.count = 0;

		const point = this._getByIndex(this.count);

		point.pos.copy(current);
		point.dir.subVectors(next, current);

		// init start up dir
		if (up) {
			point.up.copy(up);
		} else {
			// select an initial normal vector perpendicular to the first tangent vector
			let min = Number.MAX_VALUE;
			const tx = Math.abs(point.dir.x);
			const ty = Math.abs(point.dir.y);
			const tz = Math.abs(point.dir.z);
			if (tx < min) {
				min = tx;
				point.up.set(1, 0, 0);
			}
			if (ty < min) {
				min = ty;
				point.up.set(0, 1, 0);
			}
			if (tz < min) {
				point.up.set(0, 0, 1);
			}
		}

		point.right.crossVectors(point.dir, point.up).normalize();
		point.up.crossVectors(point.right, point.dir).normalize();
		point.dist = 0;
		point.widthScale = 1;
		point.sharp = false;

		point.dir.normalize();

		this.count++;
	}

	_end(current) {
		const lastPoint = this.array[this.count - 1];
		const point = this._getByIndex(this.count);

		point.pos.copy(current);
		point.dir.subVectors(current, lastPoint.pos);
		const dist = point.dir.length();
		point.dir.normalize();

		point.up.copy(lastPoint.up); // copy last up

		const vec = helpVec3_1.crossVectors(lastPoint.dir, point.dir);
		if (vec.length() > Number.EPSILON) {
			vec.normalize();
			const theta = Math.acos(Math.min(Math.max(lastPoint.dir.dot(point.dir), -1), 1)); // clamp for floating pt errors
			point.up.applyMatrix4(helpMat4.makeRotationAxis(vec, theta));
		}

		point.right.crossVectors(point.dir, point.up).normalize();

		point.dist = lastPoint.dist + dist;
		point.widthScale = 1;
		point.sharp = false;

		this.count++;
	}

	_corner(current, next, cornerRadius, cornerSplit, up) {
		if (cornerRadius > 0 && cornerSplit > 0) {
			const lastPoint = this.array[this.count - 1];
			const curve = _getCornerBezierCurve(lastPoint.pos, current, next, cornerRadius, (this.count - 1) === 0, helpCurve);
			const samplerPoints = curve.getPoints(cornerSplit); // TODO optimize

			for (let f = 0; f < cornerSplit; f++) {
				this._sharpCorner(samplerPoints[f], samplerPoints[f + 1], up, f === 0 ? 1 : 0);
			}

			if (!samplerPoints[cornerSplit].equals(next)) {
				this._sharpCorner(samplerPoints[cornerSplit], next, up, 2);
			}
		} else {
			this._sharpCorner(current, next, up, 0, true);
		}
	}

	// dirType: 0 - use middle dir / 1 - use last dir / 2- use next dir
	_sharpCorner(current, next, up, dirType = 0, sharp = false) {
		const lastPoint = this.array[this.count - 1];
		const point = this._getByIndex(this.count);

		const lastDir = helpVec3_1.subVectors(current, lastPoint.pos);
		const nextDir = helpVec3_2.subVectors(next, current);

		const lastDirLength = lastDir.length();

		lastDir.normalize();
		nextDir.normalize();

		point.pos.copy(current);

		if (dirType === 1) {
			point.dir.copy(lastDir);
		} else if (dirType === 2) {
			point.dir.copy(nextDir);
		} else {
			point.dir.addVectors(lastDir, nextDir);
			point.dir.normalize();
		}

		if (up) {
			if (point.dir.dot(up) === 1) {
				point.right.crossVectors(nextDir, up).normalize();
			} else {
				point.right.crossVectors(point.dir, up).normalize();
			}

			point.up.crossVectors(point.right, point.dir).normalize();
		} else {
			point.up.copy(lastPoint.up);

			const vec = helpVec3_3.crossVectors(lastPoint.dir, point.dir);
			if (vec.length() > Number.EPSILON) {
				vec.normalize();
				const theta = Math.acos(Math.min(Math.max(lastPoint.dir.dot(point.dir), -1), 1)); // clamp for floating pt errors
				point.up.applyMatrix4(helpMat4.makeRotationAxis(vec, theta));
			}

			point.right.crossVectors(point.dir, point.up).normalize();
		}

		point.dist = lastPoint.dist + lastDirLength;

		const _cos = lastDir.dot(nextDir);
		point.widthScale = Math.min(1 / Math.sqrt((1 + _cos) / 2), 1.415) || 1;
		point.sharp = (Math.abs(_cos - 1) > 0.05) && sharp;

		this.count++;
	}

}

/**
 * PathGeometry
 */
class PathGeometry extends THREE$2.BufferGeometry {

    /**
     * @param {Object|Number} initData - If initData is number, geometry init by empty data and set it as the max vertex. If initData is Object, it contains pathPointList and options.
     * @param {Boolean} [generateUv2=false]
     */
    constructor(initData = 3000, generateUv2 = false) {
        super();

        if (isNaN(initData)) {
            this._initByData(initData.pathPointList, initData.options, initData.usage, generateUv2);
        } else {
            this._initByMaxVertex(initData, generateUv2);
        }
    }

    _initByMaxVertex(maxVertex, generateUv2) {
        this.setAttribute('position', new THREE$2.BufferAttribute(new Float32Array(maxVertex * 3), 3).setUsage(THREE$2.DynamicDrawUsage));
        this.setAttribute('normal', new THREE$2.BufferAttribute(new Float32Array(maxVertex * 3), 3).setUsage(THREE$2.DynamicDrawUsage));
        this.setAttribute('uv', new THREE$2.BufferAttribute(new Float32Array(maxVertex * 2), 2).setUsage(THREE$2.DynamicDrawUsage));
        if (generateUv2) {
            this.setAttribute('uv2', new THREE$2.BufferAttribute(new Float32Array(maxVertex * 2), 2).setUsage(THREE$2.DynamicDrawUsage));
        }

        this.drawRange.start = 0;
        this.drawRange.count = 0;

        this.setIndex(maxVertex > 65536 ?
            new THREE$2.Uint32BufferAttribute(maxVertex * 3, 1) :
            new THREE$2.Uint16BufferAttribute(maxVertex * 3, 1)
        );
    }

    _initByData(pathPointList, options = {}, usage, generateUv2) {
        const vertexData = generatePathVertexData(pathPointList, options, generateUv2);

        if (vertexData && vertexData.count !== 0) {
            this.setAttribute('position', new THREE$2.BufferAttribute(new Float32Array(vertexData.position), 3).setUsage(usage || THREE$2.StaticDrawUsage));
            this.setAttribute('normal', new THREE$2.BufferAttribute(new Float32Array(vertexData.normal), 3).setUsage(usage || THREE$2.StaticDrawUsage));
            this.setAttribute('uv', new THREE$2.BufferAttribute(new Float32Array(vertexData.uv), 2).setUsage(usage || THREE$2.StaticDrawUsage));
            if (generateUv2) {
                this.setAttribute('uv2', new THREE$2.BufferAttribute(new Float32Array(vertexData.uv2), 2).setUsage(usage || THREE$2.StaticDrawUsage));
            }

            this.setIndex((vertexData.position.length / 3) > 65536 ?
                new THREE$2.Uint32BufferAttribute(vertexData.indices, 1) :
                new THREE$2.Uint16BufferAttribute(vertexData.indices, 1)
            );
        } else {
            this._initByMaxVertex(2, generateUv2);
        }
    }

    /**
     * Update geometry by PathPointList instance
     * @param {PathPointList} pathPointList
     * @param {Object} options
     * @param {Number} [options.width=0.1]
     * @param {Number} [options.progress=1]
     * @param {Boolean} [options.arrow=true]
     * @param {String} [options.side='both'] - "left"/"right"/"both"
     */
    update(pathPointList, options = {}) {
        const generateUv2 = !!this.getAttribute('uv2');

        const vertexData = generatePathVertexData(pathPointList, options, generateUv2);

        if (vertexData) {
            this._updateAttributes(vertexData.position, vertexData.normal, vertexData.uv, generateUv2 ? vertexData.uv2 : null, vertexData.indices);
            this.drawRange.count = vertexData.count;
        } else {
            this.drawRange.count = 0;
        }
    }

    _resizeAttribute(name, len) {
        let attribute = this.getAttribute(name);
        while (attribute.array.length < len) {
            const oldLength = attribute.array.length;
            const newAttribute = new THREE$2.BufferAttribute(
                new Float32Array(oldLength * 2),
                attribute.itemSize,
                attribute.normalized
            );
            newAttribute.name = attribute.name;
            newAttribute.usage = attribute.usage;
            this.setAttribute(name, newAttribute);
            attribute = newAttribute;
        }
    }

    _resizeIndex(len) {
        let index = this.getIndex();
        while (index.array.length < len) {
            const oldLength = index.array.length;
            const newIndex = new THREE$2.BufferAttribute(
                oldLength * 2 > 65535 ? new Uint32Array(oldLength * 2) : new Uint16Array(oldLength * 2),
                1
            );
            newIndex.name = index.name;
            newIndex.usage = index.usage;
            this.setIndex(newIndex);
            index = newIndex;
        }
    }

    _updateAttributes(position, normal, uv, uv2, indices) {
        this._resizeAttribute('position', position.length);
        const positionAttribute = this.getAttribute('position');
        positionAttribute.array.set(position, 0);
        positionAttribute.updateRange.count = position.length;
        positionAttribute.needsUpdate = true;

        this._resizeAttribute('normal', normal.length);
        const normalAttribute = this.getAttribute('normal');
        normalAttribute.array.set(normal, 0);
        normalAttribute.updateRange.count = normal.length;
        normalAttribute.needsUpdate = true;

        this._resizeAttribute('uv', uv.length);
        const uvAttribute = this.getAttribute('uv');
        uvAttribute.array.set(uv, 0);
        uvAttribute.updateRange.count = uv.length;
        uvAttribute.needsUpdate = true;

        if (uv2) {
            this._resizeAttribute('uv2', uv2.length);
            const uv2Attribute = this.getAttribute('uv2');
            uv2Attribute.array.set(uv2, 0);
            uv2Attribute.updateRange.count = uv2.length;
            uv2Attribute.needsUpdate = true;
        }

        this._resizeIndex(indices.length);
        const indexAttribute = this.getIndex();
        indexAttribute.set(indices, 0);
        indexAttribute.updateRange.count = indices.length;
        indexAttribute.needsUpdate = true;
    }

}

// Vertex Data Generate Functions

function generatePathVertexData(pathPointList, options, generateUv2 = false) {
    const width = options.width || 0.1;
    const progress = options.progress !== undefined ? options.progress : 1;
    const arrow = options.arrow !== undefined ? options.arrow : true;
    const side = options.side !== undefined ? options.side : "both";

    const halfWidth = width / 2;
    const sideWidth = (side !== "both" ? width / 2 : width);
    const totalDistance = pathPointList.distance();
    const progressDistance = progress * totalDistance;
    if (totalDistance == 0) {
        return null;
    }

    const sharpUvOffset = halfWidth / sideWidth;
    const sharpUvOffset2 = halfWidth / totalDistance;

    let count = 0;

    // modify data
    const position = [];
    const normal = [];
    const uv = [];
    const uv2 = [];
    const indices = [];
    let verticesCount = 0;

    const right = new THREE$2.Vector3();
    const left = new THREE$2.Vector3();

    // for sharp corners
    const leftOffset = new THREE$2.Vector3();
    const rightOffset = new THREE$2.Vector3();
    const tempPoint1 = new THREE$2.Vector3();
    const tempPoint2 = new THREE$2.Vector3();

    function addVertices(pathPoint) {
        const first = position.length === 0;
        const sharpCorner = pathPoint.sharp && !first;

        const uvDist = pathPoint.dist / sideWidth;
        const uvDist2 = pathPoint.dist / totalDistance;

        const dir = pathPoint.dir;
        const up = pathPoint.up;
        const _right = pathPoint.right;

        if (side !== "left") {
            right.copy(_right).multiplyScalar(halfWidth * pathPoint.widthScale);
        } else {
            right.set(0, 0, 0);
        }

        if (side !== "right") {
            left.copy(_right).multiplyScalar(-halfWidth * pathPoint.widthScale);
        } else {
            left.set(0, 0, 0);
        }

        right.add(pathPoint.pos);
        left.add(pathPoint.pos);

        if (sharpCorner) {
            leftOffset.fromArray(position, position.length - 6).sub(left);
            rightOffset.fromArray(position, position.length - 3).sub(right);

            const leftDist = leftOffset.length();
            const rightDist = rightOffset.length();

            const sideOffset = leftDist - rightDist;
            let longerOffset, longEdge;

            if (sideOffset > 0) {
                longerOffset = leftOffset;
                longEdge = left;
            } else {
                longerOffset = rightOffset;
                longEdge = right;
            }

            tempPoint1.copy(longerOffset).setLength(Math.abs(sideOffset)).add(longEdge);

            let _cos = tempPoint2.copy(longEdge).sub(tempPoint1).normalize().dot(dir);
            let _len = tempPoint2.copy(longEdge).sub(tempPoint1).length();
            let _dist = _cos * _len * 2;

            tempPoint2.copy(dir).setLength(_dist).add(tempPoint1);

            if (sideOffset > 0) {
                position.push(
                    tempPoint1.x, tempPoint1.y, tempPoint1.z, // 6
                    right.x, right.y, right.z, // 5
                    left.x, left.y, left.z, // 4
                    right.x, right.y, right.z, // 3
                    tempPoint2.x, tempPoint2.y, tempPoint2.z, // 2
                    right.x, right.y, right.z // 1
                );

                verticesCount += 6;

                indices.push(
                    verticesCount - 6, verticesCount - 8, verticesCount - 7,
                    verticesCount - 6, verticesCount - 7, verticesCount - 5,

                    verticesCount - 4, verticesCount - 6, verticesCount - 5,
                    verticesCount - 2, verticesCount - 4, verticesCount - 1
                );

                count += 12;
            } else {
                position.push(
                    left.x, left.y, left.z, // 6
                    tempPoint1.x, tempPoint1.y, tempPoint1.z, // 5
                    left.x, left.y, left.z, // 4
                    right.x, right.y, right.z, // 3
                    left.x, left.y, left.z, // 2
                    tempPoint2.x, tempPoint2.y, tempPoint2.z // 1
                );

                verticesCount += 6;

                indices.push(
                    verticesCount - 6, verticesCount - 8, verticesCount - 7,
                    verticesCount - 6, verticesCount - 7, verticesCount - 5,

                    verticesCount - 6, verticesCount - 5, verticesCount - 3,
                    verticesCount - 2, verticesCount - 3, verticesCount - 1
                );

                count += 12;
            }

            normal.push(
                up.x, up.y, up.z,
                up.x, up.y, up.z,
                up.x, up.y, up.z,
                up.x, up.y, up.z,
                up.x, up.y, up.z,
                up.x, up.y, up.z
            );

            uv.push(
                uvDist - sharpUvOffset, 0,
                uvDist - sharpUvOffset, 1,
                uvDist, 0,
                uvDist, 1,
                uvDist + sharpUvOffset, 0,
                uvDist + sharpUvOffset, 1
            );

            if (generateUv2) {
                uv2.push(
                    uvDist2 - sharpUvOffset2, 0,
                    uvDist2 - sharpUvOffset2, 1,
                    uvDist2, 0,
                    uvDist2, 1,
                    uvDist2 + sharpUvOffset2, 0,
                    uvDist2 + sharpUvOffset2, 1
                );
            }
        } else {
            position.push(
                left.x, left.y, left.z,
                right.x, right.y, right.z
            );

            normal.push(
                up.x, up.y, up.z,
                up.x, up.y, up.z
            );

            uv.push(
                uvDist, 0,
                uvDist, 1
            );

            if (generateUv2) {
                uv2.push(
                    uvDist2, 0,
                    uvDist2, 1
                );
            }

            verticesCount += 2;

            if (!first) {
                indices.push(
                    verticesCount - 2, verticesCount - 4, verticesCount - 3,
                    verticesCount - 2, verticesCount - 3, verticesCount - 1
                );

                count += 6;
            }
        }
    }

    const sharp = new THREE$2.Vector3();

    function addStart(pathPoint) {
        const dir = pathPoint.dir;
        const up = pathPoint.up;
        const _right = pathPoint.right;

        const uvDist = pathPoint.dist / sideWidth;
        const uvDist2 = pathPoint.dist / totalDistance;

        if (side !== "left") {
            right.copy(_right).multiplyScalar(halfWidth * 2);
        } else {
            right.set(0, 0, 0);
        }

        if (side !== "right") {
            left.copy(_right).multiplyScalar(-halfWidth * 2);
        } else {
            left.set(0, 0, 0);
        }

        sharp.copy(dir).setLength(halfWidth * 3);

        right.add(pathPoint.pos);
        left.add(pathPoint.pos);
        sharp.add(pathPoint.pos);

        position.push(
            left.x, left.y, left.z,
            right.x, right.y, right.z,
            sharp.x, sharp.y, sharp.z
        );

        normal.push(
            up.x, up.y, up.z,
            up.x, up.y, up.z,
            up.x, up.y, up.z
        );

        uv.push(
            uvDist, side !== "both" ? (side !== "right" ? -2 : 0) : -0.5,
            uvDist, side !== "both" ? (side !== "left" ? 2 : 0) : 1.5,
            uvDist + 1.5, side !== "both" ? 0 : 0.5
        );

        if (generateUv2) {
            uv2.push(
                uvDist2, side !== "both" ? (side !== "right" ? -2 : 0) : -0.5,
                uvDist2, side !== "both" ? (side !== "left" ? 2 : 0) : 1.5,
                uvDist2 + (1.5 * width / totalDistance), side !== "both" ? 0 : 0.5
            );
        }

        verticesCount += 3;

        indices.push(
            verticesCount - 1, verticesCount - 3, verticesCount - 2
        );

        count += 3;
    }

    let lastPoint;

    if (progressDistance > 0) {
        for (let i = 0; i < pathPointList.count; i++) {
            const pathPoint = pathPointList.array[i];

            if (pathPoint.dist > progressDistance) {
                const prevPoint = pathPointList.array[i - 1];
                lastPoint = new PathPoint();

                // linear lerp for progress
                const alpha = (progressDistance - prevPoint.dist) / (pathPoint.dist - prevPoint.dist);
                lastPoint.lerpPathPoints(prevPoint, pathPoint, alpha);

                addVertices(lastPoint);
                break;
            } else {
                addVertices(pathPoint);
            }
        }
    } else {
        lastPoint = pathPointList.array[0];
    }

    // build arrow geometry
    if (arrow) {
        lastPoint = lastPoint || pathPointList.array[pathPointList.count - 1];
        addStart(lastPoint);
    }

    return {
        position,
        normal,
        uv,
        uv2,
        indices,
        count
    };
}

/**
 * PathTubeGeometry
 */
class PathTubeGeometry extends PathGeometry {

	/**
	 * @param {Object|Number} initData - If initData is number, geometry init by empty data and set it as the max vertex. If initData is Object, it contains pathPointList and options.
	 * @param {Boolean} [generateUv2=false]
	 */
	constructor(initData = 1000, generateUv2 = false) {
		super(initData, generateUv2);
	}

	_initByData(pathPointList, options = {}, usage, generateUv2) {
		const vertexData = generateTubeVertexData(pathPointList, options, generateUv2);

		if (vertexData && vertexData.count !== 0) {
			this.setAttribute('position', new THREE$2.BufferAttribute(new Float32Array(vertexData.position), 3).setUsage(usage || THREE$2.StaticDrawUsage));
			this.setAttribute('normal', new THREE$2.BufferAttribute(new Float32Array(vertexData.normal), 3).setUsage(usage || THREE$2.StaticDrawUsage));
			this.setAttribute('uv', new THREE$2.BufferAttribute(new Float32Array(vertexData.uv), 2).setUsage(usage || THREE$2.StaticDrawUsage));
			if (generateUv2) {
				this.setAttribute('uv2', new THREE$2.BufferAttribute(new Float32Array(vertexData.uv2), 2).setUsage(usage || THREE$2.StaticDrawUsage));
			}

			this.setIndex((vertexData.position.length / 3) > 65536 ?
				new THREE$2.Uint32BufferAttribute(vertexData.indices, 1) :
				new THREE$2.Uint16BufferAttribute(vertexData.indices, 1)
			);
		} else {
			this._initByMaxVertex(2, generateUv2);
		}
	}

	/**
	 * Update geometry by PathPointList instance
	 * @param {PathPointList} pathPointList
	 * @param {Object} options
	 * @param {Number} [options.radius=0.1]
	 * @param {Number} [options.progress=1]
	 * @param {Boolean} [options.radialSegments=8]
	 * @param {String} [options.startRad=0]
	 */
	update(pathPointList, options = {}) {
		const generateUv2 = !!this.getAttribute('uv2');

		const vertexData = generateTubeVertexData(pathPointList, options, generateUv2);

		if (vertexData) {
			this._updateAttributes(vertexData.position, vertexData.normal, vertexData.uv, generateUv2 ? vertexData.uv2 : null, vertexData.indices);
			this.drawRange.count = vertexData.count;
		} else {
			this.drawRange.count = 0;
		}
	}

}

// Vertex Data Generate Functions

function generateTubeVertexData(pathPointList, options, generateUv2 = false) {
	const radius = options.radius || 0.1;
	const progress = options.progress !== undefined ? options.progress : 1;
	const radialSegments = Math.max(2, options.radialSegments || 8);
	const startRad = options.startRad || 0;

	const circum = radius * 2 * Math.PI;
	const totalDistance = pathPointList.distance();
	const progressDistance = progress * totalDistance;
	if (progressDistance == 0) {
		return null;
	}

	let count = 0;

	// modify data
	const position = [];
	const normal = [];
	const uv = [];
	const uv2 = [];
	const indices = [];
	let verticesCount = 0;

	const normalDir = new THREE$2.Vector3();
	function addVertices(pathPoint, radius, radialSegments) {
		const first = position.length === 0;
		const uvDist = pathPoint.dist / circum;
		const uvDist2 = pathPoint.dist / totalDistance;

		for (let r = 0; r <= radialSegments; r++) {
			let _r = r;
			if (_r == radialSegments) {
				_r = 0;
			}
			normalDir.copy(pathPoint.up).applyAxisAngle(pathPoint.dir, startRad + Math.PI * 2 * _r / radialSegments).normalize();

			position.push(pathPoint.pos.x + normalDir.x * radius * pathPoint.widthScale, pathPoint.pos.y + normalDir.y * radius * pathPoint.widthScale, pathPoint.pos.z + normalDir.z * radius * pathPoint.widthScale);
			normal.push(normalDir.x, normalDir.y, normalDir.z);
			uv.push(uvDist, r / radialSegments);

			if (generateUv2) {
				uv2.push(uvDist2, r / radialSegments);
			}

			verticesCount++;
		}

		if (!first) {
			const begin1 = verticesCount - (radialSegments + 1) * 2;
			const begin2 = verticesCount - (radialSegments + 1);

			for (let i = 0; i < radialSegments; i++) {
				indices.push(
					begin2 + i, begin1 + i, begin1 + i + 1,
					begin2 + i, begin1 + i + 1, begin2 + i + 1
				);

				count += 6;
			}
		}
	}

	if (progressDistance > 0) {
		for (let i = 0; i < pathPointList.count; i++) {
			const pathPoint = pathPointList.array[i];

			if (pathPoint.dist > progressDistance) {
				const prevPoint =  pathPointList.array[i - 1];
				const lastPoint = new PathPoint();

				// linear lerp for progress
				const alpha = (progressDistance - prevPoint.dist) / (pathPoint.dist - prevPoint.dist);
				lastPoint.lerpPathPoints(prevPoint, pathPoint, alpha);

				addVertices(lastPoint, radius, radialSegments);
				break;
			} else {
				addVertices(pathPoint, radius, radialSegments);
			}
		}
	}

	return {
		position,
		normal,
		uv,
		uv2,
		indices,
		count
	};
}

var __defProp$l = Object.defineProperty;
var __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$l = (obj, key, value) => __defNormalProp$l(obj, typeof key !== "symbol" ? key + "" : key, value);
class PathTube extends THREE$2.Mesh {
  // 路径点列表实例
  // 构造函数
  constructor(_options) {
    super();
    // 声明材质类型
    __publicField$l(this, "options");
    // 选项
    __publicField$l(this, "points", []);
    // 路径点数组
    __publicField$l(this, "pathPointList");
    this.options = deepMergeRetain$1(_options, {
      points: [],
      // 默认路径点为空
      materialParams: {},
      // 默认材质参数为空
      pathTubeGeometryOptions: {
        width: 0.2
        // 默认几何体宽度
      }
    });
    const { points, materialParams } = this.options;
    this.points = points;
    const up = new THREE$2.Vector3(0, 1, 0);
    this.pathPointList = new PathPointList();
    this.setPathPointList(this.options.pathPointListOptions, true);
    this.pathPointList.set(this.points, 0.3, 10, up, true);
    this.geometry = new PathTubeGeometry(
      this.pathPointList,
      // 使用路径点列表
      this.options.pathTubeGeometryOptions
      // 传入几何体选项
    );
    this.material = new THREE$2.MeshBasicMaterial(materialParams);
  }
  // 添加路径点
  addPoint(point) {
    this.points.push(point);
    this.setPoints(this.points);
  }
  // 设置路径点列表
  setPathPointList(pathPointListOptions, inside = false) {
    if (!inside) {
      this.options.pathPointListOptions = pathPointListOptions;
    }
    const { cornerRadius, cornerSplit, close, up } = this.options.pathPointListOptions;
    this.pathPointList.set(this.points, cornerRadius, cornerSplit, up, close);
  }
  // 设置路径点
  setPoints(points) {
    this.geometry.update(this.pathPointList, this.options.pathTubeGeometryOptions);
  }
}

var html2canvas$2 = {exports: {}};

/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
var html2canvas$1 = html2canvas$2.exports;

var hasRequiredHtml2canvas;

function requireHtml2canvas () {
	if (hasRequiredHtml2canvas) return html2canvas$2.exports;
	hasRequiredHtml2canvas = 1;
	(function (module, exports) {
		(function (global, factory) {
		    module.exports = factory() ;
		}(html2canvas$1, (function () {
		    /*! *****************************************************************************
		    Copyright (c) Microsoft Corporation.

		    Permission to use, copy, modify, and/or distribute this software for any
		    purpose with or without fee is hereby granted.

		    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
		    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
		    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
		    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
		    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
		    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
		    PERFORMANCE OF THIS SOFTWARE.
		    ***************************************************************************** */
		    /* global Reflect, Promise */

		    var extendStatics = function(d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };

		    function __extends(d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    }

		    var __assign = function() {
		        __assign = Object.assign || function __assign(t) {
		            for (var s, i = 1, n = arguments.length; i < n; i++) {
		                s = arguments[i];
		                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
		            }
		            return t;
		        };
		        return __assign.apply(this, arguments);
		    };

		    function __awaiter(thisArg, _arguments, P, generator) {
		        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		        return new (P || (P = Promise))(function (resolve, reject) {
		            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		            step((generator = generator.apply(thisArg, [])).next());
		        });
		    }

		    function __generator(thisArg, body) {
		        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
		        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
		        function verb(n) { return function (v) { return step([n, v]); }; }
		        function step(op) {
		            if (f) throw new TypeError("Generator is already executing.");
		            while (_) try {
		                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
		                if (y = 0, t) op = [op[0] & 2, t.value];
		                switch (op[0]) {
		                    case 0: case 1: t = op; break;
		                    case 4: _.label++; return { value: op[1], done: false };
		                    case 5: _.label++; y = op[1]; op = [0]; continue;
		                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
		                    default:
		                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
		                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
		                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
		                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
		                        if (t[2]) _.ops.pop();
		                        _.trys.pop(); continue;
		                }
		                op = body.call(thisArg, _);
		            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
		            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
		        }
		    }

		    function __spreadArray(to, from, pack) {
		        if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
		            if (ar || !(i in from)) {
		                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
		                ar[i] = from[i];
		            }
		        }
		        return to.concat(ar || from);
		    }

		    var Bounds = /** @class */ (function () {
		        function Bounds(left, top, width, height) {
		            this.left = left;
		            this.top = top;
		            this.width = width;
		            this.height = height;
		        }
		        Bounds.prototype.add = function (x, y, w, h) {
		            return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);
		        };
		        Bounds.fromClientRect = function (context, clientRect) {
		            return new Bounds(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
		        };
		        Bounds.fromDOMRectList = function (context, domRectList) {
		            var domRect = Array.from(domRectList).find(function (rect) { return rect.width !== 0; });
		            return domRect
		                ? new Bounds(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height)
		                : Bounds.EMPTY;
		        };
		        Bounds.EMPTY = new Bounds(0, 0, 0, 0);
		        return Bounds;
		    }());
		    var parseBounds = function (context, node) {
		        return Bounds.fromClientRect(context, node.getBoundingClientRect());
		    };
		    var parseDocumentSize = function (document) {
		        var body = document.body;
		        var documentElement = document.documentElement;
		        if (!body || !documentElement) {
		            throw new Error("Unable to get document size");
		        }
		        var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
		        var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
		        return new Bounds(0, 0, width, height);
		    };

		    /*
		     * css-line-break 2.1.0 <https://github.com/niklasvh/css-line-break#readme>
		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
		     * Released under MIT License
		     */
		    var toCodePoints$1 = function (str) {
		        var codePoints = [];
		        var i = 0;
		        var length = str.length;
		        while (i < length) {
		            var value = str.charCodeAt(i++);
		            if (value >= 0xd800 && value <= 0xdbff && i < length) {
		                var extra = str.charCodeAt(i++);
		                if ((extra & 0xfc00) === 0xdc00) {
		                    codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
		                }
		                else {
		                    codePoints.push(value);
		                    i--;
		                }
		            }
		            else {
		                codePoints.push(value);
		            }
		        }
		        return codePoints;
		    };
		    var fromCodePoint$1 = function () {
		        var codePoints = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            codePoints[_i] = arguments[_i];
		        }
		        if (String.fromCodePoint) {
		            return String.fromCodePoint.apply(String, codePoints);
		        }
		        var length = codePoints.length;
		        if (!length) {
		            return '';
		        }
		        var codeUnits = [];
		        var index = -1;
		        var result = '';
		        while (++index < length) {
		            var codePoint = codePoints[index];
		            if (codePoint <= 0xffff) {
		                codeUnits.push(codePoint);
		            }
		            else {
		                codePoint -= 0x10000;
		                codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
		            }
		            if (index + 1 === length || codeUnits.length > 0x4000) {
		                result += String.fromCharCode.apply(String, codeUnits);
		                codeUnits.length = 0;
		            }
		        }
		        return result;
		    };
		    var chars$2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		    // Use a lookup table to find the index.
		    var lookup$2 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
		    for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
		        lookup$2[chars$2.charCodeAt(i$2)] = i$2;
		    }

		    /*
		     * utrie 1.0.2 <https://github.com/niklasvh/utrie>
		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
		     * Released under MIT License
		     */
		    var chars$1$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		    // Use a lookup table to find the index.
		    var lookup$1$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
		    for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
		        lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
		    }
		    var decode$1 = function (base64) {
		        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
		        if (base64[base64.length - 1] === '=') {
		            bufferLength--;
		            if (base64[base64.length - 2] === '=') {
		                bufferLength--;
		            }
		        }
		        var buffer = typeof ArrayBuffer !== 'undefined' &&
		            typeof Uint8Array !== 'undefined' &&
		            typeof Uint8Array.prototype.slice !== 'undefined'
		            ? new ArrayBuffer(bufferLength)
		            : new Array(bufferLength);
		        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
		        for (i = 0; i < len; i += 4) {
		            encoded1 = lookup$1$1[base64.charCodeAt(i)];
		            encoded2 = lookup$1$1[base64.charCodeAt(i + 1)];
		            encoded3 = lookup$1$1[base64.charCodeAt(i + 2)];
		            encoded4 = lookup$1$1[base64.charCodeAt(i + 3)];
		            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
		            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
		            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
		        }
		        return buffer;
		    };
		    var polyUint16Array$1 = function (buffer) {
		        var length = buffer.length;
		        var bytes = [];
		        for (var i = 0; i < length; i += 2) {
		            bytes.push((buffer[i + 1] << 8) | buffer[i]);
		        }
		        return bytes;
		    };
		    var polyUint32Array$1 = function (buffer) {
		        var length = buffer.length;
		        var bytes = [];
		        for (var i = 0; i < length; i += 4) {
		            bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
		        }
		        return bytes;
		    };

		    /** Shift size for getting the index-2 table offset. */
		    var UTRIE2_SHIFT_2$1 = 5;
		    /** Shift size for getting the index-1 table offset. */
		    var UTRIE2_SHIFT_1$1 = 6 + 5;
		    /**
		     * Shift size for shifting left the index array values.
		     * Increases possible data size with 16-bit index values at the cost
		     * of compactability.
		     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
		     */
		    var UTRIE2_INDEX_SHIFT$1 = 2;
		    /**
		     * Difference between the two shift sizes,
		     * for getting an index-1 offset from an index-2 offset. 6=11-5
		     */
		    var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
		    /**
		     * The part of the index-2 table for U+D800..U+DBFF stores values for
		     * lead surrogate code _units_ not code _points_.
		     * Values for lead surrogate code _points_ are indexed with this portion of the table.
		     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
		     */
		    var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 0x10000 >> UTRIE2_SHIFT_2$1;
		    /** Number of entries in a data block. 32=0x20 */
		    var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
		    /** Mask for getting the lower bits for the in-data-block offset. */
		    var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
		    var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 0x400 >> UTRIE2_SHIFT_2$1;
		    /** Count the lengths of both BMP pieces. 2080=0x820 */
		    var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
		    /**
		     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
		     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
		     */
		    var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
		    var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
		    /**
		     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
		     * Variable length, for code points up to highStart, where the last single-value range starts.
		     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
		     * (For 0x100000 supplementary code points U+10000..U+10ffff.)
		     *
		     * The part of the index-2 table for supplementary code points starts
		     * after this index-1 table.
		     *
		     * Both the index-1 table and the following part of the index-2 table
		     * are omitted completely if there is only BMP data.
		     */
		    var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
		    /**
		     * Number of index-1 entries for the BMP. 32=0x20
		     * This part of the index-1 table is omitted from the serialized form.
		     */
		    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 0x10000 >> UTRIE2_SHIFT_1$1;
		    /** Number of entries in an index-2 block. 64=0x40 */
		    var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
		    /** Mask for getting the lower bits for the in-index-2-block offset. */
		    var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
		    var slice16$1 = function (view, start, end) {
		        if (view.slice) {
		            return view.slice(start, end);
		        }
		        return new Uint16Array(Array.prototype.slice.call(view, start, end));
		    };
		    var slice32$1 = function (view, start, end) {
		        if (view.slice) {
		            return view.slice(start, end);
		        }
		        return new Uint32Array(Array.prototype.slice.call(view, start, end));
		    };
		    var createTrieFromBase64$1 = function (base64, _byteLength) {
		        var buffer = decode$1(base64);
		        var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
		        var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
		        var headerLength = 24;
		        var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
		        var data = view32[5] === 2
		            ? slice16$1(view16, (headerLength + view32[4]) / 2)
		            : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
		        return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
		    };
		    var Trie$1 = /** @class */ (function () {
		        function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
		            this.initialValue = initialValue;
		            this.errorValue = errorValue;
		            this.highStart = highStart;
		            this.highValueIndex = highValueIndex;
		            this.index = index;
		            this.data = data;
		        }
		        /**
		         * Get the value for a code point as stored in the Trie.
		         *
		         * @param codePoint the code point
		         * @return the value
		         */
		        Trie.prototype.get = function (codePoint) {
		            var ix;
		            if (codePoint >= 0) {
		                if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
		                    // Ordinary BMP code point, excluding leading surrogates.
		                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
		                    // 16 bit data is stored in the index array itself.
		                    ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
		                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
		                    return this.data[ix];
		                }
		                if (codePoint <= 0xffff) {
		                    // Lead Surrogate Code Point.  A Separate index section is stored for
		                    // lead surrogate code units and code points.
		                    //   The main index has the code unit data.
		                    //   For this function, we need the code point data.
		                    // Note: this expression could be refactored for slightly improved efficiency, but
		                    //       surrogate code points will be so rare in practice that it's not worth it.
		                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2$1)];
		                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
		                    return this.data[ix];
		                }
		                if (codePoint < this.highStart) {
		                    // Supplemental code point, use two-level lookup.
		                    ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
		                    ix = this.index[ix];
		                    ix += (codePoint >> UTRIE2_SHIFT_2$1) & UTRIE2_INDEX_2_MASK$1;
		                    ix = this.index[ix];
		                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
		                    return this.data[ix];
		                }
		                if (codePoint <= 0x10ffff) {
		                    return this.data[this.highValueIndex];
		                }
		            }
		            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
		            return this.errorValue;
		        };
		        return Trie;
		    }());

		    /*
		     * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
		     * Released under MIT License
		     */
		    var chars$3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		    // Use a lookup table to find the index.
		    var lookup$3 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
		    for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
		        lookup$3[chars$3.charCodeAt(i$3)] = i$3;
		    }

		    var base64$1 = 'KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==';

		    var LETTER_NUMBER_MODIFIER = 50;
		    // Non-tailorable Line Breaking Classes
		    var BK = 1; //  Cause a line break (after)
		    var CR$1 = 2; //  Cause a line break (after), except between CR and LF
		    var LF$1 = 3; //  Cause a line break (after)
		    var CM = 4; //  Prohibit a line break between the character and the preceding character
		    var NL = 5; //  Cause a line break (after)
		    var WJ = 7; //  Prohibit line breaks before and after
		    var ZW = 8; //  Provide a break opportunity
		    var GL = 9; //  Prohibit line breaks before and after
		    var SP = 10; // Enable indirect line breaks
		    var ZWJ$1 = 11; // Prohibit line breaks within joiner sequences
		    // Break Opportunities
		    var B2 = 12; //  Provide a line break opportunity before and after the character
		    var BA = 13; //  Generally provide a line break opportunity after the character
		    var BB = 14; //  Generally provide a line break opportunity before the character
		    var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
		    var CB = 16; //   Provide a line break opportunity contingent on additional information
		    // Characters Prohibiting Certain Breaks
		    var CL = 17; //  Prohibit line breaks before
		    var CP = 18; //  Prohibit line breaks before
		    var EX = 19; //  Prohibit line breaks before
		    var IN = 20; //  Allow only indirect line breaks between pairs
		    var NS = 21; //  Allow only indirect line breaks before
		    var OP = 22; //  Prohibit line breaks after
		    var QU = 23; //  Act like they are both opening and closing
		    // Numeric Context
		    var IS = 24; //  Prevent breaks after any and before numeric
		    var NU = 25; //  Form numeric expressions for line breaking purposes
		    var PO = 26; //  Do not break following a numeric expression
		    var PR = 27; //  Do not break in front of a numeric expression
		    var SY = 28; //  Prevent a break before; and allow a break after
		    // Other Characters
		    var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
		    var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
		    var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
		    var EB = 32; //  Do not break from following Emoji Modifier
		    var EM = 33; //  Do not break from preceding Emoji Base
		    var H2 = 34; //  Form Korean syllable blocks
		    var H3 = 35; //  Form Korean syllable blocks
		    var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
		    var ID = 37; //  Break before or after; except in some numeric context
		    var JL = 38; //  Form Korean syllable blocks
		    var JV = 39; //  Form Korean syllable blocks
		    var JT = 40; //  Form Korean syllable blocks
		    var RI$1 = 41; //  Keep pairs together. For pairs; break before and after other classes
		    var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
		    var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions
		    var ea_OP = [0x2329, 0xff08];
		    var BREAK_MANDATORY = '!';
		    var BREAK_NOT_ALLOWED$1 = '×';
		    var BREAK_ALLOWED$1 = '÷';
		    var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
		    var ALPHABETICS = [AL, HL];
		    var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
		    var SPACE$1 = [SP, ZW];
		    var PREFIX_POSTFIX = [PR, PO];
		    var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
		    var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
		    var HYPHEN = [HY, BA];
		    var codePointsToCharacterClasses = function (codePoints, lineBreak) {
		        if (lineBreak === void 0) { lineBreak = 'strict'; }
		        var types = [];
		        var indices = [];
		        var categories = [];
		        codePoints.forEach(function (codePoint, index) {
		            var classType = UnicodeTrie$1.get(codePoint);
		            if (classType > LETTER_NUMBER_MODIFIER) {
		                categories.push(true);
		                classType -= LETTER_NUMBER_MODIFIER;
		            }
		            else {
		                categories.push(false);
		            }
		            if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
		                // U+2010, – U+2013, 〜 U+301C, ゠ U+30A0
		                if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
		                    indices.push(index);
		                    return types.push(CB);
		                }
		            }
		            if (classType === CM || classType === ZWJ$1) {
		                // LB10 Treat any remaining combining mark or ZWJ as AL.
		                if (index === 0) {
		                    indices.push(index);
		                    return types.push(AL);
		                }
		                // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
		                // the base character in all of the following rules. Treat ZWJ as if it were CM.
		                var prev = types[index - 1];
		                if (LINE_BREAKS.indexOf(prev) === -1) {
		                    indices.push(indices[index - 1]);
		                    return types.push(prev);
		                }
		                indices.push(index);
		                return types.push(AL);
		            }
		            indices.push(index);
		            if (classType === CJ) {
		                return types.push(lineBreak === 'strict' ? NS : ID);
		            }
		            if (classType === SA) {
		                return types.push(AL);
		            }
		            if (classType === AI) {
		                return types.push(AL);
		            }
		            // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
		            // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
		            // to take into account the actual line breaking properties for these characters.
		            if (classType === XX) {
		                if ((codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd)) {
		                    return types.push(ID);
		                }
		                else {
		                    return types.push(AL);
		                }
		            }
		            types.push(classType);
		        });
		        return [indices, types, categories];
		    };
		    var isAdjacentWithSpaceIgnored = function (a, b, currentIndex, classTypes) {
		        var current = classTypes[currentIndex];
		        if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
		            var i = currentIndex;
		            while (i <= classTypes.length) {
		                i++;
		                var next = classTypes[i];
		                if (next === b) {
		                    return true;
		                }
		                if (next !== SP) {
		                    break;
		                }
		            }
		        }
		        if (current === SP) {
		            var i = currentIndex;
		            while (i > 0) {
		                i--;
		                var prev = classTypes[i];
		                if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
		                    var n = currentIndex;
		                    while (n <= classTypes.length) {
		                        n++;
		                        var next = classTypes[n];
		                        if (next === b) {
		                            return true;
		                        }
		                        if (next !== SP) {
		                            break;
		                        }
		                    }
		                }
		                if (prev !== SP) {
		                    break;
		                }
		            }
		        }
		        return false;
		    };
		    var previousNonSpaceClassType = function (currentIndex, classTypes) {
		        var i = currentIndex;
		        while (i >= 0) {
		            var type = classTypes[i];
		            if (type === SP) {
		                i--;
		            }
		            else {
		                return type;
		            }
		        }
		        return 0;
		    };
		    var _lineBreakAtIndex = function (codePoints, classTypes, indicies, index, forbiddenBreaks) {
		        if (indicies[index] === 0) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        var currentIndex = index - 1;
		        if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        var beforeIndex = currentIndex - 1;
		        var afterIndex = currentIndex + 1;
		        var current = classTypes[currentIndex];
		        // LB4 Always break after hard line breaks.
		        // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
		        var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
		        var next = classTypes[afterIndex];
		        if (current === CR$1 && next === LF$1) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
		            return BREAK_MANDATORY;
		        }
		        // LB6 Do not break before hard line breaks.
		        if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB7 Do not break before spaces or zero width space.
		        if (SPACE$1.indexOf(next) !== -1) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
		        if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
		            return BREAK_ALLOWED$1;
		        }
		        // LB8a Do not break after a zero width joiner.
		        if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // zwj emojis
		        if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB11 Do not break before or after Word joiner and related characters.
		        if (current === WJ || next === WJ) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB12 Do not break after NBSP and related characters.
		        if (current === GL) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
		        if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB13 Do not break before ‘]’ or ‘!’ or ‘;’ or ‘/’, even after spaces.
		        if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB14 Do not break after ‘[’, even after spaces.
		        if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB15 Do not break within ‘”[’, even with intervening spaces.
		        if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
		        if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB17 Do not break within ‘——’, even with intervening spaces.
		        if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB18 Break after spaces.
		        if (current === SP) {
		            return BREAK_ALLOWED$1;
		        }
		        // LB19 Do not break before or after quotation marks, such as ‘ ” ’.
		        if (current === QU || next === QU) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB20 Break before and after unresolved CB.
		        if (next === CB || current === CB) {
		            return BREAK_ALLOWED$1;
		        }
		        // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
		        if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB21a Don't break after Hebrew + Hyphen.
		        if (before === HL && HYPHEN.indexOf(current) !== -1) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB21b Don’t break between Solidus and Hebrew letters.
		        if (current === SY && next === HL) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB22 Do not break before ellipsis.
		        if (next === IN) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB23 Do not break between digits and letters.
		        if ((ALPHABETICS.indexOf(next) !== -1 && current === NU) || (ALPHABETICS.indexOf(current) !== -1 && next === NU)) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
		        if ((current === PR && [ID, EB, EM].indexOf(next) !== -1) ||
		            ([ID, EB, EM].indexOf(current) !== -1 && next === PO)) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
		        if ((ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1) ||
		            (PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1)) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB25 Do not break between the following pairs of classes relevant to numbers:
		        if (
		        // (PR | PO) × ( OP | HY )? NU
		        ([PR, PO].indexOf(current) !== -1 &&
		            (next === NU || ([OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU))) ||
		            // ( OP | HY ) × NU
		            ([OP, HY].indexOf(current) !== -1 && next === NU) ||
		            // NU ×	(NU | SY | IS)
		            (current === NU && [NU, SY, IS].indexOf(next) !== -1)) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // NU (NU | SY | IS)* × (NU | SY | IS | CL | CP)
		        if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
		            var prevIndex = currentIndex;
		            while (prevIndex >= 0) {
		                var type = classTypes[prevIndex];
		                if (type === NU) {
		                    return BREAK_NOT_ALLOWED$1;
		                }
		                else if ([SY, IS].indexOf(type) !== -1) {
		                    prevIndex--;
		                }
		                else {
		                    break;
		                }
		            }
		        }
		        // NU (NU | SY | IS)* (CL | CP)? × (PO | PR))
		        if ([PR, PO].indexOf(next) !== -1) {
		            var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
		            while (prevIndex >= 0) {
		                var type = classTypes[prevIndex];
		                if (type === NU) {
		                    return BREAK_NOT_ALLOWED$1;
		                }
		                else if ([SY, IS].indexOf(type) !== -1) {
		                    prevIndex--;
		                }
		                else {
		                    break;
		                }
		            }
		        }
		        // LB26 Do not break a Korean syllable.
		        if ((JL === current && [JL, JV, H2, H3].indexOf(next) !== -1) ||
		            ([JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1) ||
		            ([JT, H3].indexOf(current) !== -1 && next === JT)) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB27 Treat a Korean Syllable Block the same as ID.
		        if ((KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1) ||
		            (KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR)) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB28 Do not break between alphabetics (“at”).
		        if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB29 Do not break between numeric punctuation and alphabetics (“e.g.”).
		        if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
		        if ((ALPHABETICS.concat(NU).indexOf(current) !== -1 &&
		            next === OP &&
		            ea_OP.indexOf(codePoints[afterIndex]) === -1) ||
		            (ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP)) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
		        // indicators preceding the position of the break.
		        if (current === RI$1 && next === RI$1) {
		            var i = indicies[currentIndex];
		            var count = 1;
		            while (i > 0) {
		                i--;
		                if (classTypes[i] === RI$1) {
		                    count++;
		                }
		                else {
		                    break;
		                }
		            }
		            if (count % 2 !== 0) {
		                return BREAK_NOT_ALLOWED$1;
		            }
		        }
		        // LB30b Do not break between an emoji base and an emoji modifier.
		        if (current === EB && next === EM) {
		            return BREAK_NOT_ALLOWED$1;
		        }
		        return BREAK_ALLOWED$1;
		    };
		    var cssFormattedClasses = function (codePoints, options) {
		        if (!options) {
		            options = { lineBreak: 'normal', wordBreak: 'normal' };
		        }
		        var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];
		        if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
		            classTypes = classTypes.map(function (type) { return ([NU, AL, SA].indexOf(type) !== -1 ? ID : type); });
		        }
		        var forbiddenBreakpoints = options.wordBreak === 'keep-all'
		            ? isLetterNumber.map(function (letterNumber, i) {
		                return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
		            })
		            : undefined;
		        return [indicies, classTypes, forbiddenBreakpoints];
		    };
		    var Break = /** @class */ (function () {
		        function Break(codePoints, lineBreak, start, end) {
		            this.codePoints = codePoints;
		            this.required = lineBreak === BREAK_MANDATORY;
		            this.start = start;
		            this.end = end;
		        }
		        Break.prototype.slice = function () {
		            return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
		        };
		        return Break;
		    }());
		    var LineBreaker = function (str, options) {
		        var codePoints = toCodePoints$1(str);
		        var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];
		        var length = codePoints.length;
		        var lastEnd = 0;
		        var nextIndex = 0;
		        return {
		            next: function () {
		                if (nextIndex >= length) {
		                    return { done: true, value: null };
		                }
		                var lineBreak = BREAK_NOT_ALLOWED$1;
		                while (nextIndex < length &&
		                    (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===
		                        BREAK_NOT_ALLOWED$1) { }
		                if (lineBreak !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
		                    var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
		                    lastEnd = nextIndex;
		                    return { value: value, done: false };
		                }
		                return { done: true, value: null };
		            },
		        };
		    };

		    // https://www.w3.org/TR/css-syntax-3
		    var FLAG_UNRESTRICTED = 1 << 0;
		    var FLAG_ID = 1 << 1;
		    var FLAG_INTEGER = 1 << 2;
		    var FLAG_NUMBER = 1 << 3;
		    var LINE_FEED = 0x000a;
		    var SOLIDUS = 0x002f;
		    var REVERSE_SOLIDUS = 0x005c;
		    var CHARACTER_TABULATION = 0x0009;
		    var SPACE = 0x0020;
		    var QUOTATION_MARK = 0x0022;
		    var EQUALS_SIGN = 0x003d;
		    var NUMBER_SIGN = 0x0023;
		    var DOLLAR_SIGN = 0x0024;
		    var PERCENTAGE_SIGN = 0x0025;
		    var APOSTROPHE = 0x0027;
		    var LEFT_PARENTHESIS = 0x0028;
		    var RIGHT_PARENTHESIS = 0x0029;
		    var LOW_LINE = 0x005f;
		    var HYPHEN_MINUS = 0x002d;
		    var EXCLAMATION_MARK = 0x0021;
		    var LESS_THAN_SIGN = 0x003c;
		    var GREATER_THAN_SIGN = 0x003e;
		    var COMMERCIAL_AT = 0x0040;
		    var LEFT_SQUARE_BRACKET = 0x005b;
		    var RIGHT_SQUARE_BRACKET = 0x005d;
		    var CIRCUMFLEX_ACCENT = 0x003d;
		    var LEFT_CURLY_BRACKET = 0x007b;
		    var QUESTION_MARK = 0x003f;
		    var RIGHT_CURLY_BRACKET = 0x007d;
		    var VERTICAL_LINE = 0x007c;
		    var TILDE = 0x007e;
		    var CONTROL = 0x0080;
		    var REPLACEMENT_CHARACTER = 0xfffd;
		    var ASTERISK = 0x002a;
		    var PLUS_SIGN = 0x002b;
		    var COMMA = 0x002c;
		    var COLON = 0x003a;
		    var SEMICOLON = 0x003b;
		    var FULL_STOP = 0x002e;
		    var NULL = 0x0000;
		    var BACKSPACE = 0x0008;
		    var LINE_TABULATION = 0x000b;
		    var SHIFT_OUT = 0x000e;
		    var INFORMATION_SEPARATOR_ONE = 0x001f;
		    var DELETE = 0x007f;
		    var EOF = -1;
		    var ZERO = 0x0030;
		    var a = 0x0061;
		    var e = 0x0065;
		    var f = 0x0066;
		    var u = 0x0075;
		    var z = 0x007a;
		    var A = 0x0041;
		    var E = 0x0045;
		    var F = 0x0046;
		    var U = 0x0055;
		    var Z = 0x005a;
		    var isDigit = function (codePoint) { return codePoint >= ZERO && codePoint <= 0x0039; };
		    var isSurrogateCodePoint = function (codePoint) { return codePoint >= 0xd800 && codePoint <= 0xdfff; };
		    var isHex = function (codePoint) {
		        return isDigit(codePoint) || (codePoint >= A && codePoint <= F) || (codePoint >= a && codePoint <= f);
		    };
		    var isLowerCaseLetter = function (codePoint) { return codePoint >= a && codePoint <= z; };
		    var isUpperCaseLetter = function (codePoint) { return codePoint >= A && codePoint <= Z; };
		    var isLetter = function (codePoint) { return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint); };
		    var isNonASCIICodePoint = function (codePoint) { return codePoint >= CONTROL; };
		    var isWhiteSpace = function (codePoint) {
		        return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
		    };
		    var isNameStartCodePoint = function (codePoint) {
		        return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
		    };
		    var isNameCodePoint = function (codePoint) {
		        return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
		    };
		    var isNonPrintableCodePoint = function (codePoint) {
		        return ((codePoint >= NULL && codePoint <= BACKSPACE) ||
		            codePoint === LINE_TABULATION ||
		            (codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE) ||
		            codePoint === DELETE);
		    };
		    var isValidEscape = function (c1, c2) {
		        if (c1 !== REVERSE_SOLIDUS) {
		            return false;
		        }
		        return c2 !== LINE_FEED;
		    };
		    var isIdentifierStart = function (c1, c2, c3) {
		        if (c1 === HYPHEN_MINUS) {
		            return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
		        }
		        else if (isNameStartCodePoint(c1)) {
		            return true;
		        }
		        else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
		            return true;
		        }
		        return false;
		    };
		    var isNumberStart = function (c1, c2, c3) {
		        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
		            if (isDigit(c2)) {
		                return true;
		            }
		            return c2 === FULL_STOP && isDigit(c3);
		        }
		        if (c1 === FULL_STOP) {
		            return isDigit(c2);
		        }
		        return isDigit(c1);
		    };
		    var stringToNumber = function (codePoints) {
		        var c = 0;
		        var sign = 1;
		        if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
		            if (codePoints[c] === HYPHEN_MINUS) {
		                sign = -1;
		            }
		            c++;
		        }
		        var integers = [];
		        while (isDigit(codePoints[c])) {
		            integers.push(codePoints[c++]);
		        }
		        var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
		        if (codePoints[c] === FULL_STOP) {
		            c++;
		        }
		        var fraction = [];
		        while (isDigit(codePoints[c])) {
		            fraction.push(codePoints[c++]);
		        }
		        var fracd = fraction.length;
		        var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
		        if (codePoints[c] === E || codePoints[c] === e) {
		            c++;
		        }
		        var expsign = 1;
		        if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
		            if (codePoints[c] === HYPHEN_MINUS) {
		                expsign = -1;
		            }
		            c++;
		        }
		        var exponent = [];
		        while (isDigit(codePoints[c])) {
		            exponent.push(codePoints[c++]);
		        }
		        var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
		        return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
		    };
		    var LEFT_PARENTHESIS_TOKEN = {
		        type: 2 /* LEFT_PARENTHESIS_TOKEN */
		    };
		    var RIGHT_PARENTHESIS_TOKEN = {
		        type: 3 /* RIGHT_PARENTHESIS_TOKEN */
		    };
		    var COMMA_TOKEN = { type: 4 /* COMMA_TOKEN */ };
		    var SUFFIX_MATCH_TOKEN = { type: 13 /* SUFFIX_MATCH_TOKEN */ };
		    var PREFIX_MATCH_TOKEN = { type: 8 /* PREFIX_MATCH_TOKEN */ };
		    var COLUMN_TOKEN = { type: 21 /* COLUMN_TOKEN */ };
		    var DASH_MATCH_TOKEN = { type: 9 /* DASH_MATCH_TOKEN */ };
		    var INCLUDE_MATCH_TOKEN = { type: 10 /* INCLUDE_MATCH_TOKEN */ };
		    var LEFT_CURLY_BRACKET_TOKEN = {
		        type: 11 /* LEFT_CURLY_BRACKET_TOKEN */
		    };
		    var RIGHT_CURLY_BRACKET_TOKEN = {
		        type: 12 /* RIGHT_CURLY_BRACKET_TOKEN */
		    };
		    var SUBSTRING_MATCH_TOKEN = { type: 14 /* SUBSTRING_MATCH_TOKEN */ };
		    var BAD_URL_TOKEN = { type: 23 /* BAD_URL_TOKEN */ };
		    var BAD_STRING_TOKEN = { type: 1 /* BAD_STRING_TOKEN */ };
		    var CDO_TOKEN = { type: 25 /* CDO_TOKEN */ };
		    var CDC_TOKEN = { type: 24 /* CDC_TOKEN */ };
		    var COLON_TOKEN = { type: 26 /* COLON_TOKEN */ };
		    var SEMICOLON_TOKEN = { type: 27 /* SEMICOLON_TOKEN */ };
		    var LEFT_SQUARE_BRACKET_TOKEN = {
		        type: 28 /* LEFT_SQUARE_BRACKET_TOKEN */
		    };
		    var RIGHT_SQUARE_BRACKET_TOKEN = {
		        type: 29 /* RIGHT_SQUARE_BRACKET_TOKEN */
		    };
		    var WHITESPACE_TOKEN = { type: 31 /* WHITESPACE_TOKEN */ };
		    var EOF_TOKEN = { type: 32 /* EOF_TOKEN */ };
		    var Tokenizer = /** @class */ (function () {
		        function Tokenizer() {
		            this._value = [];
		        }
		        Tokenizer.prototype.write = function (chunk) {
		            this._value = this._value.concat(toCodePoints$1(chunk));
		        };
		        Tokenizer.prototype.read = function () {
		            var tokens = [];
		            var token = this.consumeToken();
		            while (token !== EOF_TOKEN) {
		                tokens.push(token);
		                token = this.consumeToken();
		            }
		            return tokens;
		        };
		        Tokenizer.prototype.consumeToken = function () {
		            var codePoint = this.consumeCodePoint();
		            switch (codePoint) {
		                case QUOTATION_MARK:
		                    return this.consumeStringToken(QUOTATION_MARK);
		                case NUMBER_SIGN:
		                    var c1 = this.peekCodePoint(0);
		                    var c2 = this.peekCodePoint(1);
		                    var c3 = this.peekCodePoint(2);
		                    if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
		                        var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
		                        var value = this.consumeName();
		                        return { type: 5 /* HASH_TOKEN */, value: value, flags: flags };
		                    }
		                    break;
		                case DOLLAR_SIGN:
		                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
		                        this.consumeCodePoint();
		                        return SUFFIX_MATCH_TOKEN;
		                    }
		                    break;
		                case APOSTROPHE:
		                    return this.consumeStringToken(APOSTROPHE);
		                case LEFT_PARENTHESIS:
		                    return LEFT_PARENTHESIS_TOKEN;
		                case RIGHT_PARENTHESIS:
		                    return RIGHT_PARENTHESIS_TOKEN;
		                case ASTERISK:
		                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
		                        this.consumeCodePoint();
		                        return SUBSTRING_MATCH_TOKEN;
		                    }
		                    break;
		                case PLUS_SIGN:
		                    if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
		                        this.reconsumeCodePoint(codePoint);
		                        return this.consumeNumericToken();
		                    }
		                    break;
		                case COMMA:
		                    return COMMA_TOKEN;
		                case HYPHEN_MINUS:
		                    var e1 = codePoint;
		                    var e2 = this.peekCodePoint(0);
		                    var e3 = this.peekCodePoint(1);
		                    if (isNumberStart(e1, e2, e3)) {
		                        this.reconsumeCodePoint(codePoint);
		                        return this.consumeNumericToken();
		                    }
		                    if (isIdentifierStart(e1, e2, e3)) {
		                        this.reconsumeCodePoint(codePoint);
		                        return this.consumeIdentLikeToken();
		                    }
		                    if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
		                        this.consumeCodePoint();
		                        this.consumeCodePoint();
		                        return CDC_TOKEN;
		                    }
		                    break;
		                case FULL_STOP:
		                    if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
		                        this.reconsumeCodePoint(codePoint);
		                        return this.consumeNumericToken();
		                    }
		                    break;
		                case SOLIDUS:
		                    if (this.peekCodePoint(0) === ASTERISK) {
		                        this.consumeCodePoint();
		                        while (true) {
		                            var c = this.consumeCodePoint();
		                            if (c === ASTERISK) {
		                                c = this.consumeCodePoint();
		                                if (c === SOLIDUS) {
		                                    return this.consumeToken();
		                                }
		                            }
		                            if (c === EOF) {
		                                return this.consumeToken();
		                            }
		                        }
		                    }
		                    break;
		                case COLON:
		                    return COLON_TOKEN;
		                case SEMICOLON:
		                    return SEMICOLON_TOKEN;
		                case LESS_THAN_SIGN:
		                    if (this.peekCodePoint(0) === EXCLAMATION_MARK &&
		                        this.peekCodePoint(1) === HYPHEN_MINUS &&
		                        this.peekCodePoint(2) === HYPHEN_MINUS) {
		                        this.consumeCodePoint();
		                        this.consumeCodePoint();
		                        return CDO_TOKEN;
		                    }
		                    break;
		                case COMMERCIAL_AT:
		                    var a1 = this.peekCodePoint(0);
		                    var a2 = this.peekCodePoint(1);
		                    var a3 = this.peekCodePoint(2);
		                    if (isIdentifierStart(a1, a2, a3)) {
		                        var value = this.consumeName();
		                        return { type: 7 /* AT_KEYWORD_TOKEN */, value: value };
		                    }
		                    break;
		                case LEFT_SQUARE_BRACKET:
		                    return LEFT_SQUARE_BRACKET_TOKEN;
		                case REVERSE_SOLIDUS:
		                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {
		                        this.reconsumeCodePoint(codePoint);
		                        return this.consumeIdentLikeToken();
		                    }
		                    break;
		                case RIGHT_SQUARE_BRACKET:
		                    return RIGHT_SQUARE_BRACKET_TOKEN;
		                case CIRCUMFLEX_ACCENT:
		                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
		                        this.consumeCodePoint();
		                        return PREFIX_MATCH_TOKEN;
		                    }
		                    break;
		                case LEFT_CURLY_BRACKET:
		                    return LEFT_CURLY_BRACKET_TOKEN;
		                case RIGHT_CURLY_BRACKET:
		                    return RIGHT_CURLY_BRACKET_TOKEN;
		                case u:
		                case U:
		                    var u1 = this.peekCodePoint(0);
		                    var u2 = this.peekCodePoint(1);
		                    if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
		                        this.consumeCodePoint();
		                        this.consumeUnicodeRangeToken();
		                    }
		                    this.reconsumeCodePoint(codePoint);
		                    return this.consumeIdentLikeToken();
		                case VERTICAL_LINE:
		                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
		                        this.consumeCodePoint();
		                        return DASH_MATCH_TOKEN;
		                    }
		                    if (this.peekCodePoint(0) === VERTICAL_LINE) {
		                        this.consumeCodePoint();
		                        return COLUMN_TOKEN;
		                    }
		                    break;
		                case TILDE:
		                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
		                        this.consumeCodePoint();
		                        return INCLUDE_MATCH_TOKEN;
		                    }
		                    break;
		                case EOF:
		                    return EOF_TOKEN;
		            }
		            if (isWhiteSpace(codePoint)) {
		                this.consumeWhiteSpace();
		                return WHITESPACE_TOKEN;
		            }
		            if (isDigit(codePoint)) {
		                this.reconsumeCodePoint(codePoint);
		                return this.consumeNumericToken();
		            }
		            if (isNameStartCodePoint(codePoint)) {
		                this.reconsumeCodePoint(codePoint);
		                return this.consumeIdentLikeToken();
		            }
		            return { type: 6 /* DELIM_TOKEN */, value: fromCodePoint$1(codePoint) };
		        };
		        Tokenizer.prototype.consumeCodePoint = function () {
		            var value = this._value.shift();
		            return typeof value === 'undefined' ? -1 : value;
		        };
		        Tokenizer.prototype.reconsumeCodePoint = function (codePoint) {
		            this._value.unshift(codePoint);
		        };
		        Tokenizer.prototype.peekCodePoint = function (delta) {
		            if (delta >= this._value.length) {
		                return -1;
		            }
		            return this._value[delta];
		        };
		        Tokenizer.prototype.consumeUnicodeRangeToken = function () {
		            var digits = [];
		            var codePoint = this.consumeCodePoint();
		            while (isHex(codePoint) && digits.length < 6) {
		                digits.push(codePoint);
		                codePoint = this.consumeCodePoint();
		            }
		            var questionMarks = false;
		            while (codePoint === QUESTION_MARK && digits.length < 6) {
		                digits.push(codePoint);
		                codePoint = this.consumeCodePoint();
		                questionMarks = true;
		            }
		            if (questionMarks) {
		                var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? ZERO : digit); })), 16);
		                var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? F : digit); })), 16);
		                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start_1, end: end };
		            }
		            var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
		            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
		                this.consumeCodePoint();
		                codePoint = this.consumeCodePoint();
		                var endDigits = [];
		                while (isHex(codePoint) && endDigits.length < 6) {
		                    endDigits.push(codePoint);
		                    codePoint = this.consumeCodePoint();
		                }
		                var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
		                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: end };
		            }
		            else {
		                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: start };
		            }
		        };
		        Tokenizer.prototype.consumeIdentLikeToken = function () {
		            var value = this.consumeName();
		            if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
		                this.consumeCodePoint();
		                return this.consumeUrlToken();
		            }
		            else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
		                this.consumeCodePoint();
		                return { type: 19 /* FUNCTION_TOKEN */, value: value };
		            }
		            return { type: 20 /* IDENT_TOKEN */, value: value };
		        };
		        Tokenizer.prototype.consumeUrlToken = function () {
		            var value = [];
		            this.consumeWhiteSpace();
		            if (this.peekCodePoint(0) === EOF) {
		                return { type: 22 /* URL_TOKEN */, value: '' };
		            }
		            var next = this.peekCodePoint(0);
		            if (next === APOSTROPHE || next === QUOTATION_MARK) {
		                var stringToken = this.consumeStringToken(this.consumeCodePoint());
		                if (stringToken.type === 0 /* STRING_TOKEN */) {
		                    this.consumeWhiteSpace();
		                    if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
		                        this.consumeCodePoint();
		                        return { type: 22 /* URL_TOKEN */, value: stringToken.value };
		                    }
		                }
		                this.consumeBadUrlRemnants();
		                return BAD_URL_TOKEN;
		            }
		            while (true) {
		                var codePoint = this.consumeCodePoint();
		                if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
		                    return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
		                }
		                else if (isWhiteSpace(codePoint)) {
		                    this.consumeWhiteSpace();
		                    if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
		                        this.consumeCodePoint();
		                        return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
		                    }
		                    this.consumeBadUrlRemnants();
		                    return BAD_URL_TOKEN;
		                }
		                else if (codePoint === QUOTATION_MARK ||
		                    codePoint === APOSTROPHE ||
		                    codePoint === LEFT_PARENTHESIS ||
		                    isNonPrintableCodePoint(codePoint)) {
		                    this.consumeBadUrlRemnants();
		                    return BAD_URL_TOKEN;
		                }
		                else if (codePoint === REVERSE_SOLIDUS) {
		                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {
		                        value.push(this.consumeEscapedCodePoint());
		                    }
		                    else {
		                        this.consumeBadUrlRemnants();
		                        return BAD_URL_TOKEN;
		                    }
		                }
		                else {
		                    value.push(codePoint);
		                }
		            }
		        };
		        Tokenizer.prototype.consumeWhiteSpace = function () {
		            while (isWhiteSpace(this.peekCodePoint(0))) {
		                this.consumeCodePoint();
		            }
		        };
		        Tokenizer.prototype.consumeBadUrlRemnants = function () {
		            while (true) {
		                var codePoint = this.consumeCodePoint();
		                if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
		                    return;
		                }
		                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
		                    this.consumeEscapedCodePoint();
		                }
		            }
		        };
		        Tokenizer.prototype.consumeStringSlice = function (count) {
		            var SLICE_STACK_SIZE = 50000;
		            var value = '';
		            while (count > 0) {
		                var amount = Math.min(SLICE_STACK_SIZE, count);
		                value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
		                count -= amount;
		            }
		            this._value.shift();
		            return value;
		        };
		        Tokenizer.prototype.consumeStringToken = function (endingCodePoint) {
		            var value = '';
		            var i = 0;
		            do {
		                var codePoint = this._value[i];
		                if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {
		                    value += this.consumeStringSlice(i);
		                    return { type: 0 /* STRING_TOKEN */, value: value };
		                }
		                if (codePoint === LINE_FEED) {
		                    this._value.splice(0, i);
		                    return BAD_STRING_TOKEN;
		                }
		                if (codePoint === REVERSE_SOLIDUS) {
		                    var next = this._value[i + 1];
		                    if (next !== EOF && next !== undefined) {
		                        if (next === LINE_FEED) {
		                            value += this.consumeStringSlice(i);
		                            i = -1;
		                            this._value.shift();
		                        }
		                        else if (isValidEscape(codePoint, next)) {
		                            value += this.consumeStringSlice(i);
		                            value += fromCodePoint$1(this.consumeEscapedCodePoint());
		                            i = -1;
		                        }
		                    }
		                }
		                i++;
		            } while (true);
		        };
		        Tokenizer.prototype.consumeNumber = function () {
		            var repr = [];
		            var type = FLAG_INTEGER;
		            var c1 = this.peekCodePoint(0);
		            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
		                repr.push(this.consumeCodePoint());
		            }
		            while (isDigit(this.peekCodePoint(0))) {
		                repr.push(this.consumeCodePoint());
		            }
		            c1 = this.peekCodePoint(0);
		            var c2 = this.peekCodePoint(1);
		            if (c1 === FULL_STOP && isDigit(c2)) {
		                repr.push(this.consumeCodePoint(), this.consumeCodePoint());
		                type = FLAG_NUMBER;
		                while (isDigit(this.peekCodePoint(0))) {
		                    repr.push(this.consumeCodePoint());
		                }
		            }
		            c1 = this.peekCodePoint(0);
		            c2 = this.peekCodePoint(1);
		            var c3 = this.peekCodePoint(2);
		            if ((c1 === E || c1 === e) && (((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3)) || isDigit(c2))) {
		                repr.push(this.consumeCodePoint(), this.consumeCodePoint());
		                type = FLAG_NUMBER;
		                while (isDigit(this.peekCodePoint(0))) {
		                    repr.push(this.consumeCodePoint());
		                }
		            }
		            return [stringToNumber(repr), type];
		        };
		        Tokenizer.prototype.consumeNumericToken = function () {
		            var _a = this.consumeNumber(), number = _a[0], flags = _a[1];
		            var c1 = this.peekCodePoint(0);
		            var c2 = this.peekCodePoint(1);
		            var c3 = this.peekCodePoint(2);
		            if (isIdentifierStart(c1, c2, c3)) {
		                var unit = this.consumeName();
		                return { type: 15 /* DIMENSION_TOKEN */, number: number, flags: flags, unit: unit };
		            }
		            if (c1 === PERCENTAGE_SIGN) {
		                this.consumeCodePoint();
		                return { type: 16 /* PERCENTAGE_TOKEN */, number: number, flags: flags };
		            }
		            return { type: 17 /* NUMBER_TOKEN */, number: number, flags: flags };
		        };
		        Tokenizer.prototype.consumeEscapedCodePoint = function () {
		            var codePoint = this.consumeCodePoint();
		            if (isHex(codePoint)) {
		                var hex = fromCodePoint$1(codePoint);
		                while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
		                    hex += fromCodePoint$1(this.consumeCodePoint());
		                }
		                if (isWhiteSpace(this.peekCodePoint(0))) {
		                    this.consumeCodePoint();
		                }
		                var hexCodePoint = parseInt(hex, 16);
		                if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {
		                    return REPLACEMENT_CHARACTER;
		                }
		                return hexCodePoint;
		            }
		            if (codePoint === EOF) {
		                return REPLACEMENT_CHARACTER;
		            }
		            return codePoint;
		        };
		        Tokenizer.prototype.consumeName = function () {
		            var result = '';
		            while (true) {
		                var codePoint = this.consumeCodePoint();
		                if (isNameCodePoint(codePoint)) {
		                    result += fromCodePoint$1(codePoint);
		                }
		                else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
		                    result += fromCodePoint$1(this.consumeEscapedCodePoint());
		                }
		                else {
		                    this.reconsumeCodePoint(codePoint);
		                    return result;
		                }
		            }
		        };
		        return Tokenizer;
		    }());

		    var Parser = /** @class */ (function () {
		        function Parser(tokens) {
		            this._tokens = tokens;
		        }
		        Parser.create = function (value) {
		            var tokenizer = new Tokenizer();
		            tokenizer.write(value);
		            return new Parser(tokenizer.read());
		        };
		        Parser.parseValue = function (value) {
		            return Parser.create(value).parseComponentValue();
		        };
		        Parser.parseValues = function (value) {
		            return Parser.create(value).parseComponentValues();
		        };
		        Parser.prototype.parseComponentValue = function () {
		            var token = this.consumeToken();
		            while (token.type === 31 /* WHITESPACE_TOKEN */) {
		                token = this.consumeToken();
		            }
		            if (token.type === 32 /* EOF_TOKEN */) {
		                throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
		            }
		            this.reconsumeToken(token);
		            var value = this.consumeComponentValue();
		            do {
		                token = this.consumeToken();
		            } while (token.type === 31 /* WHITESPACE_TOKEN */);
		            if (token.type === 32 /* EOF_TOKEN */) {
		                return value;
		            }
		            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
		        };
		        Parser.prototype.parseComponentValues = function () {
		            var values = [];
		            while (true) {
		                var value = this.consumeComponentValue();
		                if (value.type === 32 /* EOF_TOKEN */) {
		                    return values;
		                }
		                values.push(value);
		                values.push();
		            }
		        };
		        Parser.prototype.consumeComponentValue = function () {
		            var token = this.consumeToken();
		            switch (token.type) {
		                case 11 /* LEFT_CURLY_BRACKET_TOKEN */:
		                case 28 /* LEFT_SQUARE_BRACKET_TOKEN */:
		                case 2 /* LEFT_PARENTHESIS_TOKEN */:
		                    return this.consumeSimpleBlock(token.type);
		                case 19 /* FUNCTION_TOKEN */:
		                    return this.consumeFunction(token);
		            }
		            return token;
		        };
		        Parser.prototype.consumeSimpleBlock = function (type) {
		            var block = { type: type, values: [] };
		            var token = this.consumeToken();
		            while (true) {
		                if (token.type === 32 /* EOF_TOKEN */ || isEndingTokenFor(token, type)) {
		                    return block;
		                }
		                this.reconsumeToken(token);
		                block.values.push(this.consumeComponentValue());
		                token = this.consumeToken();
		            }
		        };
		        Parser.prototype.consumeFunction = function (functionToken) {
		            var cssFunction = {
		                name: functionToken.value,
		                values: [],
		                type: 18 /* FUNCTION */
		            };
		            while (true) {
		                var token = this.consumeToken();
		                if (token.type === 32 /* EOF_TOKEN */ || token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */) {
		                    return cssFunction;
		                }
		                this.reconsumeToken(token);
		                cssFunction.values.push(this.consumeComponentValue());
		            }
		        };
		        Parser.prototype.consumeToken = function () {
		            var token = this._tokens.shift();
		            return typeof token === 'undefined' ? EOF_TOKEN : token;
		        };
		        Parser.prototype.reconsumeToken = function (token) {
		            this._tokens.unshift(token);
		        };
		        return Parser;
		    }());
		    var isDimensionToken = function (token) { return token.type === 15 /* DIMENSION_TOKEN */; };
		    var isNumberToken = function (token) { return token.type === 17 /* NUMBER_TOKEN */; };
		    var isIdentToken = function (token) { return token.type === 20 /* IDENT_TOKEN */; };
		    var isStringToken = function (token) { return token.type === 0 /* STRING_TOKEN */; };
		    var isIdentWithValue = function (token, value) {
		        return isIdentToken(token) && token.value === value;
		    };
		    var nonWhiteSpace = function (token) { return token.type !== 31 /* WHITESPACE_TOKEN */; };
		    var nonFunctionArgSeparator = function (token) {
		        return token.type !== 31 /* WHITESPACE_TOKEN */ && token.type !== 4 /* COMMA_TOKEN */;
		    };
		    var parseFunctionArgs = function (tokens) {
		        var args = [];
		        var arg = [];
		        tokens.forEach(function (token) {
		            if (token.type === 4 /* COMMA_TOKEN */) {
		                if (arg.length === 0) {
		                    throw new Error("Error parsing function args, zero tokens for arg");
		                }
		                args.push(arg);
		                arg = [];
		                return;
		            }
		            if (token.type !== 31 /* WHITESPACE_TOKEN */) {
		                arg.push(token);
		            }
		        });
		        if (arg.length) {
		            args.push(arg);
		        }
		        return args;
		    };
		    var isEndingTokenFor = function (token, type) {
		        if (type === 11 /* LEFT_CURLY_BRACKET_TOKEN */ && token.type === 12 /* RIGHT_CURLY_BRACKET_TOKEN */) {
		            return true;
		        }
		        if (type === 28 /* LEFT_SQUARE_BRACKET_TOKEN */ && token.type === 29 /* RIGHT_SQUARE_BRACKET_TOKEN */) {
		            return true;
		        }
		        return type === 2 /* LEFT_PARENTHESIS_TOKEN */ && token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */;
		    };

		    var isLength = function (token) {
		        return token.type === 17 /* NUMBER_TOKEN */ || token.type === 15 /* DIMENSION_TOKEN */;
		    };

		    var isLengthPercentage = function (token) {
		        return token.type === 16 /* PERCENTAGE_TOKEN */ || isLength(token);
		    };
		    var parseLengthPercentageTuple = function (tokens) {
		        return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
		    };
		    var ZERO_LENGTH = {
		        type: 17 /* NUMBER_TOKEN */,
		        number: 0,
		        flags: FLAG_INTEGER
		    };
		    var FIFTY_PERCENT = {
		        type: 16 /* PERCENTAGE_TOKEN */,
		        number: 50,
		        flags: FLAG_INTEGER
		    };
		    var HUNDRED_PERCENT = {
		        type: 16 /* PERCENTAGE_TOKEN */,
		        number: 100,
		        flags: FLAG_INTEGER
		    };
		    var getAbsoluteValueForTuple = function (tuple, width, height) {
		        var x = tuple[0], y = tuple[1];
		        return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];
		    };
		    var getAbsoluteValue = function (token, parent) {
		        if (token.type === 16 /* PERCENTAGE_TOKEN */) {
		            return (token.number / 100) * parent;
		        }
		        if (isDimensionToken(token)) {
		            switch (token.unit) {
		                case 'rem':
		                case 'em':
		                    return 16 * token.number; // TODO use correct font-size
		                case 'px':
		                default:
		                    return token.number;
		            }
		        }
		        return token.number;
		    };

		    var DEG = 'deg';
		    var GRAD = 'grad';
		    var RAD = 'rad';
		    var TURN = 'turn';
		    var angle = {
		        name: 'angle',
		        parse: function (_context, value) {
		            if (value.type === 15 /* DIMENSION_TOKEN */) {
		                switch (value.unit) {
		                    case DEG:
		                        return (Math.PI * value.number) / 180;
		                    case GRAD:
		                        return (Math.PI / 200) * value.number;
		                    case RAD:
		                        return value.number;
		                    case TURN:
		                        return Math.PI * 2 * value.number;
		                }
		            }
		            throw new Error("Unsupported angle type");
		        }
		    };
		    var isAngle = function (value) {
		        if (value.type === 15 /* DIMENSION_TOKEN */) {
		            if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
		                return true;
		            }
		        }
		        return false;
		    };
		    var parseNamedSide = function (tokens) {
		        var sideOrCorner = tokens
		            .filter(isIdentToken)
		            .map(function (ident) { return ident.value; })
		            .join(' ');
		        switch (sideOrCorner) {
		            case 'to bottom right':
		            case 'to right bottom':
		            case 'left top':
		            case 'top left':
		                return [ZERO_LENGTH, ZERO_LENGTH];
		            case 'to top':
		            case 'bottom':
		                return deg(0);
		            case 'to bottom left':
		            case 'to left bottom':
		            case 'right top':
		            case 'top right':
		                return [ZERO_LENGTH, HUNDRED_PERCENT];
		            case 'to right':
		            case 'left':
		                return deg(90);
		            case 'to top left':
		            case 'to left top':
		            case 'right bottom':
		            case 'bottom right':
		                return [HUNDRED_PERCENT, HUNDRED_PERCENT];
		            case 'to bottom':
		            case 'top':
		                return deg(180);
		            case 'to top right':
		            case 'to right top':
		            case 'left bottom':
		            case 'bottom left':
		                return [HUNDRED_PERCENT, ZERO_LENGTH];
		            case 'to left':
		            case 'right':
		                return deg(270);
		        }
		        return 0;
		    };
		    var deg = function (deg) { return (Math.PI * deg) / 180; };

		    var color$1 = {
		        name: 'color',
		        parse: function (context, value) {
		            if (value.type === 18 /* FUNCTION */) {
		                var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
		                if (typeof colorFunction === 'undefined') {
		                    throw new Error("Attempting to parse an unsupported color function \"" + value.name + "\"");
		                }
		                return colorFunction(context, value.values);
		            }
		            if (value.type === 5 /* HASH_TOKEN */) {
		                if (value.value.length === 3) {
		                    var r = value.value.substring(0, 1);
		                    var g = value.value.substring(1, 2);
		                    var b = value.value.substring(2, 3);
		                    return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
		                }
		                if (value.value.length === 4) {
		                    var r = value.value.substring(0, 1);
		                    var g = value.value.substring(1, 2);
		                    var b = value.value.substring(2, 3);
		                    var a = value.value.substring(3, 4);
		                    return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);
		                }
		                if (value.value.length === 6) {
		                    var r = value.value.substring(0, 2);
		                    var g = value.value.substring(2, 4);
		                    var b = value.value.substring(4, 6);
		                    return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
		                }
		                if (value.value.length === 8) {
		                    var r = value.value.substring(0, 2);
		                    var g = value.value.substring(2, 4);
		                    var b = value.value.substring(4, 6);
		                    var a = value.value.substring(6, 8);
		                    return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);
		                }
		            }
		            if (value.type === 20 /* IDENT_TOKEN */) {
		                var namedColor = COLORS[value.value.toUpperCase()];
		                if (typeof namedColor !== 'undefined') {
		                    return namedColor;
		                }
		            }
		            return COLORS.TRANSPARENT;
		        }
		    };
		    var isTransparent = function (color) { return (0xff & color) === 0; };
		    var asString = function (color) {
		        var alpha = 0xff & color;
		        var blue = 0xff & (color >> 8);
		        var green = 0xff & (color >> 16);
		        var red = 0xff & (color >> 24);
		        return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
		    };
		    var pack = function (r, g, b, a) {
		        return ((r << 24) | (g << 16) | (b << 8) | (Math.round(a * 255) << 0)) >>> 0;
		    };
		    var getTokenColorValue = function (token, i) {
		        if (token.type === 17 /* NUMBER_TOKEN */) {
		            return token.number;
		        }
		        if (token.type === 16 /* PERCENTAGE_TOKEN */) {
		            var max = i === 3 ? 1 : 255;
		            return i === 3 ? (token.number / 100) * max : Math.round((token.number / 100) * max);
		        }
		        return 0;
		    };
		    var rgb = function (_context, args) {
		        var tokens = args.filter(nonFunctionArgSeparator);
		        if (tokens.length === 3) {
		            var _a = tokens.map(getTokenColorValue), r = _a[0], g = _a[1], b = _a[2];
		            return pack(r, g, b, 1);
		        }
		        if (tokens.length === 4) {
		            var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a = _b[3];
		            return pack(r, g, b, a);
		        }
		        return 0;
		    };
		    function hue2rgb(t1, t2, hue) {
		        if (hue < 0) {
		            hue += 1;
		        }
		        if (hue >= 1) {
		            hue -= 1;
		        }
		        if (hue < 1 / 6) {
		            return (t2 - t1) * hue * 6 + t1;
		        }
		        else if (hue < 1 / 2) {
		            return t2;
		        }
		        else if (hue < 2 / 3) {
		            return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
		        }
		        else {
		            return t1;
		        }
		    }
		    var hsl = function (context, args) {
		        var tokens = args.filter(nonFunctionArgSeparator);
		        var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
		        var h = (hue.type === 17 /* NUMBER_TOKEN */ ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
		        var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
		        var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
		        var a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
		        if (s === 0) {
		            return pack(l * 255, l * 255, l * 255, 1);
		        }
		        var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
		        var t1 = l * 2 - t2;
		        var r = hue2rgb(t1, t2, h + 1 / 3);
		        var g = hue2rgb(t1, t2, h);
		        var b = hue2rgb(t1, t2, h - 1 / 3);
		        return pack(r * 255, g * 255, b * 255, a);
		    };
		    var SUPPORTED_COLOR_FUNCTIONS = {
		        hsl: hsl,
		        hsla: hsl,
		        rgb: rgb,
		        rgba: rgb
		    };
		    var parseColor = function (context, value) {
		        return color$1.parse(context, Parser.create(value).parseComponentValue());
		    };
		    var COLORS = {
		        ALICEBLUE: 0xf0f8ffff,
		        ANTIQUEWHITE: 0xfaebd7ff,
		        AQUA: 0x00ffffff,
		        AQUAMARINE: 0x7fffd4ff,
		        AZURE: 0xf0ffffff,
		        BEIGE: 0xf5f5dcff,
		        BISQUE: 0xffe4c4ff,
		        BLACK: 0x000000ff,
		        BLANCHEDALMOND: 0xffebcdff,
		        BLUE: 0x0000ffff,
		        BLUEVIOLET: 0x8a2be2ff,
		        BROWN: 0xa52a2aff,
		        BURLYWOOD: 0xdeb887ff,
		        CADETBLUE: 0x5f9ea0ff,
		        CHARTREUSE: 0x7fff00ff,
		        CHOCOLATE: 0xd2691eff,
		        CORAL: 0xff7f50ff,
		        CORNFLOWERBLUE: 0x6495edff,
		        CORNSILK: 0xfff8dcff,
		        CRIMSON: 0xdc143cff,
		        CYAN: 0x00ffffff,
		        DARKBLUE: 0x00008bff,
		        DARKCYAN: 0x008b8bff,
		        DARKGOLDENROD: 0xb886bbff,
		        DARKGRAY: 0xa9a9a9ff,
		        DARKGREEN: 0x006400ff,
		        DARKGREY: 0xa9a9a9ff,
		        DARKKHAKI: 0xbdb76bff,
		        DARKMAGENTA: 0x8b008bff,
		        DARKOLIVEGREEN: 0x556b2fff,
		        DARKORANGE: 0xff8c00ff,
		        DARKORCHID: 0x9932ccff,
		        DARKRED: 0x8b0000ff,
		        DARKSALMON: 0xe9967aff,
		        DARKSEAGREEN: 0x8fbc8fff,
		        DARKSLATEBLUE: 0x483d8bff,
		        DARKSLATEGRAY: 0x2f4f4fff,
		        DARKSLATEGREY: 0x2f4f4fff,
		        DARKTURQUOISE: 0x00ced1ff,
		        DARKVIOLET: 0x9400d3ff,
		        DEEPPINK: 0xff1493ff,
		        DEEPSKYBLUE: 0x00bfffff,
		        DIMGRAY: 0x696969ff,
		        DIMGREY: 0x696969ff,
		        DODGERBLUE: 0x1e90ffff,
		        FIREBRICK: 0xb22222ff,
		        FLORALWHITE: 0xfffaf0ff,
		        FORESTGREEN: 0x228b22ff,
		        FUCHSIA: 0xff00ffff,
		        GAINSBORO: 0xdcdcdcff,
		        GHOSTWHITE: 0xf8f8ffff,
		        GOLD: 0xffd700ff,
		        GOLDENROD: 0xdaa520ff,
		        GRAY: 0x808080ff,
		        GREEN: 0x008000ff,
		        GREENYELLOW: 0xadff2fff,
		        GREY: 0x808080ff,
		        HONEYDEW: 0xf0fff0ff,
		        HOTPINK: 0xff69b4ff,
		        INDIANRED: 0xcd5c5cff,
		        INDIGO: 0x4b0082ff,
		        IVORY: 0xfffff0ff,
		        KHAKI: 0xf0e68cff,
		        LAVENDER: 0xe6e6faff,
		        LAVENDERBLUSH: 0xfff0f5ff,
		        LAWNGREEN: 0x7cfc00ff,
		        LEMONCHIFFON: 0xfffacdff,
		        LIGHTBLUE: 0xadd8e6ff,
		        LIGHTCORAL: 0xf08080ff,
		        LIGHTCYAN: 0xe0ffffff,
		        LIGHTGOLDENRODYELLOW: 0xfafad2ff,
		        LIGHTGRAY: 0xd3d3d3ff,
		        LIGHTGREEN: 0x90ee90ff,
		        LIGHTGREY: 0xd3d3d3ff,
		        LIGHTPINK: 0xffb6c1ff,
		        LIGHTSALMON: 0xffa07aff,
		        LIGHTSEAGREEN: 0x20b2aaff,
		        LIGHTSKYBLUE: 0x87cefaff,
		        LIGHTSLATEGRAY: 0x778899ff,
		        LIGHTSLATEGREY: 0x778899ff,
		        LIGHTSTEELBLUE: 0xb0c4deff,
		        LIGHTYELLOW: 0xffffe0ff,
		        LIME: 0x00ff00ff,
		        LIMEGREEN: 0x32cd32ff,
		        LINEN: 0xfaf0e6ff,
		        MAGENTA: 0xff00ffff,
		        MAROON: 0x800000ff,
		        MEDIUMAQUAMARINE: 0x66cdaaff,
		        MEDIUMBLUE: 0x0000cdff,
		        MEDIUMORCHID: 0xba55d3ff,
		        MEDIUMPURPLE: 0x9370dbff,
		        MEDIUMSEAGREEN: 0x3cb371ff,
		        MEDIUMSLATEBLUE: 0x7b68eeff,
		        MEDIUMSPRINGGREEN: 0x00fa9aff,
		        MEDIUMTURQUOISE: 0x48d1ccff,
		        MEDIUMVIOLETRED: 0xc71585ff,
		        MIDNIGHTBLUE: 0x191970ff,
		        MINTCREAM: 0xf5fffaff,
		        MISTYROSE: 0xffe4e1ff,
		        MOCCASIN: 0xffe4b5ff,
		        NAVAJOWHITE: 0xffdeadff,
		        NAVY: 0x000080ff,
		        OLDLACE: 0xfdf5e6ff,
		        OLIVE: 0x808000ff,
		        OLIVEDRAB: 0x6b8e23ff,
		        ORANGE: 0xffa500ff,
		        ORANGERED: 0xff4500ff,
		        ORCHID: 0xda70d6ff,
		        PALEGOLDENROD: 0xeee8aaff,
		        PALEGREEN: 0x98fb98ff,
		        PALETURQUOISE: 0xafeeeeff,
		        PALEVIOLETRED: 0xdb7093ff,
		        PAPAYAWHIP: 0xffefd5ff,
		        PEACHPUFF: 0xffdab9ff,
		        PERU: 0xcd853fff,
		        PINK: 0xffc0cbff,
		        PLUM: 0xdda0ddff,
		        POWDERBLUE: 0xb0e0e6ff,
		        PURPLE: 0x800080ff,
		        REBECCAPURPLE: 0x663399ff,
		        RED: 0xff0000ff,
		        ROSYBROWN: 0xbc8f8fff,
		        ROYALBLUE: 0x4169e1ff,
		        SADDLEBROWN: 0x8b4513ff,
		        SALMON: 0xfa8072ff,
		        SANDYBROWN: 0xf4a460ff,
		        SEAGREEN: 0x2e8b57ff,
		        SEASHELL: 0xfff5eeff,
		        SIENNA: 0xa0522dff,
		        SILVER: 0xc0c0c0ff,
		        SKYBLUE: 0x87ceebff,
		        SLATEBLUE: 0x6a5acdff,
		        SLATEGRAY: 0x708090ff,
		        SLATEGREY: 0x708090ff,
		        SNOW: 0xfffafaff,
		        SPRINGGREEN: 0x00ff7fff,
		        STEELBLUE: 0x4682b4ff,
		        TAN: 0xd2b48cff,
		        TEAL: 0x008080ff,
		        THISTLE: 0xd8bfd8ff,
		        TOMATO: 0xff6347ff,
		        TRANSPARENT: 0x00000000,
		        TURQUOISE: 0x40e0d0ff,
		        VIOLET: 0xee82eeff,
		        WHEAT: 0xf5deb3ff,
		        WHITE: 0xffffffff,
		        WHITESMOKE: 0xf5f5f5ff,
		        YELLOW: 0xffff00ff,
		        YELLOWGREEN: 0x9acd32ff
		    };

		    var backgroundClip = {
		        name: 'background-clip',
		        initialValue: 'border-box',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            return tokens.map(function (token) {
		                if (isIdentToken(token)) {
		                    switch (token.value) {
		                        case 'padding-box':
		                            return 1 /* PADDING_BOX */;
		                        case 'content-box':
		                            return 2 /* CONTENT_BOX */;
		                    }
		                }
		                return 0 /* BORDER_BOX */;
		            });
		        }
		    };

		    var backgroundColor = {
		        name: "background-color",
		        initialValue: 'transparent',
		        prefix: false,
		        type: 3 /* TYPE_VALUE */,
		        format: 'color'
		    };

		    var parseColorStop = function (context, args) {
		        var color = color$1.parse(context, args[0]);
		        var stop = args[1];
		        return stop && isLengthPercentage(stop) ? { color: color, stop: stop } : { color: color, stop: null };
		    };
		    var processColorStops = function (stops, lineLength) {
		        var first = stops[0];
		        var last = stops[stops.length - 1];
		        if (first.stop === null) {
		            first.stop = ZERO_LENGTH;
		        }
		        if (last.stop === null) {
		            last.stop = HUNDRED_PERCENT;
		        }
		        var processStops = [];
		        var previous = 0;
		        for (var i = 0; i < stops.length; i++) {
		            var stop_1 = stops[i].stop;
		            if (stop_1 !== null) {
		                var absoluteValue = getAbsoluteValue(stop_1, lineLength);
		                if (absoluteValue > previous) {
		                    processStops.push(absoluteValue);
		                }
		                else {
		                    processStops.push(previous);
		                }
		                previous = absoluteValue;
		            }
		            else {
		                processStops.push(null);
		            }
		        }
		        var gapBegin = null;
		        for (var i = 0; i < processStops.length; i++) {
		            var stop_2 = processStops[i];
		            if (stop_2 === null) {
		                if (gapBegin === null) {
		                    gapBegin = i;
		                }
		            }
		            else if (gapBegin !== null) {
		                var gapLength = i - gapBegin;
		                var beforeGap = processStops[gapBegin - 1];
		                var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
		                for (var g = 1; g <= gapLength; g++) {
		                    processStops[gapBegin + g - 1] = gapValue * g;
		                }
		                gapBegin = null;
		            }
		        }
		        return stops.map(function (_a, i) {
		            var color = _a.color;
		            return { color: color, stop: Math.max(Math.min(1, processStops[i] / lineLength), 0) };
		        });
		    };
		    var getAngleFromCorner = function (corner, width, height) {
		        var centerX = width / 2;
		        var centerY = height / 2;
		        var x = getAbsoluteValue(corner[0], width) - centerX;
		        var y = centerY - getAbsoluteValue(corner[1], height);
		        return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
		    };
		    var calculateGradientDirection = function (angle, width, height) {
		        var radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);
		        var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
		        var halfWidth = width / 2;
		        var halfHeight = height / 2;
		        var halfLineLength = lineLength / 2;
		        var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
		        var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
		        return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
		    };
		    var distance = function (a, b) { return Math.sqrt(a * a + b * b); };
		    var findCorner = function (width, height, x, y, closest) {
		        var corners = [
		            [0, 0],
		            [0, height],
		            [width, 0],
		            [width, height]
		        ];
		        return corners.reduce(function (stat, corner) {
		            var cx = corner[0], cy = corner[1];
		            var d = distance(x - cx, y - cy);
		            if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
		                return {
		                    optimumCorner: corner,
		                    optimumDistance: d
		                };
		            }
		            return stat;
		        }, {
		            optimumDistance: closest ? Infinity : -Infinity,
		            optimumCorner: null
		        }).optimumCorner;
		    };
		    var calculateRadius = function (gradient, x, y, width, height) {
		        var rx = 0;
		        var ry = 0;
		        switch (gradient.size) {
		            case 0 /* CLOSEST_SIDE */:
		                // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradient’s center.
		                // If the shape is an ellipse, it exactly meets the closest side in each dimension.
		                if (gradient.shape === 0 /* CIRCLE */) {
		                    rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
		                }
		                else if (gradient.shape === 1 /* ELLIPSE */) {
		                    rx = Math.min(Math.abs(x), Math.abs(x - width));
		                    ry = Math.min(Math.abs(y), Math.abs(y - height));
		                }
		                break;
		            case 2 /* CLOSEST_CORNER */:
		                // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradient’s center.
		                // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
		                if (gradient.shape === 0 /* CIRCLE */) {
		                    rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
		                }
		                else if (gradient.shape === 1 /* ELLIPSE */) {
		                    // Compute the ratio ry/rx (which is to be the same as for "closest-side")
		                    var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
		                    var _a = findCorner(width, height, x, y, true), cx = _a[0], cy = _a[1];
		                    rx = distance(cx - x, (cy - y) / c);
		                    ry = c * rx;
		                }
		                break;
		            case 1 /* FARTHEST_SIDE */:
		                // Same as closest-side, except the ending shape is sized based on the farthest side(s)
		                if (gradient.shape === 0 /* CIRCLE */) {
		                    rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
		                }
		                else if (gradient.shape === 1 /* ELLIPSE */) {
		                    rx = Math.max(Math.abs(x), Math.abs(x - width));
		                    ry = Math.max(Math.abs(y), Math.abs(y - height));
		                }
		                break;
		            case 3 /* FARTHEST_CORNER */:
		                // Same as closest-corner, except the ending shape is sized based on the farthest corner.
		                // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
		                if (gradient.shape === 0 /* CIRCLE */) {
		                    rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
		                }
		                else if (gradient.shape === 1 /* ELLIPSE */) {
		                    // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
		                    var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
		                    var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
		                    rx = distance(cx - x, (cy - y) / c);
		                    ry = c * rx;
		                }
		                break;
		        }
		        if (Array.isArray(gradient.size)) {
		            rx = getAbsoluteValue(gradient.size[0], width);
		            ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
		        }
		        return [rx, ry];
		    };

		    var linearGradient = function (context, tokens) {
		        var angle$1 = deg(180);
		        var stops = [];
		        parseFunctionArgs(tokens).forEach(function (arg, i) {
		            if (i === 0) {
		                var firstToken = arg[0];
		                if (firstToken.type === 20 /* IDENT_TOKEN */ && firstToken.value === 'to') {
		                    angle$1 = parseNamedSide(arg);
		                    return;
		                }
		                else if (isAngle(firstToken)) {
		                    angle$1 = angle.parse(context, firstToken);
		                    return;
		                }
		            }
		            var colorStop = parseColorStop(context, arg);
		            stops.push(colorStop);
		        });
		        return { angle: angle$1, stops: stops, type: 1 /* LINEAR_GRADIENT */ };
		    };

		    var prefixLinearGradient = function (context, tokens) {
		        var angle$1 = deg(180);
		        var stops = [];
		        parseFunctionArgs(tokens).forEach(function (arg, i) {
		            if (i === 0) {
		                var firstToken = arg[0];
		                if (firstToken.type === 20 /* IDENT_TOKEN */ &&
		                    ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1) {
		                    angle$1 = parseNamedSide(arg);
		                    return;
		                }
		                else if (isAngle(firstToken)) {
		                    angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
		                    return;
		                }
		            }
		            var colorStop = parseColorStop(context, arg);
		            stops.push(colorStop);
		        });
		        return {
		            angle: angle$1,
		            stops: stops,
		            type: 1 /* LINEAR_GRADIENT */
		        };
		    };

		    var webkitGradient = function (context, tokens) {
		        var angle = deg(180);
		        var stops = [];
		        var type = 1 /* LINEAR_GRADIENT */;
		        var shape = 0 /* CIRCLE */;
		        var size = 3 /* FARTHEST_CORNER */;
		        var position = [];
		        parseFunctionArgs(tokens).forEach(function (arg, i) {
		            var firstToken = arg[0];
		            if (i === 0) {
		                if (isIdentToken(firstToken) && firstToken.value === 'linear') {
		                    type = 1 /* LINEAR_GRADIENT */;
		                    return;
		                }
		                else if (isIdentToken(firstToken) && firstToken.value === 'radial') {
		                    type = 2 /* RADIAL_GRADIENT */;
		                    return;
		                }
		            }
		            if (firstToken.type === 18 /* FUNCTION */) {
		                if (firstToken.name === 'from') {
		                    var color = color$1.parse(context, firstToken.values[0]);
		                    stops.push({ stop: ZERO_LENGTH, color: color });
		                }
		                else if (firstToken.name === 'to') {
		                    var color = color$1.parse(context, firstToken.values[0]);
		                    stops.push({ stop: HUNDRED_PERCENT, color: color });
		                }
		                else if (firstToken.name === 'color-stop') {
		                    var values = firstToken.values.filter(nonFunctionArgSeparator);
		                    if (values.length === 2) {
		                        var color = color$1.parse(context, values[1]);
		                        var stop_1 = values[0];
		                        if (isNumberToken(stop_1)) {
		                            stops.push({
		                                stop: { type: 16 /* PERCENTAGE_TOKEN */, number: stop_1.number * 100, flags: stop_1.flags },
		                                color: color
		                            });
		                        }
		                    }
		                }
		            }
		        });
		        return type === 1 /* LINEAR_GRADIENT */
		            ? {
		                angle: (angle + deg(180)) % deg(360),
		                stops: stops,
		                type: type
		            }
		            : { size: size, shape: shape, stops: stops, position: position, type: type };
		    };

		    var CLOSEST_SIDE = 'closest-side';
		    var FARTHEST_SIDE = 'farthest-side';
		    var CLOSEST_CORNER = 'closest-corner';
		    var FARTHEST_CORNER = 'farthest-corner';
		    var CIRCLE = 'circle';
		    var ELLIPSE = 'ellipse';
		    var COVER = 'cover';
		    var CONTAIN = 'contain';
		    var radialGradient = function (context, tokens) {
		        var shape = 0 /* CIRCLE */;
		        var size = 3 /* FARTHEST_CORNER */;
		        var stops = [];
		        var position = [];
		        parseFunctionArgs(tokens).forEach(function (arg, i) {
		            var isColorStop = true;
		            if (i === 0) {
		                var isAtPosition_1 = false;
		                isColorStop = arg.reduce(function (acc, token) {
		                    if (isAtPosition_1) {
		                        if (isIdentToken(token)) {
		                            switch (token.value) {
		                                case 'center':
		                                    position.push(FIFTY_PERCENT);
		                                    return acc;
		                                case 'top':
		                                case 'left':
		                                    position.push(ZERO_LENGTH);
		                                    return acc;
		                                case 'right':
		                                case 'bottom':
		                                    position.push(HUNDRED_PERCENT);
		                                    return acc;
		                            }
		                        }
		                        else if (isLengthPercentage(token) || isLength(token)) {
		                            position.push(token);
		                        }
		                    }
		                    else if (isIdentToken(token)) {
		                        switch (token.value) {
		                            case CIRCLE:
		                                shape = 0 /* CIRCLE */;
		                                return false;
		                            case ELLIPSE:
		                                shape = 1 /* ELLIPSE */;
		                                return false;
		                            case 'at':
		                                isAtPosition_1 = true;
		                                return false;
		                            case CLOSEST_SIDE:
		                                size = 0 /* CLOSEST_SIDE */;
		                                return false;
		                            case COVER:
		                            case FARTHEST_SIDE:
		                                size = 1 /* FARTHEST_SIDE */;
		                                return false;
		                            case CONTAIN:
		                            case CLOSEST_CORNER:
		                                size = 2 /* CLOSEST_CORNER */;
		                                return false;
		                            case FARTHEST_CORNER:
		                                size = 3 /* FARTHEST_CORNER */;
		                                return false;
		                        }
		                    }
		                    else if (isLength(token) || isLengthPercentage(token)) {
		                        if (!Array.isArray(size)) {
		                            size = [];
		                        }
		                        size.push(token);
		                        return false;
		                    }
		                    return acc;
		                }, isColorStop);
		            }
		            if (isColorStop) {
		                var colorStop = parseColorStop(context, arg);
		                stops.push(colorStop);
		            }
		        });
		        return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
		    };

		    var prefixRadialGradient = function (context, tokens) {
		        var shape = 0 /* CIRCLE */;
		        var size = 3 /* FARTHEST_CORNER */;
		        var stops = [];
		        var position = [];
		        parseFunctionArgs(tokens).forEach(function (arg, i) {
		            var isColorStop = true;
		            if (i === 0) {
		                isColorStop = arg.reduce(function (acc, token) {
		                    if (isIdentToken(token)) {
		                        switch (token.value) {
		                            case 'center':
		                                position.push(FIFTY_PERCENT);
		                                return false;
		                            case 'top':
		                            case 'left':
		                                position.push(ZERO_LENGTH);
		                                return false;
		                            case 'right':
		                            case 'bottom':
		                                position.push(HUNDRED_PERCENT);
		                                return false;
		                        }
		                    }
		                    else if (isLengthPercentage(token) || isLength(token)) {
		                        position.push(token);
		                        return false;
		                    }
		                    return acc;
		                }, isColorStop);
		            }
		            else if (i === 1) {
		                isColorStop = arg.reduce(function (acc, token) {
		                    if (isIdentToken(token)) {
		                        switch (token.value) {
		                            case CIRCLE:
		                                shape = 0 /* CIRCLE */;
		                                return false;
		                            case ELLIPSE:
		                                shape = 1 /* ELLIPSE */;
		                                return false;
		                            case CONTAIN:
		                            case CLOSEST_SIDE:
		                                size = 0 /* CLOSEST_SIDE */;
		                                return false;
		                            case FARTHEST_SIDE:
		                                size = 1 /* FARTHEST_SIDE */;
		                                return false;
		                            case CLOSEST_CORNER:
		                                size = 2 /* CLOSEST_CORNER */;
		                                return false;
		                            case COVER:
		                            case FARTHEST_CORNER:
		                                size = 3 /* FARTHEST_CORNER */;
		                                return false;
		                        }
		                    }
		                    else if (isLength(token) || isLengthPercentage(token)) {
		                        if (!Array.isArray(size)) {
		                            size = [];
		                        }
		                        size.push(token);
		                        return false;
		                    }
		                    return acc;
		                }, isColorStop);
		            }
		            if (isColorStop) {
		                var colorStop = parseColorStop(context, arg);
		                stops.push(colorStop);
		            }
		        });
		        return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
		    };

		    var isLinearGradient = function (background) {
		        return background.type === 1 /* LINEAR_GRADIENT */;
		    };
		    var isRadialGradient = function (background) {
		        return background.type === 2 /* RADIAL_GRADIENT */;
		    };
		    var image = {
		        name: 'image',
		        parse: function (context, value) {
		            if (value.type === 22 /* URL_TOKEN */) {
		                var image_1 = { url: value.value, type: 0 /* URL */ };
		                context.cache.addImage(value.value);
		                return image_1;
		            }
		            if (value.type === 18 /* FUNCTION */) {
		                var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
		                if (typeof imageFunction === 'undefined') {
		                    throw new Error("Attempting to parse an unsupported image function \"" + value.name + "\"");
		                }
		                return imageFunction(context, value.values);
		            }
		            throw new Error("Unsupported image type " + value.type);
		        }
		    };
		    function isSupportedImage(value) {
		        return (!(value.type === 20 /* IDENT_TOKEN */ && value.value === 'none') &&
		            (value.type !== 18 /* FUNCTION */ || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]));
		    }
		    var SUPPORTED_IMAGE_FUNCTIONS = {
		        'linear-gradient': linearGradient,
		        '-moz-linear-gradient': prefixLinearGradient,
		        '-ms-linear-gradient': prefixLinearGradient,
		        '-o-linear-gradient': prefixLinearGradient,
		        '-webkit-linear-gradient': prefixLinearGradient,
		        'radial-gradient': radialGradient,
		        '-moz-radial-gradient': prefixRadialGradient,
		        '-ms-radial-gradient': prefixRadialGradient,
		        '-o-radial-gradient': prefixRadialGradient,
		        '-webkit-radial-gradient': prefixRadialGradient,
		        '-webkit-gradient': webkitGradient
		    };

		    var backgroundImage = {
		        name: 'background-image',
		        initialValue: 'none',
		        type: 1 /* LIST */,
		        prefix: false,
		        parse: function (context, tokens) {
		            if (tokens.length === 0) {
		                return [];
		            }
		            var first = tokens[0];
		            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
		                return [];
		            }
		            return tokens
		                .filter(function (value) { return nonFunctionArgSeparator(value) && isSupportedImage(value); })
		                .map(function (value) { return image.parse(context, value); });
		        }
		    };

		    var backgroundOrigin = {
		        name: 'background-origin',
		        initialValue: 'border-box',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            return tokens.map(function (token) {
		                if (isIdentToken(token)) {
		                    switch (token.value) {
		                        case 'padding-box':
		                            return 1 /* PADDING_BOX */;
		                        case 'content-box':
		                            return 2 /* CONTENT_BOX */;
		                    }
		                }
		                return 0 /* BORDER_BOX */;
		            });
		        }
		    };

		    var backgroundPosition = {
		        name: 'background-position',
		        initialValue: '0% 0%',
		        type: 1 /* LIST */,
		        prefix: false,
		        parse: function (_context, tokens) {
		            return parseFunctionArgs(tokens)
		                .map(function (values) { return values.filter(isLengthPercentage); })
		                .map(parseLengthPercentageTuple);
		        }
		    };

		    var backgroundRepeat = {
		        name: 'background-repeat',
		        initialValue: 'repeat',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            return parseFunctionArgs(tokens)
		                .map(function (values) {
		                return values
		                    .filter(isIdentToken)
		                    .map(function (token) { return token.value; })
		                    .join(' ');
		            })
		                .map(parseBackgroundRepeat);
		        }
		    };
		    var parseBackgroundRepeat = function (value) {
		        switch (value) {
		            case 'no-repeat':
		                return 1 /* NO_REPEAT */;
		            case 'repeat-x':
		            case 'repeat no-repeat':
		                return 2 /* REPEAT_X */;
		            case 'repeat-y':
		            case 'no-repeat repeat':
		                return 3 /* REPEAT_Y */;
		            case 'repeat':
		            default:
		                return 0 /* REPEAT */;
		        }
		    };

		    var BACKGROUND_SIZE;
		    (function (BACKGROUND_SIZE) {
		        BACKGROUND_SIZE["AUTO"] = "auto";
		        BACKGROUND_SIZE["CONTAIN"] = "contain";
		        BACKGROUND_SIZE["COVER"] = "cover";
		    })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
		    var backgroundSize = {
		        name: 'background-size',
		        initialValue: '0',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            return parseFunctionArgs(tokens).map(function (values) { return values.filter(isBackgroundSizeInfoToken); });
		        }
		    };
		    var isBackgroundSizeInfoToken = function (value) {
		        return isIdentToken(value) || isLengthPercentage(value);
		    };

		    var borderColorForSide = function (side) { return ({
		        name: "border-" + side + "-color",
		        initialValue: 'transparent',
		        prefix: false,
		        type: 3 /* TYPE_VALUE */,
		        format: 'color'
		    }); };
		    var borderTopColor = borderColorForSide('top');
		    var borderRightColor = borderColorForSide('right');
		    var borderBottomColor = borderColorForSide('bottom');
		    var borderLeftColor = borderColorForSide('left');

		    var borderRadiusForSide = function (side) { return ({
		        name: "border-radius-" + side,
		        initialValue: '0 0',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
		        }
		    }); };
		    var borderTopLeftRadius = borderRadiusForSide('top-left');
		    var borderTopRightRadius = borderRadiusForSide('top-right');
		    var borderBottomRightRadius = borderRadiusForSide('bottom-right');
		    var borderBottomLeftRadius = borderRadiusForSide('bottom-left');

		    var borderStyleForSide = function (side) { return ({
		        name: "border-" + side + "-style",
		        initialValue: 'solid',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, style) {
		            switch (style) {
		                case 'none':
		                    return 0 /* NONE */;
		                case 'dashed':
		                    return 2 /* DASHED */;
		                case 'dotted':
		                    return 3 /* DOTTED */;
		                case 'double':
		                    return 4 /* DOUBLE */;
		            }
		            return 1 /* SOLID */;
		        }
		    }); };
		    var borderTopStyle = borderStyleForSide('top');
		    var borderRightStyle = borderStyleForSide('right');
		    var borderBottomStyle = borderStyleForSide('bottom');
		    var borderLeftStyle = borderStyleForSide('left');

		    var borderWidthForSide = function (side) { return ({
		        name: "border-" + side + "-width",
		        initialValue: '0',
		        type: 0 /* VALUE */,
		        prefix: false,
		        parse: function (_context, token) {
		            if (isDimensionToken(token)) {
		                return token.number;
		            }
		            return 0;
		        }
		    }); };
		    var borderTopWidth = borderWidthForSide('top');
		    var borderRightWidth = borderWidthForSide('right');
		    var borderBottomWidth = borderWidthForSide('bottom');
		    var borderLeftWidth = borderWidthForSide('left');

		    var color = {
		        name: "color",
		        initialValue: 'transparent',
		        prefix: false,
		        type: 3 /* TYPE_VALUE */,
		        format: 'color'
		    };

		    var direction = {
		        name: 'direction',
		        initialValue: 'ltr',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, direction) {
		            switch (direction) {
		                case 'rtl':
		                    return 1 /* RTL */;
		                case 'ltr':
		                default:
		                    return 0 /* LTR */;
		            }
		        }
		    };

		    var display = {
		        name: 'display',
		        initialValue: 'inline-block',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            return tokens.filter(isIdentToken).reduce(function (bit, token) {
		                return bit | parseDisplayValue(token.value);
		            }, 0 /* NONE */);
		        }
		    };
		    var parseDisplayValue = function (display) {
		        switch (display) {
		            case 'block':
		            case '-webkit-box':
		                return 2 /* BLOCK */;
		            case 'inline':
		                return 4 /* INLINE */;
		            case 'run-in':
		                return 8 /* RUN_IN */;
		            case 'flow':
		                return 16 /* FLOW */;
		            case 'flow-root':
		                return 32 /* FLOW_ROOT */;
		            case 'table':
		                return 64 /* TABLE */;
		            case 'flex':
		            case '-webkit-flex':
		                return 128 /* FLEX */;
		            case 'grid':
		            case '-ms-grid':
		                return 256 /* GRID */;
		            case 'ruby':
		                return 512 /* RUBY */;
		            case 'subgrid':
		                return 1024 /* SUBGRID */;
		            case 'list-item':
		                return 2048 /* LIST_ITEM */;
		            case 'table-row-group':
		                return 4096 /* TABLE_ROW_GROUP */;
		            case 'table-header-group':
		                return 8192 /* TABLE_HEADER_GROUP */;
		            case 'table-footer-group':
		                return 16384 /* TABLE_FOOTER_GROUP */;
		            case 'table-row':
		                return 32768 /* TABLE_ROW */;
		            case 'table-cell':
		                return 65536 /* TABLE_CELL */;
		            case 'table-column-group':
		                return 131072 /* TABLE_COLUMN_GROUP */;
		            case 'table-column':
		                return 262144 /* TABLE_COLUMN */;
		            case 'table-caption':
		                return 524288 /* TABLE_CAPTION */;
		            case 'ruby-base':
		                return 1048576 /* RUBY_BASE */;
		            case 'ruby-text':
		                return 2097152 /* RUBY_TEXT */;
		            case 'ruby-base-container':
		                return 4194304 /* RUBY_BASE_CONTAINER */;
		            case 'ruby-text-container':
		                return 8388608 /* RUBY_TEXT_CONTAINER */;
		            case 'contents':
		                return 16777216 /* CONTENTS */;
		            case 'inline-block':
		                return 33554432 /* INLINE_BLOCK */;
		            case 'inline-list-item':
		                return 67108864 /* INLINE_LIST_ITEM */;
		            case 'inline-table':
		                return 134217728 /* INLINE_TABLE */;
		            case 'inline-flex':
		                return 268435456 /* INLINE_FLEX */;
		            case 'inline-grid':
		                return 536870912 /* INLINE_GRID */;
		        }
		        return 0 /* NONE */;
		    };

		    var float = {
		        name: 'float',
		        initialValue: 'none',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, float) {
		            switch (float) {
		                case 'left':
		                    return 1 /* LEFT */;
		                case 'right':
		                    return 2 /* RIGHT */;
		                case 'inline-start':
		                    return 3 /* INLINE_START */;
		                case 'inline-end':
		                    return 4 /* INLINE_END */;
		            }
		            return 0 /* NONE */;
		        }
		    };

		    var letterSpacing = {
		        name: 'letter-spacing',
		        initialValue: '0',
		        prefix: false,
		        type: 0 /* VALUE */,
		        parse: function (_context, token) {
		            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'normal') {
		                return 0;
		            }
		            if (token.type === 17 /* NUMBER_TOKEN */) {
		                return token.number;
		            }
		            if (token.type === 15 /* DIMENSION_TOKEN */) {
		                return token.number;
		            }
		            return 0;
		        }
		    };

		    var LINE_BREAK;
		    (function (LINE_BREAK) {
		        LINE_BREAK["NORMAL"] = "normal";
		        LINE_BREAK["STRICT"] = "strict";
		    })(LINE_BREAK || (LINE_BREAK = {}));
		    var lineBreak = {
		        name: 'line-break',
		        initialValue: 'normal',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, lineBreak) {
		            switch (lineBreak) {
		                case 'strict':
		                    return LINE_BREAK.STRICT;
		                case 'normal':
		                default:
		                    return LINE_BREAK.NORMAL;
		            }
		        }
		    };

		    var lineHeight = {
		        name: 'line-height',
		        initialValue: 'normal',
		        prefix: false,
		        type: 4 /* TOKEN_VALUE */
		    };
		    var computeLineHeight = function (token, fontSize) {
		        if (isIdentToken(token) && token.value === 'normal') {
		            return 1.2 * fontSize;
		        }
		        else if (token.type === 17 /* NUMBER_TOKEN */) {
		            return fontSize * token.number;
		        }
		        else if (isLengthPercentage(token)) {
		            return getAbsoluteValue(token, fontSize);
		        }
		        return fontSize;
		    };

		    var listStyleImage = {
		        name: 'list-style-image',
		        initialValue: 'none',
		        type: 0 /* VALUE */,
		        prefix: false,
		        parse: function (context, token) {
		            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
		                return null;
		            }
		            return image.parse(context, token);
		        }
		    };

		    var listStylePosition = {
		        name: 'list-style-position',
		        initialValue: 'outside',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, position) {
		            switch (position) {
		                case 'inside':
		                    return 0 /* INSIDE */;
		                case 'outside':
		                default:
		                    return 1 /* OUTSIDE */;
		            }
		        }
		    };

		    var listStyleType = {
		        name: 'list-style-type',
		        initialValue: 'none',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, type) {
		            switch (type) {
		                case 'disc':
		                    return 0 /* DISC */;
		                case 'circle':
		                    return 1 /* CIRCLE */;
		                case 'square':
		                    return 2 /* SQUARE */;
		                case 'decimal':
		                    return 3 /* DECIMAL */;
		                case 'cjk-decimal':
		                    return 4 /* CJK_DECIMAL */;
		                case 'decimal-leading-zero':
		                    return 5 /* DECIMAL_LEADING_ZERO */;
		                case 'lower-roman':
		                    return 6 /* LOWER_ROMAN */;
		                case 'upper-roman':
		                    return 7 /* UPPER_ROMAN */;
		                case 'lower-greek':
		                    return 8 /* LOWER_GREEK */;
		                case 'lower-alpha':
		                    return 9 /* LOWER_ALPHA */;
		                case 'upper-alpha':
		                    return 10 /* UPPER_ALPHA */;
		                case 'arabic-indic':
		                    return 11 /* ARABIC_INDIC */;
		                case 'armenian':
		                    return 12 /* ARMENIAN */;
		                case 'bengali':
		                    return 13 /* BENGALI */;
		                case 'cambodian':
		                    return 14 /* CAMBODIAN */;
		                case 'cjk-earthly-branch':
		                    return 15 /* CJK_EARTHLY_BRANCH */;
		                case 'cjk-heavenly-stem':
		                    return 16 /* CJK_HEAVENLY_STEM */;
		                case 'cjk-ideographic':
		                    return 17 /* CJK_IDEOGRAPHIC */;
		                case 'devanagari':
		                    return 18 /* DEVANAGARI */;
		                case 'ethiopic-numeric':
		                    return 19 /* ETHIOPIC_NUMERIC */;
		                case 'georgian':
		                    return 20 /* GEORGIAN */;
		                case 'gujarati':
		                    return 21 /* GUJARATI */;
		                case 'gurmukhi':
		                    return 22 /* GURMUKHI */;
		                case 'hebrew':
		                    return 22 /* HEBREW */;
		                case 'hiragana':
		                    return 23 /* HIRAGANA */;
		                case 'hiragana-iroha':
		                    return 24 /* HIRAGANA_IROHA */;
		                case 'japanese-formal':
		                    return 25 /* JAPANESE_FORMAL */;
		                case 'japanese-informal':
		                    return 26 /* JAPANESE_INFORMAL */;
		                case 'kannada':
		                    return 27 /* KANNADA */;
		                case 'katakana':
		                    return 28 /* KATAKANA */;
		                case 'katakana-iroha':
		                    return 29 /* KATAKANA_IROHA */;
		                case 'khmer':
		                    return 30 /* KHMER */;
		                case 'korean-hangul-formal':
		                    return 31 /* KOREAN_HANGUL_FORMAL */;
		                case 'korean-hanja-formal':
		                    return 32 /* KOREAN_HANJA_FORMAL */;
		                case 'korean-hanja-informal':
		                    return 33 /* KOREAN_HANJA_INFORMAL */;
		                case 'lao':
		                    return 34 /* LAO */;
		                case 'lower-armenian':
		                    return 35 /* LOWER_ARMENIAN */;
		                case 'malayalam':
		                    return 36 /* MALAYALAM */;
		                case 'mongolian':
		                    return 37 /* MONGOLIAN */;
		                case 'myanmar':
		                    return 38 /* MYANMAR */;
		                case 'oriya':
		                    return 39 /* ORIYA */;
		                case 'persian':
		                    return 40 /* PERSIAN */;
		                case 'simp-chinese-formal':
		                    return 41 /* SIMP_CHINESE_FORMAL */;
		                case 'simp-chinese-informal':
		                    return 42 /* SIMP_CHINESE_INFORMAL */;
		                case 'tamil':
		                    return 43 /* TAMIL */;
		                case 'telugu':
		                    return 44 /* TELUGU */;
		                case 'thai':
		                    return 45 /* THAI */;
		                case 'tibetan':
		                    return 46 /* TIBETAN */;
		                case 'trad-chinese-formal':
		                    return 47 /* TRAD_CHINESE_FORMAL */;
		                case 'trad-chinese-informal':
		                    return 48 /* TRAD_CHINESE_INFORMAL */;
		                case 'upper-armenian':
		                    return 49 /* UPPER_ARMENIAN */;
		                case 'disclosure-open':
		                    return 50 /* DISCLOSURE_OPEN */;
		                case 'disclosure-closed':
		                    return 51 /* DISCLOSURE_CLOSED */;
		                case 'none':
		                default:
		                    return -1 /* NONE */;
		            }
		        }
		    };

		    var marginForSide = function (side) { return ({
		        name: "margin-" + side,
		        initialValue: '0',
		        prefix: false,
		        type: 4 /* TOKEN_VALUE */
		    }); };
		    var marginTop = marginForSide('top');
		    var marginRight = marginForSide('right');
		    var marginBottom = marginForSide('bottom');
		    var marginLeft = marginForSide('left');

		    var overflow = {
		        name: 'overflow',
		        initialValue: 'visible',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            return tokens.filter(isIdentToken).map(function (overflow) {
		                switch (overflow.value) {
		                    case 'hidden':
		                        return 1 /* HIDDEN */;
		                    case 'scroll':
		                        return 2 /* SCROLL */;
		                    case 'clip':
		                        return 3 /* CLIP */;
		                    case 'auto':
		                        return 4 /* AUTO */;
		                    case 'visible':
		                    default:
		                        return 0 /* VISIBLE */;
		                }
		            });
		        }
		    };

		    var overflowWrap = {
		        name: 'overflow-wrap',
		        initialValue: 'normal',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, overflow) {
		            switch (overflow) {
		                case 'break-word':
		                    return "break-word" /* BREAK_WORD */;
		                case 'normal':
		                default:
		                    return "normal" /* NORMAL */;
		            }
		        }
		    };

		    var paddingForSide = function (side) { return ({
		        name: "padding-" + side,
		        initialValue: '0',
		        prefix: false,
		        type: 3 /* TYPE_VALUE */,
		        format: 'length-percentage'
		    }); };
		    var paddingTop = paddingForSide('top');
		    var paddingRight = paddingForSide('right');
		    var paddingBottom = paddingForSide('bottom');
		    var paddingLeft = paddingForSide('left');

		    var textAlign = {
		        name: 'text-align',
		        initialValue: 'left',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, textAlign) {
		            switch (textAlign) {
		                case 'right':
		                    return 2 /* RIGHT */;
		                case 'center':
		                case 'justify':
		                    return 1 /* CENTER */;
		                case 'left':
		                default:
		                    return 0 /* LEFT */;
		            }
		        }
		    };

		    var position = {
		        name: 'position',
		        initialValue: 'static',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, position) {
		            switch (position) {
		                case 'relative':
		                    return 1 /* RELATIVE */;
		                case 'absolute':
		                    return 2 /* ABSOLUTE */;
		                case 'fixed':
		                    return 3 /* FIXED */;
		                case 'sticky':
		                    return 4 /* STICKY */;
		            }
		            return 0 /* STATIC */;
		        }
		    };

		    var textShadow = {
		        name: 'text-shadow',
		        initialValue: 'none',
		        type: 1 /* LIST */,
		        prefix: false,
		        parse: function (context, tokens) {
		            if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
		                return [];
		            }
		            return parseFunctionArgs(tokens).map(function (values) {
		                var shadow = {
		                    color: COLORS.TRANSPARENT,
		                    offsetX: ZERO_LENGTH,
		                    offsetY: ZERO_LENGTH,
		                    blur: ZERO_LENGTH
		                };
		                var c = 0;
		                for (var i = 0; i < values.length; i++) {
		                    var token = values[i];
		                    if (isLength(token)) {
		                        if (c === 0) {
		                            shadow.offsetX = token;
		                        }
		                        else if (c === 1) {
		                            shadow.offsetY = token;
		                        }
		                        else {
		                            shadow.blur = token;
		                        }
		                        c++;
		                    }
		                    else {
		                        shadow.color = color$1.parse(context, token);
		                    }
		                }
		                return shadow;
		            });
		        }
		    };

		    var textTransform = {
		        name: 'text-transform',
		        initialValue: 'none',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, textTransform) {
		            switch (textTransform) {
		                case 'uppercase':
		                    return 2 /* UPPERCASE */;
		                case 'lowercase':
		                    return 1 /* LOWERCASE */;
		                case 'capitalize':
		                    return 3 /* CAPITALIZE */;
		            }
		            return 0 /* NONE */;
		        }
		    };

		    var transform$1 = {
		        name: 'transform',
		        initialValue: 'none',
		        prefix: true,
		        type: 0 /* VALUE */,
		        parse: function (_context, token) {
		            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
		                return null;
		            }
		            if (token.type === 18 /* FUNCTION */) {
		                var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
		                if (typeof transformFunction === 'undefined') {
		                    throw new Error("Attempting to parse an unsupported transform function \"" + token.name + "\"");
		                }
		                return transformFunction(token.values);
		            }
		            return null;
		        }
		    };
		    var matrix = function (args) {
		        var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
		        return values.length === 6 ? values : null;
		    };
		    // doesn't support 3D transforms at the moment
		    var matrix3d = function (args) {
		        var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
		        var a1 = values[0], b1 = values[1]; values[2]; values[3]; var a2 = values[4], b2 = values[5]; values[6]; values[7]; values[8]; values[9]; values[10]; values[11]; var a4 = values[12], b4 = values[13]; values[14]; values[15];
		        return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
		    };
		    var SUPPORTED_TRANSFORM_FUNCTIONS = {
		        matrix: matrix,
		        matrix3d: matrix3d
		    };

		    var DEFAULT_VALUE = {
		        type: 16 /* PERCENTAGE_TOKEN */,
		        number: 50,
		        flags: FLAG_INTEGER
		    };
		    var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
		    var transformOrigin = {
		        name: 'transform-origin',
		        initialValue: '50% 50%',
		        prefix: true,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            var origins = tokens.filter(isLengthPercentage);
		            if (origins.length !== 2) {
		                return DEFAULT;
		            }
		            return [origins[0], origins[1]];
		        }
		    };

		    var visibility = {
		        name: 'visible',
		        initialValue: 'none',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, visibility) {
		            switch (visibility) {
		                case 'hidden':
		                    return 1 /* HIDDEN */;
		                case 'collapse':
		                    return 2 /* COLLAPSE */;
		                case 'visible':
		                default:
		                    return 0 /* VISIBLE */;
		            }
		        }
		    };

		    var WORD_BREAK;
		    (function (WORD_BREAK) {
		        WORD_BREAK["NORMAL"] = "normal";
		        WORD_BREAK["BREAK_ALL"] = "break-all";
		        WORD_BREAK["KEEP_ALL"] = "keep-all";
		    })(WORD_BREAK || (WORD_BREAK = {}));
		    var wordBreak = {
		        name: 'word-break',
		        initialValue: 'normal',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, wordBreak) {
		            switch (wordBreak) {
		                case 'break-all':
		                    return WORD_BREAK.BREAK_ALL;
		                case 'keep-all':
		                    return WORD_BREAK.KEEP_ALL;
		                case 'normal':
		                default:
		                    return WORD_BREAK.NORMAL;
		            }
		        }
		    };

		    var zIndex = {
		        name: 'z-index',
		        initialValue: 'auto',
		        prefix: false,
		        type: 0 /* VALUE */,
		        parse: function (_context, token) {
		            if (token.type === 20 /* IDENT_TOKEN */) {
		                return { auto: true, order: 0 };
		            }
		            if (isNumberToken(token)) {
		                return { auto: false, order: token.number };
		            }
		            throw new Error("Invalid z-index number parsed");
		        }
		    };

		    var time = {
		        name: 'time',
		        parse: function (_context, value) {
		            if (value.type === 15 /* DIMENSION_TOKEN */) {
		                switch (value.unit.toLowerCase()) {
		                    case 's':
		                        return 1000 * value.number;
		                    case 'ms':
		                        return value.number;
		                }
		            }
		            throw new Error("Unsupported time type");
		        }
		    };

		    var opacity = {
		        name: 'opacity',
		        initialValue: '1',
		        type: 0 /* VALUE */,
		        prefix: false,
		        parse: function (_context, token) {
		            if (isNumberToken(token)) {
		                return token.number;
		            }
		            return 1;
		        }
		    };

		    var textDecorationColor = {
		        name: "text-decoration-color",
		        initialValue: 'transparent',
		        prefix: false,
		        type: 3 /* TYPE_VALUE */,
		        format: 'color'
		    };

		    var textDecorationLine = {
		        name: 'text-decoration-line',
		        initialValue: 'none',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            return tokens
		                .filter(isIdentToken)
		                .map(function (token) {
		                switch (token.value) {
		                    case 'underline':
		                        return 1 /* UNDERLINE */;
		                    case 'overline':
		                        return 2 /* OVERLINE */;
		                    case 'line-through':
		                        return 3 /* LINE_THROUGH */;
		                    case 'none':
		                        return 4 /* BLINK */;
		                }
		                return 0 /* NONE */;
		            })
		                .filter(function (line) { return line !== 0 /* NONE */; });
		        }
		    };

		    var fontFamily = {
		        name: "font-family",
		        initialValue: '',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            var accumulator = [];
		            var results = [];
		            tokens.forEach(function (token) {
		                switch (token.type) {
		                    case 20 /* IDENT_TOKEN */:
		                    case 0 /* STRING_TOKEN */:
		                        accumulator.push(token.value);
		                        break;
		                    case 17 /* NUMBER_TOKEN */:
		                        accumulator.push(token.number.toString());
		                        break;
		                    case 4 /* COMMA_TOKEN */:
		                        results.push(accumulator.join(' '));
		                        accumulator.length = 0;
		                        break;
		                }
		            });
		            if (accumulator.length) {
		                results.push(accumulator.join(' '));
		            }
		            return results.map(function (result) { return (result.indexOf(' ') === -1 ? result : "'" + result + "'"); });
		        }
		    };

		    var fontSize = {
		        name: "font-size",
		        initialValue: '0',
		        prefix: false,
		        type: 3 /* TYPE_VALUE */,
		        format: 'length'
		    };

		    var fontWeight = {
		        name: 'font-weight',
		        initialValue: 'normal',
		        type: 0 /* VALUE */,
		        prefix: false,
		        parse: function (_context, token) {
		            if (isNumberToken(token)) {
		                return token.number;
		            }
		            if (isIdentToken(token)) {
		                switch (token.value) {
		                    case 'bold':
		                        return 700;
		                    case 'normal':
		                    default:
		                        return 400;
		                }
		            }
		            return 400;
		        }
		    };

		    var fontVariant = {
		        name: 'font-variant',
		        initialValue: 'none',
		        type: 1 /* LIST */,
		        prefix: false,
		        parse: function (_context, tokens) {
		            return tokens.filter(isIdentToken).map(function (token) { return token.value; });
		        }
		    };

		    var fontStyle = {
		        name: 'font-style',
		        initialValue: 'normal',
		        prefix: false,
		        type: 2 /* IDENT_VALUE */,
		        parse: function (_context, overflow) {
		            switch (overflow) {
		                case 'oblique':
		                    return "oblique" /* OBLIQUE */;
		                case 'italic':
		                    return "italic" /* ITALIC */;
		                case 'normal':
		                default:
		                    return "normal" /* NORMAL */;
		            }
		        }
		    };

		    var contains = function (bit, value) { return (bit & value) !== 0; };

		    var content = {
		        name: 'content',
		        initialValue: 'none',
		        type: 1 /* LIST */,
		        prefix: false,
		        parse: function (_context, tokens) {
		            if (tokens.length === 0) {
		                return [];
		            }
		            var first = tokens[0];
		            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
		                return [];
		            }
		            return tokens;
		        }
		    };

		    var counterIncrement = {
		        name: 'counter-increment',
		        initialValue: 'none',
		        prefix: true,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            if (tokens.length === 0) {
		                return null;
		            }
		            var first = tokens[0];
		            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
		                return null;
		            }
		            var increments = [];
		            var filtered = tokens.filter(nonWhiteSpace);
		            for (var i = 0; i < filtered.length; i++) {
		                var counter = filtered[i];
		                var next = filtered[i + 1];
		                if (counter.type === 20 /* IDENT_TOKEN */) {
		                    var increment = next && isNumberToken(next) ? next.number : 1;
		                    increments.push({ counter: counter.value, increment: increment });
		                }
		            }
		            return increments;
		        }
		    };

		    var counterReset = {
		        name: 'counter-reset',
		        initialValue: 'none',
		        prefix: true,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            if (tokens.length === 0) {
		                return [];
		            }
		            var resets = [];
		            var filtered = tokens.filter(nonWhiteSpace);
		            for (var i = 0; i < filtered.length; i++) {
		                var counter = filtered[i];
		                var next = filtered[i + 1];
		                if (isIdentToken(counter) && counter.value !== 'none') {
		                    var reset = next && isNumberToken(next) ? next.number : 0;
		                    resets.push({ counter: counter.value, reset: reset });
		                }
		            }
		            return resets;
		        }
		    };

		    var duration = {
		        name: 'duration',
		        initialValue: '0s',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (context, tokens) {
		            return tokens.filter(isDimensionToken).map(function (token) { return time.parse(context, token); });
		        }
		    };

		    var quotes = {
		        name: 'quotes',
		        initialValue: 'none',
		        prefix: true,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            if (tokens.length === 0) {
		                return null;
		            }
		            var first = tokens[0];
		            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
		                return null;
		            }
		            var quotes = [];
		            var filtered = tokens.filter(isStringToken);
		            if (filtered.length % 2 !== 0) {
		                return null;
		            }
		            for (var i = 0; i < filtered.length; i += 2) {
		                var open_1 = filtered[i].value;
		                var close_1 = filtered[i + 1].value;
		                quotes.push({ open: open_1, close: close_1 });
		            }
		            return quotes;
		        }
		    };
		    var getQuote = function (quotes, depth, open) {
		        if (!quotes) {
		            return '';
		        }
		        var quote = quotes[Math.min(depth, quotes.length - 1)];
		        if (!quote) {
		            return '';
		        }
		        return open ? quote.open : quote.close;
		    };

		    var boxShadow = {
		        name: 'box-shadow',
		        initialValue: 'none',
		        type: 1 /* LIST */,
		        prefix: false,
		        parse: function (context, tokens) {
		            if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
		                return [];
		            }
		            return parseFunctionArgs(tokens).map(function (values) {
		                var shadow = {
		                    color: 0x000000ff,
		                    offsetX: ZERO_LENGTH,
		                    offsetY: ZERO_LENGTH,
		                    blur: ZERO_LENGTH,
		                    spread: ZERO_LENGTH,
		                    inset: false
		                };
		                var c = 0;
		                for (var i = 0; i < values.length; i++) {
		                    var token = values[i];
		                    if (isIdentWithValue(token, 'inset')) {
		                        shadow.inset = true;
		                    }
		                    else if (isLength(token)) {
		                        if (c === 0) {
		                            shadow.offsetX = token;
		                        }
		                        else if (c === 1) {
		                            shadow.offsetY = token;
		                        }
		                        else if (c === 2) {
		                            shadow.blur = token;
		                        }
		                        else {
		                            shadow.spread = token;
		                        }
		                        c++;
		                    }
		                    else {
		                        shadow.color = color$1.parse(context, token);
		                    }
		                }
		                return shadow;
		            });
		        }
		    };

		    var paintOrder = {
		        name: 'paint-order',
		        initialValue: 'normal',
		        prefix: false,
		        type: 1 /* LIST */,
		        parse: function (_context, tokens) {
		            var DEFAULT_VALUE = [0 /* FILL */, 1 /* STROKE */, 2 /* MARKERS */];
		            var layers = [];
		            tokens.filter(isIdentToken).forEach(function (token) {
		                switch (token.value) {
		                    case 'stroke':
		                        layers.push(1 /* STROKE */);
		                        break;
		                    case 'fill':
		                        layers.push(0 /* FILL */);
		                        break;
		                    case 'markers':
		                        layers.push(2 /* MARKERS */);
		                        break;
		                }
		            });
		            DEFAULT_VALUE.forEach(function (value) {
		                if (layers.indexOf(value) === -1) {
		                    layers.push(value);
		                }
		            });
		            return layers;
		        }
		    };

		    var webkitTextStrokeColor = {
		        name: "-webkit-text-stroke-color",
		        initialValue: 'currentcolor',
		        prefix: false,
		        type: 3 /* TYPE_VALUE */,
		        format: 'color'
		    };

		    var webkitTextStrokeWidth = {
		        name: "-webkit-text-stroke-width",
		        initialValue: '0',
		        type: 0 /* VALUE */,
		        prefix: false,
		        parse: function (_context, token) {
		            if (isDimensionToken(token)) {
		                return token.number;
		            }
		            return 0;
		        }
		    };

		    var CSSParsedDeclaration = /** @class */ (function () {
		        function CSSParsedDeclaration(context, declaration) {
		            var _a, _b;
		            this.animationDuration = parse(context, duration, declaration.animationDuration);
		            this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
		            this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
		            this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
		            this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
		            this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
		            this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
		            this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
		            this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
		            this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
		            this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
		            this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
		            this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
		            this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
		            this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
		            this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
		            this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
		            this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
		            this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
		            this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
		            this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
		            this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
		            this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
		            this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
		            this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
		            this.color = parse(context, color, declaration.color);
		            this.direction = parse(context, direction, declaration.direction);
		            this.display = parse(context, display, declaration.display);
		            this.float = parse(context, float, declaration.cssFloat);
		            this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
		            this.fontSize = parse(context, fontSize, declaration.fontSize);
		            this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
		            this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
		            this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
		            this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
		            this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
		            this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
		            this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
		            this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
		            this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
		            this.marginTop = parse(context, marginTop, declaration.marginTop);
		            this.marginRight = parse(context, marginRight, declaration.marginRight);
		            this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
		            this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
		            this.opacity = parse(context, opacity, declaration.opacity);
		            var overflowTuple = parse(context, overflow, declaration.overflow);
		            this.overflowX = overflowTuple[0];
		            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
		            this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
		            this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
		            this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
		            this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
		            this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
		            this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
		            this.position = parse(context, position, declaration.position);
		            this.textAlign = parse(context, textAlign, declaration.textAlign);
		            this.textDecorationColor = parse(context, textDecorationColor, (_a = declaration.textDecorationColor) !== null && _a !== void 0 ? _a : declaration.color);
		            this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
		            this.textShadow = parse(context, textShadow, declaration.textShadow);
		            this.textTransform = parse(context, textTransform, declaration.textTransform);
		            this.transform = parse(context, transform$1, declaration.transform);
		            this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
		            this.visibility = parse(context, visibility, declaration.visibility);
		            this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
		            this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
		            this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
		            this.zIndex = parse(context, zIndex, declaration.zIndex);
		        }
		        CSSParsedDeclaration.prototype.isVisible = function () {
		            return this.display > 0 && this.opacity > 0 && this.visibility === 0 /* VISIBLE */;
		        };
		        CSSParsedDeclaration.prototype.isTransparent = function () {
		            return isTransparent(this.backgroundColor);
		        };
		        CSSParsedDeclaration.prototype.isTransformed = function () {
		            return this.transform !== null;
		        };
		        CSSParsedDeclaration.prototype.isPositioned = function () {
		            return this.position !== 0 /* STATIC */;
		        };
		        CSSParsedDeclaration.prototype.isPositionedWithZIndex = function () {
		            return this.isPositioned() && !this.zIndex.auto;
		        };
		        CSSParsedDeclaration.prototype.isFloating = function () {
		            return this.float !== 0 /* NONE */;
		        };
		        CSSParsedDeclaration.prototype.isInlineLevel = function () {
		            return (contains(this.display, 4 /* INLINE */) ||
		                contains(this.display, 33554432 /* INLINE_BLOCK */) ||
		                contains(this.display, 268435456 /* INLINE_FLEX */) ||
		                contains(this.display, 536870912 /* INLINE_GRID */) ||
		                contains(this.display, 67108864 /* INLINE_LIST_ITEM */) ||
		                contains(this.display, 134217728 /* INLINE_TABLE */));
		        };
		        return CSSParsedDeclaration;
		    }());
		    var CSSParsedPseudoDeclaration = /** @class */ (function () {
		        function CSSParsedPseudoDeclaration(context, declaration) {
		            this.content = parse(context, content, declaration.content);
		            this.quotes = parse(context, quotes, declaration.quotes);
		        }
		        return CSSParsedPseudoDeclaration;
		    }());
		    var CSSParsedCounterDeclaration = /** @class */ (function () {
		        function CSSParsedCounterDeclaration(context, declaration) {
		            this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
		            this.counterReset = parse(context, counterReset, declaration.counterReset);
		        }
		        return CSSParsedCounterDeclaration;
		    }());
		    // eslint-disable-next-line @typescript-eslint/no-explicit-any
		    var parse = function (context, descriptor, style) {
		        var tokenizer = new Tokenizer();
		        var value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;
		        tokenizer.write(value);
		        var parser = new Parser(tokenizer.read());
		        switch (descriptor.type) {
		            case 2 /* IDENT_VALUE */:
		                var token = parser.parseComponentValue();
		                return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
		            case 0 /* VALUE */:
		                return descriptor.parse(context, parser.parseComponentValue());
		            case 1 /* LIST */:
		                return descriptor.parse(context, parser.parseComponentValues());
		            case 4 /* TOKEN_VALUE */:
		                return parser.parseComponentValue();
		            case 3 /* TYPE_VALUE */:
		                switch (descriptor.format) {
		                    case 'angle':
		                        return angle.parse(context, parser.parseComponentValue());
		                    case 'color':
		                        return color$1.parse(context, parser.parseComponentValue());
		                    case 'image':
		                        return image.parse(context, parser.parseComponentValue());
		                    case 'length':
		                        var length_1 = parser.parseComponentValue();
		                        return isLength(length_1) ? length_1 : ZERO_LENGTH;
		                    case 'length-percentage':
		                        var value_1 = parser.parseComponentValue();
		                        return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
		                    case 'time':
		                        return time.parse(context, parser.parseComponentValue());
		                }
		                break;
		        }
		    };

		    var elementDebuggerAttribute = 'data-html2canvas-debug';
		    var getElementDebugType = function (element) {
		        var attribute = element.getAttribute(elementDebuggerAttribute);
		        switch (attribute) {
		            case 'all':
		                return 1 /* ALL */;
		            case 'clone':
		                return 2 /* CLONE */;
		            case 'parse':
		                return 3 /* PARSE */;
		            case 'render':
		                return 4 /* RENDER */;
		            default:
		                return 0 /* NONE */;
		        }
		    };
		    var isDebugging = function (element, type) {
		        var elementType = getElementDebugType(element);
		        return elementType === 1 /* ALL */ || type === elementType;
		    };

		    var ElementContainer = /** @class */ (function () {
		        function ElementContainer(context, element) {
		            this.context = context;
		            this.textNodes = [];
		            this.elements = [];
		            this.flags = 0;
		            if (isDebugging(element, 3 /* PARSE */)) {
		                debugger;
		            }
		            this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
		            if (isHTMLElementNode(element)) {
		                if (this.styles.animationDuration.some(function (duration) { return duration > 0; })) {
		                    element.style.animationDuration = '0s';
		                }
		                if (this.styles.transform !== null) {
		                    // getBoundingClientRect takes transforms into account
		                    element.style.transform = 'none';
		                }
		            }
		            this.bounds = parseBounds(this.context, element);
		            if (isDebugging(element, 4 /* RENDER */)) {
		                this.flags |= 16 /* DEBUG_RENDER */;
		            }
		        }
		        return ElementContainer;
		    }());

		    /*
		     * text-segmentation 1.0.3 <https://github.com/niklasvh/text-segmentation>
		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
		     * Released under MIT License
		     */
		    var base64 = 'AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=';

		    /*
		     * utrie 1.0.2 <https://github.com/niklasvh/utrie>
		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
		     * Released under MIT License
		     */
		    var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		    // Use a lookup table to find the index.
		    var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
		    for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
		        lookup$1[chars$1.charCodeAt(i$1)] = i$1;
		    }
		    var decode = function (base64) {
		        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
		        if (base64[base64.length - 1] === '=') {
		            bufferLength--;
		            if (base64[base64.length - 2] === '=') {
		                bufferLength--;
		            }
		        }
		        var buffer = typeof ArrayBuffer !== 'undefined' &&
		            typeof Uint8Array !== 'undefined' &&
		            typeof Uint8Array.prototype.slice !== 'undefined'
		            ? new ArrayBuffer(bufferLength)
		            : new Array(bufferLength);
		        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
		        for (i = 0; i < len; i += 4) {
		            encoded1 = lookup$1[base64.charCodeAt(i)];
		            encoded2 = lookup$1[base64.charCodeAt(i + 1)];
		            encoded3 = lookup$1[base64.charCodeAt(i + 2)];
		            encoded4 = lookup$1[base64.charCodeAt(i + 3)];
		            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
		            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
		            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
		        }
		        return buffer;
		    };
		    var polyUint16Array = function (buffer) {
		        var length = buffer.length;
		        var bytes = [];
		        for (var i = 0; i < length; i += 2) {
		            bytes.push((buffer[i + 1] << 8) | buffer[i]);
		        }
		        return bytes;
		    };
		    var polyUint32Array = function (buffer) {
		        var length = buffer.length;
		        var bytes = [];
		        for (var i = 0; i < length; i += 4) {
		            bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
		        }
		        return bytes;
		    };

		    /** Shift size for getting the index-2 table offset. */
		    var UTRIE2_SHIFT_2 = 5;
		    /** Shift size for getting the index-1 table offset. */
		    var UTRIE2_SHIFT_1 = 6 + 5;
		    /**
		     * Shift size for shifting left the index array values.
		     * Increases possible data size with 16-bit index values at the cost
		     * of compactability.
		     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
		     */
		    var UTRIE2_INDEX_SHIFT = 2;
		    /**
		     * Difference between the two shift sizes,
		     * for getting an index-1 offset from an index-2 offset. 6=11-5
		     */
		    var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
		    /**
		     * The part of the index-2 table for U+D800..U+DBFF stores values for
		     * lead surrogate code _units_ not code _points_.
		     * Values for lead surrogate code _points_ are indexed with this portion of the table.
		     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
		     */
		    var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;
		    /** Number of entries in a data block. 32=0x20 */
		    var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
		    /** Mask for getting the lower bits for the in-data-block offset. */
		    var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
		    var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
		    /** Count the lengths of both BMP pieces. 2080=0x820 */
		    var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
		    /**
		     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
		     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
		     */
		    var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
		    var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
		    /**
		     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
		     * Variable length, for code points up to highStart, where the last single-value range starts.
		     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
		     * (For 0x100000 supplementary code points U+10000..U+10ffff.)
		     *
		     * The part of the index-2 table for supplementary code points starts
		     * after this index-1 table.
		     *
		     * Both the index-1 table and the following part of the index-2 table
		     * are omitted completely if there is only BMP data.
		     */
		    var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
		    /**
		     * Number of index-1 entries for the BMP. 32=0x20
		     * This part of the index-1 table is omitted from the serialized form.
		     */
		    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;
		    /** Number of entries in an index-2 block. 64=0x40 */
		    var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
		    /** Mask for getting the lower bits for the in-index-2-block offset. */
		    var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
		    var slice16 = function (view, start, end) {
		        if (view.slice) {
		            return view.slice(start, end);
		        }
		        return new Uint16Array(Array.prototype.slice.call(view, start, end));
		    };
		    var slice32 = function (view, start, end) {
		        if (view.slice) {
		            return view.slice(start, end);
		        }
		        return new Uint32Array(Array.prototype.slice.call(view, start, end));
		    };
		    var createTrieFromBase64 = function (base64, _byteLength) {
		        var buffer = decode(base64);
		        var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
		        var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
		        var headerLength = 24;
		        var index = slice16(view16, headerLength / 2, view32[4] / 2);
		        var data = view32[5] === 2
		            ? slice16(view16, (headerLength + view32[4]) / 2)
		            : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
		        return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
		    };
		    var Trie = /** @class */ (function () {
		        function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
		            this.initialValue = initialValue;
		            this.errorValue = errorValue;
		            this.highStart = highStart;
		            this.highValueIndex = highValueIndex;
		            this.index = index;
		            this.data = data;
		        }
		        /**
		         * Get the value for a code point as stored in the Trie.
		         *
		         * @param codePoint the code point
		         * @return the value
		         */
		        Trie.prototype.get = function (codePoint) {
		            var ix;
		            if (codePoint >= 0) {
		                if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
		                    // Ordinary BMP code point, excluding leading surrogates.
		                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
		                    // 16 bit data is stored in the index array itself.
		                    ix = this.index[codePoint >> UTRIE2_SHIFT_2];
		                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
		                    return this.data[ix];
		                }
		                if (codePoint <= 0xffff) {
		                    // Lead Surrogate Code Point.  A Separate index section is stored for
		                    // lead surrogate code units and code points.
		                    //   The main index has the code unit data.
		                    //   For this function, we need the code point data.
		                    // Note: this expression could be refactored for slightly improved efficiency, but
		                    //       surrogate code points will be so rare in practice that it's not worth it.
		                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];
		                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
		                    return this.data[ix];
		                }
		                if (codePoint < this.highStart) {
		                    // Supplemental code point, use two-level lookup.
		                    ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
		                    ix = this.index[ix];
		                    ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;
		                    ix = this.index[ix];
		                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
		                    return this.data[ix];
		                }
		                if (codePoint <= 0x10ffff) {
		                    return this.data[this.highValueIndex];
		                }
		            }
		            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
		            return this.errorValue;
		        };
		        return Trie;
		    }());

		    /*
		     * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
		     * Released under MIT License
		     */
		    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		    // Use a lookup table to find the index.
		    var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
		    for (var i = 0; i < chars.length; i++) {
		        lookup[chars.charCodeAt(i)] = i;
		    }

		    var Prepend = 1;
		    var CR = 2;
		    var LF = 3;
		    var Control = 4;
		    var Extend = 5;
		    var SpacingMark = 7;
		    var L = 8;
		    var V = 9;
		    var T = 10;
		    var LV = 11;
		    var LVT = 12;
		    var ZWJ = 13;
		    var Extended_Pictographic = 14;
		    var RI = 15;
		    var toCodePoints = function (str) {
		        var codePoints = [];
		        var i = 0;
		        var length = str.length;
		        while (i < length) {
		            var value = str.charCodeAt(i++);
		            if (value >= 0xd800 && value <= 0xdbff && i < length) {
		                var extra = str.charCodeAt(i++);
		                if ((extra & 0xfc00) === 0xdc00) {
		                    codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
		                }
		                else {
		                    codePoints.push(value);
		                    i--;
		                }
		            }
		            else {
		                codePoints.push(value);
		            }
		        }
		        return codePoints;
		    };
		    var fromCodePoint = function () {
		        var codePoints = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            codePoints[_i] = arguments[_i];
		        }
		        if (String.fromCodePoint) {
		            return String.fromCodePoint.apply(String, codePoints);
		        }
		        var length = codePoints.length;
		        if (!length) {
		            return '';
		        }
		        var codeUnits = [];
		        var index = -1;
		        var result = '';
		        while (++index < length) {
		            var codePoint = codePoints[index];
		            if (codePoint <= 0xffff) {
		                codeUnits.push(codePoint);
		            }
		            else {
		                codePoint -= 0x10000;
		                codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
		            }
		            if (index + 1 === length || codeUnits.length > 0x4000) {
		                result += String.fromCharCode.apply(String, codeUnits);
		                codeUnits.length = 0;
		            }
		        }
		        return result;
		    };
		    var UnicodeTrie = createTrieFromBase64(base64);
		    var BREAK_NOT_ALLOWED = '×';
		    var BREAK_ALLOWED = '÷';
		    var codePointToClass = function (codePoint) { return UnicodeTrie.get(codePoint); };
		    var _graphemeBreakAtIndex = function (_codePoints, classTypes, index) {
		        var prevIndex = index - 2;
		        var prev = classTypes[prevIndex];
		        var current = classTypes[index - 1];
		        var next = classTypes[index];
		        // GB3 Do not break between a CR and LF
		        if (current === CR && next === LF) {
		            return BREAK_NOT_ALLOWED;
		        }
		        // GB4 Otherwise, break before and after controls.
		        if (current === CR || current === LF || current === Control) {
		            return BREAK_ALLOWED;
		        }
		        // GB5
		        if (next === CR || next === LF || next === Control) {
		            return BREAK_ALLOWED;
		        }
		        // Do not break Hangul syllable sequences.
		        // GB6
		        if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
		            return BREAK_NOT_ALLOWED;
		        }
		        // GB7
		        if ((current === LV || current === V) && (next === V || next === T)) {
		            return BREAK_NOT_ALLOWED;
		        }
		        // GB8
		        if ((current === LVT || current === T) && next === T) {
		            return BREAK_NOT_ALLOWED;
		        }
		        // GB9 Do not break before extending characters or ZWJ.
		        if (next === ZWJ || next === Extend) {
		            return BREAK_NOT_ALLOWED;
		        }
		        // Do not break before SpacingMarks, or after Prepend characters.
		        // GB9a
		        if (next === SpacingMark) {
		            return BREAK_NOT_ALLOWED;
		        }
		        // GB9a
		        if (current === Prepend) {
		            return BREAK_NOT_ALLOWED;
		        }
		        // GB11 Do not break within emoji modifier sequences or emoji zwj sequences.
		        if (current === ZWJ && next === Extended_Pictographic) {
		            while (prev === Extend) {
		                prev = classTypes[--prevIndex];
		            }
		            if (prev === Extended_Pictographic) {
		                return BREAK_NOT_ALLOWED;
		            }
		        }
		        // GB12 Do not break within emoji flag sequences.
		        // That is, do not break between regional indicator (RI) symbols
		        // if there is an odd number of RI characters before the break point.
		        if (current === RI && next === RI) {
		            var countRI = 0;
		            while (prev === RI) {
		                countRI++;
		                prev = classTypes[--prevIndex];
		            }
		            if (countRI % 2 === 0) {
		                return BREAK_NOT_ALLOWED;
		            }
		        }
		        return BREAK_ALLOWED;
		    };
		    var GraphemeBreaker = function (str) {
		        var codePoints = toCodePoints(str);
		        var length = codePoints.length;
		        var index = 0;
		        var lastEnd = 0;
		        var classTypes = codePoints.map(codePointToClass);
		        return {
		            next: function () {
		                if (index >= length) {
		                    return { done: true, value: null };
		                }
		                var graphemeBreak = BREAK_NOT_ALLOWED;
		                while (index < length &&
		                    (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) { }
		                if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
		                    var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
		                    lastEnd = index;
		                    return { value: value, done: false };
		                }
		                return { done: true, value: null };
		            },
		        };
		    };
		    var splitGraphemes = function (str) {
		        var breaker = GraphemeBreaker(str);
		        var graphemes = [];
		        var bk;
		        while (!(bk = breaker.next()).done) {
		            if (bk.value) {
		                graphemes.push(bk.value.slice());
		            }
		        }
		        return graphemes;
		    };

		    var testRangeBounds = function (document) {
		        var TEST_HEIGHT = 123;
		        if (document.createRange) {
		            var range = document.createRange();
		            if (range.getBoundingClientRect) {
		                var testElement = document.createElement('boundtest');
		                testElement.style.height = TEST_HEIGHT + "px";
		                testElement.style.display = 'block';
		                document.body.appendChild(testElement);
		                range.selectNode(testElement);
		                var rangeBounds = range.getBoundingClientRect();
		                var rangeHeight = Math.round(rangeBounds.height);
		                document.body.removeChild(testElement);
		                if (rangeHeight === TEST_HEIGHT) {
		                    return true;
		                }
		            }
		        }
		        return false;
		    };
		    var testIOSLineBreak = function (document) {
		        var testElement = document.createElement('boundtest');
		        testElement.style.width = '50px';
		        testElement.style.display = 'block';
		        testElement.style.fontSize = '12px';
		        testElement.style.letterSpacing = '0px';
		        testElement.style.wordSpacing = '0px';
		        document.body.appendChild(testElement);
		        var range = document.createRange();
		        testElement.innerHTML = typeof ''.repeat === 'function' ? '&#128104;'.repeat(10) : '';
		        var node = testElement.firstChild;
		        var textList = toCodePoints$1(node.data).map(function (i) { return fromCodePoint$1(i); });
		        var offset = 0;
		        var prev = {};
		        // ios 13 does not handle range getBoundingClientRect line changes correctly #2177
		        var supports = textList.every(function (text, i) {
		            range.setStart(node, offset);
		            range.setEnd(node, offset + text.length);
		            var rect = range.getBoundingClientRect();
		            offset += text.length;
		            var boundAhead = rect.x > prev.x || rect.y > prev.y;
		            prev = rect;
		            if (i === 0) {
		                return true;
		            }
		            return boundAhead;
		        });
		        document.body.removeChild(testElement);
		        return supports;
		    };
		    var testCORS = function () { return typeof new Image().crossOrigin !== 'undefined'; };
		    var testResponseType = function () { return typeof new XMLHttpRequest().responseType === 'string'; };
		    var testSVG = function (document) {
		        var img = new Image();
		        var canvas = document.createElement('canvas');
		        var ctx = canvas.getContext('2d');
		        if (!ctx) {
		            return false;
		        }
		        img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
		        try {
		            ctx.drawImage(img, 0, 0);
		            canvas.toDataURL();
		        }
		        catch (e) {
		            return false;
		        }
		        return true;
		    };
		    var isGreenPixel = function (data) {
		        return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
		    };
		    var testForeignObject = function (document) {
		        var canvas = document.createElement('canvas');
		        var size = 100;
		        canvas.width = size;
		        canvas.height = size;
		        var ctx = canvas.getContext('2d');
		        if (!ctx) {
		            return Promise.reject(false);
		        }
		        ctx.fillStyle = 'rgb(0, 255, 0)';
		        ctx.fillRect(0, 0, size, size);
		        var img = new Image();
		        var greenImageSrc = canvas.toDataURL();
		        img.src = greenImageSrc;
		        var svg = createForeignObjectSVG(size, size, 0, 0, img);
		        ctx.fillStyle = 'red';
		        ctx.fillRect(0, 0, size, size);
		        return loadSerializedSVG$1(svg)
		            .then(function (img) {
		            ctx.drawImage(img, 0, 0);
		            var data = ctx.getImageData(0, 0, size, size).data;
		            ctx.fillStyle = 'red';
		            ctx.fillRect(0, 0, size, size);
		            var node = document.createElement('div');
		            node.style.backgroundImage = "url(" + greenImageSrc + ")";
		            node.style.height = size + "px";
		            // Firefox 55 does not render inline <img /> tags
		            return isGreenPixel(data)
		                ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node))
		                : Promise.reject(false);
		        })
		            .then(function (img) {
		            ctx.drawImage(img, 0, 0);
		            // Edge does not render background-images
		            return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
		        })
		            .catch(function () { return false; });
		    };
		    var createForeignObjectSVG = function (width, height, x, y, node) {
		        var xmlns = 'http://www.w3.org/2000/svg';
		        var svg = document.createElementNS(xmlns, 'svg');
		        var foreignObject = document.createElementNS(xmlns, 'foreignObject');
		        svg.setAttributeNS(null, 'width', width.toString());
		        svg.setAttributeNS(null, 'height', height.toString());
		        foreignObject.setAttributeNS(null, 'width', '100%');
		        foreignObject.setAttributeNS(null, 'height', '100%');
		        foreignObject.setAttributeNS(null, 'x', x.toString());
		        foreignObject.setAttributeNS(null, 'y', y.toString());
		        foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
		        svg.appendChild(foreignObject);
		        foreignObject.appendChild(node);
		        return svg;
		    };
		    var loadSerializedSVG$1 = function (svg) {
		        return new Promise(function (resolve, reject) {
		            var img = new Image();
		            img.onload = function () { return resolve(img); };
		            img.onerror = reject;
		            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
		        });
		    };
		    var FEATURES = {
		        get SUPPORT_RANGE_BOUNDS() {
		            var value = testRangeBounds(document);
		            Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });
		            return value;
		        },
		        get SUPPORT_WORD_BREAKING() {
		            var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
		            Object.defineProperty(FEATURES, 'SUPPORT_WORD_BREAKING', { value: value });
		            return value;
		        },
		        get SUPPORT_SVG_DRAWING() {
		            var value = testSVG(document);
		            Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });
		            return value;
		        },
		        get SUPPORT_FOREIGNOBJECT_DRAWING() {
		            var value = typeof Array.from === 'function' && typeof window.fetch === 'function'
		                ? testForeignObject(document)
		                : Promise.resolve(false);
		            Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });
		            return value;
		        },
		        get SUPPORT_CORS_IMAGES() {
		            var value = testCORS();
		            Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });
		            return value;
		        },
		        get SUPPORT_RESPONSE_TYPE() {
		            var value = testResponseType();
		            Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });
		            return value;
		        },
		        get SUPPORT_CORS_XHR() {
		            var value = 'withCredentials' in new XMLHttpRequest();
		            Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });
		            return value;
		        },
		        get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
		            var value = !!(typeof Intl !== 'undefined' && Intl.Segmenter);
		            Object.defineProperty(FEATURES, 'SUPPORT_NATIVE_TEXT_SEGMENTATION', { value: value });
		            return value;
		        }
		    };

		    var TextBounds = /** @class */ (function () {
		        function TextBounds(text, bounds) {
		            this.text = text;
		            this.bounds = bounds;
		        }
		        return TextBounds;
		    }());
		    var parseTextBounds = function (context, value, styles, node) {
		        var textList = breakText(value, styles);
		        var textBounds = [];
		        var offset = 0;
		        textList.forEach(function (text) {
		            if (styles.textDecorationLine.length || text.trim().length > 0) {
		                if (FEATURES.SUPPORT_RANGE_BOUNDS) {
		                    var clientRects = createRange(node, offset, text.length).getClientRects();
		                    if (clientRects.length > 1) {
		                        var subSegments = segmentGraphemes(text);
		                        var subOffset_1 = 0;
		                        subSegments.forEach(function (subSegment) {
		                            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
		                            subOffset_1 += subSegment.length;
		                        });
		                    }
		                    else {
		                        textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
		                    }
		                }
		                else {
		                    var replacementNode = node.splitText(text.length);
		                    textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
		                    node = replacementNode;
		                }
		            }
		            else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
		                node = node.splitText(text.length);
		            }
		            offset += text.length;
		        });
		        return textBounds;
		    };
		    var getWrapperBounds = function (context, node) {
		        var ownerDocument = node.ownerDocument;
		        if (ownerDocument) {
		            var wrapper = ownerDocument.createElement('html2canvaswrapper');
		            wrapper.appendChild(node.cloneNode(true));
		            var parentNode = node.parentNode;
		            if (parentNode) {
		                parentNode.replaceChild(wrapper, node);
		                var bounds = parseBounds(context, wrapper);
		                if (wrapper.firstChild) {
		                    parentNode.replaceChild(wrapper.firstChild, wrapper);
		                }
		                return bounds;
		            }
		        }
		        return Bounds.EMPTY;
		    };
		    var createRange = function (node, offset, length) {
		        var ownerDocument = node.ownerDocument;
		        if (!ownerDocument) {
		            throw new Error('Node has no owner document');
		        }
		        var range = ownerDocument.createRange();
		        range.setStart(node, offset);
		        range.setEnd(node, offset + length);
		        return range;
		    };
		    var segmentGraphemes = function (value) {
		        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
		            var segmenter = new Intl.Segmenter(void 0, { granularity: 'grapheme' });
		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
		            return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
		        }
		        return splitGraphemes(value);
		    };
		    var segmentWords = function (value, styles) {
		        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
		            var segmenter = new Intl.Segmenter(void 0, {
		                granularity: 'word'
		            });
		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
		            return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
		        }
		        return breakWords(value, styles);
		    };
		    var breakText = function (value, styles) {
		        return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
		    };
		    // https://drafts.csswg.org/css-text/#word-separator
		    var wordSeparators = [0x0020, 0x00a0, 0x1361, 0x10100, 0x10101, 0x1039, 0x1091];
		    var breakWords = function (str, styles) {
		        var breaker = LineBreaker(str, {
		            lineBreak: styles.lineBreak,
		            wordBreak: styles.overflowWrap === "break-word" /* BREAK_WORD */ ? 'break-word' : styles.wordBreak
		        });
		        var words = [];
		        var bk;
		        var _loop_1 = function () {
		            if (bk.value) {
		                var value = bk.value.slice();
		                var codePoints = toCodePoints$1(value);
		                var word_1 = '';
		                codePoints.forEach(function (codePoint) {
		                    if (wordSeparators.indexOf(codePoint) === -1) {
		                        word_1 += fromCodePoint$1(codePoint);
		                    }
		                    else {
		                        if (word_1.length) {
		                            words.push(word_1);
		                        }
		                        words.push(fromCodePoint$1(codePoint));
		                        word_1 = '';
		                    }
		                });
		                if (word_1.length) {
		                    words.push(word_1);
		                }
		            }
		        };
		        while (!(bk = breaker.next()).done) {
		            _loop_1();
		        }
		        return words;
		    };

		    var TextContainer = /** @class */ (function () {
		        function TextContainer(context, node, styles) {
		            this.text = transform(node.data, styles.textTransform);
		            this.textBounds = parseTextBounds(context, this.text, styles, node);
		        }
		        return TextContainer;
		    }());
		    var transform = function (text, transform) {
		        switch (transform) {
		            case 1 /* LOWERCASE */:
		                return text.toLowerCase();
		            case 3 /* CAPITALIZE */:
		                return text.replace(CAPITALIZE, capitalize);
		            case 2 /* UPPERCASE */:
		                return text.toUpperCase();
		            default:
		                return text;
		        }
		    };
		    var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
		    var capitalize = function (m, p1, p2) {
		        if (m.length > 0) {
		            return p1 + p2.toUpperCase();
		        }
		        return m;
		    };

		    var ImageElementContainer = /** @class */ (function (_super) {
		        __extends(ImageElementContainer, _super);
		        function ImageElementContainer(context, img) {
		            var _this = _super.call(this, context, img) || this;
		            _this.src = img.currentSrc || img.src;
		            _this.intrinsicWidth = img.naturalWidth;
		            _this.intrinsicHeight = img.naturalHeight;
		            _this.context.cache.addImage(_this.src);
		            return _this;
		        }
		        return ImageElementContainer;
		    }(ElementContainer));

		    var CanvasElementContainer = /** @class */ (function (_super) {
		        __extends(CanvasElementContainer, _super);
		        function CanvasElementContainer(context, canvas) {
		            var _this = _super.call(this, context, canvas) || this;
		            _this.canvas = canvas;
		            _this.intrinsicWidth = canvas.width;
		            _this.intrinsicHeight = canvas.height;
		            return _this;
		        }
		        return CanvasElementContainer;
		    }(ElementContainer));

		    var SVGElementContainer = /** @class */ (function (_super) {
		        __extends(SVGElementContainer, _super);
		        function SVGElementContainer(context, img) {
		            var _this = _super.call(this, context, img) || this;
		            var s = new XMLSerializer();
		            var bounds = parseBounds(context, img);
		            img.setAttribute('width', bounds.width + "px");
		            img.setAttribute('height', bounds.height + "px");
		            _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
		            _this.intrinsicWidth = img.width.baseVal.value;
		            _this.intrinsicHeight = img.height.baseVal.value;
		            _this.context.cache.addImage(_this.svg);
		            return _this;
		        }
		        return SVGElementContainer;
		    }(ElementContainer));

		    var LIElementContainer = /** @class */ (function (_super) {
		        __extends(LIElementContainer, _super);
		        function LIElementContainer(context, element) {
		            var _this = _super.call(this, context, element) || this;
		            _this.value = element.value;
		            return _this;
		        }
		        return LIElementContainer;
		    }(ElementContainer));

		    var OLElementContainer = /** @class */ (function (_super) {
		        __extends(OLElementContainer, _super);
		        function OLElementContainer(context, element) {
		            var _this = _super.call(this, context, element) || this;
		            _this.start = element.start;
		            _this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;
		            return _this;
		        }
		        return OLElementContainer;
		    }(ElementContainer));

		    var CHECKBOX_BORDER_RADIUS = [
		        {
		            type: 15 /* DIMENSION_TOKEN */,
		            flags: 0,
		            unit: 'px',
		            number: 3
		        }
		    ];
		    var RADIO_BORDER_RADIUS = [
		        {
		            type: 16 /* PERCENTAGE_TOKEN */,
		            flags: 0,
		            number: 50
		        }
		    ];
		    var reformatInputBounds = function (bounds) {
		        if (bounds.width > bounds.height) {
		            return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
		        }
		        else if (bounds.width < bounds.height) {
		            return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
		        }
		        return bounds;
		    };
		    var getInputValue = function (node) {
		        var value = node.type === PASSWORD ? new Array(node.value.length + 1).join('\u2022') : node.value;
		        return value.length === 0 ? node.placeholder || '' : value;
		    };
		    var CHECKBOX = 'checkbox';
		    var RADIO = 'radio';
		    var PASSWORD = 'password';
		    var INPUT_COLOR = 0x2a2a2aff;
		    var InputElementContainer = /** @class */ (function (_super) {
		        __extends(InputElementContainer, _super);
		        function InputElementContainer(context, input) {
		            var _this = _super.call(this, context, input) || this;
		            _this.type = input.type.toLowerCase();
		            _this.checked = input.checked;
		            _this.value = getInputValue(input);
		            if (_this.type === CHECKBOX || _this.type === RADIO) {
		                _this.styles.backgroundColor = 0xdededeff;
		                _this.styles.borderTopColor =
		                    _this.styles.borderRightColor =
		                        _this.styles.borderBottomColor =
		                            _this.styles.borderLeftColor =
		                                0xa5a5a5ff;
		                _this.styles.borderTopWidth =
		                    _this.styles.borderRightWidth =
		                        _this.styles.borderBottomWidth =
		                            _this.styles.borderLeftWidth =
		                                1;
		                _this.styles.borderTopStyle =
		                    _this.styles.borderRightStyle =
		                        _this.styles.borderBottomStyle =
		                            _this.styles.borderLeftStyle =
		                                1 /* SOLID */;
		                _this.styles.backgroundClip = [0 /* BORDER_BOX */];
		                _this.styles.backgroundOrigin = [0 /* BORDER_BOX */];
		                _this.bounds = reformatInputBounds(_this.bounds);
		            }
		            switch (_this.type) {
		                case CHECKBOX:
		                    _this.styles.borderTopRightRadius =
		                        _this.styles.borderTopLeftRadius =
		                            _this.styles.borderBottomRightRadius =
		                                _this.styles.borderBottomLeftRadius =
		                                    CHECKBOX_BORDER_RADIUS;
		                    break;
		                case RADIO:
		                    _this.styles.borderTopRightRadius =
		                        _this.styles.borderTopLeftRadius =
		                            _this.styles.borderBottomRightRadius =
		                                _this.styles.borderBottomLeftRadius =
		                                    RADIO_BORDER_RADIUS;
		                    break;
		            }
		            return _this;
		        }
		        return InputElementContainer;
		    }(ElementContainer));

		    var SelectElementContainer = /** @class */ (function (_super) {
		        __extends(SelectElementContainer, _super);
		        function SelectElementContainer(context, element) {
		            var _this = _super.call(this, context, element) || this;
		            var option = element.options[element.selectedIndex || 0];
		            _this.value = option ? option.text || '' : '';
		            return _this;
		        }
		        return SelectElementContainer;
		    }(ElementContainer));

		    var TextareaElementContainer = /** @class */ (function (_super) {
		        __extends(TextareaElementContainer, _super);
		        function TextareaElementContainer(context, element) {
		            var _this = _super.call(this, context, element) || this;
		            _this.value = element.value;
		            return _this;
		        }
		        return TextareaElementContainer;
		    }(ElementContainer));

		    var IFrameElementContainer = /** @class */ (function (_super) {
		        __extends(IFrameElementContainer, _super);
		        function IFrameElementContainer(context, iframe) {
		            var _this = _super.call(this, context, iframe) || this;
		            _this.src = iframe.src;
		            _this.width = parseInt(iframe.width, 10) || 0;
		            _this.height = parseInt(iframe.height, 10) || 0;
		            _this.backgroundColor = _this.styles.backgroundColor;
		            try {
		                if (iframe.contentWindow &&
		                    iframe.contentWindow.document &&
		                    iframe.contentWindow.document.documentElement) {
		                    _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
		                    // http://www.w3.org/TR/css3-background/#special-backgrounds
		                    var documentBackgroundColor = iframe.contentWindow.document.documentElement
		                        ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor)
		                        : COLORS.TRANSPARENT;
		                    var bodyBackgroundColor = iframe.contentWindow.document.body
		                        ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor)
		                        : COLORS.TRANSPARENT;
		                    _this.backgroundColor = isTransparent(documentBackgroundColor)
		                        ? isTransparent(bodyBackgroundColor)
		                            ? _this.styles.backgroundColor
		                            : bodyBackgroundColor
		                        : documentBackgroundColor;
		                }
		            }
		            catch (e) { }
		            return _this;
		        }
		        return IFrameElementContainer;
		    }(ElementContainer));

		    var LIST_OWNERS = ['OL', 'UL', 'MENU'];
		    var parseNodeTree = function (context, node, parent, root) {
		        for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
		            nextNode = childNode.nextSibling;
		            if (isTextNode(childNode) && childNode.data.trim().length > 0) {
		                parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
		            }
		            else if (isElementNode(childNode)) {
		                if (isSlotElement(childNode) && childNode.assignedNodes) {
		                    childNode.assignedNodes().forEach(function (childNode) { return parseNodeTree(context, childNode, parent, root); });
		                }
		                else {
		                    var container = createContainer(context, childNode);
		                    if (container.styles.isVisible()) {
		                        if (createsRealStackingContext(childNode, container, root)) {
		                            container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
		                        }
		                        else if (createsStackingContext(container.styles)) {
		                            container.flags |= 2 /* CREATES_STACKING_CONTEXT */;
		                        }
		                        if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
		                            container.flags |= 8 /* IS_LIST_OWNER */;
		                        }
		                        parent.elements.push(container);
		                        childNode.slot;
		                        if (childNode.shadowRoot) {
		                            parseNodeTree(context, childNode.shadowRoot, container, root);
		                        }
		                        else if (!isTextareaElement(childNode) &&
		                            !isSVGElement(childNode) &&
		                            !isSelectElement(childNode)) {
		                            parseNodeTree(context, childNode, container, root);
		                        }
		                    }
		                }
		            }
		        }
		    };
		    var createContainer = function (context, element) {
		        if (isImageElement(element)) {
		            return new ImageElementContainer(context, element);
		        }
		        if (isCanvasElement(element)) {
		            return new CanvasElementContainer(context, element);
		        }
		        if (isSVGElement(element)) {
		            return new SVGElementContainer(context, element);
		        }
		        if (isLIElement(element)) {
		            return new LIElementContainer(context, element);
		        }
		        if (isOLElement(element)) {
		            return new OLElementContainer(context, element);
		        }
		        if (isInputElement(element)) {
		            return new InputElementContainer(context, element);
		        }
		        if (isSelectElement(element)) {
		            return new SelectElementContainer(context, element);
		        }
		        if (isTextareaElement(element)) {
		            return new TextareaElementContainer(context, element);
		        }
		        if (isIFrameElement(element)) {
		            return new IFrameElementContainer(context, element);
		        }
		        return new ElementContainer(context, element);
		    };
		    var parseTree = function (context, element) {
		        var container = createContainer(context, element);
		        container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
		        parseNodeTree(context, element, container, container);
		        return container;
		    };
		    var createsRealStackingContext = function (node, container, root) {
		        return (container.styles.isPositionedWithZIndex() ||
		            container.styles.opacity < 1 ||
		            container.styles.isTransformed() ||
		            (isBodyElement(node) && root.styles.isTransparent()));
		    };
		    var createsStackingContext = function (styles) { return styles.isPositioned() || styles.isFloating(); };
		    var isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
		    var isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
		    var isHTMLElementNode = function (node) {
		        return isElementNode(node) && typeof node.style !== 'undefined' && !isSVGElementNode(node);
		    };
		    var isSVGElementNode = function (element) {
		        return typeof element.className === 'object';
		    };
		    var isLIElement = function (node) { return node.tagName === 'LI'; };
		    var isOLElement = function (node) { return node.tagName === 'OL'; };
		    var isInputElement = function (node) { return node.tagName === 'INPUT'; };
		    var isHTMLElement = function (node) { return node.tagName === 'HTML'; };
		    var isSVGElement = function (node) { return node.tagName === 'svg'; };
		    var isBodyElement = function (node) { return node.tagName === 'BODY'; };
		    var isCanvasElement = function (node) { return node.tagName === 'CANVAS'; };
		    var isVideoElement = function (node) { return node.tagName === 'VIDEO'; };
		    var isImageElement = function (node) { return node.tagName === 'IMG'; };
		    var isIFrameElement = function (node) { return node.tagName === 'IFRAME'; };
		    var isStyleElement = function (node) { return node.tagName === 'STYLE'; };
		    var isScriptElement = function (node) { return node.tagName === 'SCRIPT'; };
		    var isTextareaElement = function (node) { return node.tagName === 'TEXTAREA'; };
		    var isSelectElement = function (node) { return node.tagName === 'SELECT'; };
		    var isSlotElement = function (node) { return node.tagName === 'SLOT'; };
		    // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
		    var isCustomElement = function (node) { return node.tagName.indexOf('-') > 0; };

		    var CounterState = /** @class */ (function () {
		        function CounterState() {
		            this.counters = {};
		        }
		        CounterState.prototype.getCounterValue = function (name) {
		            var counter = this.counters[name];
		            if (counter && counter.length) {
		                return counter[counter.length - 1];
		            }
		            return 1;
		        };
		        CounterState.prototype.getCounterValues = function (name) {
		            var counter = this.counters[name];
		            return counter ? counter : [];
		        };
		        CounterState.prototype.pop = function (counters) {
		            var _this = this;
		            counters.forEach(function (counter) { return _this.counters[counter].pop(); });
		        };
		        CounterState.prototype.parse = function (style) {
		            var _this = this;
		            var counterIncrement = style.counterIncrement;
		            var counterReset = style.counterReset;
		            var canReset = true;
		            if (counterIncrement !== null) {
		                counterIncrement.forEach(function (entry) {
		                    var counter = _this.counters[entry.counter];
		                    if (counter && entry.increment !== 0) {
		                        canReset = false;
		                        if (!counter.length) {
		                            counter.push(1);
		                        }
		                        counter[Math.max(0, counter.length - 1)] += entry.increment;
		                    }
		                });
		            }
		            var counterNames = [];
		            if (canReset) {
		                counterReset.forEach(function (entry) {
		                    var counter = _this.counters[entry.counter];
		                    counterNames.push(entry.counter);
		                    if (!counter) {
		                        counter = _this.counters[entry.counter] = [];
		                    }
		                    counter.push(entry.reset);
		                });
		            }
		            return counterNames;
		        };
		        return CounterState;
		    }());
		    var ROMAN_UPPER = {
		        integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
		        values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
		    };
		    var ARMENIAN = {
		        integers: [
		            9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70,
		            60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
		        ],
		        values: [
		            'Ք',
		            'Փ',
		            'Ւ',
		            'Ց',
		            'Ր',
		            'Տ',
		            'Վ',
		            'Ս',
		            'Ռ',
		            'Ջ',
		            'Պ',
		            'Չ',
		            'Ո',
		            'Շ',
		            'Ն',
		            'Յ',
		            'Մ',
		            'Ճ',
		            'Ղ',
		            'Ձ',
		            'Հ',
		            'Կ',
		            'Ծ',
		            'Խ',
		            'Լ',
		            'Ի',
		            'Ժ',
		            'Թ',
		            'Ը',
		            'Է',
		            'Զ',
		            'Ե',
		            'Դ',
		            'Գ',
		            'Բ',
		            'Ա'
		        ]
		    };
		    var HEBREW = {
		        integers: [
		            10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20,
		            19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
		        ],
		        values: [
		            'י׳',
		            'ט׳',
		            'ח׳',
		            'ז׳',
		            'ו׳',
		            'ה׳',
		            'ד׳',
		            'ג׳',
		            'ב׳',
		            'א׳',
		            'ת',
		            'ש',
		            'ר',
		            'ק',
		            'צ',
		            'פ',
		            'ע',
		            'ס',
		            'נ',
		            'מ',
		            'ל',
		            'כ',
		            'יט',
		            'יח',
		            'יז',
		            'טז',
		            'טו',
		            'י',
		            'ט',
		            'ח',
		            'ז',
		            'ו',
		            'ה',
		            'ד',
		            'ג',
		            'ב',
		            'א'
		        ]
		    };
		    var GEORGIAN = {
		        integers: [
		            10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90,
		            80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
		        ],
		        values: [
		            'ჵ',
		            'ჰ',
		            'ჯ',
		            'ჴ',
		            'ხ',
		            'ჭ',
		            'წ',
		            'ძ',
		            'ც',
		            'ჩ',
		            'შ',
		            'ყ',
		            'ღ',
		            'ქ',
		            'ფ',
		            'ჳ',
		            'ტ',
		            'ს',
		            'რ',
		            'ჟ',
		            'პ',
		            'ო',
		            'ჲ',
		            'ნ',
		            'მ',
		            'ლ',
		            'კ',
		            'ი',
		            'თ',
		            'ჱ',
		            'ზ',
		            'ვ',
		            'ე',
		            'დ',
		            'გ',
		            'ბ',
		            'ა'
		        ]
		    };
		    var createAdditiveCounter = function (value, min, max, symbols, fallback, suffix) {
		        if (value < min || value > max) {
		            return createCounterText(value, fallback, suffix.length > 0);
		        }
		        return (symbols.integers.reduce(function (string, integer, index) {
		            while (value >= integer) {
		                value -= integer;
		                string += symbols.values[index];
		            }
		            return string;
		        }, '') + suffix);
		    };
		    var createCounterStyleWithSymbolResolver = function (value, codePointRangeLength, isNumeric, resolver) {
		        var string = '';
		        do {
		            if (!isNumeric) {
		                value--;
		            }
		            string = resolver(value) + string;
		            value /= codePointRangeLength;
		        } while (value * codePointRangeLength >= codePointRangeLength);
		        return string;
		    };
		    var createCounterStyleFromRange = function (value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
		        var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
		        return ((value < 0 ? '-' : '') +
		            (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
		                return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
		            }) +
		                suffix));
		    };
		    var createCounterStyleFromSymbols = function (value, symbols, suffix) {
		        if (suffix === void 0) { suffix = '. '; }
		        var codePointRangeLength = symbols.length;
		        return (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) { return symbols[Math.floor(codePoint % codePointRangeLength)]; }) + suffix);
		    };
		    var CJK_ZEROS = 1 << 0;
		    var CJK_TEN_COEFFICIENTS = 1 << 1;
		    var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
		    var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
		    var createCJKCounter = function (value, numbers, multipliers, negativeSign, suffix, flags) {
		        if (value < -9999 || value > 9999) {
		            return createCounterText(value, 4 /* CJK_DECIMAL */, suffix.length > 0);
		        }
		        var tmp = Math.abs(value);
		        var string = suffix;
		        if (tmp === 0) {
		            return numbers[0] + string;
		        }
		        for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
		            var coefficient = tmp % 10;
		            if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {
		                string = numbers[coefficient] + string;
		            }
		            else if (coefficient > 1 ||
		                (coefficient === 1 && digit === 0) ||
		                (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS)) ||
		                (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100) ||
		                (coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS))) {
		                string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
		            }
		            else if (coefficient === 1 && digit > 0) {
		                string = multipliers[digit - 1] + string;
		            }
		            tmp = Math.floor(tmp / 10);
		        }
		        return (value < 0 ? negativeSign : '') + string;
		    };
		    var CHINESE_INFORMAL_MULTIPLIERS = '十百千萬';
		    var CHINESE_FORMAL_MULTIPLIERS = '拾佰仟萬';
		    var JAPANESE_NEGATIVE = 'マイナス';
		    var KOREAN_NEGATIVE = '마이너스';
		    var createCounterText = function (value, type, appendSuffix) {
		        var defaultSuffix = appendSuffix ? '. ' : '';
		        var cjkSuffix = appendSuffix ? '、' : '';
		        var koreanSuffix = appendSuffix ? ', ' : '';
		        var spaceSuffix = appendSuffix ? ' ' : '';
		        switch (type) {
		            case 0 /* DISC */:
		                return '•' + spaceSuffix;
		            case 1 /* CIRCLE */:
		                return '◦' + spaceSuffix;
		            case 2 /* SQUARE */:
		                return '◾' + spaceSuffix;
		            case 5 /* DECIMAL_LEADING_ZERO */:
		                var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
		                return string.length < 4 ? "0" + string : string;
		            case 4 /* CJK_DECIMAL */:
		                return createCounterStyleFromSymbols(value, '〇一二三四五六七八九', cjkSuffix);
		            case 6 /* LOWER_ROMAN */:
		                return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
		            case 7 /* UPPER_ROMAN */:
		                return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix);
		            case 8 /* LOWER_GREEK */:
		                return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
		            case 9 /* LOWER_ALPHA */:
		                return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
		            case 10 /* UPPER_ALPHA */:
		                return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
		            case 11 /* ARABIC_INDIC */:
		                return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
		            case 12 /* ARMENIAN */:
		            case 49 /* UPPER_ARMENIAN */:
		                return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix);
		            case 35 /* LOWER_ARMENIAN */:
		                return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
		            case 13 /* BENGALI */:
		                return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
		            case 14 /* CAMBODIAN */:
		            case 30 /* KHMER */:
		                return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
		            case 15 /* CJK_EARTHLY_BRANCH */:
		                return createCounterStyleFromSymbols(value, '子丑寅卯辰巳午未申酉戌亥', cjkSuffix);
		            case 16 /* CJK_HEAVENLY_STEM */:
		                return createCounterStyleFromSymbols(value, '甲乙丙丁戊己庚辛壬癸', cjkSuffix);
		            case 17 /* CJK_IDEOGRAPHIC */:
		            case 48 /* TRAD_CHINESE_INFORMAL */:
		                return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
		            case 47 /* TRAD_CHINESE_FORMAL */:
		                return createCJKCounter(value, '零壹貳參肆伍陸柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
		            case 42 /* SIMP_CHINESE_INFORMAL */:
		                return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
		            case 41 /* SIMP_CHINESE_FORMAL */:
		                return createCJKCounter(value, '零壹贰叁肆伍陆柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
		            case 26 /* JAPANESE_INFORMAL */:
		                return createCJKCounter(value, '〇一二三四五六七八九', '十百千万', JAPANESE_NEGATIVE, cjkSuffix, 0);
		            case 25 /* JAPANESE_FORMAL */:
		                return createCJKCounter(value, '零壱弐参四伍六七八九', '拾百千万', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
		            case 31 /* KOREAN_HANGUL_FORMAL */:
		                return createCJKCounter(value, '영일이삼사오육칠팔구', '십백천만', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
		            case 33 /* KOREAN_HANJA_INFORMAL */:
		                return createCJKCounter(value, '零一二三四五六七八九', '十百千萬', KOREAN_NEGATIVE, koreanSuffix, 0);
		            case 32 /* KOREAN_HANJA_FORMAL */:
		                return createCJKCounter(value, '零壹貳參四五六七八九', '拾百千', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
		            case 18 /* DEVANAGARI */:
		                return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);
		            case 20 /* GEORGIAN */:
		                return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3 /* DECIMAL */, defaultSuffix);
		            case 21 /* GUJARATI */:
		                return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);
		            case 22 /* GURMUKHI */:
		                return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);
		            case 22 /* HEBREW */:
		                return createAdditiveCounter(value, 1, 10999, HEBREW, 3 /* DECIMAL */, defaultSuffix);
		            case 23 /* HIRAGANA */:
		                return createCounterStyleFromSymbols(value, 'あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん');
		            case 24 /* HIRAGANA_IROHA */:
		                return createCounterStyleFromSymbols(value, 'いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす');
		            case 27 /* KANNADA */:
		                return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);
		            case 28 /* KATAKANA */:
		                return createCounterStyleFromSymbols(value, 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン', cjkSuffix);
		            case 29 /* KATAKANA_IROHA */:
		                return createCounterStyleFromSymbols(value, 'イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス', cjkSuffix);
		            case 34 /* LAO */:
		                return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);
		            case 37 /* MONGOLIAN */:
		                return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);
		            case 38 /* MYANMAR */:
		                return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);
		            case 39 /* ORIYA */:
		                return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);
		            case 40 /* PERSIAN */:
		                return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);
		            case 43 /* TAMIL */:
		                return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);
		            case 44 /* TELUGU */:
		                return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);
		            case 45 /* THAI */:
		                return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);
		            case 46 /* TIBETAN */:
		                return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);
		            case 3 /* DECIMAL */:
		            default:
		                return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
		        }
		    };

		    var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';
		    var DocumentCloner = /** @class */ (function () {
		        function DocumentCloner(context, element, options) {
		            this.context = context;
		            this.options = options;
		            this.scrolledElements = [];
		            this.referenceElement = element;
		            this.counters = new CounterState();
		            this.quoteDepth = 0;
		            if (!element.ownerDocument) {
		                throw new Error('Cloned element does not have an owner document');
		            }
		            this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
		        }
		        DocumentCloner.prototype.toIFrame = function (ownerDocument, windowSize) {
		            var _this = this;
		            var iframe = createIFrameContainer(ownerDocument, windowSize);
		            if (!iframe.contentWindow) {
		                return Promise.reject("Unable to find iframe window");
		            }
		            var scrollX = ownerDocument.defaultView.pageXOffset;
		            var scrollY = ownerDocument.defaultView.pageYOffset;
		            var cloneWindow = iframe.contentWindow;
		            var documentClone = cloneWindow.document;
		            /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
		             if window url is about:blank, we can assign the url to current by writing onto the document
		             */
		            var iframeLoad = iframeLoader(iframe).then(function () { return __awaiter(_this, void 0, void 0, function () {
		                var onclone, referenceElement;
		                return __generator(this, function (_a) {
		                    switch (_a.label) {
		                        case 0:
		                            this.scrolledElements.forEach(restoreNodeScroll);
		                            if (cloneWindow) {
		                                cloneWindow.scrollTo(windowSize.left, windowSize.top);
		                                if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&
		                                    (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
		                                    this.context.logger.warn('Unable to restore scroll position for cloned document');
		                                    this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
		                                }
		                            }
		                            onclone = this.options.onclone;
		                            referenceElement = this.clonedReferenceElement;
		                            if (typeof referenceElement === 'undefined') {
		                                return [2 /*return*/, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
		                            }
		                            if (!(documentClone.fonts && documentClone.fonts.ready)) return [3 /*break*/, 2];
		                            return [4 /*yield*/, documentClone.fonts.ready];
		                        case 1:
		                            _a.sent();
		                            _a.label = 2;
		                        case 2:
		                            if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3 /*break*/, 4];
		                            return [4 /*yield*/, imagesReady(documentClone)];
		                        case 3:
		                            _a.sent();
		                            _a.label = 4;
		                        case 4:
		                            if (typeof onclone === 'function') {
		                                return [2 /*return*/, Promise.resolve()
		                                        .then(function () { return onclone(documentClone, referenceElement); })
		                                        .then(function () { return iframe; })];
		                            }
		                            return [2 /*return*/, iframe];
		                    }
		                });
		            }); });
		            documentClone.open();
		            documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
		            // Chrome scrolls the parent document for some reason after the write to the cloned window???
		            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
		            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
		            documentClone.close();
		            return iframeLoad;
		        };
		        DocumentCloner.prototype.createElementClone = function (node) {
		            if (isDebugging(node, 2 /* CLONE */)) {
		                debugger;
		            }
		            if (isCanvasElement(node)) {
		                return this.createCanvasClone(node);
		            }
		            if (isVideoElement(node)) {
		                return this.createVideoClone(node);
		            }
		            if (isStyleElement(node)) {
		                return this.createStyleClone(node);
		            }
		            var clone = node.cloneNode(false);
		            if (isImageElement(clone)) {
		                if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
		                    clone.src = node.currentSrc;
		                    clone.srcset = '';
		                }
		                if (clone.loading === 'lazy') {
		                    clone.loading = 'eager';
		                }
		            }
		            if (isCustomElement(clone)) {
		                return this.createCustomElementClone(clone);
		            }
		            return clone;
		        };
		        DocumentCloner.prototype.createCustomElementClone = function (node) {
		            var clone = document.createElement('html2canvascustomelement');
		            copyCSSStyles(node.style, clone);
		            return clone;
		        };
		        DocumentCloner.prototype.createStyleClone = function (node) {
		            try {
		                var sheet = node.sheet;
		                if (sheet && sheet.cssRules) {
		                    var css = [].slice.call(sheet.cssRules, 0).reduce(function (css, rule) {
		                        if (rule && typeof rule.cssText === 'string') {
		                            return css + rule.cssText;
		                        }
		                        return css;
		                    }, '');
		                    var style = node.cloneNode(false);
		                    style.textContent = css;
		                    return style;
		                }
		            }
		            catch (e) {
		                // accessing node.sheet.cssRules throws a DOMException
		                this.context.logger.error('Unable to access cssRules property', e);
		                if (e.name !== 'SecurityError') {
		                    throw e;
		                }
		            }
		            return node.cloneNode(false);
		        };
		        DocumentCloner.prototype.createCanvasClone = function (canvas) {
		            var _a;
		            if (this.options.inlineImages && canvas.ownerDocument) {
		                var img = canvas.ownerDocument.createElement('img');
		                try {
		                    img.src = canvas.toDataURL();
		                    return img;
		                }
		                catch (e) {
		                    this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
		                }
		            }
		            var clonedCanvas = canvas.cloneNode(false);
		            try {
		                clonedCanvas.width = canvas.width;
		                clonedCanvas.height = canvas.height;
		                var ctx = canvas.getContext('2d');
		                var clonedCtx = clonedCanvas.getContext('2d');
		                if (clonedCtx) {
		                    if (!this.options.allowTaint && ctx) {
		                        clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
		                    }
		                    else {
		                        var gl = (_a = canvas.getContext('webgl2')) !== null && _a !== void 0 ? _a : canvas.getContext('webgl');
		                        if (gl) {
		                            var attribs = gl.getContextAttributes();
		                            if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
		                                this.context.logger.warn('Unable to clone WebGL context as it has preserveDrawingBuffer=false', canvas);
		                            }
		                        }
		                        clonedCtx.drawImage(canvas, 0, 0);
		                    }
		                }
		                return clonedCanvas;
		            }
		            catch (e) {
		                this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
		            }
		            return clonedCanvas;
		        };
		        DocumentCloner.prototype.createVideoClone = function (video) {
		            var canvas = video.ownerDocument.createElement('canvas');
		            canvas.width = video.offsetWidth;
		            canvas.height = video.offsetHeight;
		            var ctx = canvas.getContext('2d');
		            try {
		                if (ctx) {
		                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
		                    if (!this.options.allowTaint) {
		                        ctx.getImageData(0, 0, canvas.width, canvas.height);
		                    }
		                }
		                return canvas;
		            }
		            catch (e) {
		                this.context.logger.info("Unable to clone video as it is tainted", video);
		            }
		            var blankCanvas = video.ownerDocument.createElement('canvas');
		            blankCanvas.width = video.offsetWidth;
		            blankCanvas.height = video.offsetHeight;
		            return blankCanvas;
		        };
		        DocumentCloner.prototype.appendChildNode = function (clone, child, copyStyles) {
		            if (!isElementNode(child) ||
		                (!isScriptElement(child) &&
		                    !child.hasAttribute(IGNORE_ATTRIBUTE) &&
		                    (typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child)))) {
		                if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
		                    clone.appendChild(this.cloneNode(child, copyStyles));
		                }
		            }
		        };
		        DocumentCloner.prototype.cloneChildNodes = function (node, clone, copyStyles) {
		            var _this = this;
		            for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
		                if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === 'function') {
		                    var assignedNodes = child.assignedNodes();
		                    if (assignedNodes.length) {
		                        assignedNodes.forEach(function (assignedNode) { return _this.appendChildNode(clone, assignedNode, copyStyles); });
		                    }
		                }
		                else {
		                    this.appendChildNode(clone, child, copyStyles);
		                }
		            }
		        };
		        DocumentCloner.prototype.cloneNode = function (node, copyStyles) {
		            if (isTextNode(node)) {
		                return document.createTextNode(node.data);
		            }
		            if (!node.ownerDocument) {
		                return node.cloneNode(false);
		            }
		            var window = node.ownerDocument.defaultView;
		            if (window && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
		                var clone = this.createElementClone(node);
		                clone.style.transitionProperty = 'none';
		                var style = window.getComputedStyle(node);
		                var styleBefore = window.getComputedStyle(node, ':before');
		                var styleAfter = window.getComputedStyle(node, ':after');
		                if (this.referenceElement === node && isHTMLElementNode(clone)) {
		                    this.clonedReferenceElement = clone;
		                }
		                if (isBodyElement(clone)) {
		                    createPseudoHideStyles(clone);
		                }
		                var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
		                var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
		                if (isCustomElement(node)) {
		                    copyStyles = true;
		                }
		                if (!isVideoElement(node)) {
		                    this.cloneChildNodes(node, clone, copyStyles);
		                }
		                if (before) {
		                    clone.insertBefore(before, clone.firstChild);
		                }
		                var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
		                if (after) {
		                    clone.appendChild(after);
		                }
		                this.counters.pop(counters);
		                if ((style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) ||
		                    copyStyles) {
		                    copyCSSStyles(style, clone);
		                }
		                if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
		                    this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
		                }
		                if ((isTextareaElement(node) || isSelectElement(node)) &&
		                    (isTextareaElement(clone) || isSelectElement(clone))) {
		                    clone.value = node.value;
		                }
		                return clone;
		            }
		            return node.cloneNode(false);
		        };
		        DocumentCloner.prototype.resolvePseudoContent = function (node, clone, style, pseudoElt) {
		            var _this = this;
		            if (!style) {
		                return;
		            }
		            var value = style.content;
		            var document = clone.ownerDocument;
		            if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {
		                return;
		            }
		            this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
		            var declaration = new CSSParsedPseudoDeclaration(this.context, style);
		            var anonymousReplacedElement = document.createElement('html2canvaspseudoelement');
		            copyCSSStyles(style, anonymousReplacedElement);
		            declaration.content.forEach(function (token) {
		                if (token.type === 0 /* STRING_TOKEN */) {
		                    anonymousReplacedElement.appendChild(document.createTextNode(token.value));
		                }
		                else if (token.type === 22 /* URL_TOKEN */) {
		                    var img = document.createElement('img');
		                    img.src = token.value;
		                    img.style.opacity = '1';
		                    anonymousReplacedElement.appendChild(img);
		                }
		                else if (token.type === 18 /* FUNCTION */) {
		                    if (token.name === 'attr') {
		                        var attr = token.values.filter(isIdentToken);
		                        if (attr.length) {
		                            anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value) || ''));
		                        }
		                    }
		                    else if (token.name === 'counter') {
		                        var _a = token.values.filter(nonFunctionArgSeparator), counter = _a[0], counterStyle = _a[1];
		                        if (counter && isIdentToken(counter)) {
		                            var counterState = _this.counters.getCounterValue(counter.value);
		                            var counterType = counterStyle && isIdentToken(counterStyle)
		                                ? listStyleType.parse(_this.context, counterStyle.value)
		                                : 3 /* DECIMAL */;
		                            anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState, counterType, false)));
		                        }
		                    }
		                    else if (token.name === 'counters') {
		                        var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
		                        if (counter && isIdentToken(counter)) {
		                            var counterStates = _this.counters.getCounterValues(counter.value);
		                            var counterType_1 = counterStyle && isIdentToken(counterStyle)
		                                ? listStyleType.parse(_this.context, counterStyle.value)
		                                : 3 /* DECIMAL */;
		                            var separator = delim && delim.type === 0 /* STRING_TOKEN */ ? delim.value : '';
		                            var text = counterStates
		                                .map(function (value) { return createCounterText(value, counterType_1, false); })
		                                .join(separator);
		                            anonymousReplacedElement.appendChild(document.createTextNode(text));
		                        }
		                    }
		                    else ;
		                }
		                else if (token.type === 20 /* IDENT_TOKEN */) {
		                    switch (token.value) {
		                        case 'open-quote':
		                            anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
		                            break;
		                        case 'close-quote':
		                            anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
		                            break;
		                        default:
		                            // safari doesn't parse string tokens correctly because of lack of quotes
		                            anonymousReplacedElement.appendChild(document.createTextNode(token.value));
		                    }
		                }
		            });
		            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
		            var newClassName = pseudoElt === PseudoElementType.BEFORE
		                ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE
		                : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
		            if (isSVGElementNode(clone)) {
		                clone.className.baseValue += newClassName;
		            }
		            else {
		                clone.className += newClassName;
		            }
		            return anonymousReplacedElement;
		        };
		        DocumentCloner.destroy = function (container) {
		            if (container.parentNode) {
		                container.parentNode.removeChild(container);
		                return true;
		            }
		            return false;
		        };
		        return DocumentCloner;
		    }());
		    var PseudoElementType;
		    (function (PseudoElementType) {
		        PseudoElementType[PseudoElementType["BEFORE"] = 0] = "BEFORE";
		        PseudoElementType[PseudoElementType["AFTER"] = 1] = "AFTER";
		    })(PseudoElementType || (PseudoElementType = {}));
		    var createIFrameContainer = function (ownerDocument, bounds) {
		        var cloneIframeContainer = ownerDocument.createElement('iframe');
		        cloneIframeContainer.className = 'html2canvas-container';
		        cloneIframeContainer.style.visibility = 'hidden';
		        cloneIframeContainer.style.position = 'fixed';
		        cloneIframeContainer.style.left = '-10000px';
		        cloneIframeContainer.style.top = '0px';
		        cloneIframeContainer.style.border = '0';
		        cloneIframeContainer.width = bounds.width.toString();
		        cloneIframeContainer.height = bounds.height.toString();
		        cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it
		        cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');
		        ownerDocument.body.appendChild(cloneIframeContainer);
		        return cloneIframeContainer;
		    };
		    var imageReady = function (img) {
		        return new Promise(function (resolve) {
		            if (img.complete) {
		                resolve();
		                return;
		            }
		            if (!img.src) {
		                resolve();
		                return;
		            }
		            img.onload = resolve;
		            img.onerror = resolve;
		        });
		    };
		    var imagesReady = function (document) {
		        return Promise.all([].slice.call(document.images, 0).map(imageReady));
		    };
		    var iframeLoader = function (iframe) {
		        return new Promise(function (resolve, reject) {
		            var cloneWindow = iframe.contentWindow;
		            if (!cloneWindow) {
		                return reject("No window assigned for iframe");
		            }
		            var documentClone = cloneWindow.document;
		            cloneWindow.onload = iframe.onload = function () {
		                cloneWindow.onload = iframe.onload = null;
		                var interval = setInterval(function () {
		                    if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
		                        clearInterval(interval);
		                        resolve(iframe);
		                    }
		                }, 50);
		            };
		        });
		    };
		    var ignoredStyleProperties = [
		        'all',
		        'd',
		        'content' // Safari shows pseudoelements if content is set
		    ];
		    var copyCSSStyles = function (style, target) {
		        // Edge does not provide value for cssText
		        for (var i = style.length - 1; i >= 0; i--) {
		            var property = style.item(i);
		            if (ignoredStyleProperties.indexOf(property) === -1) {
		                target.style.setProperty(property, style.getPropertyValue(property));
		            }
		        }
		        return target;
		    };
		    var serializeDoctype = function (doctype) {
		        var str = '';
		        if (doctype) {
		            str += '<!DOCTYPE ';
		            if (doctype.name) {
		                str += doctype.name;
		            }
		            if (doctype.internalSubset) {
		                str += doctype.internalSubset;
		            }
		            if (doctype.publicId) {
		                str += "\"" + doctype.publicId + "\"";
		            }
		            if (doctype.systemId) {
		                str += "\"" + doctype.systemId + "\"";
		            }
		            str += '>';
		        }
		        return str;
		    };
		    var restoreOwnerScroll = function (ownerDocument, x, y) {
		        if (ownerDocument &&
		            ownerDocument.defaultView &&
		            (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
		            ownerDocument.defaultView.scrollTo(x, y);
		        }
		    };
		    var restoreNodeScroll = function (_a) {
		        var element = _a[0], x = _a[1], y = _a[2];
		        element.scrollLeft = x;
		        element.scrollTop = y;
		    };
		    var PSEUDO_BEFORE = ':before';
		    var PSEUDO_AFTER = ':after';
		    var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
		    var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';
		    var PSEUDO_HIDE_ELEMENT_STYLE = "{\n    content: \"\" !important;\n    display: none !important;\n}";
		    var createPseudoHideStyles = function (body) {
		        createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
		    };
		    var createStyles = function (body, styles) {
		        var document = body.ownerDocument;
		        if (document) {
		            var style = document.createElement('style');
		            style.textContent = styles;
		            body.appendChild(style);
		        }
		    };

		    var CacheStorage = /** @class */ (function () {
		        function CacheStorage() {
		        }
		        CacheStorage.getOrigin = function (url) {
		            var link = CacheStorage._link;
		            if (!link) {
		                return 'about:blank';
		            }
		            link.href = url;
		            link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
		            return link.protocol + link.hostname + link.port;
		        };
		        CacheStorage.isSameOrigin = function (src) {
		            return CacheStorage.getOrigin(src) === CacheStorage._origin;
		        };
		        CacheStorage.setContext = function (window) {
		            CacheStorage._link = window.document.createElement('a');
		            CacheStorage._origin = CacheStorage.getOrigin(window.location.href);
		        };
		        CacheStorage._origin = 'about:blank';
		        return CacheStorage;
		    }());
		    var Cache = /** @class */ (function () {
		        function Cache(context, _options) {
		            this.context = context;
		            this._options = _options;
		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
		            this._cache = {};
		        }
		        Cache.prototype.addImage = function (src) {
		            var result = Promise.resolve();
		            if (this.has(src)) {
		                return result;
		            }
		            if (isBlobImage(src) || isRenderable(src)) {
		                (this._cache[src] = this.loadImage(src)).catch(function () {
		                    // prevent unhandled rejection
		                });
		                return result;
		            }
		            return result;
		        };
		        // eslint-disable-next-line @typescript-eslint/no-explicit-any
		        Cache.prototype.match = function (src) {
		            return this._cache[src];
		        };
		        Cache.prototype.loadImage = function (key) {
		            return __awaiter(this, void 0, void 0, function () {
		                var isSameOrigin, useCORS, useProxy, src;
		                var _this = this;
		                return __generator(this, function (_a) {
		                    switch (_a.label) {
		                        case 0:
		                            isSameOrigin = CacheStorage.isSameOrigin(key);
		                            useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
		                            useProxy = !isInlineImage(key) &&
		                                !isSameOrigin &&
		                                !isBlobImage(key) &&
		                                typeof this._options.proxy === 'string' &&
		                                FEATURES.SUPPORT_CORS_XHR &&
		                                !useCORS;
		                            if (!isSameOrigin &&
		                                this._options.allowTaint === false &&
		                                !isInlineImage(key) &&
		                                !isBlobImage(key) &&
		                                !useProxy &&
		                                !useCORS) {
		                                return [2 /*return*/];
		                            }
		                            src = key;
		                            if (!useProxy) return [3 /*break*/, 2];
		                            return [4 /*yield*/, this.proxy(src)];
		                        case 1:
		                            src = _a.sent();
		                            _a.label = 2;
		                        case 2:
		                            this.context.logger.debug("Added image " + key.substring(0, 256));
		                            return [4 /*yield*/, new Promise(function (resolve, reject) {
		                                    var img = new Image();
		                                    img.onload = function () { return resolve(img); };
		                                    img.onerror = reject;
		                                    //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
		                                    if (isInlineBase64Image(src) || useCORS) {
		                                        img.crossOrigin = 'anonymous';
		                                    }
		                                    img.src = src;
		                                    if (img.complete === true) {
		                                        // Inline XML images may fail to parse, throwing an Error later on
		                                        setTimeout(function () { return resolve(img); }, 500);
		                                    }
		                                    if (_this._options.imageTimeout > 0) {
		                                        setTimeout(function () { return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image"); }, _this._options.imageTimeout);
		                                    }
		                                })];
		                        case 3: return [2 /*return*/, _a.sent()];
		                    }
		                });
		            });
		        };
		        Cache.prototype.has = function (key) {
		            return typeof this._cache[key] !== 'undefined';
		        };
		        Cache.prototype.keys = function () {
		            return Promise.resolve(Object.keys(this._cache));
		        };
		        Cache.prototype.proxy = function (src) {
		            var _this = this;
		            var proxy = this._options.proxy;
		            if (!proxy) {
		                throw new Error('No proxy defined');
		            }
		            var key = src.substring(0, 256);
		            return new Promise(function (resolve, reject) {
		                var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
		                var xhr = new XMLHttpRequest();
		                xhr.onload = function () {
		                    if (xhr.status === 200) {
		                        if (responseType === 'text') {
		                            resolve(xhr.response);
		                        }
		                        else {
		                            var reader_1 = new FileReader();
		                            reader_1.addEventListener('load', function () { return resolve(reader_1.result); }, false);
		                            reader_1.addEventListener('error', function (e) { return reject(e); }, false);
		                            reader_1.readAsDataURL(xhr.response);
		                        }
		                    }
		                    else {
		                        reject("Failed to proxy resource " + key + " with status code " + xhr.status);
		                    }
		                };
		                xhr.onerror = reject;
		                var queryString = proxy.indexOf('?') > -1 ? '&' : '?';
		                xhr.open('GET', "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
		                if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
		                    xhr.responseType = responseType;
		                }
		                if (_this._options.imageTimeout) {
		                    var timeout_1 = _this._options.imageTimeout;
		                    xhr.timeout = timeout_1;
		                    xhr.ontimeout = function () { return reject("Timed out (" + timeout_1 + "ms) proxying " + key); };
		                }
		                xhr.send();
		            });
		        };
		        return Cache;
		    }());
		    var INLINE_SVG = /^data:image\/svg\+xml/i;
		    var INLINE_BASE64 = /^data:image\/.*;base64,/i;
		    var INLINE_IMG = /^data:image\/.*/i;
		    var isRenderable = function (src) { return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src); };
		    var isInlineImage = function (src) { return INLINE_IMG.test(src); };
		    var isInlineBase64Image = function (src) { return INLINE_BASE64.test(src); };
		    var isBlobImage = function (src) { return src.substr(0, 4) === 'blob'; };
		    var isSVG = function (src) { return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src); };

		    var Vector = /** @class */ (function () {
		        function Vector(x, y) {
		            this.type = 0 /* VECTOR */;
		            this.x = x;
		            this.y = y;
		        }
		        Vector.prototype.add = function (deltaX, deltaY) {
		            return new Vector(this.x + deltaX, this.y + deltaY);
		        };
		        return Vector;
		    }());

		    var lerp = function (a, b, t) {
		        return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
		    };
		    var BezierCurve = /** @class */ (function () {
		        function BezierCurve(start, startControl, endControl, end) {
		            this.type = 1 /* BEZIER_CURVE */;
		            this.start = start;
		            this.startControl = startControl;
		            this.endControl = endControl;
		            this.end = end;
		        }
		        BezierCurve.prototype.subdivide = function (t, firstHalf) {
		            var ab = lerp(this.start, this.startControl, t);
		            var bc = lerp(this.startControl, this.endControl, t);
		            var cd = lerp(this.endControl, this.end, t);
		            var abbc = lerp(ab, bc, t);
		            var bccd = lerp(bc, cd, t);
		            var dest = lerp(abbc, bccd, t);
		            return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
		        };
		        BezierCurve.prototype.add = function (deltaX, deltaY) {
		            return new BezierCurve(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
		        };
		        BezierCurve.prototype.reverse = function () {
		            return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
		        };
		        return BezierCurve;
		    }());
		    var isBezierCurve = function (path) { return path.type === 1 /* BEZIER_CURVE */; };

		    var BoundCurves = /** @class */ (function () {
		        function BoundCurves(element) {
		            var styles = element.styles;
		            var bounds = element.bounds;
		            var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];
		            var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
		            var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
		            var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
		            var factors = [];
		            factors.push((tlh + trh) / bounds.width);
		            factors.push((blh + brh) / bounds.width);
		            factors.push((tlv + blv) / bounds.height);
		            factors.push((trv + brv) / bounds.height);
		            var maxFactor = Math.max.apply(Math, factors);
		            if (maxFactor > 1) {
		                tlh /= maxFactor;
		                tlv /= maxFactor;
		                trh /= maxFactor;
		                trv /= maxFactor;
		                brh /= maxFactor;
		                brv /= maxFactor;
		                blh /= maxFactor;
		                blv /= maxFactor;
		            }
		            var topWidth = bounds.width - trh;
		            var rightHeight = bounds.height - brv;
		            var bottomWidth = bounds.width - brh;
		            var leftHeight = bounds.height - blv;
		            var borderTopWidth = styles.borderTopWidth;
		            var borderRightWidth = styles.borderRightWidth;
		            var borderBottomWidth = styles.borderBottomWidth;
		            var borderLeftWidth = styles.borderLeftWidth;
		            var paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);
		            var paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);
		            var paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
		            var paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
		            this.topLeftBorderDoubleOuterBox =
		                tlh > 0 || tlv > 0
		                    ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3, tlh - borderLeftWidth / 3, tlv - borderTopWidth / 3, CORNER.TOP_LEFT)
		                    : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3);
		            this.topRightBorderDoubleOuterBox =
		                tlh > 0 || tlv > 0
		                    ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 3, trh - borderRightWidth / 3, trv - borderTopWidth / 3, CORNER.TOP_RIGHT)
		                    : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + borderTopWidth / 3);
		            this.bottomRightBorderDoubleOuterBox =
		                brh > 0 || brv > 0
		                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 3, brv - borderBottomWidth / 3, CORNER.BOTTOM_RIGHT)
		                    : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
		            this.bottomLeftBorderDoubleOuterBox =
		                blh > 0 || blv > 0
		                    ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + leftHeight, blh - borderLeftWidth / 3, blv - borderBottomWidth / 3, CORNER.BOTTOM_LEFT)
		                    : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
		            this.topLeftBorderDoubleInnerBox =
		                tlh > 0 || tlv > 0
		                    ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3, tlh - (borderLeftWidth * 2) / 3, tlv - (borderTopWidth * 2) / 3, CORNER.TOP_LEFT)
		                    : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
		            this.topRightBorderDoubleInnerBox =
		                tlh > 0 || tlv > 0
		                    ? getCurvePoints(bounds.left + topWidth, bounds.top + (borderTopWidth * 2) / 3, trh - (borderRightWidth * 2) / 3, trv - (borderTopWidth * 2) / 3, CORNER.TOP_RIGHT)
		                    : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
		            this.bottomRightBorderDoubleInnerBox =
		                brh > 0 || brv > 0
		                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - (borderRightWidth * 2) / 3, brv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_RIGHT)
		                    : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
		            this.bottomLeftBorderDoubleInnerBox =
		                blh > 0 || blv > 0
		                    ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + leftHeight, blh - (borderLeftWidth * 2) / 3, blv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_LEFT)
		                    : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
		            this.topLeftBorderStroke =
		                tlh > 0 || tlv > 0
		                    ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2, tlh - borderLeftWidth / 2, tlv - borderTopWidth / 2, CORNER.TOP_LEFT)
		                    : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2);
		            this.topRightBorderStroke =
		                tlh > 0 || tlv > 0
		                    ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 2, trh - borderRightWidth / 2, trv - borderTopWidth / 2, CORNER.TOP_RIGHT)
		                    : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + borderTopWidth / 2);
		            this.bottomRightBorderStroke =
		                brh > 0 || brv > 0
		                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 2, brv - borderBottomWidth / 2, CORNER.BOTTOM_RIGHT)
		                    : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
		            this.bottomLeftBorderStroke =
		                blh > 0 || blv > 0
		                    ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + leftHeight, blh - borderLeftWidth / 2, blv - borderBottomWidth / 2, CORNER.BOTTOM_LEFT)
		                    : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
		            this.topLeftBorderBox =
		                tlh > 0 || tlv > 0
		                    ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT)
		                    : new Vector(bounds.left, bounds.top);
		            this.topRightBorderBox =
		                trh > 0 || trv > 0
		                    ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT)
		                    : new Vector(bounds.left + bounds.width, bounds.top);
		            this.bottomRightBorderBox =
		                brh > 0 || brv > 0
		                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT)
		                    : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
		            this.bottomLeftBorderBox =
		                blh > 0 || blv > 0
		                    ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT)
		                    : new Vector(bounds.left, bounds.top + bounds.height);
		            this.topLeftPaddingBox =
		                tlh > 0 || tlv > 0
		                    ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + borderTopWidth, Math.max(0, tlh - borderLeftWidth), Math.max(0, tlv - borderTopWidth), CORNER.TOP_LEFT)
		                    : new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);
		            this.topRightPaddingBox =
		                trh > 0 || trv > 0
		                    ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth), bounds.top + borderTopWidth, topWidth > bounds.width + borderRightWidth ? 0 : Math.max(0, trh - borderRightWidth), Math.max(0, trv - borderTopWidth), CORNER.TOP_RIGHT)
		                    : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);
		            this.bottomRightPaddingBox =
		                brh > 0 || brv > 0
		                    ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth), Math.max(0, brh - borderRightWidth), Math.max(0, brv - borderBottomWidth), CORNER.BOTTOM_RIGHT)
		                    : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + bounds.height - borderBottomWidth);
		            this.bottomLeftPaddingBox =
		                blh > 0 || blv > 0
		                    ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth), Math.max(0, blh - borderLeftWidth), Math.max(0, blv - borderBottomWidth), CORNER.BOTTOM_LEFT)
		                    : new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);
		            this.topLeftContentBox =
		                tlh > 0 || tlv > 0
		                    ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop, Math.max(0, tlh - (borderLeftWidth + paddingLeft)), Math.max(0, tlv - (borderTopWidth + paddingTop)), CORNER.TOP_LEFT)
		                    : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);
		            this.topRightContentBox =
		                trh > 0 || trv > 0
		                    ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft), bounds.top + borderTopWidth + paddingTop, topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft, trv - (borderTopWidth + paddingTop), CORNER.TOP_RIGHT)
		                    : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + borderTopWidth + paddingTop);
		            this.bottomRightContentBox =
		                brh > 0 || brv > 0
		                    ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop), Math.max(0, brh - (borderRightWidth + paddingRight)), brv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_RIGHT)
		                    : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
		            this.bottomLeftContentBox =
		                blh > 0 || blv > 0
		                    ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth + paddingLeft)), blv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_LEFT)
		                    : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
		        }
		        return BoundCurves;
		    }());
		    var CORNER;
		    (function (CORNER) {
		        CORNER[CORNER["TOP_LEFT"] = 0] = "TOP_LEFT";
		        CORNER[CORNER["TOP_RIGHT"] = 1] = "TOP_RIGHT";
		        CORNER[CORNER["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
		        CORNER[CORNER["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
		    })(CORNER || (CORNER = {}));
		    var getCurvePoints = function (x, y, r1, r2, position) {
		        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
		        var ox = r1 * kappa; // control point offset horizontal
		        var oy = r2 * kappa; // control point offset vertical
		        var xm = x + r1; // x-middle
		        var ym = y + r2; // y-middle
		        switch (position) {
		            case CORNER.TOP_LEFT:
		                return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
		            case CORNER.TOP_RIGHT:
		                return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
		            case CORNER.BOTTOM_RIGHT:
		                return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
		            case CORNER.BOTTOM_LEFT:
		            default:
		                return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
		        }
		    };
		    var calculateBorderBoxPath = function (curves) {
		        return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
		    };
		    var calculateContentBoxPath = function (curves) {
		        return [
		            curves.topLeftContentBox,
		            curves.topRightContentBox,
		            curves.bottomRightContentBox,
		            curves.bottomLeftContentBox
		        ];
		    };
		    var calculatePaddingBoxPath = function (curves) {
		        return [
		            curves.topLeftPaddingBox,
		            curves.topRightPaddingBox,
		            curves.bottomRightPaddingBox,
		            curves.bottomLeftPaddingBox
		        ];
		    };

		    var TransformEffect = /** @class */ (function () {
		        function TransformEffect(offsetX, offsetY, matrix) {
		            this.offsetX = offsetX;
		            this.offsetY = offsetY;
		            this.matrix = matrix;
		            this.type = 0 /* TRANSFORM */;
		            this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
		        }
		        return TransformEffect;
		    }());
		    var ClipEffect = /** @class */ (function () {
		        function ClipEffect(path, target) {
		            this.path = path;
		            this.target = target;
		            this.type = 1 /* CLIP */;
		        }
		        return ClipEffect;
		    }());
		    var OpacityEffect = /** @class */ (function () {
		        function OpacityEffect(opacity) {
		            this.opacity = opacity;
		            this.type = 2 /* OPACITY */;
		            this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
		        }
		        return OpacityEffect;
		    }());
		    var isTransformEffect = function (effect) {
		        return effect.type === 0 /* TRANSFORM */;
		    };
		    var isClipEffect = function (effect) { return effect.type === 1 /* CLIP */; };
		    var isOpacityEffect = function (effect) { return effect.type === 2 /* OPACITY */; };

		    var equalPath = function (a, b) {
		        if (a.length === b.length) {
		            return a.some(function (v, i) { return v === b[i]; });
		        }
		        return false;
		    };
		    var transformPath = function (path, deltaX, deltaY, deltaW, deltaH) {
		        return path.map(function (point, index) {
		            switch (index) {
		                case 0:
		                    return point.add(deltaX, deltaY);
		                case 1:
		                    return point.add(deltaX + deltaW, deltaY);
		                case 2:
		                    return point.add(deltaX + deltaW, deltaY + deltaH);
		                case 3:
		                    return point.add(deltaX, deltaY + deltaH);
		            }
		            return point;
		        });
		    };

		    var StackingContext = /** @class */ (function () {
		        function StackingContext(container) {
		            this.element = container;
		            this.inlineLevel = [];
		            this.nonInlineLevel = [];
		            this.negativeZIndex = [];
		            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
		            this.positiveZIndex = [];
		            this.nonPositionedFloats = [];
		            this.nonPositionedInlineLevel = [];
		        }
		        return StackingContext;
		    }());
		    var ElementPaint = /** @class */ (function () {
		        function ElementPaint(container, parent) {
		            this.container = container;
		            this.parent = parent;
		            this.effects = [];
		            this.curves = new BoundCurves(this.container);
		            if (this.container.styles.opacity < 1) {
		                this.effects.push(new OpacityEffect(this.container.styles.opacity));
		            }
		            if (this.container.styles.transform !== null) {
		                var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
		                var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
		                var matrix = this.container.styles.transform;
		                this.effects.push(new TransformEffect(offsetX, offsetY, matrix));
		            }
		            if (this.container.styles.overflowX !== 0 /* VISIBLE */) {
		                var borderBox = calculateBorderBoxPath(this.curves);
		                var paddingBox = calculatePaddingBoxPath(this.curves);
		                if (equalPath(borderBox, paddingBox)) {
		                    this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
		                }
		                else {
		                    this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */));
		                    this.effects.push(new ClipEffect(paddingBox, 4 /* CONTENT */));
		                }
		            }
		        }
		        ElementPaint.prototype.getEffects = function (target) {
		            var inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(this.container.styles.position) === -1;
		            var parent = this.parent;
		            var effects = this.effects.slice(0);
		            while (parent) {
		                var croplessEffects = parent.effects.filter(function (effect) { return !isClipEffect(effect); });
		                if (inFlow || parent.container.styles.position !== 0 /* STATIC */ || !parent.parent) {
		                    effects.unshift.apply(effects, croplessEffects);
		                    inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(parent.container.styles.position) === -1;
		                    if (parent.container.styles.overflowX !== 0 /* VISIBLE */) {
		                        var borderBox = calculateBorderBoxPath(parent.curves);
		                        var paddingBox = calculatePaddingBoxPath(parent.curves);
		                        if (!equalPath(borderBox, paddingBox)) {
		                            effects.unshift(new ClipEffect(paddingBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
		                        }
		                    }
		                }
		                else {
		                    effects.unshift.apply(effects, croplessEffects);
		                }
		                parent = parent.parent;
		            }
		            return effects.filter(function (effect) { return contains(effect.target, target); });
		        };
		        return ElementPaint;
		    }());
		    var parseStackTree = function (parent, stackingContext, realStackingContext, listItems) {
		        parent.container.elements.forEach(function (child) {
		            var treatAsRealStackingContext = contains(child.flags, 4 /* CREATES_REAL_STACKING_CONTEXT */);
		            var createsStackingContext = contains(child.flags, 2 /* CREATES_STACKING_CONTEXT */);
		            var paintContainer = new ElementPaint(child, parent);
		            if (contains(child.styles.display, 2048 /* LIST_ITEM */)) {
		                listItems.push(paintContainer);
		            }
		            var listOwnerItems = contains(child.flags, 8 /* IS_LIST_OWNER */) ? [] : listItems;
		            if (treatAsRealStackingContext || createsStackingContext) {
		                var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
		                var stack = new StackingContext(paintContainer);
		                if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
		                    var order_1 = child.styles.zIndex.order;
		                    if (order_1 < 0) {
		                        var index_1 = 0;
		                        parentStack.negativeZIndex.some(function (current, i) {
		                            if (order_1 > current.element.container.styles.zIndex.order) {
		                                index_1 = i;
		                                return false;
		                            }
		                            else if (index_1 > 0) {
		                                return true;
		                            }
		                            return false;
		                        });
		                        parentStack.negativeZIndex.splice(index_1, 0, stack);
		                    }
		                    else if (order_1 > 0) {
		                        var index_2 = 0;
		                        parentStack.positiveZIndex.some(function (current, i) {
		                            if (order_1 >= current.element.container.styles.zIndex.order) {
		                                index_2 = i + 1;
		                                return false;
		                            }
		                            else if (index_2 > 0) {
		                                return true;
		                            }
		                            return false;
		                        });
		                        parentStack.positiveZIndex.splice(index_2, 0, stack);
		                    }
		                    else {
		                        parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
		                    }
		                }
		                else {
		                    if (child.styles.isFloating()) {
		                        parentStack.nonPositionedFloats.push(stack);
		                    }
		                    else {
		                        parentStack.nonPositionedInlineLevel.push(stack);
		                    }
		                }
		                parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
		            }
		            else {
		                if (child.styles.isInlineLevel()) {
		                    stackingContext.inlineLevel.push(paintContainer);
		                }
		                else {
		                    stackingContext.nonInlineLevel.push(paintContainer);
		                }
		                parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
		            }
		            if (contains(child.flags, 8 /* IS_LIST_OWNER */)) {
		                processListItems(child, listOwnerItems);
		            }
		        });
		    };
		    var processListItems = function (owner, elements) {
		        var numbering = owner instanceof OLElementContainer ? owner.start : 1;
		        var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
		        for (var i = 0; i < elements.length; i++) {
		            var item = elements[i];
		            if (item.container instanceof LIElementContainer &&
		                typeof item.container.value === 'number' &&
		                item.container.value !== 0) {
		                numbering = item.container.value;
		            }
		            item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
		            numbering += reversed ? -1 : 1;
		        }
		    };
		    var parseStackingContexts = function (container) {
		        var paintContainer = new ElementPaint(container, null);
		        var root = new StackingContext(paintContainer);
		        var listItems = [];
		        parseStackTree(paintContainer, root, root, listItems);
		        processListItems(paintContainer.container, listItems);
		        return root;
		    };

		    var parsePathForBorder = function (curves, borderSide) {
		        switch (borderSide) {
		            case 0:
		                return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
		            case 1:
		                return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
		            case 2:
		                return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
		            case 3:
		            default:
		                return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
		        }
		    };
		    var parsePathForBorderDoubleOuter = function (curves, borderSide) {
		        switch (borderSide) {
		            case 0:
		                return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
		            case 1:
		                return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
		            case 2:
		                return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
		            case 3:
		            default:
		                return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
		        }
		    };
		    var parsePathForBorderDoubleInner = function (curves, borderSide) {
		        switch (borderSide) {
		            case 0:
		                return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
		            case 1:
		                return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
		            case 2:
		                return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
		            case 3:
		            default:
		                return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
		        }
		    };
		    var parsePathForBorderStroke = function (curves, borderSide) {
		        switch (borderSide) {
		            case 0:
		                return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
		            case 1:
		                return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
		            case 2:
		                return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
		            case 3:
		            default:
		                return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
		        }
		    };
		    var createStrokePathFromCurves = function (outer1, outer2) {
		        var path = [];
		        if (isBezierCurve(outer1)) {
		            path.push(outer1.subdivide(0.5, false));
		        }
		        else {
		            path.push(outer1);
		        }
		        if (isBezierCurve(outer2)) {
		            path.push(outer2.subdivide(0.5, true));
		        }
		        else {
		            path.push(outer2);
		        }
		        return path;
		    };
		    var createPathFromCurves = function (outer1, inner1, outer2, inner2) {
		        var path = [];
		        if (isBezierCurve(outer1)) {
		            path.push(outer1.subdivide(0.5, false));
		        }
		        else {
		            path.push(outer1);
		        }
		        if (isBezierCurve(outer2)) {
		            path.push(outer2.subdivide(0.5, true));
		        }
		        else {
		            path.push(outer2);
		        }
		        if (isBezierCurve(inner2)) {
		            path.push(inner2.subdivide(0.5, true).reverse());
		        }
		        else {
		            path.push(inner2);
		        }
		        if (isBezierCurve(inner1)) {
		            path.push(inner1.subdivide(0.5, false).reverse());
		        }
		        else {
		            path.push(inner1);
		        }
		        return path;
		    };

		    var paddingBox = function (element) {
		        var bounds = element.bounds;
		        var styles = element.styles;
		        return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
		    };
		    var contentBox = function (element) {
		        var styles = element.styles;
		        var bounds = element.bounds;
		        var paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);
		        var paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);
		        var paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);
		        var paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);
		        return bounds.add(paddingLeft + styles.borderLeftWidth, paddingTop + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom));
		    };

		    var calculateBackgroundPositioningArea = function (backgroundOrigin, element) {
		        if (backgroundOrigin === 0 /* BORDER_BOX */) {
		            return element.bounds;
		        }
		        if (backgroundOrigin === 2 /* CONTENT_BOX */) {
		            return contentBox(element);
		        }
		        return paddingBox(element);
		    };
		    var calculateBackgroundPaintingArea = function (backgroundClip, element) {
		        if (backgroundClip === 0 /* BORDER_BOX */) {
		            return element.bounds;
		        }
		        if (backgroundClip === 2 /* CONTENT_BOX */) {
		            return contentBox(element);
		        }
		        return paddingBox(element);
		    };
		    var calculateBackgroundRendering = function (container, index, intrinsicSize) {
		        var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
		        var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
		        var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
		        var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
		        var position = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
		        var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
		        var offsetX = Math.round(backgroundPositioningArea.left + position[0]);
		        var offsetY = Math.round(backgroundPositioningArea.top + position[1]);
		        return [path, offsetX, offsetY, sizeWidth, sizeHeight];
		    };
		    var isAuto = function (token) { return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO; };
		    var hasIntrinsicValue = function (value) { return typeof value === 'number'; };
		    var calculateBackgroundSize = function (size, _a, bounds) {
		        var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];
		        var first = size[0], second = size[1];
		        if (!first) {
		            return [0, 0];
		        }
		        if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
		            return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
		        }
		        var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
		        if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
		            if (hasIntrinsicValue(intrinsicProportion)) {
		                var targetRatio = bounds.width / bounds.height;
		                return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER)
		                    ? [bounds.width, bounds.width / intrinsicProportion]
		                    : [bounds.height * intrinsicProportion, bounds.height];
		            }
		            return [bounds.width, bounds.height];
		        }
		        var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
		        var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
		        var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
		        // If the background-size is auto or auto auto:
		        if (isAuto(first) && (!second || isAuto(second))) {
		            // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.
		            if (hasIntrinsicWidth && hasIntrinsicHeight) {
		                return [intrinsicWidth, intrinsicHeight];
		            }
		            // If the image has no intrinsic dimensions and has no intrinsic proportions,
		            // it's rendered at the size of the background positioning area.
		            if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
		                return [bounds.width, bounds.height];
		            }
		            // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.
		            // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.
		            // The other dimension is computed using the specified dimension and the intrinsic proportions.
		            if (hasIntrinsicDimensions && hasIntrinsicProportion) {
		                var width_1 = hasIntrinsicWidth
		                    ? intrinsicWidth
		                    : intrinsicHeight * intrinsicProportion;
		                var height_1 = hasIntrinsicHeight
		                    ? intrinsicHeight
		                    : intrinsicWidth / intrinsicProportion;
		                return [width_1, height_1];
		            }
		            // If the image has only one intrinsic dimension but has no intrinsic proportions,
		            // it's rendered using the specified dimension and the other dimension of the background positioning area.
		            var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
		            var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
		            return [width_2, height_2];
		        }
		        // If the image has intrinsic proportions, it's stretched to the specified dimension.
		        // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.
		        if (hasIntrinsicProportion) {
		            var width_3 = 0;
		            var height_3 = 0;
		            if (isLengthPercentage(first)) {
		                width_3 = getAbsoluteValue(first, bounds.width);
		            }
		            else if (isLengthPercentage(second)) {
		                height_3 = getAbsoluteValue(second, bounds.height);
		            }
		            if (isAuto(first)) {
		                width_3 = height_3 * intrinsicProportion;
		            }
		            else if (!second || isAuto(second)) {
		                height_3 = width_3 / intrinsicProportion;
		            }
		            return [width_3, height_3];
		        }
		        // If the image has no intrinsic proportions, it's stretched to the specified dimension.
		        // The unspecified dimension is computed using the image's corresponding intrinsic dimension,
		        // if there is one. If there is no such intrinsic dimension,
		        // it becomes the corresponding dimension of the background positioning area.
		        var width = null;
		        var height = null;
		        if (isLengthPercentage(first)) {
		            width = getAbsoluteValue(first, bounds.width);
		        }
		        else if (second && isLengthPercentage(second)) {
		            height = getAbsoluteValue(second, bounds.height);
		        }
		        if (width !== null && (!second || isAuto(second))) {
		            height =
		                hasIntrinsicWidth && hasIntrinsicHeight
		                    ? (width / intrinsicWidth) * intrinsicHeight
		                    : bounds.height;
		        }
		        if (height !== null && isAuto(first)) {
		            width =
		                hasIntrinsicWidth && hasIntrinsicHeight
		                    ? (height / intrinsicHeight) * intrinsicWidth
		                    : bounds.width;
		        }
		        if (width !== null && height !== null) {
		            return [width, height];
		        }
		        throw new Error("Unable to calculate background-size for element");
		    };
		    var getBackgroundValueForIndex = function (values, index) {
		        var value = values[index];
		        if (typeof value === 'undefined') {
		            return values[0];
		        }
		        return value;
		    };
		    var calculateBackgroundRepeatPath = function (repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
		        var x = _a[0], y = _a[1];
		        var width = _b[0], height = _b[1];
		        switch (repeat) {
		            case 2 /* REPEAT_X */:
		                return [
		                    new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
		                    new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
		                    new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
		                    new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
		                ];
		            case 3 /* REPEAT_Y */:
		                return [
		                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
		                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
		                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
		                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
		                ];
		            case 1 /* NO_REPEAT */:
		                return [
		                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
		                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
		                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
		                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
		                ];
		            default:
		                return [
		                    new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
		                    new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
		                    new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
		                    new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
		                ];
		        }
		    };

		    var SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

		    var SAMPLE_TEXT = 'Hidden Text';
		    var FontMetrics = /** @class */ (function () {
		        function FontMetrics(document) {
		            this._data = {};
		            this._document = document;
		        }
		        FontMetrics.prototype.parseMetrics = function (fontFamily, fontSize) {
		            var container = this._document.createElement('div');
		            var img = this._document.createElement('img');
		            var span = this._document.createElement('span');
		            var body = this._document.body;
		            container.style.visibility = 'hidden';
		            container.style.fontFamily = fontFamily;
		            container.style.fontSize = fontSize;
		            container.style.margin = '0';
		            container.style.padding = '0';
		            container.style.whiteSpace = 'nowrap';
		            body.appendChild(container);
		            img.src = SMALL_IMAGE;
		            img.width = 1;
		            img.height = 1;
		            img.style.margin = '0';
		            img.style.padding = '0';
		            img.style.verticalAlign = 'baseline';
		            span.style.fontFamily = fontFamily;
		            span.style.fontSize = fontSize;
		            span.style.margin = '0';
		            span.style.padding = '0';
		            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
		            container.appendChild(span);
		            container.appendChild(img);
		            var baseline = img.offsetTop - span.offsetTop + 2;
		            container.removeChild(span);
		            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
		            container.style.lineHeight = 'normal';
		            img.style.verticalAlign = 'super';
		            var middle = img.offsetTop - container.offsetTop + 2;
		            body.removeChild(container);
		            return { baseline: baseline, middle: middle };
		        };
		        FontMetrics.prototype.getMetrics = function (fontFamily, fontSize) {
		            var key = fontFamily + " " + fontSize;
		            if (typeof this._data[key] === 'undefined') {
		                this._data[key] = this.parseMetrics(fontFamily, fontSize);
		            }
		            return this._data[key];
		        };
		        return FontMetrics;
		    }());

		    var Renderer = /** @class */ (function () {
		        function Renderer(context, options) {
		            this.context = context;
		            this.options = options;
		        }
		        return Renderer;
		    }());

		    var MASK_OFFSET = 10000;
		    var CanvasRenderer = /** @class */ (function (_super) {
		        __extends(CanvasRenderer, _super);
		        function CanvasRenderer(context, options) {
		            var _this = _super.call(this, context, options) || this;
		            _this._activeEffects = [];
		            _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
		            _this.ctx = _this.canvas.getContext('2d');
		            if (!options.canvas) {
		                _this.canvas.width = Math.floor(options.width * options.scale);
		                _this.canvas.height = Math.floor(options.height * options.scale);
		                _this.canvas.style.width = options.width + "px";
		                _this.canvas.style.height = options.height + "px";
		            }
		            _this.fontMetrics = new FontMetrics(document);
		            _this.ctx.scale(_this.options.scale, _this.options.scale);
		            _this.ctx.translate(-options.x, -options.y);
		            _this.ctx.textBaseline = 'bottom';
		            _this._activeEffects = [];
		            _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
		            return _this;
		        }
		        CanvasRenderer.prototype.applyEffects = function (effects) {
		            var _this = this;
		            while (this._activeEffects.length) {
		                this.popEffect();
		            }
		            effects.forEach(function (effect) { return _this.applyEffect(effect); });
		        };
		        CanvasRenderer.prototype.applyEffect = function (effect) {
		            this.ctx.save();
		            if (isOpacityEffect(effect)) {
		                this.ctx.globalAlpha = effect.opacity;
		            }
		            if (isTransformEffect(effect)) {
		                this.ctx.translate(effect.offsetX, effect.offsetY);
		                this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
		                this.ctx.translate(-effect.offsetX, -effect.offsetY);
		            }
		            if (isClipEffect(effect)) {
		                this.path(effect.path);
		                this.ctx.clip();
		            }
		            this._activeEffects.push(effect);
		        };
		        CanvasRenderer.prototype.popEffect = function () {
		            this._activeEffects.pop();
		            this.ctx.restore();
		        };
		        CanvasRenderer.prototype.renderStack = function (stack) {
		            return __awaiter(this, void 0, void 0, function () {
		                var styles;
		                return __generator(this, function (_a) {
		                    switch (_a.label) {
		                        case 0:
		                            styles = stack.element.container.styles;
		                            if (!styles.isVisible()) return [3 /*break*/, 2];
		                            return [4 /*yield*/, this.renderStackContent(stack)];
		                        case 1:
		                            _a.sent();
		                            _a.label = 2;
		                        case 2: return [2 /*return*/];
		                    }
		                });
		            });
		        };
		        CanvasRenderer.prototype.renderNode = function (paint) {
		            return __awaiter(this, void 0, void 0, function () {
		                return __generator(this, function (_a) {
		                    switch (_a.label) {
		                        case 0:
		                            if (contains(paint.container.flags, 16 /* DEBUG_RENDER */)) {
		                                debugger;
		                            }
		                            if (!paint.container.styles.isVisible()) return [3 /*break*/, 3];
		                            return [4 /*yield*/, this.renderNodeBackgroundAndBorders(paint)];
		                        case 1:
		                            _a.sent();
		                            return [4 /*yield*/, this.renderNodeContent(paint)];
		                        case 2:
		                            _a.sent();
		                            _a.label = 3;
		                        case 3: return [2 /*return*/];
		                    }
		                });
		            });
		        };
		        CanvasRenderer.prototype.renderTextWithLetterSpacing = function (text, letterSpacing, baseline) {
		            var _this = this;
		            if (letterSpacing === 0) {
		                this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
		            }
		            else {
		                var letters = segmentGraphemes(text.text);
		                letters.reduce(function (left, letter) {
		                    _this.ctx.fillText(letter, left, text.bounds.top + baseline);
		                    return left + _this.ctx.measureText(letter).width;
		                }, text.bounds.left);
		            }
		        };
		        CanvasRenderer.prototype.createFontStyle = function (styles) {
		            var fontVariant = styles.fontVariant
		                .filter(function (variant) { return variant === 'normal' || variant === 'small-caps'; })
		                .join('');
		            var fontFamily = fixIOSSystemFonts(styles.fontFamily).join(', ');
		            var fontSize = isDimensionToken(styles.fontSize)
		                ? "" + styles.fontSize.number + styles.fontSize.unit
		                : styles.fontSize.number + "px";
		            return [
		                [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),
		                fontFamily,
		                fontSize
		            ];
		        };
		        CanvasRenderer.prototype.renderTextNode = function (text, styles) {
		            return __awaiter(this, void 0, void 0, function () {
		                var _a, font, fontFamily, fontSize, _b, baseline, middle, paintOrder;
		                var _this = this;
		                return __generator(this, function (_c) {
		                    _a = this.createFontStyle(styles), font = _a[0], fontFamily = _a[1], fontSize = _a[2];
		                    this.ctx.font = font;
		                    this.ctx.direction = styles.direction === 1 /* RTL */ ? 'rtl' : 'ltr';
		                    this.ctx.textAlign = 'left';
		                    this.ctx.textBaseline = 'alphabetic';
		                    _b = this.fontMetrics.getMetrics(fontFamily, fontSize), baseline = _b.baseline, middle = _b.middle;
		                    paintOrder = styles.paintOrder;
		                    text.textBounds.forEach(function (text) {
		                        paintOrder.forEach(function (paintOrderLayer) {
		                            switch (paintOrderLayer) {
		                                case 0 /* FILL */:
		                                    _this.ctx.fillStyle = asString(styles.color);
		                                    _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
		                                    var textShadows = styles.textShadow;
		                                    if (textShadows.length && text.text.trim().length) {
		                                        textShadows
		                                            .slice(0)
		                                            .reverse()
		                                            .forEach(function (textShadow) {
		                                            _this.ctx.shadowColor = asString(textShadow.color);
		                                            _this.ctx.shadowOffsetX = textShadow.offsetX.number * _this.options.scale;
		                                            _this.ctx.shadowOffsetY = textShadow.offsetY.number * _this.options.scale;
		                                            _this.ctx.shadowBlur = textShadow.blur.number;
		                                            _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
		                                        });
		                                        _this.ctx.shadowColor = '';
		                                        _this.ctx.shadowOffsetX = 0;
		                                        _this.ctx.shadowOffsetY = 0;
		                                        _this.ctx.shadowBlur = 0;
		                                    }
		                                    if (styles.textDecorationLine.length) {
		                                        _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
		                                        styles.textDecorationLine.forEach(function (textDecorationLine) {
		                                            switch (textDecorationLine) {
		                                                case 1 /* UNDERLINE */:
		                                                    // Draws a line at the baseline of the font
		                                                    // TODO As some browsers display the line as more than 1px if the font-size is big,
		                                                    // need to take that into account both in position and size
		                                                    _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1);
		                                                    break;
		                                                case 2 /* OVERLINE */:
		                                                    _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);
		                                                    break;
		                                                case 3 /* LINE_THROUGH */:
		                                                    // TODO try and find exact position for line-through
		                                                    _this.ctx.fillRect(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1);
		                                                    break;
		                                            }
		                                        });
		                                    }
		                                    break;
		                                case 1 /* STROKE */:
		                                    if (styles.webkitTextStrokeWidth && text.text.trim().length) {
		                                        _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
		                                        _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
		                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
		                                        _this.ctx.lineJoin = !!window.chrome ? 'miter' : 'round';
		                                        _this.ctx.strokeText(text.text, text.bounds.left, text.bounds.top + baseline);
		                                    }
		                                    _this.ctx.strokeStyle = '';
		                                    _this.ctx.lineWidth = 0;
		                                    _this.ctx.lineJoin = 'miter';
		                                    break;
		                            }
		                        });
		                    });
		                    return [2 /*return*/];
		                });
		            });
		        };
		        CanvasRenderer.prototype.renderReplacedElement = function (container, curves, image) {
		            if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
		                var box = contentBox(container);
		                var path = calculatePaddingBoxPath(curves);
		                this.path(path);
		                this.ctx.save();
		                this.ctx.clip();
		                this.ctx.drawImage(image, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
		                this.ctx.restore();
		            }
		        };
		        CanvasRenderer.prototype.renderNodeContent = function (paint) {
		            return __awaiter(this, void 0, void 0, function () {
		                var container, curves, styles, _i, _a, child, image, image, iframeRenderer, canvas, size, _b, fontFamily, fontSize, baseline, bounds, x, textBounds, img, image, url, fontFamily, bounds;
		                return __generator(this, function (_c) {
		                    switch (_c.label) {
		                        case 0:
		                            this.applyEffects(paint.getEffects(4 /* CONTENT */));
		                            container = paint.container;
		                            curves = paint.curves;
		                            styles = container.styles;
		                            _i = 0, _a = container.textNodes;
		                            _c.label = 1;
		                        case 1:
		                            if (!(_i < _a.length)) return [3 /*break*/, 4];
		                            child = _a[_i];
		                            return [4 /*yield*/, this.renderTextNode(child, styles)];
		                        case 2:
		                            _c.sent();
		                            _c.label = 3;
		                        case 3:
		                            _i++;
		                            return [3 /*break*/, 1];
		                        case 4:
		                            if (!(container instanceof ImageElementContainer)) return [3 /*break*/, 8];
		                            _c.label = 5;
		                        case 5:
		                            _c.trys.push([5, 7, , 8]);
		                            return [4 /*yield*/, this.context.cache.match(container.src)];
		                        case 6:
		                            image = _c.sent();
		                            this.renderReplacedElement(container, curves, image);
		                            return [3 /*break*/, 8];
		                        case 7:
		                            _c.sent();
		                            this.context.logger.error("Error loading image " + container.src);
		                            return [3 /*break*/, 8];
		                        case 8:
		                            if (container instanceof CanvasElementContainer) {
		                                this.renderReplacedElement(container, curves, container.canvas);
		                            }
		                            if (!(container instanceof SVGElementContainer)) return [3 /*break*/, 12];
		                            _c.label = 9;
		                        case 9:
		                            _c.trys.push([9, 11, , 12]);
		                            return [4 /*yield*/, this.context.cache.match(container.svg)];
		                        case 10:
		                            image = _c.sent();
		                            this.renderReplacedElement(container, curves, image);
		                            return [3 /*break*/, 12];
		                        case 11:
		                            _c.sent();
		                            this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
		                            return [3 /*break*/, 12];
		                        case 12:
		                            if (!(container instanceof IFrameElementContainer && container.tree)) return [3 /*break*/, 14];
		                            iframeRenderer = new CanvasRenderer(this.context, {
		                                scale: this.options.scale,
		                                backgroundColor: container.backgroundColor,
		                                x: 0,
		                                y: 0,
		                                width: container.width,
		                                height: container.height
		                            });
		                            return [4 /*yield*/, iframeRenderer.render(container.tree)];
		                        case 13:
		                            canvas = _c.sent();
		                            if (container.width && container.height) {
		                                this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
		                            }
		                            _c.label = 14;
		                        case 14:
		                            if (container instanceof InputElementContainer) {
		                                size = Math.min(container.bounds.width, container.bounds.height);
		                                if (container.type === CHECKBOX) {
		                                    if (container.checked) {
		                                        this.ctx.save();
		                                        this.path([
		                                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
		                                            new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
		                                            new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
		                                            new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
		                                            new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
		                                            new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
		                                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
		                                        ]);
		                                        this.ctx.fillStyle = asString(INPUT_COLOR);
		                                        this.ctx.fill();
		                                        this.ctx.restore();
		                                    }
		                                }
		                                else if (container.type === RADIO) {
		                                    if (container.checked) {
		                                        this.ctx.save();
		                                        this.ctx.beginPath();
		                                        this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
		                                        this.ctx.fillStyle = asString(INPUT_COLOR);
		                                        this.ctx.fill();
		                                        this.ctx.restore();
		                                    }
		                                }
		                            }
		                            if (isTextInputElement(container) && container.value.length) {
		                                _b = this.createFontStyle(styles), fontFamily = _b[0], fontSize = _b[1];
		                                baseline = this.fontMetrics.getMetrics(fontFamily, fontSize).baseline;
		                                this.ctx.font = fontFamily;
		                                this.ctx.fillStyle = asString(styles.color);
		                                this.ctx.textBaseline = 'alphabetic';
		                                this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
		                                bounds = contentBox(container);
		                                x = 0;
		                                switch (container.styles.textAlign) {
		                                    case 1 /* CENTER */:
		                                        x += bounds.width / 2;
		                                        break;
		                                    case 2 /* RIGHT */:
		                                        x += bounds.width;
		                                        break;
		                                }
		                                textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
		                                this.ctx.save();
		                                this.path([
		                                    new Vector(bounds.left, bounds.top),
		                                    new Vector(bounds.left + bounds.width, bounds.top),
		                                    new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
		                                    new Vector(bounds.left, bounds.top + bounds.height)
		                                ]);
		                                this.ctx.clip();
		                                this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
		                                this.ctx.restore();
		                                this.ctx.textBaseline = 'alphabetic';
		                                this.ctx.textAlign = 'left';
		                            }
		                            if (!contains(container.styles.display, 2048 /* LIST_ITEM */)) return [3 /*break*/, 20];
		                            if (!(container.styles.listStyleImage !== null)) return [3 /*break*/, 19];
		                            img = container.styles.listStyleImage;
		                            if (!(img.type === 0 /* URL */)) return [3 /*break*/, 18];
		                            image = void 0;
		                            url = img.url;
		                            _c.label = 15;
		                        case 15:
		                            _c.trys.push([15, 17, , 18]);
		                            return [4 /*yield*/, this.context.cache.match(url)];
		                        case 16:
		                            image = _c.sent();
		                            this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);
		                            return [3 /*break*/, 18];
		                        case 17:
		                            _c.sent();
		                            this.context.logger.error("Error loading list-style-image " + url);
		                            return [3 /*break*/, 18];
		                        case 18: return [3 /*break*/, 20];
		                        case 19:
		                            if (paint.listValue && container.styles.listStyleType !== -1 /* NONE */) {
		                                fontFamily = this.createFontStyle(styles)[0];
		                                this.ctx.font = fontFamily;
		                                this.ctx.fillStyle = asString(styles.color);
		                                this.ctx.textBaseline = 'middle';
		                                this.ctx.textAlign = 'right';
		                                bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
		                                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
		                                this.ctx.textBaseline = 'bottom';
		                                this.ctx.textAlign = 'left';
		                            }
		                            _c.label = 20;
		                        case 20: return [2 /*return*/];
		                    }
		                });
		            });
		        };
		        CanvasRenderer.prototype.renderStackContent = function (stack) {
		            return __awaiter(this, void 0, void 0, function () {
		                var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
		                return __generator(this, function (_p) {
		                    switch (_p.label) {
		                        case 0:
		                            if (contains(stack.element.container.flags, 16 /* DEBUG_RENDER */)) {
		                                debugger;
		                            }
		                            // https://www.w3.org/TR/css-position-3/#painting-order
		                            // 1. the background and borders of the element forming the stacking context.
		                            return [4 /*yield*/, this.renderNodeBackgroundAndBorders(stack.element)];
		                        case 1:
		                            // https://www.w3.org/TR/css-position-3/#painting-order
		                            // 1. the background and borders of the element forming the stacking context.
		                            _p.sent();
		                            _i = 0, _a = stack.negativeZIndex;
		                            _p.label = 2;
		                        case 2:
		                            if (!(_i < _a.length)) return [3 /*break*/, 5];
		                            child = _a[_i];
		                            return [4 /*yield*/, this.renderStack(child)];
		                        case 3:
		                            _p.sent();
		                            _p.label = 4;
		                        case 4:
		                            _i++;
		                            return [3 /*break*/, 2];
		                        case 5: 
		                        // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
		                        return [4 /*yield*/, this.renderNodeContent(stack.element)];
		                        case 6:
		                            // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
		                            _p.sent();
		                            _b = 0, _c = stack.nonInlineLevel;
		                            _p.label = 7;
		                        case 7:
		                            if (!(_b < _c.length)) return [3 /*break*/, 10];
		                            child = _c[_b];
		                            return [4 /*yield*/, this.renderNode(child)];
		                        case 8:
		                            _p.sent();
		                            _p.label = 9;
		                        case 9:
		                            _b++;
		                            return [3 /*break*/, 7];
		                        case 10:
		                            _d = 0, _e = stack.nonPositionedFloats;
		                            _p.label = 11;
		                        case 11:
		                            if (!(_d < _e.length)) return [3 /*break*/, 14];
		                            child = _e[_d];
		                            return [4 /*yield*/, this.renderStack(child)];
		                        case 12:
		                            _p.sent();
		                            _p.label = 13;
		                        case 13:
		                            _d++;
		                            return [3 /*break*/, 11];
		                        case 14:
		                            _f = 0, _g = stack.nonPositionedInlineLevel;
		                            _p.label = 15;
		                        case 15:
		                            if (!(_f < _g.length)) return [3 /*break*/, 18];
		                            child = _g[_f];
		                            return [4 /*yield*/, this.renderStack(child)];
		                        case 16:
		                            _p.sent();
		                            _p.label = 17;
		                        case 17:
		                            _f++;
		                            return [3 /*break*/, 15];
		                        case 18:
		                            _h = 0, _j = stack.inlineLevel;
		                            _p.label = 19;
		                        case 19:
		                            if (!(_h < _j.length)) return [3 /*break*/, 22];
		                            child = _j[_h];
		                            return [4 /*yield*/, this.renderNode(child)];
		                        case 20:
		                            _p.sent();
		                            _p.label = 21;
		                        case 21:
		                            _h++;
		                            return [3 /*break*/, 19];
		                        case 22:
		                            _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
		                            _p.label = 23;
		                        case 23:
		                            if (!(_k < _l.length)) return [3 /*break*/, 26];
		                            child = _l[_k];
		                            return [4 /*yield*/, this.renderStack(child)];
		                        case 24:
		                            _p.sent();
		                            _p.label = 25;
		                        case 25:
		                            _k++;
		                            return [3 /*break*/, 23];
		                        case 26:
		                            _m = 0, _o = stack.positiveZIndex;
		                            _p.label = 27;
		                        case 27:
		                            if (!(_m < _o.length)) return [3 /*break*/, 30];
		                            child = _o[_m];
		                            return [4 /*yield*/, this.renderStack(child)];
		                        case 28:
		                            _p.sent();
		                            _p.label = 29;
		                        case 29:
		                            _m++;
		                            return [3 /*break*/, 27];
		                        case 30: return [2 /*return*/];
		                    }
		                });
		            });
		        };
		        CanvasRenderer.prototype.mask = function (paths) {
		            this.ctx.beginPath();
		            this.ctx.moveTo(0, 0);
		            this.ctx.lineTo(this.canvas.width, 0);
		            this.ctx.lineTo(this.canvas.width, this.canvas.height);
		            this.ctx.lineTo(0, this.canvas.height);
		            this.ctx.lineTo(0, 0);
		            this.formatPath(paths.slice(0).reverse());
		            this.ctx.closePath();
		        };
		        CanvasRenderer.prototype.path = function (paths) {
		            this.ctx.beginPath();
		            this.formatPath(paths);
		            this.ctx.closePath();
		        };
		        CanvasRenderer.prototype.formatPath = function (paths) {
		            var _this = this;
		            paths.forEach(function (point, index) {
		                var start = isBezierCurve(point) ? point.start : point;
		                if (index === 0) {
		                    _this.ctx.moveTo(start.x, start.y);
		                }
		                else {
		                    _this.ctx.lineTo(start.x, start.y);
		                }
		                if (isBezierCurve(point)) {
		                    _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
		                }
		            });
		        };
		        CanvasRenderer.prototype.renderRepeat = function (path, pattern, offsetX, offsetY) {
		            this.path(path);
		            this.ctx.fillStyle = pattern;
		            this.ctx.translate(offsetX, offsetY);
		            this.ctx.fill();
		            this.ctx.translate(-offsetX, -offsetY);
		        };
		        CanvasRenderer.prototype.resizeImage = function (image, width, height) {
		            var _a;
		            if (image.width === width && image.height === height) {
		                return image;
		            }
		            var ownerDocument = (_a = this.canvas.ownerDocument) !== null && _a !== void 0 ? _a : document;
		            var canvas = ownerDocument.createElement('canvas');
		            canvas.width = Math.max(1, width);
		            canvas.height = Math.max(1, height);
		            var ctx = canvas.getContext('2d');
		            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
		            return canvas;
		        };
		        CanvasRenderer.prototype.renderBackgroundImage = function (container) {
		            return __awaiter(this, void 0, void 0, function () {
		                var index, _loop_1, this_1, _i, _a, backgroundImage;
		                return __generator(this, function (_b) {
		                    switch (_b.label) {
		                        case 0:
		                            index = container.styles.backgroundImage.length - 1;
		                            _loop_1 = function (backgroundImage) {
		                                var image, url, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position, x, y, _g, rx, ry, radialGradient_1, midX, midY, f, invF;
		                                return __generator(this, function (_h) {
		                                    switch (_h.label) {
		                                        case 0:
		                                            if (!(backgroundImage.type === 0 /* URL */)) return [3 /*break*/, 5];
		                                            image = void 0;
		                                            url = backgroundImage.url;
		                                            _h.label = 1;
		                                        case 1:
		                                            _h.trys.push([1, 3, , 4]);
		                                            return [4 /*yield*/, this_1.context.cache.match(url)];
		                                        case 2:
		                                            image = _h.sent();
		                                            return [3 /*break*/, 4];
		                                        case 3:
		                                            _h.sent();
		                                            this_1.context.logger.error("Error loading background-image " + url);
		                                            return [3 /*break*/, 4];
		                                        case 4:
		                                            if (image) {
		                                                _c = calculateBackgroundRendering(container, index, [
		                                                    image.width,
		                                                    image.height,
		                                                    image.width / image.height
		                                                ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
		                                                pattern = this_1.ctx.createPattern(this_1.resizeImage(image, width, height), 'repeat');
		                                                this_1.renderRepeat(path, pattern, x, y);
		                                            }
		                                            return [3 /*break*/, 6];
		                                        case 5:
		                                            if (isLinearGradient(backgroundImage)) {
		                                                _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
		                                                _e = calculateGradientDirection(backgroundImage.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
		                                                canvas = document.createElement('canvas');
		                                                canvas.width = width;
		                                                canvas.height = height;
		                                                ctx = canvas.getContext('2d');
		                                                gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
		                                                processColorStops(backgroundImage.stops, lineLength).forEach(function (colorStop) {
		                                                    return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
		                                                });
		                                                ctx.fillStyle = gradient_1;
		                                                ctx.fillRect(0, 0, width, height);
		                                                if (width > 0 && height > 0) {
		                                                    pattern = this_1.ctx.createPattern(canvas, 'repeat');
		                                                    this_1.renderRepeat(path, pattern, x, y);
		                                                }
		                                            }
		                                            else if (isRadialGradient(backgroundImage)) {
		                                                _f = calculateBackgroundRendering(container, index, [
		                                                    null,
		                                                    null,
		                                                    null
		                                                ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
		                                                position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;
		                                                x = getAbsoluteValue(position[0], width);
		                                                y = getAbsoluteValue(position[position.length - 1], height);
		                                                _g = calculateRadius(backgroundImage, x, y, width, height), rx = _g[0], ry = _g[1];
		                                                if (rx > 0 && ry > 0) {
		                                                    radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
		                                                    processColorStops(backgroundImage.stops, rx * 2).forEach(function (colorStop) {
		                                                        return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
		                                                    });
		                                                    this_1.path(path);
		                                                    this_1.ctx.fillStyle = radialGradient_1;
		                                                    if (rx !== ry) {
		                                                        midX = container.bounds.left + 0.5 * container.bounds.width;
		                                                        midY = container.bounds.top + 0.5 * container.bounds.height;
		                                                        f = ry / rx;
		                                                        invF = 1 / f;
		                                                        this_1.ctx.save();
		                                                        this_1.ctx.translate(midX, midY);
		                                                        this_1.ctx.transform(1, 0, 0, f, 0, 0);
		                                                        this_1.ctx.translate(-midX, -midY);
		                                                        this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
		                                                        this_1.ctx.restore();
		                                                    }
		                                                    else {
		                                                        this_1.ctx.fill();
		                                                    }
		                                                }
		                                            }
		                                            _h.label = 6;
		                                        case 6:
		                                            index--;
		                                            return [2 /*return*/];
		                                    }
		                                });
		                            };
		                            this_1 = this;
		                            _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
		                            _b.label = 1;
		                        case 1:
		                            if (!(_i < _a.length)) return [3 /*break*/, 4];
		                            backgroundImage = _a[_i];
		                            return [5 /*yield**/, _loop_1(backgroundImage)];
		                        case 2:
		                            _b.sent();
		                            _b.label = 3;
		                        case 3:
		                            _i++;
		                            return [3 /*break*/, 1];
		                        case 4: return [2 /*return*/];
		                    }
		                });
		            });
		        };
		        CanvasRenderer.prototype.renderSolidBorder = function (color, side, curvePoints) {
		            return __awaiter(this, void 0, void 0, function () {
		                return __generator(this, function (_a) {
		                    this.path(parsePathForBorder(curvePoints, side));
		                    this.ctx.fillStyle = asString(color);
		                    this.ctx.fill();
		                    return [2 /*return*/];
		                });
		            });
		        };
		        CanvasRenderer.prototype.renderDoubleBorder = function (color, width, side, curvePoints) {
		            return __awaiter(this, void 0, void 0, function () {
		                var outerPaths, innerPaths;
		                return __generator(this, function (_a) {
		                    switch (_a.label) {
		                        case 0:
		                            if (!(width < 3)) return [3 /*break*/, 2];
		                            return [4 /*yield*/, this.renderSolidBorder(color, side, curvePoints)];
		                        case 1:
		                            _a.sent();
		                            return [2 /*return*/];
		                        case 2:
		                            outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
		                            this.path(outerPaths);
		                            this.ctx.fillStyle = asString(color);
		                            this.ctx.fill();
		                            innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
		                            this.path(innerPaths);
		                            this.ctx.fill();
		                            return [2 /*return*/];
		                    }
		                });
		            });
		        };
		        CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function (paint) {
		            return __awaiter(this, void 0, void 0, function () {
		                var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
		                var _this = this;
		                return __generator(this, function (_a) {
		                    switch (_a.label) {
		                        case 0:
		                            this.applyEffects(paint.getEffects(2 /* BACKGROUND_BORDERS */));
		                            styles = paint.container.styles;
		                            hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
		                            borders = [
		                                { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
		                                { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
		                                { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
		                                { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
		                            ];
		                            backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
		                            if (!(hasBackground || styles.boxShadow.length)) return [3 /*break*/, 2];
		                            this.ctx.save();
		                            this.path(backgroundPaintingArea);
		                            this.ctx.clip();
		                            if (!isTransparent(styles.backgroundColor)) {
		                                this.ctx.fillStyle = asString(styles.backgroundColor);
		                                this.ctx.fill();
		                            }
		                            return [4 /*yield*/, this.renderBackgroundImage(paint.container)];
		                        case 1:
		                            _a.sent();
		                            this.ctx.restore();
		                            styles.boxShadow
		                                .slice(0)
		                                .reverse()
		                                .forEach(function (shadow) {
		                                _this.ctx.save();
		                                var borderBoxArea = calculateBorderBoxPath(paint.curves);
		                                var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
		                                var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
		                                if (shadow.inset) {
		                                    _this.path(borderBoxArea);
		                                    _this.ctx.clip();
		                                    _this.mask(shadowPaintingArea);
		                                }
		                                else {
		                                    _this.mask(borderBoxArea);
		                                    _this.ctx.clip();
		                                    _this.path(shadowPaintingArea);
		                                }
		                                _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
		                                _this.ctx.shadowOffsetY = shadow.offsetY.number;
		                                _this.ctx.shadowColor = asString(shadow.color);
		                                _this.ctx.shadowBlur = shadow.blur.number;
		                                _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';
		                                _this.ctx.fill();
		                                _this.ctx.restore();
		                            });
		                            _a.label = 2;
		                        case 2:
		                            side = 0;
		                            _i = 0, borders_1 = borders;
		                            _a.label = 3;
		                        case 3:
		                            if (!(_i < borders_1.length)) return [3 /*break*/, 13];
		                            border = borders_1[_i];
		                            if (!(border.style !== 0 /* NONE */ && !isTransparent(border.color) && border.width > 0)) return [3 /*break*/, 11];
		                            if (!(border.style === 2 /* DASHED */)) return [3 /*break*/, 5];
		                            return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2 /* DASHED */)];
		                        case 4:
		                            _a.sent();
		                            return [3 /*break*/, 11];
		                        case 5:
		                            if (!(border.style === 3 /* DOTTED */)) return [3 /*break*/, 7];
		                            return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3 /* DOTTED */)];
		                        case 6:
		                            _a.sent();
		                            return [3 /*break*/, 11];
		                        case 7:
		                            if (!(border.style === 4 /* DOUBLE */)) return [3 /*break*/, 9];
		                            return [4 /*yield*/, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
		                        case 8:
		                            _a.sent();
		                            return [3 /*break*/, 11];
		                        case 9: return [4 /*yield*/, this.renderSolidBorder(border.color, side, paint.curves)];
		                        case 10:
		                            _a.sent();
		                            _a.label = 11;
		                        case 11:
		                            side++;
		                            _a.label = 12;
		                        case 12:
		                            _i++;
		                            return [3 /*break*/, 3];
		                        case 13: return [2 /*return*/];
		                    }
		                });
		            });
		        };
		        CanvasRenderer.prototype.renderDashedDottedBorder = function (color, width, side, curvePoints, style) {
		            return __awaiter(this, void 0, void 0, function () {
		                var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
		                return __generator(this, function (_a) {
		                    this.ctx.save();
		                    strokePaths = parsePathForBorderStroke(curvePoints, side);
		                    boxPaths = parsePathForBorder(curvePoints, side);
		                    if (style === 2 /* DASHED */) {
		                        this.path(boxPaths);
		                        this.ctx.clip();
		                    }
		                    if (isBezierCurve(boxPaths[0])) {
		                        startX = boxPaths[0].start.x;
		                        startY = boxPaths[0].start.y;
		                    }
		                    else {
		                        startX = boxPaths[0].x;
		                        startY = boxPaths[0].y;
		                    }
		                    if (isBezierCurve(boxPaths[1])) {
		                        endX = boxPaths[1].end.x;
		                        endY = boxPaths[1].end.y;
		                    }
		                    else {
		                        endX = boxPaths[1].x;
		                        endY = boxPaths[1].y;
		                    }
		                    if (side === 0 || side === 2) {
		                        length = Math.abs(startX - endX);
		                    }
		                    else {
		                        length = Math.abs(startY - endY);
		                    }
		                    this.ctx.beginPath();
		                    if (style === 3 /* DOTTED */) {
		                        this.formatPath(strokePaths);
		                    }
		                    else {
		                        this.formatPath(boxPaths.slice(0, 2));
		                    }
		                    dashLength = width < 3 ? width * 3 : width * 2;
		                    spaceLength = width < 3 ? width * 2 : width;
		                    if (style === 3 /* DOTTED */) {
		                        dashLength = width;
		                        spaceLength = width;
		                    }
		                    useLineDash = true;
		                    if (length <= dashLength * 2) {
		                        useLineDash = false;
		                    }
		                    else if (length <= dashLength * 2 + spaceLength) {
		                        multiplier = length / (2 * dashLength + spaceLength);
		                        dashLength *= multiplier;
		                        spaceLength *= multiplier;
		                    }
		                    else {
		                        numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
		                        minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
		                        maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
		                        spaceLength =
		                            maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace)
		                                ? minSpace
		                                : maxSpace;
		                    }
		                    if (useLineDash) {
		                        if (style === 3 /* DOTTED */) {
		                            this.ctx.setLineDash([0, dashLength + spaceLength]);
		                        }
		                        else {
		                            this.ctx.setLineDash([dashLength, spaceLength]);
		                        }
		                    }
		                    if (style === 3 /* DOTTED */) {
		                        this.ctx.lineCap = 'round';
		                        this.ctx.lineWidth = width;
		                    }
		                    else {
		                        this.ctx.lineWidth = width * 2 + 1.1;
		                    }
		                    this.ctx.strokeStyle = asString(color);
		                    this.ctx.stroke();
		                    this.ctx.setLineDash([]);
		                    // dashed round edge gap
		                    if (style === 2 /* DASHED */) {
		                        if (isBezierCurve(boxPaths[0])) {
		                            path1 = boxPaths[3];
		                            path2 = boxPaths[0];
		                            this.ctx.beginPath();
		                            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
		                            this.ctx.stroke();
		                        }
		                        if (isBezierCurve(boxPaths[1])) {
		                            path1 = boxPaths[1];
		                            path2 = boxPaths[2];
		                            this.ctx.beginPath();
		                            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
		                            this.ctx.stroke();
		                        }
		                    }
		                    this.ctx.restore();
		                    return [2 /*return*/];
		                });
		            });
		        };
		        CanvasRenderer.prototype.render = function (element) {
		            return __awaiter(this, void 0, void 0, function () {
		                var stack;
		                return __generator(this, function (_a) {
		                    switch (_a.label) {
		                        case 0:
		                            if (this.options.backgroundColor) {
		                                this.ctx.fillStyle = asString(this.options.backgroundColor);
		                                this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
		                            }
		                            stack = parseStackingContexts(element);
		                            return [4 /*yield*/, this.renderStack(stack)];
		                        case 1:
		                            _a.sent();
		                            this.applyEffects([]);
		                            return [2 /*return*/, this.canvas];
		                    }
		                });
		            });
		        };
		        return CanvasRenderer;
		    }(Renderer));
		    var isTextInputElement = function (container) {
		        if (container instanceof TextareaElementContainer) {
		            return true;
		        }
		        else if (container instanceof SelectElementContainer) {
		            return true;
		        }
		        else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
		            return true;
		        }
		        return false;
		    };
		    var calculateBackgroundCurvedPaintingArea = function (clip, curves) {
		        switch (clip) {
		            case 0 /* BORDER_BOX */:
		                return calculateBorderBoxPath(curves);
		            case 2 /* CONTENT_BOX */:
		                return calculateContentBoxPath(curves);
		            case 1 /* PADDING_BOX */:
		            default:
		                return calculatePaddingBoxPath(curves);
		        }
		    };
		    var canvasTextAlign = function (textAlign) {
		        switch (textAlign) {
		            case 1 /* CENTER */:
		                return 'center';
		            case 2 /* RIGHT */:
		                return 'right';
		            case 0 /* LEFT */:
		            default:
		                return 'left';
		        }
		    };
		    // see https://github.com/niklasvh/html2canvas/pull/2645
		    var iOSBrokenFonts = ['-apple-system', 'system-ui'];
		    var fixIOSSystemFonts = function (fontFamilies) {
		        return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent)
		            ? fontFamilies.filter(function (fontFamily) { return iOSBrokenFonts.indexOf(fontFamily) === -1; })
		            : fontFamilies;
		    };

		    var ForeignObjectRenderer = /** @class */ (function (_super) {
		        __extends(ForeignObjectRenderer, _super);
		        function ForeignObjectRenderer(context, options) {
		            var _this = _super.call(this, context, options) || this;
		            _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
		            _this.ctx = _this.canvas.getContext('2d');
		            _this.options = options;
		            _this.canvas.width = Math.floor(options.width * options.scale);
		            _this.canvas.height = Math.floor(options.height * options.scale);
		            _this.canvas.style.width = options.width + "px";
		            _this.canvas.style.height = options.height + "px";
		            _this.ctx.scale(_this.options.scale, _this.options.scale);
		            _this.ctx.translate(-options.x, -options.y);
		            _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
		            return _this;
		        }
		        ForeignObjectRenderer.prototype.render = function (element) {
		            return __awaiter(this, void 0, void 0, function () {
		                var svg, img;
		                return __generator(this, function (_a) {
		                    switch (_a.label) {
		                        case 0:
		                            svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
		                            return [4 /*yield*/, loadSerializedSVG(svg)];
		                        case 1:
		                            img = _a.sent();
		                            if (this.options.backgroundColor) {
		                                this.ctx.fillStyle = asString(this.options.backgroundColor);
		                                this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
		                            }
		                            this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
		                            return [2 /*return*/, this.canvas];
		                    }
		                });
		            });
		        };
		        return ForeignObjectRenderer;
		    }(Renderer));
		    var loadSerializedSVG = function (svg) {
		        return new Promise(function (resolve, reject) {
		            var img = new Image();
		            img.onload = function () {
		                resolve(img);
		            };
		            img.onerror = reject;
		            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
		        });
		    };

		    var Logger = /** @class */ (function () {
		        function Logger(_a) {
		            var id = _a.id, enabled = _a.enabled;
		            this.id = id;
		            this.enabled = enabled;
		            this.start = Date.now();
		        }
		        // eslint-disable-next-line @typescript-eslint/no-explicit-any
		        Logger.prototype.debug = function () {
		            var args = [];
		            for (var _i = 0; _i < arguments.length; _i++) {
		                args[_i] = arguments[_i];
		            }
		            if (this.enabled) {
		                // eslint-disable-next-line no-console
		                if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {
		                    // eslint-disable-next-line no-console
		                    console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
		                }
		                else {
		                    this.info.apply(this, args);
		                }
		            }
		        };
		        Logger.prototype.getTime = function () {
		            return Date.now() - this.start;
		        };
		        // eslint-disable-next-line @typescript-eslint/no-explicit-any
		        Logger.prototype.info = function () {
		            var args = [];
		            for (var _i = 0; _i < arguments.length; _i++) {
		                args[_i] = arguments[_i];
		            }
		            if (this.enabled) {
		                // eslint-disable-next-line no-console
		                if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {
		                    // eslint-disable-next-line no-console
		                    console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
		                }
		            }
		        };
		        // eslint-disable-next-line @typescript-eslint/no-explicit-any
		        Logger.prototype.warn = function () {
		            var args = [];
		            for (var _i = 0; _i < arguments.length; _i++) {
		                args[_i] = arguments[_i];
		            }
		            if (this.enabled) {
		                // eslint-disable-next-line no-console
		                if (typeof window !== 'undefined' && window.console && typeof console.warn === 'function') {
		                    // eslint-disable-next-line no-console
		                    console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
		                }
		                else {
		                    this.info.apply(this, args);
		                }
		            }
		        };
		        // eslint-disable-next-line @typescript-eslint/no-explicit-any
		        Logger.prototype.error = function () {
		            var args = [];
		            for (var _i = 0; _i < arguments.length; _i++) {
		                args[_i] = arguments[_i];
		            }
		            if (this.enabled) {
		                // eslint-disable-next-line no-console
		                if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {
		                    // eslint-disable-next-line no-console
		                    console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
		                }
		                else {
		                    this.info.apply(this, args);
		                }
		            }
		        };
		        Logger.instances = {};
		        return Logger;
		    }());

		    var Context = /** @class */ (function () {
		        function Context(options, windowBounds) {
		            var _a;
		            this.windowBounds = windowBounds;
		            this.instanceName = "#" + Context.instanceCount++;
		            this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
		            this.cache = (_a = options.cache) !== null && _a !== void 0 ? _a : new Cache(this, options);
		        }
		        Context.instanceCount = 1;
		        return Context;
		    }());

		    var html2canvas = function (element, options) {
		        if (options === void 0) { options = {}; }
		        return renderElement(element, options);
		    };
		    if (typeof window !== 'undefined') {
		        CacheStorage.setContext(window);
		    }
		    var renderElement = function (element, opts) { return __awaiter(void 0, void 0, void 0, function () {
		        var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a, width, height, left, top, backgroundColor, renderOptions, canvas, renderer, root, renderer;
		        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
		        return __generator(this, function (_u) {
		            switch (_u.label) {
		                case 0:
		                    if (!element || typeof element !== 'object') {
		                        return [2 /*return*/, Promise.reject('Invalid element provided as first argument')];
		                    }
		                    ownerDocument = element.ownerDocument;
		                    if (!ownerDocument) {
		                        throw new Error("Element is not attached to a Document");
		                    }
		                    defaultView = ownerDocument.defaultView;
		                    if (!defaultView) {
		                        throw new Error("Document is not attached to a Window");
		                    }
		                    resourceOptions = {
		                        allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
		                        imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15000,
		                        proxy: opts.proxy,
		                        useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
		                    };
		                    contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
		                    windowOptions = {
		                        windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
		                        windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
		                        scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
		                        scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
		                    };
		                    windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
		                    context = new Context(contextOptions, windowBounds);
		                    foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
		                    cloneOptions = {
		                        allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
		                        onclone: opts.onclone,
		                        ignoreElements: opts.ignoreElements,
		                        inlineImages: foreignObjectRendering,
		                        copyStyles: foreignObjectRendering
		                    };
		                    context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
		                    documentCloner = new DocumentCloner(context, element, cloneOptions);
		                    clonedElement = documentCloner.clonedReferenceElement;
		                    if (!clonedElement) {
		                        return [2 /*return*/, Promise.reject("Unable to find element in cloned iframe")];
		                    }
		                    return [4 /*yield*/, documentCloner.toIFrame(ownerDocument, windowBounds)];
		                case 1:
		                    container = _u.sent();
		                    _a = isBodyElement(clonedElement) || isHTMLElement(clonedElement)
		                        ? parseDocumentSize(clonedElement.ownerDocument)
		                        : parseBounds(context, clonedElement), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
		                    backgroundColor = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
		                    renderOptions = {
		                        canvas: opts.canvas,
		                        backgroundColor: backgroundColor,
		                        scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
		                        x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
		                        y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
		                        width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
		                        height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
		                    };
		                    if (!foreignObjectRendering) return [3 /*break*/, 3];
		                    context.logger.debug("Document cloned, using foreign object rendering");
		                    renderer = new ForeignObjectRenderer(context, renderOptions);
		                    return [4 /*yield*/, renderer.render(clonedElement)];
		                case 2:
		                    canvas = _u.sent();
		                    return [3 /*break*/, 5];
		                case 3:
		                    context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
		                    context.logger.debug("Starting DOM parsing");
		                    root = parseTree(context, clonedElement);
		                    if (backgroundColor === root.styles.backgroundColor) {
		                        root.styles.backgroundColor = COLORS.TRANSPARENT;
		                    }
		                    context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
		                    renderer = new CanvasRenderer(context, renderOptions);
		                    return [4 /*yield*/, renderer.render(root)];
		                case 4:
		                    canvas = _u.sent();
		                    _u.label = 5;
		                case 5:
		                    if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
		                        if (!DocumentCloner.destroy(container)) {
		                            context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
		                        }
		                    }
		                    context.logger.debug("Finished rendering");
		                    return [2 /*return*/, canvas];
		            }
		        });
		    }); };
		    var parseBackgroundColor = function (context, element, backgroundColorOverride) {
		        var ownerDocument = element.ownerDocument;
		        // http://www.w3.org/TR/css3-background/#special-backgrounds
		        var documentBackgroundColor = ownerDocument.documentElement
		            ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor)
		            : COLORS.TRANSPARENT;
		        var bodyBackgroundColor = ownerDocument.body
		            ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor)
		            : COLORS.TRANSPARENT;
		        var defaultBackgroundColor = typeof backgroundColorOverride === 'string'
		            ? parseColor(context, backgroundColorOverride)
		            : backgroundColorOverride === null
		                ? COLORS.TRANSPARENT
		                : 0xffffffff;
		        return element === ownerDocument.documentElement
		            ? isTransparent(documentBackgroundColor)
		                ? isTransparent(bodyBackgroundColor)
		                    ? defaultBackgroundColor
		                    : bodyBackgroundColor
		                : documentBackgroundColor
		            : defaultBackgroundColor;
		    };

		    return html2canvas;

		})));
		
	} (html2canvas$2));
	return html2canvas$2.exports;
}

var html2canvasExports = requireHtml2canvas();
var html2canvas = /*@__PURE__*/getDefaultExportFromCjs(html2canvasExports);

var __defProp$k = Object.defineProperty;
var __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$k = (obj, key, value) => __defNormalProp$k(obj, key + "" , value);
class Sprite extends THREE$2.Sprite {
  constructor(_options) {
    super(_options.material);
    __publicField$k(this, "options");
    this.options = deepMergeRetain$1(_options, {});
    html2canvas(this.options.element).then((canvas) => {
    });
  }
}

var __defProp$j = Object.defineProperty;
var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$j = (obj, key, value) => __defNormalProp$j(obj, typeof key !== "symbol" ? key + "" : key, value);
class Wall extends Object3D {
  // 网格对象
  // 构造函数
  constructor(options) {
    super();
    __publicField$j(this, "points");
    // 存储路径点
    __publicField$j(this, "geometry");
    // 拉伸几何体
    __publicField$j(this, "material");
    // 材质
    __publicField$j(this, "mesh");
    const { width, height, path, extrudeGeometryOptions } = options;
    const { closed, curveType, tension, points } = path;
    const pts2 = [];
    pts2.push(new Vector2(0, width));
    pts2.push(new Vector2(-height, width));
    pts2.push(new Vector2(-height, 0));
    pts2.push(new Vector2(0, 0));
    const shape = new Shape(pts2);
    this.points = Tool$1.v3ArrayToVector3Array(points);
    const curve = new CatmullRomCurve3(this.points, closed, curveType, tension);
    curve.arcLengthDivisions = 1e3;
    const extrudeSettings = {
      steps: this.points.length * 100,
      // 步数
      bevelEnabled: false,
      // 禁用斜角
      extrudePath: curve,
      // 设置拉伸路径
      ...extrudeGeometryOptions
      // 合并额外的几何体选项
    };
    this.geometry = new ExtrudeGeometry(shape, extrudeSettings);
    this.material = new MeshStandardMaterial();
    this.mesh = new Mesh(this.geometry, this.material);
  }
}

var HeatmapConfig = {
  defaultRadius: 40,
  defaultRenderer: "canvas2d",
  defaultGradient: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1: "rgb(255,0,0)" },
  defaultMaxOpacity: 1,
  defaultMinOpacity: 0,
  defaultBlur: 0.85,
  defaultXField: "x",
  defaultYField: "y",
  defaultValueField: "value",
  plugins: {}
};
var Store = function StoreClosure() {
  var Store2 = function Store3(config) {
    this._coordinator = {};
    this._data = [];
    this._radi = [];
    this._min = 10;
    this._max = 1;
    this._xField = config["xField"] || config.defaultXField;
    this._yField = config["yField"] || config.defaultYField;
    this._valueField = config["valueField"] || config.defaultValueField;
    if (config["radius"]) {
      this._cfgRadius = config["radius"];
    }
  };
  var defaultRadius = HeatmapConfig.defaultRadius;
  Store2.prototype = {
    // when forceRender = false -> called from setData, omits renderall event
    _organiseData: function(dataPoint, forceRender) {
      var x = dataPoint[this._xField];
      var y = dataPoint[this._yField];
      var radi = this._radi;
      var store = this._data;
      var max = this._max;
      var min = this._min;
      var value = dataPoint[this._valueField] || 1;
      var radius = dataPoint.radius || this._cfgRadius || defaultRadius;
      if (!store[x]) {
        store[x] = [];
        radi[x] = [];
      }
      if (!store[x][y]) {
        store[x][y] = value;
        radi[x][y] = radius;
      } else {
        store[x][y] += value;
      }
      var storedVal = store[x][y];
      if (storedVal > max) {
        if (!forceRender) {
          this._max = storedVal;
        } else {
          this.setDataMax(storedVal);
        }
        return false;
      } else if (storedVal < min) {
        if (!forceRender) {
          this._min = storedVal;
        } else {
          this.setDataMin(storedVal);
        }
        return false;
      } else {
        return {
          x,
          y,
          value,
          radius,
          min,
          max
        };
      }
    },
    _unOrganizeData: function() {
      var unorganizedData = [];
      var data = this._data;
      var radi = this._radi;
      for (var x in data) {
        for (var y in data[x]) {
          unorganizedData.push({
            x,
            y,
            radius: radi[x][y],
            value: data[x][y]
          });
        }
      }
      return {
        min: this._min,
        max: this._max,
        data: unorganizedData
      };
    },
    _onExtremaChange: function() {
      this._coordinator.emit("extremachange", {
        min: this._min,
        max: this._max
      });
    },
    addData: function() {
      if (arguments[0].length > 0) {
        var dataArr = arguments[0];
        var dataLen = dataArr.length;
        while (dataLen--) {
          this.addData.call(this, dataArr[dataLen]);
        }
      } else {
        var organisedEntry = this._organiseData(arguments[0], true);
        if (organisedEntry) {
          if (this._data.length === 0) {
            this._min = this._max = organisedEntry.value;
          }
          this._coordinator.emit("renderpartial", {
            min: this._min,
            max: this._max,
            data: [organisedEntry]
          });
        }
      }
      return this;
    },
    setData: function(data) {
      var dataPoints = data.data;
      var pointsLen = dataPoints.length;
      this._data = [];
      this._radi = [];
      for (var i = 0; i < pointsLen; i++) {
        this._organiseData(dataPoints[i], false);
      }
      this._max = data.max;
      this._min = data.min || 0;
      this._onExtremaChange();
      this._coordinator.emit("renderall", this._getInternalData());
      return this;
    },
    removeData: function() {
    },
    setDataMax: function(max) {
      this._max = max;
      this._onExtremaChange();
      this._coordinator.emit("renderall", this._getInternalData());
      return this;
    },
    setDataMin: function(min) {
      this._min = min;
      this._onExtremaChange();
      this._coordinator.emit("renderall", this._getInternalData());
      return this;
    },
    setCoordinator: function(coordinator) {
      this._coordinator = coordinator;
    },
    _getInternalData: function() {
      return {
        max: this._max,
        min: this._min,
        data: this._data,
        radi: this._radi
      };
    },
    getData: function() {
      return this._unOrganizeData();
    }
    /*,
    
          TODO: rethink.
    
        getValueAt: function(point) {
          var value;
          var radius = 100;
          var x = point.x;
          var y = point.y;
          var data = this._data;
    
          if (data[x] && data[x][y]) {
            return data[x][y];
          } else {
            var values = [];
            // radial search for datapoints based on default radius
            for(var distance = 1; distance < radius; distance++) {
              var neighbors = distance * 2 +1;
              var startX = x - distance;
              var startY = y - distance;
    
              for(var i = 0; i < neighbors; i++) {
                for (var o = 0; o < neighbors; o++) {
                  if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {
                    if (data[startY+i] && data[startY+i][startX+o]) {
                      values.push(data[startY+i][startX+o]);
                    }
                  } else {
                    continue;
                  } 
                }
              }
            }
            if (values.length > 0) {
              return Math.max.apply(Math, values);
            }
          }
          return false;
        }*/
  };
  return Store2;
}();
var Canvas2dRenderer = function Canvas2dRendererClosure() {
  var _getColorPalette = function(config) {
    var gradientConfig = config.gradient || config.defaultGradient;
    var paletteCanvas = document.createElement("canvas");
    var paletteCtx = paletteCanvas.getContext("2d");
    paletteCanvas.width = 256;
    paletteCanvas.height = 1;
    var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
    for (var key in gradientConfig) {
      gradient.addColorStop(key, gradientConfig[key]);
    }
    paletteCtx.fillStyle = gradient;
    paletteCtx.fillRect(0, 0, 256, 1);
    return paletteCtx.getImageData(0, 0, 256, 1).data;
  };
  var _getPointTemplate = function(radius, blurFactor) {
    var tplCanvas = document.createElement("canvas");
    var tplCtx = tplCanvas.getContext("2d");
    var x = radius;
    var y = radius;
    tplCanvas.width = tplCanvas.height = radius * 2;
    if (blurFactor == 1) {
      tplCtx.beginPath();
      tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);
      tplCtx.fillStyle = "rgba(0,0,0,1)";
      tplCtx.fill();
    } else {
      var gradient = tplCtx.createRadialGradient(x, y, radius * blurFactor, x, y, radius);
      gradient.addColorStop(0, "rgba(0,0,0,1)");
      gradient.addColorStop(1, "rgba(0,0,0,0)");
      tplCtx.fillStyle = gradient;
      tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);
    }
    return tplCanvas;
  };
  var _prepareData = function(data) {
    var renderData = [];
    var min = data.min;
    var max = data.max;
    var radi = data.radi;
    var data = data.data;
    var xValues = Object.keys(data);
    var xValuesLen = xValues.length;
    while (xValuesLen--) {
      var xValue = xValues[xValuesLen];
      var yValues = Object.keys(data[xValue]);
      var yValuesLen = yValues.length;
      while (yValuesLen--) {
        var yValue = yValues[yValuesLen];
        var value = data[xValue][yValue];
        var radius = radi[xValue][yValue];
        renderData.push({
          x: xValue,
          y: yValue,
          value,
          radius
        });
      }
    }
    return {
      min,
      max,
      data: renderData
    };
  };
  function Canvas2dRenderer2(config) {
    var container = config.container;
    var shadowCanvas = this.shadowCanvas = document.createElement("canvas");
    var canvas = this.canvas = config.canvas || document.createElement("canvas");
    this._renderBoundaries = [1e4, 1e4, 0, 0];
    var computed = getComputedStyle(config.container) || {};
    canvas.className = "heatmap-canvas";
    this._width = canvas.width = shadowCanvas.width = config.width || +computed.width.replace(/px/, "");
    this._height = canvas.height = shadowCanvas.height = config.height || +computed.height.replace(/px/, "");
    this.shadowCtx = shadowCanvas.getContext("2d");
    this.ctx = canvas.getContext("2d");
    canvas.style.cssText = shadowCanvas.style.cssText = "position:absolute;left:0;top:0;";
    container.style.position = "relative";
    container.appendChild(canvas);
    this._palette = _getColorPalette(config);
    this._templates = {};
    this._setStyles(config);
  }
  Canvas2dRenderer2.prototype = {
    renderPartial: function(data) {
      if (data.data.length > 0) {
        this._drawAlpha(data);
        this._colorize();
      }
    },
    renderAll: function(data) {
      this._clear();
      if (data.data.length > 0) {
        this._drawAlpha(_prepareData(data));
        this._colorize();
      }
    },
    _updateGradient: function(config) {
      this._palette = _getColorPalette(config);
    },
    updateConfig: function(config) {
      if (config["gradient"]) {
        this._updateGradient(config);
      }
      this._setStyles(config);
    },
    setDimensions: function(width, height) {
      this._width = width;
      this._height = height;
      this.canvas.width = this.shadowCanvas.width = width;
      this.canvas.height = this.shadowCanvas.height = height;
    },
    _clear: function() {
      this.shadowCtx.clearRect(0, 0, this._width, this._height);
      this.ctx.clearRect(0, 0, this._width, this._height);
    },
    _setStyles: function(config) {
      this._blur = config.blur == 0 ? 0 : config.blur || config.defaultBlur;
      if (config.backgroundColor) {
        this.canvas.style.backgroundColor = config.backgroundColor;
      }
      this._width = this.canvas.width = this.shadowCanvas.width = config.width || this._width;
      this._height = this.canvas.height = this.shadowCanvas.height = config.height || this._height;
      this._opacity = (config.opacity || 0) * 255;
      this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;
      this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;
      this._useGradientOpacity = !!config.useGradientOpacity;
    },
    _drawAlpha: function(data) {
      var min = this._min = data.min;
      var max = this._max = data.max;
      var data = data.data || [];
      var dataLen = data.length;
      var blur = 1 - this._blur;
      while (dataLen--) {
        var point = data[dataLen];
        var x = point.x;
        var y = point.y;
        var radius = point.radius;
        var value = Math.min(point.value, max);
        var rectX = x - radius;
        var rectY = y - radius;
        var shadowCtx = this.shadowCtx;
        var tpl;
        if (!this._templates[radius]) {
          this._templates[radius] = tpl = _getPointTemplate(radius, blur);
        } else {
          tpl = this._templates[radius];
        }
        var templateAlpha = (value - min) / (max - min);
        shadowCtx.globalAlpha = templateAlpha < 0.01 ? 0.01 : templateAlpha;
        shadowCtx.drawImage(tpl, rectX, rectY);
        if (rectX < this._renderBoundaries[0]) {
          this._renderBoundaries[0] = rectX;
        }
        if (rectY < this._renderBoundaries[1]) {
          this._renderBoundaries[1] = rectY;
        }
        if (rectX + 2 * radius > this._renderBoundaries[2]) {
          this._renderBoundaries[2] = rectX + 2 * radius;
        }
        if (rectY + 2 * radius > this._renderBoundaries[3]) {
          this._renderBoundaries[3] = rectY + 2 * radius;
        }
      }
    },
    _colorize: function() {
      var x = this._renderBoundaries[0];
      var y = this._renderBoundaries[1];
      var width = this._renderBoundaries[2] - x;
      var height = this._renderBoundaries[3] - y;
      var maxWidth = this._width;
      var maxHeight = this._height;
      var opacity = this._opacity;
      var maxOpacity = this._maxOpacity;
      var minOpacity = this._minOpacity;
      var useGradientOpacity = this._useGradientOpacity;
      if (x < 0) {
        x = 0;
      }
      if (y < 0) {
        y = 0;
      }
      if (x + width > maxWidth) {
        width = maxWidth - x;
      }
      if (y + height > maxHeight) {
        height = maxHeight - y;
      }
      var img = this.shadowCtx.getImageData(x, y, width, height);
      var imgData = img.data;
      var len = imgData.length;
      var palette = this._palette;
      for (var i = 3; i < len; i += 4) {
        var alpha = imgData[i];
        var offset = alpha * 4;
        if (!offset) {
          continue;
        }
        var finalAlpha;
        if (opacity > 0) {
          finalAlpha = opacity;
        } else {
          if (alpha < maxOpacity) {
            if (alpha < minOpacity) {
              finalAlpha = minOpacity;
            } else {
              finalAlpha = alpha;
            }
          } else {
            finalAlpha = maxOpacity;
          }
        }
        imgData[i - 3] = palette[offset];
        imgData[i - 2] = palette[offset + 1];
        imgData[i - 1] = palette[offset + 2];
        imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;
      }
      img.data = imgData;
      this.ctx.putImageData(img, x, y);
      this._renderBoundaries = [1e3, 1e3, 0, 0];
    },
    getValueAt: function(point) {
      var value;
      var shadowCtx = this.shadowCtx;
      var img = shadowCtx.getImageData(point.x, point.y, 1, 1);
      var data = img.data[3];
      var max = this._max;
      var min = this._min;
      value = Math.abs(max - min) * (data / 255) >> 0;
      return value;
    },
    getDataURL: function() {
      return this.canvas.toDataURL();
    }
  };
  return Canvas2dRenderer2;
}();
var Renderer = function RendererClosure() {
  var rendererFn = false;
  if (HeatmapConfig["defaultRenderer"] === "canvas2d") {
    rendererFn = Canvas2dRenderer;
  }
  return rendererFn;
}();
var Util = {
  merge: function() {
    var merged = {};
    var argsLen = arguments.length;
    for (var i = 0; i < argsLen; i++) {
      var obj = arguments[i];
      for (var key in obj) {
        merged[key] = obj[key];
      }
    }
    return merged;
  }
};
var Heatmap = function HeatmapClosure() {
  var Coordinator = function CoordinatorClosure() {
    function Coordinator2() {
      this.cStore = {};
    }
    Coordinator2.prototype = {
      on: function(evtName, callback, scope) {
        var cStore = this.cStore;
        if (!cStore[evtName]) {
          cStore[evtName] = [];
        }
        cStore[evtName].push(function(data) {
          return callback.call(scope, data);
        });
      },
      emit: function(evtName, data) {
        var cStore = this.cStore;
        if (cStore[evtName]) {
          var len = cStore[evtName].length;
          for (var i = 0; i < len; i++) {
            var callback = cStore[evtName][i];
            callback(data);
          }
        }
      }
    };
    return Coordinator2;
  }();
  var _connect = function(scope) {
    var renderer = scope._renderer;
    var coordinator = scope._coordinator;
    var store = scope._store;
    coordinator.on("renderpartial", renderer.renderPartial, renderer);
    coordinator.on("renderall", renderer.renderAll, renderer);
    coordinator.on("extremachange", function(data) {
      scope._config.onExtremaChange && scope._config.onExtremaChange({
        min: data.min,
        max: data.max,
        gradient: scope._config["gradient"] || scope._config["defaultGradient"]
      });
    });
    store.setCoordinator(coordinator);
  };
  function Heatmap2() {
    var config = this._config = Util.merge(HeatmapConfig, arguments[0] || {});
    this._coordinator = new Coordinator();
    if (config["plugin"]) {
      var pluginToLoad = config["plugin"];
      if (!HeatmapConfig.plugins[pluginToLoad]) {
        throw new Error("Plugin '" + pluginToLoad + "' not found. Maybe it was not registered.");
      } else {
        var plugin = HeatmapConfig.plugins[pluginToLoad];
        this._renderer = new plugin.renderer(config);
        this._store = new plugin.store(config);
      }
    } else {
      this._renderer = new Renderer(config);
      this._store = new Store(config);
    }
    _connect(this);
  }
  Heatmap2.prototype = {
    addData: function() {
      this._store.addData.apply(this._store, arguments);
      return this;
    },
    removeData: function() {
      this._store.removeData && this._store.removeData.apply(this._store, arguments);
      return this;
    },
    setData: function() {
      this._store.setData.apply(this._store, arguments);
      return this;
    },
    setDataMax: function() {
      this._store.setDataMax.apply(this._store, arguments);
      return this;
    },
    setDataMin: function() {
      this._store.setDataMin.apply(this._store, arguments);
      return this;
    },
    configure: function(config) {
      this._config = Util.merge(this._config, config);
      this._renderer.updateConfig(this._config);
      this._coordinator.emit("renderall", this._store._getInternalData());
      return this;
    },
    repaint: function() {
      this._coordinator.emit("renderall", this._store._getInternalData());
      return this;
    },
    getData: function() {
      return this._store.getData();
    },
    getDataURL: function() {
      return this._renderer.getDataURL();
    },
    getValueAt: function(point) {
      if (this._store.getValueAt) {
        return this._store.getValueAt(point);
      } else if (this._renderer.getValueAt) {
        return this._renderer.getValueAt(point);
      } else {
        return null;
      }
    }
  };
  return Heatmap2;
}();

var __defProp$i = Object.defineProperty;
var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$i = (obj, key, value) => __defNormalProp$i(obj, typeof key !== "symbol" ? key + "" : key, value);
const DefaultHeatmap2dMeshOptions = {};
class HeatMap2dMesh extends Object3D {
  constructor(_options) {
    super();
    __publicField$i(this, "heatmap");
    __publicField$i(this, "options", DefaultHeatmap2dMeshOptions);
    this.options = deepMergeRetain$1(this.options, _options);
    this.setConfig(_options.style);
  }
  setConfig(config) {
    this.heatmap.configure(config);
  }
  setData(options) {
    let { max, min, data } = options;
    const { style } = this.options;
    let { radius } = style;
    radius = radius ?? 40;
    const v3Array = data.map((d) => {
      return new THREE$2.Vector3(d.x, 0, d.y);
    });
    const box3 = Tool$1.getBox3ByV3Array(v3Array);
    let minValue = Number.MAX_SAFE_INTEGER;
    let maxValue = Number.MIN_SAFE_INTEGER;
    let offsetPoints = [];
    for (let i = 0; i < data.length; i++) {
      let d = data[i];
      let minx = box3.min.x;
      let minz = box3.min.z;
      offsetPoints.push({
        // "x": d.x - minx,
        // "y": d.y - minz,
        "x": Math.floor(d.x - minx + radius),
        "y": Math.floor(d.y - minz + radius),
        "value": d.value
      });
      minValue = Math.min(minValue, d.value);
      maxValue = Math.max(maxValue, d.value);
    }
    this.heatmap = new Heatmap(style);
    this.heatmap.setData({
      data: offsetPoints,
      min: min ?? minValue,
      max: max ?? maxValue
    });
    this.buildMesh(box3, radius);
  }
  buildMesh(box3, radius) {
    const size = box3.getSize(new THREE$2.Vector3());
    const center = box3.getCenter(new THREE$2.Vector3());
    let _width = size.x + radius * 2;
    let _height = size.z + radius * 2;
    let canvas = this.heatmap._renderer.canvas;
    const geometry = new THREE$2.PlaneGeometry(_width, _height);
    const material = new THREE$2.MeshBasicMaterial();
    material.map = canvas ? new THREE$2.CanvasTexture(canvas) : null;
    const plane = new THREE$2.Mesh(geometry, material);
    this.add(plane);
    this.position.copy(center);
  }
}

var __defProp$h = Object.defineProperty;
var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$h = (obj, key, value) => __defNormalProp$h(obj, typeof key !== "symbol" ? key + "" : key, value);
const DefaultHeatmap3dMeshOptions = {
  zoom: 1,
  widthSegments: 100,
  heightSegments: 100
};
class HeatMap3dMesh extends Object3D {
  constructor(_options) {
    super();
    __publicField$h(this, "heatmap");
    __publicField$h(this, "options", DefaultHeatmap3dMeshOptions);
    this.options = deepMergeRetain$1(this.options, _options);
    this.setConfig(_options.style);
  }
  setConfig(config) {
    this.heatmap.configure(config);
  }
  setData(options) {
    let { max, min, data } = options;
    const { style } = this.options;
    let { radius } = style;
    radius = radius ?? 40;
    const v3Array = data.map((d) => {
      return new THREE$2.Vector3(d.x, 0, d.y);
    });
    const box3 = Tool$1.getBox3ByV3Array(v3Array);
    let minValue = Number.MAX_SAFE_INTEGER;
    let maxValue = Number.MIN_SAFE_INTEGER;
    let offsetPoints = [];
    for (let i = 0; i < data.length; i++) {
      let d = data[i];
      let minx = box3.min.x;
      let minz = box3.min.z;
      offsetPoints.push({
        // "x": d.x - minx,
        // "y": d.y - minz,
        "x": Math.floor(d.x - minx + radius),
        "y": Math.floor(d.y - minz + radius),
        "value": d.value
      });
      minValue = Math.min(minValue, d.value);
      maxValue = Math.max(maxValue, d.value);
    }
    this.heatmap = new Heatmap(style);
    this.heatmap.setData({
      data: offsetPoints,
      min: min ?? minValue,
      max: max ?? maxValue
    });
    this.buildMesh(box3, radius);
  }
  buildMesh(box3, radius) {
    const size = box3.getSize(new THREE$2.Vector3());
    const center = box3.getCenter(new THREE$2.Vector3());
    let _width = size.x + radius * 2;
    let _height = size.z + radius * 2;
    let canvas = this.heatmap._renderer.canvas;
    const geometry = THREE$2.PlaneGeometry.fromJSON({
      width: _width,
      height: _height,
      widthSegments: this.options.widthSegments,
      heightSegments: this.options.heightSegments
    });
    const material = new THREE$2.MeshBasicMaterial();
    material.map = canvas ? new THREE$2.CanvasTexture(canvas) : null;
    const plane = new THREE$2.Mesh(geometry, material);
    this.add(plane);
    this.position.copy(center);
  }
  setHeatmapMaterial() {
    const material = new THREE$2.MeshBasicMaterial();
    const heatmap = this.heatmap;
    const texture = new THREE$2.CanvasTexture(heatmap._renderer.canvas);
    material.map = texture;
    material.side = THREE$2.DoubleSide;
    material.transparent = true;
    material.onBeforeCompile = (shader) => {
      shader.uniforms["height"] = { value: this.options.zoom };
      shader.vertexShader = shader.vertexShader.replace("#include <common>", `
						#include <common>
						uniform sampler2D map;
						uniform float height;`);
      shader.vertexShader = shader.vertexShader.replace("#include <begin_vertex>", `#include <begin_vertex>
			 vec4 frgColor = texture2D(map, uv);
			 float z = height * frgColor.a;
			 transformed = vec3( position.x, position.y, z);`);
    };
    var link = document.createElement("a");
    link.href = heatmap._renderer.canvas.toDataURL("image/png");
    link.download = "canvas_image.png";
    return material;
  }
}

var __defProp$g = Object.defineProperty;
var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$g = (obj, key, value) => __defNormalProp$g(obj, typeof key !== "symbol" ? key + "" : key, value);
var HtmlMeshType = /* @__PURE__ */ ((HtmlMeshType2) => {
  HtmlMeshType2[HtmlMeshType2["CSS2DObject"] = 0] = "CSS2DObject";
  HtmlMeshType2[HtmlMeshType2["CSS3DObject"] = 1] = "CSS3DObject";
  HtmlMeshType2[HtmlMeshType2["CSS3DSprite"] = 2] = "CSS3DSprite";
  return HtmlMeshType2;
})(HtmlMeshType || {});
class HtmlMesh extends THREE$2.Object3D {
  constructor(_options) {
    super();
    __publicField$g(this, "options");
    __publicField$g(this, "object");
    __publicField$g(this, "isHtmlMesh", true);
    this.options = deepMergeRetain(_options, {
      type: 1 /* CSS3DObject */
    });
    const { type, element } = this.options;
    switch (type) {
      case 0 /* CSS2DObject */:
        this.object = new CSS2DObject(element);
        break;
      case 1 /* CSS3DObject */:
        this.object = new CSS3DObject(element);
        break;
      case 2 /* CSS3DSprite */:
        this.object = new CSS3DSprite(element);
        break;
    }
    this.add(this.object);
  }
}

var __defProp$f = Object.defineProperty;
var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$f = (obj, key, value) => __defNormalProp$f(obj, typeof key !== "symbol" ? key + "" : key, value);
var LineType = /* @__PURE__ */ ((LineType2) => {
  LineType2["Line"] = "Line";
  LineType2["LineLoop"] = "LineLoop";
  LineType2["LineSegments"] = "LineSegments";
  return LineType2;
})(LineType || {});
var LineMaterialType = /* @__PURE__ */ ((LineMaterialType2) => {
  LineMaterialType2["LineBasicMaterial"] = "LineBasicMaterial";
  LineMaterialType2["LineDashedMaterial"] = "LineDashedMaterial";
  return LineMaterialType2;
})(LineMaterialType || {});
const LineDefaultsOptions = {
  points: [],
  // 默认控制点为空
  vertexColors: [],
  // 默认顶点颜色为空
  lineType: "Line" /* Line */,
  // 默认使用普通线
  materialType: "LineBasicMaterial" /* LineBasicMaterial */,
  // 默认使用基础材质
  materialParams: {
    color: 16777215,
    // 默认颜色为白色
    scale: 1,
    // 默认比例为 1
    dashSize: 3,
    // 默认虚线大小
    gapSize: 1
    // 默认虚线间隔
  },
  isDelayInit: false
  // 默认不延迟初始化
};
class Line extends THREE$2.Object3D {
  // 控制点数组
  // 构造函数
  constructor(_options) {
    super();
    __publicField$f(this, "line");
    // 线条对象
    __publicField$f(this, "material");
    // 材质对象
    __publicField$f(this, "options", LineDefaultsOptions);
    // 选项
    __publicField$f(this, "isPlumLine", true);
    // 是否为梅花线
    __publicField$f(this, "points", []);
    this.options = deepMergeRetain$1(this.options, _options);
    this.init();
    if (!this.options.isDelayInit) {
      this.update(this.options);
    }
  }
  // 更新方法
  update(_options) {
    const { lineType, materialType, points, materialParams } = _options;
    if (isNil(this.line) || lineType !== this.options.lineType) {
      this.clear();
      Reflect.set(this, "line", null);
      this.createLine(_options);
      this.add(this.line);
    }
    if (materialType !== this.options.materialType || isNil(this.material)) {
      this.createMaterial(_options);
    } else {
      !isNil(materialParams) && this.material.setValues(materialParams);
    }
    this.options = deepMergeRetain$1(this.options, _options);
    this.points = Tool$1.v3ArrayToVector3Array(this.options.points);
    this.setPoints();
    this.setColors();
    this.line.material = this.material;
  }
  updateAfter() {
  }
  // 添加控制点
  addPoint(point) {
    this.points.push(point);
    this.setPoints(this.points);
  }
  // 设置控制点
  setPoints(points = this.getLinePoints()) {
    this.line.geometry.setFromPoints(points);
    if (this.options.materialType === "LineDashedMaterial" /* LineDashedMaterial */) {
      this.line.computeLineDistances();
    }
  }
  // 设置线条颜色
  setColors() {
    let colors = this.options.vertexColors.map((color) => {
      return isColor(color) ? color.toArray() : color;
    });
    const itemSize = this.options.vertexColors?.[0]?.length === 4 ? 4 : 3;
    this.line.geometry.setAttribute("color", new THREE$2.Float32BufferAttribute(colors.flat(), itemSize));
  }
  // 初始化方法
  init() {
  }
  // 获取控制点
  getLinePoints() {
    return this.points;
  }
  // 创建线条
  createLine(_options) {
    const { lineType } = _options;
    switch (lineType) {
      case "Line" /* Line */:
        this.line = new THREE$2.Line();
        break;
      case "LineLoop" /* LineLoop */:
        this.line = new THREE$2.LineLoop();
        break;
      case "LineSegments" /* LineSegments */:
        this.line = new THREE$2.LineSegments();
        break;
    }
  }
  // 创建材质
  createMaterial(_options) {
    const { materialType, materialParams } = _options;
    switch (materialType) {
      case "LineBasicMaterial" /* LineBasicMaterial */:
        this.material = new THREE$2.LineBasicMaterial(materialParams);
        break;
      case "LineDashedMaterial" /* LineDashedMaterial */:
        this.material = new THREE$2.LineDashedMaterial(materialParams);
        break;
    }
  }
}

var __defProp$e = Object.defineProperty;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$e = (obj, key, value) => __defNormalProp$e(obj, key + "" , value);
var CurveType = /* @__PURE__ */ ((CurveType2) => {
  CurveType2["Centripetal"] = "centripetal";
  CurveType2["Chordal"] = "chordal";
  CurveType2["CatmullRom"] = "catmullrom";
  return CurveType2;
})(CurveType || {});
const CatmullRomLineDefaultsOptions = {
  closed: false,
  // 默认不闭合
  curveType: "catmullrom" /* CatmullRom */,
  // 默认使用 Catmull-Rom 曲线
  tension: 0.5,
  // 默认张力为 0.5
  segments: 20
  // 默认分段数为 20
};
class CatmullRomLine extends Line {
  // 声明选项
  // 构造函数
  constructor(_options) {
    super({
      ...CatmullRomLineDefaultsOptions,
      // 合并默认选项和传入选项
      ..._options,
      isDelayInit: true
      // 延迟初始化
    });
    __publicField$e(this, "catmullRomCurve3", new CatmullRomCurve3());
    this.update(this.options);
  }
  // 更新方法
  update(_options) {
    super.update(_options);
  }
  // 获取曲线点
  getLinePoints() {
    const { points, closed, curveType, tension, segments } = this.options;
    this.catmullRomCurve3.points = this.points;
    this.catmullRomCurve3.closed = closed;
    this.catmullRomCurve3.curveType = curveType;
    this.catmullRomCurve3.tension = tension;
    return this.catmullRomCurve3.getPoints(this.options.segments);
  }
}

var __defProp$d = Object.defineProperty;
var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$d = (obj, key, value) => __defNormalProp$d(obj, key + "" , value);
class CubicBezierLine extends Line {
  constructor(_options) {
    super({
      ..._options,
      isDelayInit: true
    });
    __publicField$d(this, "cubicBezierCurve3", new CubicBezierCurve3());
    this.update(this.options);
  }
  getLinePoints() {
    const cubicBezierCurve3 = LineTool.getCubicBezierCurve3Points({
      cubicBezierCurve3: this.cubicBezierCurve3,
      ...this.options
    });
    return cubicBezierCurve3.getPoints(this.options.segments);
  }
}

var __defProp$c = Object.defineProperty;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$c = (obj, key, value) => __defNormalProp$c(obj, key + "" , value);
class QuadraticBezierLine extends Line {
  constructor(_options) {
    super({
      ..._options,
      isDelayInit: true
    });
    __publicField$c(this, "quadraticBezierCurve3", new QuadraticBezierCurve3());
    this.update(this.options);
  }
  init() {
  }
  update(_options) {
    super.update(_options);
  }
  getLinePoints() {
    const quadraticBezierCurve3 = LineTool.getQuadraticBezierCurve3Points({
      ...this.options,
      quadraticBezierCurve3: this.quadraticBezierCurve3
    });
    return quadraticBezierCurve3.getPoints(this.options.segments || 20);
  }
}

var __defProp$b = Object.defineProperty;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$b = (obj, key, value) => __defNormalProp$b(obj, key + "" , value);
const CatmullRomLine2DefaultsOptions = {
  closed: false,
  curveType: CurveType.CatmullRom,
  tension: 0.5,
  segments: 20
};
class CatmullRomLine2 extends Line2 {
  constructor(_options) {
    super({
      ...CatmullRomLine2DefaultsOptions,
      ..._options,
      isDelayInit: true
    });
    __publicField$b(this, "catmullRomCurve3", new CatmullRomCurve3());
    this.update(this.options);
  }
  update(_options) {
    super.update(_options);
  }
  getLinePoints() {
    const { points, closed, curveType, tension, segments } = this.options;
    this.catmullRomCurve3.points = this.points;
    this.catmullRomCurve3.closed = closed;
    this.catmullRomCurve3.curveType = curveType;
    this.catmullRomCurve3.tension = tension;
    return this.catmullRomCurve3.getPoints(this.options.segments);
  }
}

var __defProp$a = Object.defineProperty;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$a = (obj, key, value) => __defNormalProp$a(obj, key + "" , value);
class CubicBezierLineLine extends Line2 {
  constructor(_options) {
    super({
      ..._options,
      isDelayInit: true
    });
    __publicField$a(this, "cubicBezierCurve3", new CubicBezierCurve3());
    this.update(this.options);
  }
  getLinePoints() {
    const cubicBezierCurve3 = LineTool.getCubicBezierCurve3Points({
      cubicBezierCurve3: this.cubicBezierCurve3,
      ...this.options
    });
    return cubicBezierCurve3.getPoints(this.options.segments);
  }
}

var __defProp$9 = Object.defineProperty;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$9 = (obj, key, value) => __defNormalProp$9(obj, key + "" , value);
class QuadraticBezierLine2 extends Line2 {
  constructor(_options) {
    super({
      ..._options,
      isDelayInit: true
    });
    __publicField$9(this, "quadraticBezierCurve3");
    this.quadraticBezierCurve3 = new QuadraticBezierCurve3();
    this.update(this.options);
  }
  init() {
  }
  update(_options) {
    super.update(_options);
  }
  getLinePoints() {
    const quadraticBezierCurve3 = LineTool.getQuadraticBezierCurve3Points({
      ...this.options,
      quadraticBezierCurve3: this.quadraticBezierCurve3
    });
    return quadraticBezierCurve3.getPoints(this.options.segments);
  }
}

var __defProp$8 = Object.defineProperty;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$8 = (obj, key, value) => __defNormalProp$8(obj, key + "" , value);
class PathMesh extends Mesh {
  // 路径点列表实例
  // 构造函数
  constructor(_options) {
    super();
    __publicField$8(this, "pathPointList", new PathPointList());
    const { pathPointListParams, pathGeometryParams, meshBasicMaterialParams } = _options;
    this.setPathPointList(pathPointListParams);
    this.geometry = new PathGeometry({
      pathPointList: this.pathPointList,
      // 指定路径点列表
      options: pathGeometryParams,
      // 传入几何体选项
      usage: pathGeometryParams.usage
      // 设置几何体使用方式
    }, pathGeometryParams.generateUv2);
    this.material = new MeshBasicMaterial({
      color: 5824222,
      // 默认颜色
      depthWrite: true,
      // 开启深度写入
      transparent: true,
      // 允许透明度
      opacity: 1,
      // 默认不透明
      ...meshBasicMaterialParams
      // 合并传入的材质参数
    });
  }
  // 设置路径点列表
  setPathPointList(options) {
    this.pathPointList.set(options.points, options.cornerRadius, options.cornerSplit, options.up, options.close);
  }
}

var __defProp$7 = Object.defineProperty;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$7 = (obj, key, value) => __defNormalProp$7(obj, key + "" , value);
class PathTubeMesh extends Mesh {
  // 路径点列表实例
  // 构造函数
  constructor(_options) {
    super();
    __publicField$7(this, "pathPointList", new PathPointList());
    const { pathPointListParams, pathTubeGeometryParams, meshBasicMaterialParams } = _options;
    this.setPathPointList(pathPointListParams);
    this.geometry = new PathTubeGeometry({
      pathPointList: this.pathPointList,
      // 使用路径点列表
      options: pathTubeGeometryParams
      // 传入几何体选项
    }, pathTubeGeometryParams.generateUv2);
    this.material = new MeshBasicMaterial({
      color: 5824222,
      // 默认颜色
      depthWrite: true,
      // 开启深度写入
      transparent: true,
      // 允许透明度
      opacity: 1,
      // 默认不透明
      ...meshBasicMaterialParams
      // 合并传入的材质参数
    });
  }
  // 设置路径点列表
  setPathPointList(options) {
    this.pathPointList.set(options.points, options.cornerRadius, options.cornerSplit, options.up, options.close);
  }
}

var __defProp$6 = Object.defineProperty;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
class Path extends THREE$2.Mesh {
  // 路径点列表实例
  // 构造函数
  constructor(_options) {
    super();
    // 声明材质类型
    __publicField$6(this, "options");
    // 选项
    __publicField$6(this, "points", []);
    // 路径点数组
    __publicField$6(this, "pathPointList");
    this.options = deepMergeRetain$1(_options, {
      points: [],
      // 默认路径点为空
      materialParams: {},
      // 默认材质参数为空
      pathGeometryOptions: {
        width: 0.2
        // 默认几何体宽度
      }
    });
    const { points, materialParams } = this.options;
    this.points = points;
    const up = new THREE$2.Vector3(0, 1, 0);
    this.pathPointList = new PathPointList();
    this.pathPointList.set(this.points, 0.3, 10, up, true);
    this.geometry = new PathGeometry();
    this.material = new THREE$2.MeshBasicMaterial(materialParams);
  }
  // 添加路径点
  addPoint(point) {
    this.points.push(point);
    this.setPoints(this.points);
  }
  // 设置路径点列表
  setPathPointList(pathPointListOptions) {
    this.options.pathPointListOptions = pathPointListOptions;
    const { cornerRadius, cornerSplit, close, up } = this.options.pathPointListOptions;
    this.pathPointList.set(this.points, cornerRadius, cornerSplit, up, close);
  }
  // 设置路径点
  setPoints(points) {
    this.geometry.update(this.pathPointList, this.options.pathGeometryOptions);
  }
}

var __defProp$5 = Object.defineProperty;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, key + "" , value);
class Package extends Component {
  constructor(options) {
    super(options);
  }
}
__publicField$5(Package, "Type", "plumSceneSerializer");

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.
 * JZlib is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

// deno-lint-ignore-file no-this-alias prefer-const

// Global

const MAX_BITS$3 = 15;
const D_CODES$2 = 30;
const BL_CODES$2 = 19;

const LENGTH_CODES$2 = 29;
const LITERALS$2 = 256;
const L_CODES$2 = (LITERALS$2 + 1 + LENGTH_CODES$2);
const HEAP_SIZE$2 = (2 * L_CODES$2 + 1);

const END_BLOCK$1 = 256;

// Bit length codes must not exceed MAX_BL_BITS bits
const MAX_BL_BITS$1 = 7;

// repeat previous bit length 3-6 times (2 bits of repeat count)
const REP_3_6$1 = 16;

// repeat a zero length 3-10 times (3 bits of repeat count)
const REPZ_3_10$1 = 17;

// repeat a zero length 11-138 times (7 bits of repeat count)
const REPZ_11_138$1 = 18;

// The lengths of the bit length codes are sent in order of decreasing
// probability, to avoid transmitting the lengths for unused bit
// length codes.

const Buf_size$1 = 8 * 2;

// JZlib version : "1.0.2"
const Z_DEFAULT_COMPRESSION$2 = -1;

// compression strategy
const Z_FILTERED$1 = 1;
const Z_HUFFMAN_ONLY$1 = 2;
const Z_DEFAULT_STRATEGY$2 = 0;

const Z_NO_FLUSH$4 = 0;
const Z_PARTIAL_FLUSH$1 = 1;
const Z_FULL_FLUSH$2 = 3;
const Z_FINISH$5 = 4;

const Z_OK$5 = 0;
const Z_STREAM_END$5 = 1;
const Z_NEED_DICT$3 = 2;
const Z_STREAM_ERROR$4 = -2;
const Z_DATA_ERROR$4 = -3;
const Z_BUF_ERROR$3 = -5;

// Tree

function extractArray(array) {
	return flatArray(array.map(([length, value]) => (new Array(length)).fill(value, 0, length)));
}

function flatArray(array) {
	return array.reduce((a, b) => a.concat(Array.isArray(b) ? flatArray(b) : b), []);
}

// see definition of array dist_code below
const _dist_code$1 = [0, 1, 2, 3].concat(...extractArray([
	[2, 4], [2, 5], [4, 6], [4, 7], [8, 8], [8, 9], [16, 10], [16, 11], [32, 12], [32, 13], [64, 14], [64, 15], [2, 0], [1, 16],
	[1, 17], [2, 18], [2, 19], [4, 20], [4, 21], [8, 22], [8, 23], [16, 24], [16, 25], [32, 26], [32, 27], [64, 28], [64, 29]
]));

function Tree() {
	const that = this;

	// dyn_tree; // the dynamic tree
	// max_code; // largest code with non zero frequency
	// stat_desc; // the corresponding static tree

	// Compute the optimal bit lengths for a tree and update the total bit
	// length
	// for the current block.
	// IN assertion: the fields freq and dad are set, heap[heap_max] and
	// above are the tree nodes sorted by increasing frequency.
	// OUT assertions: the field len is set to the optimal bit length, the
	// array bl_count contains the frequencies for each bit length.
	// The length opt_len is updated; static_len is also updated if stree is
	// not null.
	function gen_bitlen(s) {
		const tree = that.dyn_tree;
		const stree = that.stat_desc.static_tree;
		const extra = that.stat_desc.extra_bits;
		const base = that.stat_desc.extra_base;
		const max_length = that.stat_desc.max_length;
		let h; // heap index
		let n, m; // iterate over the tree elements
		let bits; // bit length
		let xbits; // extra bits
		let f; // frequency
		let overflow = 0; // number of elements with bit length too large

		for (bits = 0; bits <= MAX_BITS$3; bits++)
			s.bl_count[bits] = 0;

		// In a first pass, compute the optimal bit lengths (which may
		// overflow in the case of the bit length tree).
		tree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap

		for (h = s.heap_max + 1; h < HEAP_SIZE$2; h++) {
			n = s.heap[h];
			bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
			if (bits > max_length) {
				bits = max_length;
				overflow++;
			}
			tree[n * 2 + 1] = bits;
			// We overwrite tree[n*2+1] which is no longer needed

			if (n > that.max_code)
				continue; // not a leaf node

			s.bl_count[bits]++;
			xbits = 0;
			if (n >= base)
				xbits = extra[n - base];
			f = tree[n * 2];
			s.opt_len += f * (bits + xbits);
			if (stree)
				s.static_len += f * (stree[n * 2 + 1] + xbits);
		}
		if (overflow === 0)
			return;

		// This happens for example on obj2 and pic of the Calgary corpus
		// Find the first bit length which could increase:
		do {
			bits = max_length - 1;
			while (s.bl_count[bits] === 0)
				bits--;
			s.bl_count[bits]--; // move one leaf down the tree
			s.bl_count[bits + 1] += 2; // move one overflow item as its brother
			s.bl_count[max_length]--;
			// The brother of the overflow item also moves one step up,
			// but this does not affect bl_count[max_length]
			overflow -= 2;
		} while (overflow > 0);

		for (bits = max_length; bits !== 0; bits--) {
			n = s.bl_count[bits];
			while (n !== 0) {
				m = s.heap[--h];
				if (m > that.max_code)
					continue;
				if (tree[m * 2 + 1] != bits) {
					s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
					tree[m * 2 + 1] = bits;
				}
				n--;
			}
		}
	}

	// Reverse the first len bits of a code, using straightforward code (a
	// faster
	// method would use a table)
	// IN assertion: 1 <= len <= 15
	function bi_reverse(code, // the value to invert
		len // its bit length
	) {
		let res = 0;
		do {
			res |= code & 1;
			code >>>= 1;
			res <<= 1;
		} while (--len > 0);
		return res >>> 1;
	}

	// Generate the codes for a given tree and bit counts (which need not be
	// optimal).
	// IN assertion: the array bl_count contains the bit length statistics for
	// the given tree and the field len is set for all tree elements.
	// OUT assertion: the field code is set for all tree elements of non
	// zero code length.
	function gen_codes(tree, // the tree to decorate
		max_code, // largest code with non zero frequency
		bl_count // number of codes at each bit length
	) {
		const next_code = []; // next code value for each
		// bit length
		let code = 0; // running code value
		let bits; // bit index
		let n; // code index
		let len;

		// The distribution counts are first used to generate the code values
		// without bit reversal.
		for (bits = 1; bits <= MAX_BITS$3; bits++) {
			next_code[bits] = code = ((code + bl_count[bits - 1]) << 1);
		}

		// Check that the bit counts in bl_count are consistent. The last code
		// must be all ones.
		// Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
		// "inconsistent bit counts");
		// Tracev((stderr,"gen_codes: max_code %d ", max_code));

		for (n = 0; n <= max_code; n++) {
			len = tree[n * 2 + 1];
			if (len === 0)
				continue;
			// Now reverse the bits
			tree[n * 2] = bi_reverse(next_code[len]++, len);
		}
	}

	// Construct one Huffman tree and assigns the code bit strings and lengths.
	// Update the total bit length for the current block.
	// IN assertion: the field freq is set for all tree elements.
	// OUT assertions: the fields len and code are set to the optimal bit length
	// and corresponding code. The length opt_len is updated; static_len is
	// also updated if stree is not null. The field max_code is set.
	that.build_tree = function (s) {
		const tree = that.dyn_tree;
		const stree = that.stat_desc.static_tree;
		const elems = that.stat_desc.elems;
		let n, m; // iterate over heap elements
		let max_code = -1; // largest code with non zero frequency
		let node; // new node being created

		// Construct the initial heap, with least frequent element in
		// heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
		// heap[0] is not used.
		s.heap_len = 0;
		s.heap_max = HEAP_SIZE$2;

		for (n = 0; n < elems; n++) {
			if (tree[n * 2] !== 0) {
				s.heap[++s.heap_len] = max_code = n;
				s.depth[n] = 0;
			} else {
				tree[n * 2 + 1] = 0;
			}
		}

		// The pkzip format requires that at least one distance code exists,
		// and that at least one bit should be sent even if there is only one
		// possible code. So to avoid special checks later on we force at least
		// two codes of non zero frequency.
		while (s.heap_len < 2) {
			node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
			tree[node * 2] = 1;
			s.depth[node] = 0;
			s.opt_len--;
			if (stree)
				s.static_len -= stree[node * 2 + 1];
			// node is 0 or 1 so it does not have extra bits
		}
		that.max_code = max_code;

		// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
		// establish sub-heaps of increasing lengths:

		for (n = Math.floor(s.heap_len / 2); n >= 1; n--)
			s.pqdownheap(tree, n);

		// Construct the Huffman tree by repeatedly combining the least two
		// frequent nodes.

		node = elems; // next internal node of the tree
		do {
			// n = node of least frequency
			n = s.heap[1];
			s.heap[1] = s.heap[s.heap_len--];
			s.pqdownheap(tree, 1);
			m = s.heap[1]; // m = node of next least frequency

			s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency
			s.heap[--s.heap_max] = m;

			// Create a new node father of n and m
			tree[node * 2] = (tree[n * 2] + tree[m * 2]);
			s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
			tree[n * 2 + 1] = tree[m * 2 + 1] = node;

			// and insert the new node in the heap
			s.heap[1] = node++;
			s.pqdownheap(tree, 1);
		} while (s.heap_len >= 2);

		s.heap[--s.heap_max] = s.heap[1];

		// At this point, the fields freq and dad are set. We can now
		// generate the bit lengths.

		gen_bitlen(s);

		// The field len is now set, we can generate the bit codes
		gen_codes(tree, that.max_code, s.bl_count);
	};

}

Tree._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...extractArray([
	[2, 8], [2, 9], [2, 10], [2, 11], [4, 12], [4, 13], [4, 14], [4, 15], [8, 16], [8, 17], [8, 18], [8, 19],
	[16, 20], [16, 21], [16, 22], [16, 23], [32, 24], [32, 25], [32, 26], [31, 27], [1, 28]]));

Tree.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];

Tree.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384,
	24576];

// Mapping from a distance to a distance code. dist is the distance - 1 and
// must not have side effects. _dist_code[256] and _dist_code[257] are never
// used.
Tree.d_code = function (dist) {
	return ((dist) < 256 ? _dist_code$1[dist] : _dist_code$1[256 + ((dist) >>> 7)]);
};

// extra bits for each length code
Tree.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

// extra bits for each distance code
Tree.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

// extra bits for each bit length code
Tree.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

Tree.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

// StaticTree

function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
	const that = this;
	that.static_tree = static_tree;
	that.extra_bits = extra_bits;
	that.extra_base = extra_base;
	that.elems = elems;
	that.max_length = max_length;
}

const static_ltree2_first_part = [12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82,
	210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86,
	214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81,
	209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85,
	213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 19, 275, 147, 403, 83, 339, 211, 467, 51, 307,
	179, 435, 115, 371, 243, 499, 11, 267, 139, 395, 75, 331, 203, 459, 43, 299, 171, 427, 107, 363, 235, 491, 27, 283, 155, 411, 91, 347, 219, 475,
	59, 315, 187, 443, 123, 379, 251, 507, 7, 263, 135, 391, 71, 327, 199, 455, 39, 295, 167, 423, 103, 359, 231, 487, 23, 279, 151, 407, 87, 343, 215,
	471, 55, 311, 183, 439, 119, 375, 247, 503, 15, 271, 143, 399, 79, 335, 207, 463, 47, 303, 175, 431, 111, 367, 239, 495, 31, 287, 159, 415, 95,
	351, 223, 479, 63, 319, 191, 447, 127, 383, 255, 511, 0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120, 4, 68, 36, 100, 20, 84, 52,
	116, 3, 131, 67, 195, 35, 163, 99, 227];
const static_ltree2_second_part = extractArray([[144, 8], [112, 9], [24, 7], [8, 8]]);
StaticTree.static_ltree = flatArray(static_ltree2_first_part.map((value, index) => [value, static_ltree2_second_part[index]]));

const static_dtree_first_part = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23];
const static_dtree_second_part = extractArray([[30, 5]]);
StaticTree.static_dtree = flatArray(static_dtree_first_part.map((value, index) => [value, static_dtree_second_part[index]]));

StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS$2 + 1, L_CODES$2, MAX_BITS$3);

StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES$2, MAX_BITS$3);

StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES$2, MAX_BL_BITS$1);

// Deflate

const MAX_MEM_LEVEL$1 = 9;
const DEF_MEM_LEVEL$1 = 8;

function Config$1(good_length, max_lazy, nice_length, max_chain, func) {
	const that = this;
	that.good_length = good_length;
	that.max_lazy = max_lazy;
	that.nice_length = nice_length;
	that.max_chain = max_chain;
	that.func = func;
}

const STORED$2 = 0;
const FAST = 1;
const SLOW = 2;
const config_table = [
	new Config$1(0, 0, 0, 0, STORED$2),
	new Config$1(4, 4, 8, 4, FAST),
	new Config$1(4, 5, 16, 8, FAST),
	new Config$1(4, 6, 32, 32, FAST),
	new Config$1(4, 4, 16, 16, SLOW),
	new Config$1(8, 16, 32, 32, SLOW),
	new Config$1(8, 16, 128, 128, SLOW),
	new Config$1(8, 32, 128, 256, SLOW),
	new Config$1(32, 128, 258, 1024, SLOW),
	new Config$1(32, 258, 258, 4096, SLOW)
];

const z_errmsg = ["need dictionary", // Z_NEED_DICT
	// 2
	"stream end", // Z_STREAM_END 1
	"", // Z_OK 0
	"", // Z_ERRNO (-1)
	"stream error", // Z_STREAM_ERROR (-2)
	"data error", // Z_DATA_ERROR (-3)
	"", // Z_MEM_ERROR (-4)
	"buffer error", // Z_BUF_ERROR (-5)
	"",// Z_VERSION_ERROR (-6)
	""];

// block not completed, need more input or more output
const NeedMore = 0;

// block flush performed
const BlockDone = 1;

// finish started, need only more output at next deflate
const FinishStarted = 2;

// finish done, accept no more input or output
const FinishDone = 3;

// preset dictionary flag in zlib header
const PRESET_DICT$2 = 0x20;

const INIT_STATE$1 = 42;
const BUSY_STATE$1 = 113;
const FINISH_STATE$1 = 666;

// The deflate compression method
const Z_DEFLATED$4 = 8;

const STORED_BLOCK$1 = 0;
const STATIC_TREES$1 = 1;
const DYN_TREES$1 = 2;

const MIN_MATCH$2 = 3;
const MAX_MATCH$2 = 258;
const MIN_LOOKAHEAD$1 = (MAX_MATCH$2 + MIN_MATCH$2 + 1);

function smaller$1(tree, n, m, depth) {
	const tn2 = tree[n * 2];
	const tm2 = tree[m * 2];
	return (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));
}

function Deflate$2() {

	const that = this;
	let strm; // pointer back to this zlib stream
	let status; // as the name implies
	// pending_buf; // output still pending
	let pending_buf_size; // size of pending_buf
	// pending_out; // next pending byte to output to the stream
	// pending; // nb of bytes in the pending buffer

	// dist_buf; // buffer for distances
	// lc_buf; // buffer for literals or lengths
	// To simplify the code, dist_buf and lc_buf have the same number of elements.
	// To use different lengths, an extra flag array would be necessary.

	let last_flush; // value of flush param for previous deflate call

	let w_size; // LZ77 win size (32K by default)
	let w_bits; // log2(w_size) (8..16)
	let w_mask; // w_size - 1

	let win;
	// Sliding win. Input bytes are read into the second half of the win,
	// and move to the first half later to keep a dictionary of at least wSize
	// bytes. With this organization, matches are limited to a distance of
	// wSize-MAX_MATCH bytes, but this ensures that IO is always
	// performed with a length multiple of the block size. Also, it limits
	// the win size to 64K, which is quite useful on MSDOS.
	// To do: use the user input buffer as sliding win.

	let window_size;
	// Actual size of win: 2*wSize, except when the user input buffer
	// is directly used as sliding win.

	let prev;
	// Link to older string with same hash index. To limit the size of this
	// array to 64K, this link is maintained only for the last 32K strings.
	// An index in this array is thus a win index modulo 32K.

	let head; // Heads of the hash chains or NIL.

	let ins_h; // hash index of string to be inserted
	let hash_size; // number of elements in hash table
	let hash_bits; // log2(hash_size)
	let hash_mask; // hash_size-1

	// Number of bits by which ins_h must be shifted at each input
	// step. It must be such that after MIN_MATCH steps, the oldest
	// byte no longer takes part in the hash key, that is:
	// hash_shift * MIN_MATCH >= hash_bits
	let hash_shift;

	// Window position at the beginning of the current output block. Gets
	// negative when the win is moved backwards.

	let block_start;

	let match_length; // length of best match
	let prev_match; // previous match
	let match_available; // set if previous match exists
	let strstart; // start of string to insert
	let match_start; // start of matching string
	let lookahead; // number of valid bytes ahead in win

	// Length of the best match at previous step. Matches not greater than this
	// are discarded. This is used in the lazy match evaluation.
	let prev_length;

	// To speed up deflation, hash chains are never searched beyond this
	// length. A higher limit improves compression ratio but degrades the speed.
	let max_chain_length;

	// Attempt to find a better match only when the current match is strictly
	// smaller than this value. This mechanism is used only for compression
	// levels >= 4.
	let max_lazy_match;

	// Insert new strings in the hash table only if the match length is not
	// greater than this length. This saves time but degrades compression.
	// max_insert_length is used only for compression levels <= 3.

	let level; // compression level (1..9)
	let strategy; // favor or force Huffman coding

	// Use a faster search when the previous match is longer than this
	let good_match;

	// Stop searching when current match exceeds this
	let nice_match;

	let dyn_ltree; // literal and length tree
	let dyn_dtree; // distance tree
	let bl_tree; // Huffman tree for bit lengths

	const l_desc = new Tree(); // desc for literal tree
	const d_desc = new Tree(); // desc for distance tree
	const bl_desc = new Tree(); // desc for bit length tree

	// that.heap_len; // number of elements in the heap
	// that.heap_max; // element of largest frequency
	// The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	// The same heap array is used to build all trees.

	// Depth of each subtree used as tie breaker for trees of equal frequency
	that.depth = [];

	// Size of match buffer for literals/lengths. There are 4 reasons for
	// limiting lit_bufsize to 64K:
	// - frequencies can be kept in 16 bit counters
	// - if compression is not successful for the first block, all input
	// data is still in the win so we can still emit a stored block even
	// when input comes from standard input. (This can also be done for
	// all blocks if lit_bufsize is not greater than 32K.)
	// - if compression is not successful for a file smaller than 64K, we can
	// even emit a stored file instead of a stored block (saving 5 bytes).
	// This is applicable only for zip (not gzip or zlib).
	// - creating new Huffman trees less frequently may not provide fast
	// adaptation to changes in the input data statistics. (Take for
	// example a binary file with poorly compressible code followed by
	// a highly compressible string table.) Smaller buffer sizes give
	// fast adaptation but have of course the overhead of transmitting
	// trees more frequently.
	// - I can't count above 4
	let lit_bufsize;

	let last_lit; // running index in dist_buf and lc_buf

	// that.opt_len; // bit length of current block with optimal trees
	// that.static_len; // bit length of current block with static trees
	let matches; // number of string matches in current block
	let last_eob_len; // bit length of EOB code for last block

	// Output buffer. bits are inserted starting at the bottom (least
	// significant bits).
	let bi_buf;

	// Number of valid bits in bi_buf. All bits above the last valid bit
	// are always zero.
	let bi_valid;

	// number of codes at each bit length for an optimal tree
	that.bl_count = [];

	// heap used to build the Huffman trees
	that.heap = [];

	dyn_ltree = [];
	dyn_dtree = [];
	bl_tree = [];

	function lm_init() {
		window_size = 2 * w_size;

		head[hash_size - 1] = 0;
		for (let i = 0; i < hash_size - 1; i++) {
			head[i] = 0;
		}

		// Set the default configuration parameters:
		max_lazy_match = config_table[level].max_lazy;
		good_match = config_table[level].good_length;
		nice_match = config_table[level].nice_length;
		max_chain_length = config_table[level].max_chain;

		strstart = 0;
		block_start = 0;
		lookahead = 0;
		match_length = prev_length = MIN_MATCH$2 - 1;
		match_available = 0;
		ins_h = 0;
	}

	function init_block() {
		let i;
		// Initialize the trees.
		for (i = 0; i < L_CODES$2; i++)
			dyn_ltree[i * 2] = 0;
		for (i = 0; i < D_CODES$2; i++)
			dyn_dtree[i * 2] = 0;
		for (i = 0; i < BL_CODES$2; i++)
			bl_tree[i * 2] = 0;

		dyn_ltree[END_BLOCK$1 * 2] = 1;
		that.opt_len = that.static_len = 0;
		last_lit = matches = 0;
	}

	// Initialize the tree data structures for a new zlib stream.
	function tr_init() {

		l_desc.dyn_tree = dyn_ltree;
		l_desc.stat_desc = StaticTree.static_l_desc;

		d_desc.dyn_tree = dyn_dtree;
		d_desc.stat_desc = StaticTree.static_d_desc;

		bl_desc.dyn_tree = bl_tree;
		bl_desc.stat_desc = StaticTree.static_bl_desc;

		bi_buf = 0;
		bi_valid = 0;
		last_eob_len = 8; // enough lookahead for inflate

		// Initialize the first block of the first file:
		init_block();
	}

	// Restore the heap property by moving down the tree starting at node k,
	// exchanging a node with the smallest of its two sons if necessary,
	// stopping
	// when the heap property is re-established (each father smaller than its
	// two sons).
	that.pqdownheap = function (tree, // the tree to restore
		k // node to move down
	) {
		const heap = that.heap;
		const v = heap[k];
		let j = k << 1; // left son of k
		while (j <= that.heap_len) {
			// Set j to the smallest of the two sons:
			if (j < that.heap_len && smaller$1(tree, heap[j + 1], heap[j], that.depth)) {
				j++;
			}
			// Exit if v is smaller than both sons
			if (smaller$1(tree, v, heap[j], that.depth))
				break;

			// Exchange v with the smallest son
			heap[k] = heap[j];
			k = j;
			// And continue down the tree, setting j to the left son of k
			j <<= 1;
		}
		heap[k] = v;
	};

	// Scan a literal or distance tree to determine the frequencies of the codes
	// in the bit length tree.
	function scan_tree(tree,// the tree to be scanned
		max_code // and its largest code of non zero frequency
	) {
		let prevlen = -1; // last emitted length
		let curlen; // length of current code
		let nextlen = tree[0 * 2 + 1]; // length of next code
		let count = 0; // repeat count of the current code
		let max_count = 7; // max repeat count
		let min_count = 4; // min repeat count

		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}
		tree[(max_code + 1) * 2 + 1] = 0xffff; // guard

		for (let n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[(n + 1) * 2 + 1];
			if (++count < max_count && curlen == nextlen) {
				continue;
			} else if (count < min_count) {
				bl_tree[curlen * 2] += count;
			} else if (curlen !== 0) {
				if (curlen != prevlen)
					bl_tree[curlen * 2]++;
				bl_tree[REP_3_6$1 * 2]++;
			} else if (count <= 10) {
				bl_tree[REPZ_3_10$1 * 2]++;
			} else {
				bl_tree[REPZ_11_138$1 * 2]++;
			}
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen == nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}

	// Construct the Huffman tree for the bit lengths and return the index in
	// bl_order of the last bit length code to send.
	function build_bl_tree() {
		let max_blindex; // index of last bit length code of non zero freq

		// Determine the bit length frequencies for literal and distance trees
		scan_tree(dyn_ltree, l_desc.max_code);
		scan_tree(dyn_dtree, d_desc.max_code);

		// Build the bit length tree:
		bl_desc.build_tree(that);
		// opt_len now includes the length of the tree representations, except
		// the lengths of the bit lengths codes and the 5+5+4 bits for the
		// counts.

		// Determine the number of bit length codes to send. The pkzip format
		// requires that at least 4 bit length codes be sent. (appnote.txt says
		// 3 but the actual value used is 4.)
		for (max_blindex = BL_CODES$2 - 1; max_blindex >= 3; max_blindex--) {
			if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)
				break;
		}
		// Update opt_len to include the bit length tree and counts
		that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;

		return max_blindex;
	}

	// Output a byte on the stream.
	// IN assertion: there is enough room in pending_buf.
	function put_byte(p) {
		that.pending_buf[that.pending++] = p;
	}

	function put_short(w) {
		put_byte(w & 0xff);
		put_byte((w >>> 8) & 0xff);
	}

	function putShortMSB(b) {
		put_byte((b >> 8) & 0xff);
		put_byte((b & 0xff) & 0xff);
	}

	function send_bits(value, length) {
		let val;
		const len = length;
		if (bi_valid > Buf_size$1 - len) {
			val = value;
			// bi_buf |= (val << bi_valid);
			bi_buf |= ((val << bi_valid) & 0xffff);
			put_short(bi_buf);
			bi_buf = val >>> (Buf_size$1 - bi_valid);
			bi_valid += len - Buf_size$1;
		} else {
			// bi_buf |= (value) << bi_valid;
			bi_buf |= (((value) << bi_valid) & 0xffff);
			bi_valid += len;
		}
	}

	function send_code(c, tree) {
		const c2 = c * 2;
		send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);
	}

	// Send a literal or distance tree in compressed form, using the codes in
	// bl_tree.
	function send_tree(tree,// the tree to be sent
		max_code // and its largest code of non zero frequency
	) {
		let n; // iterates over all tree elements
		let prevlen = -1; // last emitted length
		let curlen; // length of current code
		let nextlen = tree[0 * 2 + 1]; // length of next code
		let count = 0; // repeat count of the current code
		let max_count = 7; // max repeat count
		let min_count = 4; // min repeat count

		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}

		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[(n + 1) * 2 + 1];
			if (++count < max_count && curlen == nextlen) {
				continue;
			} else if (count < min_count) {
				do {
					send_code(curlen, bl_tree);
				} while (--count !== 0);
			} else if (curlen !== 0) {
				if (curlen != prevlen) {
					send_code(curlen, bl_tree);
					count--;
				}
				send_code(REP_3_6$1, bl_tree);
				send_bits(count - 3, 2);
			} else if (count <= 10) {
				send_code(REPZ_3_10$1, bl_tree);
				send_bits(count - 3, 3);
			} else {
				send_code(REPZ_11_138$1, bl_tree);
				send_bits(count - 11, 7);
			}
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen == nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}

	// Send the header for a block using dynamic Huffman trees: the counts, the
	// lengths of the bit length codes, the literal tree and the distance tree.
	// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	function send_all_trees(lcodes, dcodes, blcodes) {
		let rank; // index in bl_order

		send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt
		send_bits(dcodes - 1, 5);
		send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt
		for (rank = 0; rank < blcodes; rank++) {
			send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);
		}
		send_tree(dyn_ltree, lcodes - 1); // literal tree
		send_tree(dyn_dtree, dcodes - 1); // distance tree
	}

	// Flush the bit buffer, keeping at most 7 bits in it.
	function bi_flush() {
		if (bi_valid == 16) {
			put_short(bi_buf);
			bi_buf = 0;
			bi_valid = 0;
		} else if (bi_valid >= 8) {
			put_byte(bi_buf & 0xff);
			bi_buf >>>= 8;
			bi_valid -= 8;
		}
	}

	// Send one empty static block to give enough lookahead for inflate.
	// This takes 10 bits, of which 7 may remain in the bit buffer.
	// The current inflate code requires 9 bits of lookahead. If the
	// last two codes for the previous block (real code plus EOB) were coded
	// on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
	// the last real code. In this case we send two empty static blocks instead
	// of one. (There are no problems if the previous block is stored or fixed.)
	// To simplify the code, we assume the worst case of last real code encoded
	// on one bit only.
	function _tr_align() {
		send_bits(STATIC_TREES$1 << 1, 3);
		send_code(END_BLOCK$1, StaticTree.static_ltree);

		bi_flush();

		// Of the 10 bits for the empty block, we have already sent
		// (10 - bi_valid) bits. The lookahead for the last real code (before
		// the EOB of the previous block) was thus at least one plus the length
		// of the EOB plus what we have just sent of the empty static block.
		if (1 + last_eob_len + 10 - bi_valid < 9) {
			send_bits(STATIC_TREES$1 << 1, 3);
			send_code(END_BLOCK$1, StaticTree.static_ltree);
			bi_flush();
		}
		last_eob_len = 7;
	}

	// Save the match info and tally the frequency counts. Return true if
	// the current block must be flushed.
	function _tr_tally(dist, // distance of matched string
		lc // match length-MIN_MATCH or unmatched char (if dist==0)
	) {
		let out_length, in_length, dcode;
		that.dist_buf[last_lit] = dist;
		that.lc_buf[last_lit] = lc & 0xff;
		last_lit++;

		if (dist === 0) {
			// lc is the unmatched char
			dyn_ltree[lc * 2]++;
		} else {
			matches++;
			// Here, lc is the match length - MIN_MATCH
			dist--; // dist = match distance - 1
			dyn_ltree[(Tree._length_code[lc] + LITERALS$2 + 1) * 2]++;
			dyn_dtree[Tree.d_code(dist) * 2]++;
		}

		if ((last_lit & 0x1fff) === 0 && level > 2) {
			// Compute an upper bound for the compressed length
			out_length = last_lit * 8;
			in_length = strstart - block_start;
			for (dcode = 0; dcode < D_CODES$2; dcode++) {
				out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
			}
			out_length >>>= 3;
			if ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))
				return true;
		}

		return (last_lit == lit_bufsize - 1);
		// We avoid equality with lit_bufsize because of wraparound at 64K
		// on 16 bit machines and because stored blocks are restricted to
		// 64K-1 bytes.
	}

	// Send the block data compressed using the given Huffman trees
	function compress_block(ltree, dtree) {
		let dist; // distance of matched string
		let lc; // match length or unmatched char (if dist === 0)
		let lx = 0; // running index in dist_buf and lc_buf
		let code; // the code to send
		let extra; // number of extra bits to send

		if (last_lit !== 0) {
			do {
				dist = that.dist_buf[lx];
				lc = that.lc_buf[lx];
				lx++;

				if (dist === 0) {
					send_code(lc, ltree); // send a literal byte
				} else {
					// Here, lc is the match length - MIN_MATCH
					code = Tree._length_code[lc];

					send_code(code + LITERALS$2 + 1, ltree); // send the length
					// code
					extra = Tree.extra_lbits[code];
					if (extra !== 0) {
						lc -= Tree.base_length[code];
						send_bits(lc, extra); // send the extra length bits
					}
					dist--; // dist is now the match distance - 1
					code = Tree.d_code(dist);

					send_code(code, dtree); // send the distance code
					extra = Tree.extra_dbits[code];
					if (extra !== 0) {
						dist -= Tree.base_dist[code];
						send_bits(dist, extra); // send the extra distance bits
					}
				} // literal or match pair ?
			} while (lx < last_lit);
		}

		send_code(END_BLOCK$1, ltree);
		last_eob_len = ltree[END_BLOCK$1 * 2 + 1];
	}

	// Flush the bit buffer and align the output on a byte boundary
	function bi_windup() {
		if (bi_valid > 8) {
			put_short(bi_buf);
		} else if (bi_valid > 0) {
			put_byte(bi_buf & 0xff);
		}
		bi_buf = 0;
		bi_valid = 0;
	}

	// Copy a stored block, storing first the length and its
	// one's complement if requested.
	function copy_block(buf, // the input data
		len, // its length
		header // true if block header must be written
	) {
		bi_windup(); // align on byte boundary
		last_eob_len = 8; // enough lookahead for inflate

		{
			put_short(len);
			put_short(~len);
		}

		that.pending_buf.set(win.subarray(buf, buf + len), that.pending);
		that.pending += len;
	}

	// Send a stored block
	function _tr_stored_block(buf, // input block
		stored_len, // length of input block
		eof // true if this is the last block for a file
	) {
		send_bits((STORED_BLOCK$1 << 1) + (eof ? 1 : 0), 3); // send block type
		copy_block(buf, stored_len); // with header
	}

	// Determine the best encoding for the current block: dynamic trees, static
	// trees or store, and output the encoded block to the zip file.
	function _tr_flush_block(buf, // input block, or NULL if too old
		stored_len, // length of input block
		eof // true if this is the last block for a file
	) {
		let opt_lenb, static_lenb;// opt_len and static_len in bytes
		let max_blindex = 0; // index of last bit length code of non zero freq

		// Build the Huffman trees unless a stored block is forced
		if (level > 0) {
			// Construct the literal and distance trees
			l_desc.build_tree(that);

			d_desc.build_tree(that);

			// At this point, opt_len and static_len are the total bit lengths
			// of
			// the compressed block data, excluding the tree representations.

			// Build the bit length tree for the above two trees, and get the
			// index
			// in bl_order of the last bit length code to send.
			max_blindex = build_bl_tree();

			// Determine the best encoding. Compute first the block length in
			// bytes
			opt_lenb = (that.opt_len + 3 + 7) >>> 3;
			static_lenb = (that.static_len + 3 + 7) >>> 3;

			if (static_lenb <= opt_lenb)
				opt_lenb = static_lenb;
		} else {
			opt_lenb = static_lenb = stored_len + 5; // force a stored block
		}

		if ((stored_len + 4 <= opt_lenb) && buf != -1) {
			// 4: two words for the lengths
			// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
			// Otherwise we can't have processed more than WSIZE input bytes
			// since
			// the last block flush, because compression would have been
			// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
			// transform a block into a stored block.
			_tr_stored_block(buf, stored_len, eof);
		} else if (static_lenb == opt_lenb) {
			send_bits((STATIC_TREES$1 << 1) + (eof ? 1 : 0), 3);
			compress_block(StaticTree.static_ltree, StaticTree.static_dtree);
		} else {
			send_bits((DYN_TREES$1 << 1) + (eof ? 1 : 0), 3);
			send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
			compress_block(dyn_ltree, dyn_dtree);
		}

		// The above check is made mod 2^32, for files larger than 512 MB
		// and uLong implemented on 32 bits.

		init_block();

		if (eof) {
			bi_windup();
		}
	}

	function flush_block_only(eof) {
		_tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
		block_start = strstart;
		strm.flush_pending();
	}

	// Fill the win when the lookahead becomes insufficient.
	// Updates strstart and lookahead.
	//
	// IN assertion: lookahead < MIN_LOOKAHEAD
	// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	// At least one byte has been read, or avail_in === 0; reads are
	// performed for at least two bytes (required for the zip translate_eol
	// option -- not supported here).
	function fill_window() {
		let n, m;
		let p;
		let more; // Amount of free space at the end of the win.

		do {
			more = (window_size - lookahead - strstart);

			// Deal with !@#$% 64K limit:
			if (more === 0 && strstart === 0 && lookahead === 0) {
				more = w_size;
			} else if (more == -1) {
				// Very unlikely, but possible on 16 bit machine if strstart ==
				// 0
				// and lookahead == 1 (input done one byte at time)
				more--;

				// If the win is almost full and there is insufficient
				// lookahead,
				// move the upper half to the lower one to make room in the
				// upper half.
			} else if (strstart >= w_size + w_size - MIN_LOOKAHEAD$1) {
				win.set(win.subarray(w_size, w_size + w_size), 0);

				match_start -= w_size;
				strstart -= w_size; // we now have strstart >= MAX_DIST
				block_start -= w_size;

				// Slide the hash table (could be avoided with 32 bit values
				// at the expense of memory usage). We slide even when level ==
				// 0
				// to keep the hash table consistent if we switch back to level
				// > 0
				// later. (Using level 0 permanently is not an optimal usage of
				// zlib, so we don't care about this pathological case.)

				n = hash_size;
				p = n;
				do {
					m = (head[--p] & 0xffff);
					head[p] = (m >= w_size ? m - w_size : 0);
				} while (--n !== 0);

				n = w_size;
				p = n;
				do {
					m = (prev[--p] & 0xffff);
					prev[p] = (m >= w_size ? m - w_size : 0);
					// If n is not on any hash chain, prev[n] is garbage but
					// its value will never be used.
				} while (--n !== 0);
				more += w_size;
			}

			if (strm.avail_in === 0)
				return;

			// If there was no sliding:
			// strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
			// more == window_size - lookahead - strstart
			// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
			// => more >= window_size - 2*WSIZE + 2
			// In the BIG_MEM or MMAP case (not yet supported),
			// window_size == input_size + MIN_LOOKAHEAD &&
			// strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
			// Otherwise, window_size == 2*WSIZE so more >= 2.
			// If there was sliding, more >= WSIZE. So in all cases, more >= 2.

			n = strm.read_buf(win, strstart + lookahead, more);
			lookahead += n;

			// Initialize the hash value now that we have some input:
			if (lookahead >= MIN_MATCH$2) {
				ins_h = win[strstart] & 0xff;
				ins_h = (((ins_h) << hash_shift) ^ (win[strstart + 1] & 0xff)) & hash_mask;
			}
			// If the whole input has less than MIN_MATCH bytes, ins_h is
			// garbage,
			// but this is not important since only literal bytes will be
			// emitted.
		} while (lookahead < MIN_LOOKAHEAD$1 && strm.avail_in !== 0);
	}

	// Copy without compression as much as possible from the input stream,
	// return
	// the current block state.
	// This function does not insert new strings in the dictionary since
	// uncompressible data is probably not useful. This function is used
	// only for the level=0 compression option.
	// NOTE: this function should be optimized to avoid extra copying from
	// win to pending_buf.
	function deflate_stored(flush) {
		// Stored blocks are limited to 0xffff bytes, pending_buf is limited
		// to pending_buf_size, and each stored block has a 5 byte header:

		let max_block_size = 0xffff;
		let max_start;

		if (max_block_size > pending_buf_size - 5) {
			max_block_size = pending_buf_size - 5;
		}

		// Copy as much as possible from input to output:
		while (true) {
			// Fill the win as much as possible:
			if (lookahead <= 1) {
				fill_window();
				if (lookahead === 0 && flush == Z_NO_FLUSH$4)
					return NeedMore;
				if (lookahead === 0)
					break; // flush the current block
			}

			strstart += lookahead;
			lookahead = 0;

			// Emit a stored block if pending_buf will be full:
			max_start = block_start + max_block_size;
			if (strstart === 0 || strstart >= max_start) {
				// strstart === 0 is possible when wraparound on 16-bit machine
				lookahead = (strstart - max_start);
				strstart = max_start;

				flush_block_only(false);
				if (strm.avail_out === 0)
					return NeedMore;

			}

			// Flush if we may have to slide, otherwise block_start may become
			// negative and the data will be gone:
			if (strstart - block_start >= w_size - MIN_LOOKAHEAD$1) {
				flush_block_only(false);
				if (strm.avail_out === 0)
					return NeedMore;
			}
		}

		flush_block_only(flush == Z_FINISH$5);
		if (strm.avail_out === 0)
			return (flush == Z_FINISH$5) ? FinishStarted : NeedMore;

		return flush == Z_FINISH$5 ? FinishDone : BlockDone;
	}

	function longest_match(cur_match) {
		let chain_length = max_chain_length; // max hash chain length
		let scan = strstart; // current string
		let match; // matched string
		let len; // length of current match
		let best_len = prev_length; // best match length so far
		const limit = strstart > (w_size - MIN_LOOKAHEAD$1) ? strstart - (w_size - MIN_LOOKAHEAD$1) : 0;
		let _nice_match = nice_match;

		// Stop when cur_match becomes <= limit. To simplify the code,
		// we prevent matches with the string of win index 0.

		const wmask = w_mask;

		const strend = strstart + MAX_MATCH$2;
		let scan_end1 = win[scan + best_len - 1];
		let scan_end = win[scan + best_len];

		// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of
		// 16.
		// It is easy to get rid of this optimization if necessary.

		// Do not waste too much time if we already have a good match:
		if (prev_length >= good_match) {
			chain_length >>= 2;
		}

		// Do not look for matches beyond the end of the input. This is
		// necessary
		// to make deflate deterministic.
		if (_nice_match > lookahead)
			_nice_match = lookahead;

		do {
			match = cur_match;

			// Skip to next match if the match length cannot increase
			// or if the match length is less than 2:
			if (win[match + best_len] != scan_end || win[match + best_len - 1] != scan_end1 || win[match] != win[scan]
				|| win[++match] != win[scan + 1])
				continue;

			// The check at best_len-1 can be removed because it will be made
			// again later. (This heuristic is not always a win.)
			// It is not necessary to compare scan[2] and match[2] since they
			// are always equal when the other bytes match, given that
			// the hash keys are equal and that HASH_BITS >= 8.
			scan += 2;
			match++;

			// We check for insufficient lookahead only every 8th comparison;
			// the 256th check will be made at strstart+258.
			do {
				// empty block
			} while (win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match]
			&& win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match]
			&& win[++scan] == win[++match] && win[++scan] == win[++match] && scan < strend);

			len = MAX_MATCH$2 - (strend - scan);
			scan = strend - MAX_MATCH$2;

			if (len > best_len) {
				match_start = cur_match;
				best_len = len;
				if (len >= _nice_match)
					break;
				scan_end1 = win[scan + best_len - 1];
				scan_end = win[scan + best_len];
			}

		} while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);

		if (best_len <= lookahead)
			return best_len;
		return lookahead;
	}

	// Compress as much as possible from the input stream, return the current
	// block state.
	// This function does not perform lazy evaluation of matches and inserts
	// new strings in the dictionary only for unmatched strings or for short
	// matches. It is used only for the fast compression options.
	function deflate_fast(flush) {
		// short hash_head = 0; // head of the hash chain
		let hash_head = 0; // head of the hash chain
		let bflush; // set if current block must be flushed

		while (true) {
			// Make sure that we always have enough lookahead, except
			// at the end of the input file. We need MAX_MATCH bytes
			// for the next match, plus MIN_MATCH bytes to insert the
			// string following the next match.
			if (lookahead < MIN_LOOKAHEAD$1) {
				fill_window();
				if (lookahead < MIN_LOOKAHEAD$1 && flush == Z_NO_FLUSH$4) {
					return NeedMore;
				}
				if (lookahead === 0)
					break; // flush the current block
			}

			// Insert the string win[strstart .. strstart+2] in the
			// dictionary, and set hash_head to the head of the hash chain:
			if (lookahead >= MIN_MATCH$2) {
				ins_h = (((ins_h) << hash_shift) ^ (win[(strstart) + (MIN_MATCH$2 - 1)] & 0xff)) & hash_mask;

				// prev[strstart&w_mask]=hash_head=head[ins_h];
				hash_head = (head[ins_h] & 0xffff);
				prev[strstart & w_mask] = head[ins_h];
				head[ins_h] = strstart;
			}

			// Find the longest match, discarding those <= prev_length.
			// At this point we have always match_length < MIN_MATCH

			if (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD$1) {
				// To simplify the code, we prevent matches with the string
				// of win index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).
				if (strategy != Z_HUFFMAN_ONLY$1) {
					match_length = longest_match(hash_head);
				}
				// longest_match() sets match_start
			}
			if (match_length >= MIN_MATCH$2) {
				// check_match(strstart, match_start, match_length);

				bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH$2);

				lookahead -= match_length;

				// Insert new strings in the hash table only if the match length
				// is not too large. This saves time but degrades compression.
				if (match_length <= max_lazy_match && lookahead >= MIN_MATCH$2) {
					match_length--; // string at strstart already in hash table
					do {
						strstart++;

						ins_h = ((ins_h << hash_shift) ^ (win[(strstart) + (MIN_MATCH$2 - 1)] & 0xff)) & hash_mask;
						// prev[strstart&w_mask]=hash_head=head[ins_h];
						hash_head = (head[ins_h] & 0xffff);
						prev[strstart & w_mask] = head[ins_h];
						head[ins_h] = strstart;

						// strstart never exceeds WSIZE-MAX_MATCH, so there are
						// always MIN_MATCH bytes ahead.
					} while (--match_length !== 0);
					strstart++;
				} else {
					strstart += match_length;
					match_length = 0;
					ins_h = win[strstart] & 0xff;

					ins_h = (((ins_h) << hash_shift) ^ (win[strstart + 1] & 0xff)) & hash_mask;
					// If lookahead < MIN_MATCH, ins_h is garbage, but it does
					// not
					// matter since it will be recomputed at next deflate call.
				}
			} else {
				// No match, output a literal byte

				bflush = _tr_tally(0, win[strstart] & 0xff);
				lookahead--;
				strstart++;
			}
			if (bflush) {

				flush_block_only(false);
				if (strm.avail_out === 0)
					return NeedMore;
			}
		}

		flush_block_only(flush == Z_FINISH$5);
		if (strm.avail_out === 0) {
			if (flush == Z_FINISH$5)
				return FinishStarted;
			else
				return NeedMore;
		}
		return flush == Z_FINISH$5 ? FinishDone : BlockDone;
	}

	// Same as above, but achieves better compression. We use a lazy
	// evaluation for matches: a match is finally adopted only if there is
	// no better match at the next win position.
	function deflate_slow(flush) {
		// short hash_head = 0; // head of hash chain
		let hash_head = 0; // head of hash chain
		let bflush; // set if current block must be flushed
		let max_insert;

		// Process the input block.
		while (true) {
			// Make sure that we always have enough lookahead, except
			// at the end of the input file. We need MAX_MATCH bytes
			// for the next match, plus MIN_MATCH bytes to insert the
			// string following the next match.

			if (lookahead < MIN_LOOKAHEAD$1) {
				fill_window();
				if (lookahead < MIN_LOOKAHEAD$1 && flush == Z_NO_FLUSH$4) {
					return NeedMore;
				}
				if (lookahead === 0)
					break; // flush the current block
			}

			// Insert the string win[strstart .. strstart+2] in the
			// dictionary, and set hash_head to the head of the hash chain:

			if (lookahead >= MIN_MATCH$2) {
				ins_h = (((ins_h) << hash_shift) ^ (win[(strstart) + (MIN_MATCH$2 - 1)] & 0xff)) & hash_mask;
				// prev[strstart&w_mask]=hash_head=head[ins_h];
				hash_head = (head[ins_h] & 0xffff);
				prev[strstart & w_mask] = head[ins_h];
				head[ins_h] = strstart;
			}

			// Find the longest match, discarding those <= prev_length.
			prev_length = match_length;
			prev_match = match_start;
			match_length = MIN_MATCH$2 - 1;

			if (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD$1) {
				// To simplify the code, we prevent matches with the string
				// of win index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).

				if (strategy != Z_HUFFMAN_ONLY$1) {
					match_length = longest_match(hash_head);
				}
				// longest_match() sets match_start

				if (match_length <= 5 && (strategy == Z_FILTERED$1 || (match_length == MIN_MATCH$2 && strstart - match_start > 4096))) {

					// If prev_match is also MIN_MATCH, match_start is garbage
					// but we will ignore the current match anyway.
					match_length = MIN_MATCH$2 - 1;
				}
			}

			// If there was a match at the previous step and the current
			// match is not better, output the previous match:
			if (prev_length >= MIN_MATCH$2 && match_length <= prev_length) {
				max_insert = strstart + lookahead - MIN_MATCH$2;
				// Do not insert strings in hash table beyond this.

				// check_match(strstart-1, prev_match, prev_length);

				bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH$2);

				// Insert in hash table all strings up to the end of the match.
				// strstart-1 and strstart are already inserted. If there is not
				// enough lookahead, the last two strings are not inserted in
				// the hash table.
				lookahead -= prev_length - 1;
				prev_length -= 2;
				do {
					if (++strstart <= max_insert) {
						ins_h = (((ins_h) << hash_shift) ^ (win[(strstart) + (MIN_MATCH$2 - 1)] & 0xff)) & hash_mask;
						// prev[strstart&w_mask]=hash_head=head[ins_h];
						hash_head = (head[ins_h] & 0xffff);
						prev[strstart & w_mask] = head[ins_h];
						head[ins_h] = strstart;
					}
				} while (--prev_length !== 0);
				match_available = 0;
				match_length = MIN_MATCH$2 - 1;
				strstart++;

				if (bflush) {
					flush_block_only(false);
					if (strm.avail_out === 0)
						return NeedMore;
				}
			} else if (match_available !== 0) {

				// If there was no match at the previous position, output a
				// single literal. If there was a match but the current match
				// is longer, truncate the previous match to a single literal.

				bflush = _tr_tally(0, win[strstart - 1] & 0xff);

				if (bflush) {
					flush_block_only(false);
				}
				strstart++;
				lookahead--;
				if (strm.avail_out === 0)
					return NeedMore;
			} else {
				// There is no previous match to compare with, wait for
				// the next step to decide.

				match_available = 1;
				strstart++;
				lookahead--;
			}
		}

		if (match_available !== 0) {
			bflush = _tr_tally(0, win[strstart - 1] & 0xff);
			match_available = 0;
		}
		flush_block_only(flush == Z_FINISH$5);

		if (strm.avail_out === 0) {
			if (flush == Z_FINISH$5)
				return FinishStarted;
			else
				return NeedMore;
		}

		return flush == Z_FINISH$5 ? FinishDone : BlockDone;
	}

	function deflateReset(strm) {
		strm.total_in = strm.total_out = 0;
		strm.msg = null; //

		that.pending = 0;
		that.pending_out = 0;

		status = BUSY_STATE$1;

		last_flush = Z_NO_FLUSH$4;

		tr_init();
		lm_init();
		return Z_OK$5;
	}

	that.deflateInit = function (strm, _level, bits, _method, memLevel, _strategy) {
		if (!_method)
			_method = Z_DEFLATED$4;
		if (!memLevel)
			memLevel = DEF_MEM_LEVEL$1;
		if (!_strategy)
			_strategy = Z_DEFAULT_STRATEGY$2;

		// byte[] my_version=ZLIB_VERSION;

		//
		// if (!version || version[0] != my_version[0]
		// || stream_size != sizeof(z_stream)) {
		// return Z_VERSION_ERROR;
		// }

		strm.msg = null;

		if (_level == Z_DEFAULT_COMPRESSION$2)
			_level = 6;

		if (memLevel < 1 || memLevel > MAX_MEM_LEVEL$1 || _method != Z_DEFLATED$4 || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0
			|| _strategy > Z_HUFFMAN_ONLY$1) {
			return Z_STREAM_ERROR$4;
		}

		strm.dstate = that;

		w_bits = bits;
		w_size = 1 << w_bits;
		w_mask = w_size - 1;

		hash_bits = memLevel + 7;
		hash_size = 1 << hash_bits;
		hash_mask = hash_size - 1;
		hash_shift = Math.floor((hash_bits + MIN_MATCH$2 - 1) / MIN_MATCH$2);

		win = new Uint8Array(w_size * 2);
		prev = [];
		head = [];

		lit_bufsize = 1 << (memLevel + 6); // 16K elements by default

		that.pending_buf = new Uint8Array(lit_bufsize * 4);
		pending_buf_size = lit_bufsize * 4;

		that.dist_buf = new Uint16Array(lit_bufsize);
		that.lc_buf = new Uint8Array(lit_bufsize);

		level = _level;

		strategy = _strategy;

		return deflateReset(strm);
	};

	that.deflateEnd = function () {
		if (status != INIT_STATE$1 && status != BUSY_STATE$1 && status != FINISH_STATE$1) {
			return Z_STREAM_ERROR$4;
		}
		// Deallocate in reverse order of allocations:
		that.lc_buf = null;
		that.dist_buf = null;
		that.pending_buf = null;
		head = null;
		prev = null;
		win = null;
		// free
		that.dstate = null;
		return status == BUSY_STATE$1 ? Z_DATA_ERROR$4 : Z_OK$5;
	};

	that.deflateParams = function (strm, _level, _strategy) {
		let err = Z_OK$5;

		if (_level == Z_DEFAULT_COMPRESSION$2) {
			_level = 6;
		}
		if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY$1) {
			return Z_STREAM_ERROR$4;
		}

		if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {
			// Flush the last buffer:
			err = strm.deflate(Z_PARTIAL_FLUSH$1);
		}

		if (level != _level) {
			level = _level;
			max_lazy_match = config_table[level].max_lazy;
			good_match = config_table[level].good_length;
			nice_match = config_table[level].nice_length;
			max_chain_length = config_table[level].max_chain;
		}
		strategy = _strategy;
		return err;
	};

	that.deflateSetDictionary = function (_strm, dictionary, dictLength) {
		let length = dictLength;
		let n, index = 0;

		if (!dictionary || status != INIT_STATE$1)
			return Z_STREAM_ERROR$4;

		if (length < MIN_MATCH$2)
			return Z_OK$5;
		if (length > w_size - MIN_LOOKAHEAD$1) {
			length = w_size - MIN_LOOKAHEAD$1;
			index = dictLength - length; // use the tail of the dictionary
		}
		win.set(dictionary.subarray(index, index + length), 0);

		strstart = length;
		block_start = length;

		// Insert all strings in the hash table (except for the last two bytes).
		// s->lookahead stays null, so s->ins_h will be recomputed at the next
		// call of fill_window.

		ins_h = win[0] & 0xff;
		ins_h = (((ins_h) << hash_shift) ^ (win[1] & 0xff)) & hash_mask;

		for (n = 0; n <= length - MIN_MATCH$2; n++) {
			ins_h = (((ins_h) << hash_shift) ^ (win[(n) + (MIN_MATCH$2 - 1)] & 0xff)) & hash_mask;
			prev[n & w_mask] = head[ins_h];
			head[ins_h] = n;
		}
		return Z_OK$5;
	};

	that.deflate = function (_strm, flush) {
		let i, header, level_flags, old_flush, bstate;

		if (flush > Z_FINISH$5 || flush < 0) {
			return Z_STREAM_ERROR$4;
		}

		if (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE$1 && flush != Z_FINISH$5)) {
			_strm.msg = z_errmsg[Z_NEED_DICT$3 - (Z_STREAM_ERROR$4)];
			return Z_STREAM_ERROR$4;
		}
		if (_strm.avail_out === 0) {
			_strm.msg = z_errmsg[Z_NEED_DICT$3 - (Z_BUF_ERROR$3)];
			return Z_BUF_ERROR$3;
		}

		strm = _strm; // just in case
		old_flush = last_flush;
		last_flush = flush;

		// Write the zlib header
		if (status == INIT_STATE$1) {
			header = (Z_DEFLATED$4 + ((w_bits - 8) << 4)) << 8;
			level_flags = ((level - 1) & 0xff) >> 1;

			if (level_flags > 3)
				level_flags = 3;
			header |= (level_flags << 6);
			if (strstart !== 0)
				header |= PRESET_DICT$2;
			header += 31 - (header % 31);

			status = BUSY_STATE$1;
			putShortMSB(header);
		}

		// Flush as much pending output as possible
		if (that.pending !== 0) {
			strm.flush_pending();
			if (strm.avail_out === 0) {
				// console.log(" avail_out==0");
				// Since avail_out is 0, deflate will be called again with
				// more output space, but possibly with both pending and
				// avail_in equal to zero. There won't be anything to do,
				// but this is not an error situation so make sure we
				// return OK instead of BUF_ERROR at next call of deflate:
				last_flush = -1;
				return Z_OK$5;
			}

			// Make sure there is something to do and avoid duplicate
			// consecutive
			// flushes. For repeated and useless calls with Z_FINISH, we keep
			// returning Z_STREAM_END instead of Z_BUFF_ERROR.
		} else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH$5) {
			strm.msg = z_errmsg[Z_NEED_DICT$3 - (Z_BUF_ERROR$3)];
			return Z_BUF_ERROR$3;
		}

		// User must not provide more input after the first FINISH:
		if (status == FINISH_STATE$1 && strm.avail_in !== 0) {
			_strm.msg = z_errmsg[Z_NEED_DICT$3 - (Z_BUF_ERROR$3)];
			return Z_BUF_ERROR$3;
		}

		// Start a new block or continue the current one.
		if (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH$4 && status != FINISH_STATE$1)) {
			bstate = -1;
			switch (config_table[level].func) {
				case STORED$2:
					bstate = deflate_stored(flush);
					break;
				case FAST:
					bstate = deflate_fast(flush);
					break;
				case SLOW:
					bstate = deflate_slow(flush);
					break;
			}

			if (bstate == FinishStarted || bstate == FinishDone) {
				status = FINISH_STATE$1;
			}
			if (bstate == NeedMore || bstate == FinishStarted) {
				if (strm.avail_out === 0) {
					last_flush = -1; // avoid BUF_ERROR next call, see above
				}
				return Z_OK$5;
				// If flush != Z_NO_FLUSH && avail_out === 0, the next call
				// of deflate should use the same flush parameter to make sure
				// that the flush is complete. So we don't have to output an
				// empty block here, this will be done at next call. This also
				// ensures that for a very small output buffer, we emit at most
				// one empty block.
			}

			if (bstate == BlockDone) {
				if (flush == Z_PARTIAL_FLUSH$1) {
					_tr_align();
				} else { // FULL_FLUSH or SYNC_FLUSH
					_tr_stored_block(0, 0, false);
					// For a full flush, this empty block will be recognized
					// as a special marker by inflate_sync().
					if (flush == Z_FULL_FLUSH$2) {
						// state.head[s.hash_size-1]=0;
						for (i = 0; i < hash_size/*-1*/; i++)
							// forget history
							head[i] = 0;
					}
				}
				strm.flush_pending();
				if (strm.avail_out === 0) {
					last_flush = -1; // avoid BUF_ERROR at next call, see above
					return Z_OK$5;
				}
			}
		}

		if (flush != Z_FINISH$5)
			return Z_OK$5;
		return Z_STREAM_END$5;
	};
}

// ZStream

function ZStream$2() {
	const that = this;
	that.next_in_index = 0;
	that.next_out_index = 0;
	// that.next_in; // next input byte
	that.avail_in = 0; // number of bytes available at next_in
	that.total_in = 0; // total nb of input bytes read so far
	// that.next_out; // next output byte should be put there
	that.avail_out = 0; // remaining free space at next_out
	that.total_out = 0; // total nb of bytes output so far
	// that.msg;
	// that.dstate;
}

ZStream$2.prototype = {
	deflateInit(level, bits) {
		const that = this;
		that.dstate = new Deflate$2();
		if (!bits)
			bits = MAX_BITS$3;
		return that.dstate.deflateInit(that, level, bits);
	},

	deflate(flush) {
		const that = this;
		if (!that.dstate) {
			return Z_STREAM_ERROR$4;
		}
		return that.dstate.deflate(that, flush);
	},

	deflateEnd() {
		const that = this;
		if (!that.dstate)
			return Z_STREAM_ERROR$4;
		const ret = that.dstate.deflateEnd();
		that.dstate = null;
		return ret;
	},

	deflateParams(level, strategy) {
		const that = this;
		if (!that.dstate)
			return Z_STREAM_ERROR$4;
		return that.dstate.deflateParams(that, level, strategy);
	},

	deflateSetDictionary(dictionary, dictLength) {
		const that = this;
		if (!that.dstate)
			return Z_STREAM_ERROR$4;
		return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
	},

	// Read a new buffer from the current input stream, update the
	// total number of bytes read. All deflate() input goes through
	// this function so some applications may wish to modify it to avoid
	// allocating a large strm->next_in buffer and copying from it.
	// (See also flush_pending()).
	read_buf(buf, start, size) {
		const that = this;
		let len = that.avail_in;
		if (len > size)
			len = size;
		if (len === 0)
			return 0;
		that.avail_in -= len;
		buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
		that.next_in_index += len;
		that.total_in += len;
		return len;
	},

	// Flush as much pending output as possible. All deflate() output goes
	// through this function so some applications may wish to modify it
	// to avoid allocating a large strm->next_out buffer and copying into it.
	// (See also read_buf()).
	flush_pending() {
		const that = this;
		let len = that.dstate.pending;

		if (len > that.avail_out)
			len = that.avail_out;
		if (len === 0)
			return;

		// if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index
		// || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +
		// len)) {
		// console.log(that.dstate.pending_buf.length + ", " + that.dstate.pending_out + ", " + that.next_out.length + ", " +
		// that.next_out_index + ", " + len);
		// console.log("avail_out=" + that.avail_out);
		// }

		that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);

		that.next_out_index += len;
		that.dstate.pending_out += len;
		that.total_out += len;
		that.avail_out -= len;
		that.dstate.pending -= len;
		if (that.dstate.pending === 0) {
			that.dstate.pending_out = 0;
		}
	}
};

// Deflate

function ZipDeflate(options) {
	const that = this;
	const z = new ZStream$2();
	const bufsize = getMaximumCompressedSize$1(options && options.chunkSize ? options.chunkSize : 64 * 1024);
	const flush = Z_NO_FLUSH$4;
	const buf = new Uint8Array(bufsize);
	let level = options ? options.level : Z_DEFAULT_COMPRESSION$2;
	if (typeof level == "undefined")
		level = Z_DEFAULT_COMPRESSION$2;
	z.deflateInit(level);
	z.next_out = buf;

	that.append = function (data, onprogress) {
		let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
		const buffers = [];
		if (!data.length)
			return;
		z.next_in_index = 0;
		z.next_in = data;
		z.avail_in = data.length;
		do {
			z.next_out_index = 0;
			z.avail_out = bufsize;
			err = z.deflate(flush);
			if (err != Z_OK$5)
				throw new Error("deflating: " + z.msg);
			if (z.next_out_index)
				if (z.next_out_index == bufsize)
					buffers.push(new Uint8Array(buf));
				else
					buffers.push(buf.subarray(0, z.next_out_index));
			bufferSize += z.next_out_index;
			if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
				onprogress(z.next_in_index);
				lastIndex = z.next_in_index;
			}
		} while (z.avail_in > 0 || z.avail_out === 0);
		if (buffers.length > 1) {
			array = new Uint8Array(bufferSize);
			buffers.forEach(function (chunk) {
				array.set(chunk, bufferIndex);
				bufferIndex += chunk.length;
			});
		} else {
			array = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
		}
		return array;
	};
	that.flush = function () {
		let err, array, bufferIndex = 0, bufferSize = 0;
		const buffers = [];
		do {
			z.next_out_index = 0;
			z.avail_out = bufsize;
			err = z.deflate(Z_FINISH$5);
			if (err != Z_STREAM_END$5 && err != Z_OK$5)
				throw new Error("deflating: " + z.msg);
			if (bufsize - z.avail_out > 0)
				buffers.push(buf.slice(0, z.next_out_index));
			bufferSize += z.next_out_index;
		} while (z.avail_in > 0 || z.avail_out === 0);
		z.deflateEnd();
		array = new Uint8Array(bufferSize);
		buffers.forEach(function (chunk) {
			array.set(chunk, bufferIndex);
			bufferIndex += chunk.length;
		});
		return array;
	};
}

function getMaximumCompressedSize$1(uncompressedSize) {
	return uncompressedSize + (5 * (Math.floor(uncompressedSize / 16383) + 1));
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.
 * JZlib is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

// deno-lint-ignore-file no-this-alias prefer-const

// Global

const MAX_BITS$2 = 15;

const Z_OK$4 = 0;
const Z_STREAM_END$4 = 1;
const Z_NEED_DICT$2 = 2;
const Z_STREAM_ERROR$3 = -2;
const Z_DATA_ERROR$3 = -3;
const Z_MEM_ERROR$2 = -4;
const Z_BUF_ERROR$2 = -5;

const inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,
	0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];

const MANY = 1440;

// JZlib version : "1.0.2"
const Z_NO_FLUSH$3 = 0;
const Z_FINISH$4 = 4;

// InfTree
const fixed_bl = 9;
const fixed_bd = 5;

const fixed_tl = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,
	0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,
	0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,
	0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,
	0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,
	35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,
	26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,
	7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,
	8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,
	8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,
	0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,
	81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,
	0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,
	84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,
	0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,
	80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,
	0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,
	0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,
	0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,
	193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,
	120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,
	227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,
	92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,
	249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,
	130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,
	181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,
	102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,
	221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,
	8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,
	147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,
	85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,
	235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,
	141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,
	167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,
	107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,
	207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,
	127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255];
const fixed_td = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,
	8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,
	24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577];

// Tables for deflate from PKZIP's appnote.txt.
const cplens = [ // Copy lengths for literal codes 257..285
	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];

// see note #13 above about 258
const cplext = [ // Extra bits for literal codes 257..285
	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid
];

const cpdist = [ // Copy offsets for distance codes 0..29
	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];

const cpdext = [ // Extra bits for distance codes
	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

// If BMAX needs to be larger than 16, then h and x[] should be uLong.
const BMAX = 15; // maximum bit length of any code

function InfTree() {
	const that = this;

	let hn; // hufts used in space
	let v; // work area for huft_build
	let c; // bit length count table
	let r; // table entry for structure assignment
	let u; // table stack
	let x; // bit offsets, then code stack

	function huft_build(b, // code lengths in bits (all assumed <=
		// BMAX)
		bindex, n, // number of codes (assumed <= 288)
		s, // number of simple-valued codes (0..s-1)
		d, // list of base values for non-simple codes
		e, // list of extra bits for non-simple codes
		t, // result: starting table
		m, // maximum lookup bits, returns actual
		hp,// space for trees
		hn,// hufts used in space
		v // working area: values in order of bit length
	) {
		// Given a list of code lengths and a maximum table size, make a set of
		// tables to decode that set of codes. Return Z_OK on success,
		// Z_BUF_ERROR
		// if the given code set is incomplete (the tables are still built in
		// this
		// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set
		// of
		// lengths), or Z_MEM_ERROR if not enough memory.

		let a; // counter for codes of length k
		let f; // i repeats in table every f entries
		let g; // maximum code length
		let h; // table level
		let i; // counter, current code
		let j; // counter
		let k; // number of bits in current code
		let l; // bits per table (returned in m)
		let mask; // (1 << w) - 1, to avoid cc -O bug on HP
		let p; // pointer into c[], b[], or v[]
		let q; // points to current table
		let w; // bits before this table == (l * h)
		let xp; // pointer into x
		let y; // number of dummy codes added
		let z; // number of entries in current table

		// Generate counts for each bit length

		p = 0;
		i = n;
		do {
			c[b[bindex + p]]++;
			p++;
			i--; // assume all entries <= BMAX
		} while (i !== 0);

		if (c[0] == n) { // null input--all zero length codes
			t[0] = -1;
			m[0] = 0;
			return Z_OK$4;
		}

		// Find minimum and maximum length, bound *m by those
		l = m[0];
		for (j = 1; j <= BMAX; j++)
			if (c[j] !== 0)
				break;
		k = j; // minimum code length
		if (l < j) {
			l = j;
		}
		for (i = BMAX; i !== 0; i--) {
			if (c[i] !== 0)
				break;
		}
		g = i; // maximum code length
		if (l > i) {
			l = i;
		}
		m[0] = l;

		// Adjust last length count to fill out codes, if needed
		for (y = 1 << j; j < i; j++, y <<= 1) {
			if ((y -= c[j]) < 0) {
				return Z_DATA_ERROR$3;
			}
		}
		if ((y -= c[i]) < 0) {
			return Z_DATA_ERROR$3;
		}
		c[i] += y;

		// Generate starting offsets into the value table for each length
		x[1] = j = 0;
		p = 1;
		xp = 2;
		while (--i !== 0) { // note that i == g from above
			x[xp] = (j += c[p]);
			xp++;
			p++;
		}

		// Make a table of values in order of bit lengths
		i = 0;
		p = 0;
		do {
			if ((j = b[bindex + p]) !== 0) {
				v[x[j]++] = i;
			}
			p++;
		} while (++i < n);
		n = x[g]; // set n to length of v

		// Generate the Huffman codes and for each, make the table entries
		x[0] = i = 0; // first Huffman code is zero
		p = 0; // grab values in bit order
		h = -1; // no tables yet--level -1
		w = -l; // bits decoded == (l * h)
		u[0] = 0; // just to keep compilers happy
		q = 0; // ditto
		z = 0; // ditto

		// go through the bit lengths (k already is bits in shortest code)
		for (; k <= g; k++) {
			a = c[k];
			while (a-- !== 0) {
				// here i is the Huffman code of length k bits for value *p
				// make tables up to required level
				while (k > w + l) {
					h++;
					w += l; // previous table always l bits
					// compute minimum size table less than or equal to l bits
					z = g - w;
					z = (z > l) ? l : z; // table size upper limit
					if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
						// too few codes for
						// k-w bit table
						f -= a + 1; // deduct codes from patterns left
						xp = k;
						if (j < z) {
							while (++j < z) { // try smaller tables up to z bits
								if ((f <<= 1) <= c[++xp])
									break; // enough codes to use up j bits
								f -= c[xp]; // else deduct codes from patterns
							}
						}
					}
					z = 1 << j; // table entries for j-bit table

					// allocate new table
					if (hn[0] + z > MANY) { // (note: doesn't matter for fixed)
						return Z_DATA_ERROR$3; // overflow of MANY
					}
					u[h] = q = /* hp+ */hn[0]; // DEBUG
					hn[0] += z;

					// connect to last table, if there is one
					if (h !== 0) {
						x[h] = i; // save pattern for backing up
						r[0] = /* (byte) */j; // bits in this table
						r[1] = /* (byte) */l; // bits to dump before this table
						j = i >>> (w - l);
						r[2] = /* (int) */(q - u[h - 1] - j); // offset to this table
						hp.set(r, (u[h - 1] + j) * 3);
						// to
						// last
						// table
					} else {
						t[0] = q; // first table is returned result
					}
				}

				// set up table entry in r
				r[1] = /* (byte) */(k - w);
				if (p >= n) {
					r[0] = 128 + 64; // out of values--invalid code
				} else if (v[p] < s) {
					r[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is
					// end-of-block
					r[2] = v[p++]; // simple code is just the value
				} else {
					r[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look
					// up in lists
					r[2] = d[v[p++] - s];
				}

				// fill code-like entries with r
				f = 1 << (k - w);
				for (j = i >>> w; j < z; j += f) {
					hp.set(r, (q + j) * 3);
				}

				// backwards increment the k-bit code i
				for (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {
					i ^= j;
				}
				i ^= j;

				// backup over finished tables
				mask = (1 << w) - 1; // needed on HP, cc -O bug
				while ((i & mask) != x[h]) {
					h--; // don't need to update q
					w -= l;
					mask = (1 << w) - 1;
				}
			}
		}
		// Return Z_BUF_ERROR if we were given an incomplete table
		return y !== 0 && g != 1 ? Z_BUF_ERROR$2 : Z_OK$4;
	}

	function initWorkArea(vsize) {
		let i;
		if (!hn) {
			hn = []; // []; //new Array(1);
			v = []; // new Array(vsize);
			c = new Int32Array(BMAX + 1); // new Array(BMAX + 1);
			r = []; // new Array(3);
			u = new Int32Array(BMAX); // new Array(BMAX);
			x = new Int32Array(BMAX + 1); // new Array(BMAX + 1);
		}
		if (v.length < vsize) {
			v = []; // new Array(vsize);
		}
		for (i = 0; i < vsize; i++) {
			v[i] = 0;
		}
		for (i = 0; i < BMAX + 1; i++) {
			c[i] = 0;
		}
		for (i = 0; i < 3; i++) {
			r[i] = 0;
		}
		// for(int i=0; i<BMAX; i++){u[i]=0;}
		u.set(c.subarray(0, BMAX), 0);
		// for(int i=0; i<BMAX+1; i++){x[i]=0;}
		x.set(c.subarray(0, BMAX + 1), 0);
	}

	that.inflate_trees_bits = function (c, // 19 code lengths
		bb, // bits tree desired/actual depth
		tb, // bits tree result
		hp, // space for trees
		z // for messages
	) {
		let result;
		initWorkArea(19);
		hn[0] = 0;
		result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);

		if (result == Z_DATA_ERROR$3) {
			z.msg = "oversubscribed dynamic bit lengths tree";
		} else if (result == Z_BUF_ERROR$2 || bb[0] === 0) {
			z.msg = "incomplete dynamic bit lengths tree";
			result = Z_DATA_ERROR$3;
		}
		return result;
	};

	that.inflate_trees_dynamic = function (nl, // number of literal/length codes
		nd, // number of distance codes
		c, // that many (total) code lengths
		bl, // literal desired/actual bit depth
		bd, // distance desired/actual bit depth
		tl, // literal/length tree result
		td, // distance tree result
		hp, // space for trees
		z // for messages
	) {
		let result;

		// build literal/length tree
		initWorkArea(288);
		hn[0] = 0;
		result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
		if (result != Z_OK$4 || bl[0] === 0) {
			if (result == Z_DATA_ERROR$3) {
				z.msg = "oversubscribed literal/length tree";
			} else if (result != Z_MEM_ERROR$2) {
				z.msg = "incomplete literal/length tree";
				result = Z_DATA_ERROR$3;
			}
			return result;
		}

		// build distance tree
		initWorkArea(288);
		result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);

		if (result != Z_OK$4 || (bd[0] === 0 && nl > 257)) {
			if (result == Z_DATA_ERROR$3) {
				z.msg = "oversubscribed distance tree";
			} else if (result == Z_BUF_ERROR$2) {
				z.msg = "incomplete distance tree";
				result = Z_DATA_ERROR$3;
			} else if (result != Z_MEM_ERROR$2) {
				z.msg = "empty distance tree with lengths";
				result = Z_DATA_ERROR$3;
			}
			return result;
		}

		return Z_OK$4;
	};

}

InfTree.inflate_trees_fixed = function (bl, // literal desired/actual bit depth
	bd, // distance desired/actual bit depth
	tl,// literal/length tree result
	td// distance tree result
) {
	bl[0] = fixed_bl;
	bd[0] = fixed_bd;
	tl[0] = fixed_tl;
	td[0] = fixed_td;
	return Z_OK$4;
};

// InfCodes

// waiting for "i:"=input,
// "o:"=output,
// "x:"=nothing
const START = 0; // x: set up for LEN
const LEN$1 = 1; // i: get length/literal/eob next
const LENEXT$1 = 2; // i: getting length extra (have base)
const DIST$1 = 3; // i: get distance next
const DISTEXT$1 = 4;// i: getting distance extra
const COPY$1 = 5; // o: copying bytes in win, waiting
// for space
const LIT$1 = 6; // o: got literal, waiting for output
// space
const WASH = 7; // o: got eob, possibly still output
// waiting
const END = 8; // x: got eob and all data flushed
const BADCODE = 9;// x: got error

function InfCodes() {
	const that = this;

	let mode; // current inflate_codes mode

	// mode dependent information
	let len = 0;

	let tree; // pointer into tree
	let tree_index = 0;
	let need = 0; // bits needed

	let lit = 0;

	// if EXT or COPY, where and how much
	let get = 0; // bits to get for extra
	let dist = 0; // distance back to copy from

	let lbits = 0; // ltree bits decoded per branch
	let dbits = 0; // dtree bits decoder per branch
	let ltree; // literal/length/eob tree
	let ltree_index = 0; // literal/length/eob tree
	let dtree; // distance tree
	let dtree_index = 0; // distance tree

	// Called with number of bytes left to write in win at least 258
	// (the maximum string length) and number of input bytes available
	// at least ten. The ten bytes are six bytes for the longest length/
	// distance pair plus four bytes for overloading the bit buffer.

	function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {
		let t; // temporary pointer
		let tp; // temporary pointer
		let tp_index; // temporary pointer
		let e; // extra bits or operation
		let b; // bit buffer
		let k; // bits in bit buffer
		let p; // input data pointer
		let n; // bytes available there
		let q; // output win write pointer
		let m; // bytes to end of win or read pointer
		let ml; // mask for literal/length tree
		let md; // mask for distance tree
		let c; // bytes to copy
		let d; // distance back to copy from
		let r; // copy source pointer

		let tp_index_t_3; // (tp_index+t)*3

		// load input, output, bit values
		p = z.next_in_index;
		n = z.avail_in;
		b = s.bitb;
		k = s.bitk;
		q = s.write;
		m = q < s.read ? s.read - q - 1 : s.end - q;

		// initialize masks
		ml = inflate_mask[bl];
		md = inflate_mask[bd];

		// do until not enough input or output space for fast loop
		do { // assume called with m >= 258 && n >= 10
			// get literal/length code
			while (k < (20)) { // max bits for literal/length code
				n--;
				b |= (z.read_byte(p++) & 0xff) << k;
				k += 8;
			}

			t = b & ml;
			tp = tl;
			tp_index = tl_index;
			tp_index_t_3 = (tp_index + t) * 3;
			if ((e = tp[tp_index_t_3]) === 0) {
				b >>= (tp[tp_index_t_3 + 1]);
				k -= (tp[tp_index_t_3 + 1]);

				s.win[q++] = /* (byte) */tp[tp_index_t_3 + 2];
				m--;
				continue;
			}
			do {

				b >>= (tp[tp_index_t_3 + 1]);
				k -= (tp[tp_index_t_3 + 1]);

				if ((e & 16) !== 0) {
					e &= 15;
					c = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);

					b >>= e;
					k -= e;

					// decode distance base of block to copy
					while (k < (15)) { // max bits for distance code
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					t = b & md;
					tp = td;
					tp_index = td_index;
					tp_index_t_3 = (tp_index + t) * 3;
					e = tp[tp_index_t_3];

					do {

						b >>= (tp[tp_index_t_3 + 1]);
						k -= (tp[tp_index_t_3 + 1]);

						if ((e & 16) !== 0) {
							// get extra bits to add to distance base
							e &= 15;
							while (k < (e)) { // get extra bits (up to 13)
								n--;
								b |= (z.read_byte(p++) & 0xff) << k;
								k += 8;
							}

							d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);

							b >>= (e);
							k -= (e);

							// do the copy
							m -= c;
							if (q >= d) { // offset before dest
								// just copy
								r = q - d;
								if (q - r > 0 && 2 > (q - r)) {
									s.win[q++] = s.win[r++]; // minimum
									// count is
									// three,
									s.win[q++] = s.win[r++]; // so unroll
									// loop a
									// little
									c -= 2;
								} else {
									s.win.set(s.win.subarray(r, r + 2), q);
									q += 2;
									r += 2;
									c -= 2;
								}
							} else { // else offset after destination
								r = q - d;
								do {
									r += s.end; // force pointer in win
								} while (r < 0); // covers invalid distances
								e = s.end - r;
								if (c > e) { // if source crosses,
									c -= e; // wrapped copy
									if (q - r > 0 && e > (q - r)) {
										do {
											s.win[q++] = s.win[r++];
										} while (--e !== 0);
									} else {
										s.win.set(s.win.subarray(r, r + e), q);
										q += e;
										r += e;
										e = 0;
									}
									r = 0; // copy rest from start of win
								}

							}

							// copy all or what's left
							if (q - r > 0 && c > (q - r)) {
								do {
									s.win[q++] = s.win[r++];
								} while (--c !== 0);
							} else {
								s.win.set(s.win.subarray(r, r + c), q);
								q += c;
								r += c;
								c = 0;
							}
							break;
						} else if ((e & 64) === 0) {
							t += tp[tp_index_t_3 + 2];
							t += (b & inflate_mask[e]);
							tp_index_t_3 = (tp_index + t) * 3;
							e = tp[tp_index_t_3];
						} else {
							z.msg = "invalid distance code";

							c = z.avail_in - n;
							c = (k >> 3) < c ? k >> 3 : c;
							n += c;
							p -= c;
							k -= c << 3;

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;

							return Z_DATA_ERROR$3;
						}
						// eslint-disable-next-line no-constant-condition
					} while (true);
					break;
				}

				if ((e & 64) === 0) {
					t += tp[tp_index_t_3 + 2];
					t += (b & inflate_mask[e]);
					tp_index_t_3 = (tp_index + t) * 3;
					if ((e = tp[tp_index_t_3]) === 0) {

						b >>= (tp[tp_index_t_3 + 1]);
						k -= (tp[tp_index_t_3 + 1]);

						s.win[q++] = /* (byte) */tp[tp_index_t_3 + 2];
						m--;
						break;
					}
				} else if ((e & 32) !== 0) {

					c = z.avail_in - n;
					c = (k >> 3) < c ? k >> 3 : c;
					n += c;
					p -= c;
					k -= c << 3;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;

					return Z_STREAM_END$4;
				} else {
					z.msg = "invalid literal/length code";

					c = z.avail_in - n;
					c = (k >> 3) < c ? k >> 3 : c;
					n += c;
					p -= c;
					k -= c << 3;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;

					return Z_DATA_ERROR$3;
				}
				// eslint-disable-next-line no-constant-condition
			} while (true);
		} while (m >= 258 && n >= 10);

		// not enough input or output--restore pointers and return
		c = z.avail_in - n;
		c = (k >> 3) < c ? k >> 3 : c;
		n += c;
		p -= c;
		k -= c << 3;

		s.bitb = b;
		s.bitk = k;
		z.avail_in = n;
		z.total_in += p - z.next_in_index;
		z.next_in_index = p;
		s.write = q;

		return Z_OK$4;
	}

	that.init = function (bl, bd, tl, tl_index, td, td_index) {
		mode = START;
		lbits = /* (byte) */bl;
		dbits = /* (byte) */bd;
		ltree = tl;
		ltree_index = tl_index;
		dtree = td;
		dtree_index = td_index;
		tree = null;
	};

	that.proc = function (s, z, r) {
		let j; // temporary storage
		let tindex; // temporary pointer
		let e; // extra bits or operation
		let b = 0; // bit buffer
		let k = 0; // bits in bit buffer
		let p = 0; // input data pointer
		let n; // bytes available there
		let q; // output win write pointer
		let m; // bytes to end of win or read pointer
		let f; // pointer to copy strings from

		// copy input/output information to locals (UPDATE macro restores)
		p = z.next_in_index;
		n = z.avail_in;
		b = s.bitb;
		k = s.bitk;
		q = s.write;
		m = q < s.read ? s.read - q - 1 : s.end - q;

		// process input and output based on current state
		while (true) {
			switch (mode) {
				// waiting for "i:"=input, "o:"=output, "x:"=nothing
				case START: // x: set up for LEN
					if (m >= 258 && n >= 10) {

						s.bitb = b;
						s.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						s.write = q;
						r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);

						p = z.next_in_index;
						n = z.avail_in;
						b = s.bitb;
						k = s.bitk;
						q = s.write;
						m = q < s.read ? s.read - q - 1 : s.end - q;

						if (r != Z_OK$4) {
							mode = r == Z_STREAM_END$4 ? WASH : BADCODE;
							break;
						}
					}
					need = lbits;
					tree = ltree;
					tree_index = ltree_index;

					mode = LEN$1;
				/* falls through */
				case LEN$1: // i: get length/literal/eob next
					j = need;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK$4;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					tindex = (tree_index + (b & inflate_mask[j])) * 3;

					b >>>= (tree[tindex + 1]);
					k -= (tree[tindex + 1]);

					e = tree[tindex];

					if (e === 0) { // literal
						lit = tree[tindex + 2];
						mode = LIT$1;
						break;
					}
					if ((e & 16) !== 0) { // length
						get = e & 15;
						len = tree[tindex + 2];
						mode = LENEXT$1;
						break;
					}
					if ((e & 64) === 0) { // next table
						need = e;
						tree_index = tindex / 3 + tree[tindex + 2];
						break;
					}
					if ((e & 32) !== 0) { // end of block
						mode = WASH;
						break;
					}
					mode = BADCODE; // invalid code
					z.msg = "invalid literal/length code";
					r = Z_DATA_ERROR$3;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case LENEXT$1: // i: getting length extra (have base)
					j = get;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK$4;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					len += (b & inflate_mask[j]);

					b >>= j;
					k -= j;

					need = dbits;
					tree = dtree;
					tree_index = dtree_index;
					mode = DIST$1;
				/* falls through */
				case DIST$1: // i: get distance next
					j = need;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK$4;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					tindex = (tree_index + (b & inflate_mask[j])) * 3;

					b >>= tree[tindex + 1];
					k -= tree[tindex + 1];

					e = (tree[tindex]);
					if ((e & 16) !== 0) { // distance
						get = e & 15;
						dist = tree[tindex + 2];
						mode = DISTEXT$1;
						break;
					}
					if ((e & 64) === 0) { // next table
						need = e;
						tree_index = tindex / 3 + tree[tindex + 2];
						break;
					}
					mode = BADCODE; // invalid code
					z.msg = "invalid distance code";
					r = Z_DATA_ERROR$3;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case DISTEXT$1: // i: getting distance extra
					j = get;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK$4;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					dist += (b & inflate_mask[j]);

					b >>= j;
					k -= j;

					mode = COPY$1;
				/* falls through */
				case COPY$1: // o: copying bytes in win, waiting for space
					f = q - dist;
					while (f < 0) { // modulo win size-"while" instead
						f += s.end; // of "if" handles invalid distances
					}
					while (len !== 0) {

						if (m === 0) {
							if (q == s.end && s.read !== 0) {
								q = 0;
								m = q < s.read ? s.read - q - 1 : s.end - q;
							}
							if (m === 0) {
								s.write = q;
								r = s.inflate_flush(z, r);
								q = s.write;
								m = q < s.read ? s.read - q - 1 : s.end - q;

								if (q == s.end && s.read !== 0) {
									q = 0;
									m = q < s.read ? s.read - q - 1 : s.end - q;
								}

								if (m === 0) {
									s.bitb = b;
									s.bitk = k;
									z.avail_in = n;
									z.total_in += p - z.next_in_index;
									z.next_in_index = p;
									s.write = q;
									return s.inflate_flush(z, r);
								}
							}
						}

						s.win[q++] = s.win[f++];
						m--;

						if (f == s.end)
							f = 0;
						len--;
					}
					mode = START;
					break;
				case LIT$1: // o: got literal, waiting for output space
					if (m === 0) {
						if (q == s.end && s.read !== 0) {
							q = 0;
							m = q < s.read ? s.read - q - 1 : s.end - q;
						}
						if (m === 0) {
							s.write = q;
							r = s.inflate_flush(z, r);
							q = s.write;
							m = q < s.read ? s.read - q - 1 : s.end - q;

							if (q == s.end && s.read !== 0) {
								q = 0;
								m = q < s.read ? s.read - q - 1 : s.end - q;
							}
							if (m === 0) {
								s.bitb = b;
								s.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								s.write = q;
								return s.inflate_flush(z, r);
							}
						}
					}
					r = Z_OK$4;

					s.win[q++] = /* (byte) */lit;
					m--;

					mode = START;
					break;
				case WASH: // o: got eob, possibly more output
					if (k > 7) { // return unused byte, if any
						k -= 8;
						n++;
						p--; // can always return one
					}

					s.write = q;
					r = s.inflate_flush(z, r);
					q = s.write;
					m = q < s.read ? s.read - q - 1 : s.end - q;

					if (s.read != s.write) {
						s.bitb = b;
						s.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						s.write = q;
						return s.inflate_flush(z, r);
					}
					mode = END;
				/* falls through */
				case END:
					r = Z_STREAM_END$4;
					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case BADCODE: // x: got error

					r = Z_DATA_ERROR$3;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				default:
					r = Z_STREAM_ERROR$3;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);
			}
		}
	};

	that.free = function () {
		// ZFREE(z, c);
	};

}

// InfBlocks

// Table for deflate from PKZIP's appnote.txt.
const border = [ // Order of the bit length code lengths
	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

const TYPE$2 = 0; // get type bits (3, including end bit)
const LENS$2 = 1; // get lengths for stored
const STORED$1 = 2;// processing stored block
const TABLE$1 = 3; // get table lengths
const BTREE = 4; // get bit lengths tree for a dynamic
// block
const DTREE = 5; // get length, distance trees for a
// dynamic block
const CODES$2 = 6; // processing fixed or dynamic block
const DRY = 7; // output remaining win bytes
const DONELOCKS = 8; // finished last block, done
const BADBLOCKS = 9; // ot a data error--stuck here

function InfBlocks(z, w) {
	const that = this;

	let mode = TYPE$2; // current inflate_block mode

	let left = 0; // if STORED, bytes left to copy

	let table = 0; // table lengths (14 bits)
	let index = 0; // index into blens (or border)
	let blens; // bit lengths of codes
	const bb = [0]; // bit length tree depth
	const tb = [0]; // bit length decoding tree

	const codes = new InfCodes(); // if CODES, current state

	let last = 0; // true if this block is the last block

	let hufts = new Int32Array(MANY * 3); // single malloc for tree space
	const check = 0; // check on output
	const inftree = new InfTree();

	that.bitk = 0; // bits in bit buffer
	that.bitb = 0; // bit buffer
	that.win = new Uint8Array(w); // sliding win
	that.end = w; // one byte after sliding win
	that.read = 0; // win read pointer
	that.write = 0; // win write pointer

	that.reset = function (z, c) {
		if (c)
			c[0] = check;
		// if (mode == BTREE || mode == DTREE) {
		// }
		if (mode == CODES$2) {
			codes.free(z);
		}
		mode = TYPE$2;
		that.bitk = 0;
		that.bitb = 0;
		that.read = that.write = 0;
	};

	that.reset(z, null);

	// copy as much as possible from the sliding win to the output area
	that.inflate_flush = function (z, r) {
		let n;
		let p;
		let q;

		// local copies of source and destination pointers
		p = z.next_out_index;
		q = that.read;

		// compute number of bytes to copy as far as end of win
		n = /* (int) */((q <= that.write ? that.write : that.end) - q);
		if (n > z.avail_out)
			n = z.avail_out;
		if (n !== 0 && r == Z_BUF_ERROR$2)
			r = Z_OK$4;

		// update counters
		z.avail_out -= n;
		z.total_out += n;

		// copy as far as end of win
		z.next_out.set(that.win.subarray(q, q + n), p);
		p += n;
		q += n;

		// see if more to copy at beginning of win
		if (q == that.end) {
			// wrap pointers
			q = 0;
			if (that.write == that.end)
				that.write = 0;

			// compute bytes to copy
			n = that.write - q;
			if (n > z.avail_out)
				n = z.avail_out;
			if (n !== 0 && r == Z_BUF_ERROR$2)
				r = Z_OK$4;

			// update counters
			z.avail_out -= n;
			z.total_out += n;

			// copy
			z.next_out.set(that.win.subarray(q, q + n), p);
			p += n;
			q += n;
		}

		// update pointers
		z.next_out_index = p;
		that.read = q;

		// done
		return r;
	};

	that.proc = function (z, r) {
		let t; // temporary storage
		let b; // bit buffer
		let k; // bits in bit buffer
		let p; // input data pointer
		let n; // bytes available there
		let q; // output win write pointer
		let m; // bytes to end of win or read pointer

		let i;

		// copy input/output information to locals (UPDATE macro restores)
		// {
		p = z.next_in_index;
		n = z.avail_in;
		b = that.bitb;
		k = that.bitk;
		// }
		// {
		q = that.write;
		m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
		// }

		// process input based on current state
		// DEBUG dtree
		while (true) {
			let bl, bd, tl, td, bl_, bd_, tl_, td_;
			switch (mode) {
				case TYPE$2:

					while (k < (3)) {
						if (n !== 0) {
							r = Z_OK$4;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}
					t = /* (int) */(b & 7);
					last = t & 1;

					switch (t >>> 1) {
						case 0: // stored
							// {
							b >>>= (3);
							k -= (3);
							// }
							t = k & 7; // go to byte boundary

							// {
							b >>>= (t);
							k -= (t);
							// }
							mode = LENS$2; // get length of stored block
							break;
						case 1: // fixed
							// {
							bl = []; // new Array(1);
							bd = []; // new Array(1);
							tl = [[]]; // new Array(1);
							td = [[]]; // new Array(1);

							InfTree.inflate_trees_fixed(bl, bd, tl, td);
							codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
							// }

							// {
							b >>>= (3);
							k -= (3);
							// }

							mode = CODES$2;
							break;
						case 2: // dynamic

							// {
							b >>>= (3);
							k -= (3);
							// }

							mode = TABLE$1;
							break;
						case 3: // illegal

							// {
							b >>>= (3);
							k -= (3);
							// }
							mode = BADBLOCKS;
							z.msg = "invalid block type";
							r = Z_DATA_ERROR$3;

							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
					}
					break;
				case LENS$2:

					while (k < (32)) {
						if (n !== 0) {
							r = Z_OK$4;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {
						mode = BADBLOCKS;
						z.msg = "invalid stored block lengths";
						r = Z_DATA_ERROR$3;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					left = (b & 0xffff);
					b = k = 0; // dump bits
					mode = left !== 0 ? STORED$1 : (last !== 0 ? DRY : TYPE$2);
					break;
				case STORED$1:
					if (n === 0) {
						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}

					if (m === 0) {
						if (q == that.end && that.read !== 0) {
							q = 0;
							m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
						}
						if (m === 0) {
							that.write = q;
							r = that.inflate_flush(z, r);
							q = that.write;
							m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
							if (q == that.end && that.read !== 0) {
								q = 0;
								m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
							}
							if (m === 0) {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
						}
					}
					r = Z_OK$4;

					t = left;
					if (t > n)
						t = n;
					if (t > m)
						t = m;
					that.win.set(z.read_buf(p, t), q);
					p += t;
					n -= t;
					q += t;
					m -= t;
					if ((left -= t) !== 0)
						break;
					mode = last !== 0 ? DRY : TYPE$2;
					break;
				case TABLE$1:

					while (k < (14)) {
						if (n !== 0) {
							r = Z_OK$4;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}

						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					table = t = (b & 0x3fff);
					if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {
						mode = BADBLOCKS;
						z.msg = "too many length or distance symbols";
						r = Z_DATA_ERROR$3;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
					if (!blens || blens.length < t) {
						blens = []; // new Array(t);
					} else {
						for (i = 0; i < t; i++) {
							blens[i] = 0;
						}
					}

					// {
					b >>>= (14);
					k -= (14);
					// }

					index = 0;
					mode = BTREE;
				/* falls through */
				case BTREE:
					while (index < 4 + (table >>> 10)) {
						while (k < (3)) {
							if (n !== 0) {
								r = Z_OK$4;
							} else {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
							n--;
							b |= (z.read_byte(p++) & 0xff) << k;
							k += 8;
						}

						blens[border[index++]] = b & 7;

						// {
						b >>>= (3);
						k -= (3);
						// }
					}

					while (index < 19) {
						blens[border[index++]] = 0;
					}

					bb[0] = 7;
					t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);
					if (t != Z_OK$4) {
						r = t;
						if (r == Z_DATA_ERROR$3) {
							blens = null;
							mode = BADBLOCKS;
						}

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}

					index = 0;
					mode = DTREE;
				/* falls through */
				case DTREE:
					while (true) {
						t = table;
						if (index >= 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {
							break;
						}

						let j, c;

						t = bb[0];

						while (k < (t)) {
							if (n !== 0) {
								r = Z_OK$4;
							} else {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
							n--;
							b |= (z.read_byte(p++) & 0xff) << k;
							k += 8;
						}

						// if (tb[0] == -1) {
						// System.err.println("null...");
						// }

						t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];
						c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];

						if (c < 16) {
							b >>>= (t);
							k -= (t);
							blens[index++] = c;
						} else { // c == 16..18
							i = c == 18 ? 7 : c - 14;
							j = c == 18 ? 11 : 3;

							while (k < (t + i)) {
								if (n !== 0) {
									r = Z_OK$4;
								} else {
									that.bitb = b;
									that.bitk = k;
									z.avail_in = n;
									z.total_in += p - z.next_in_index;
									z.next_in_index = p;
									that.write = q;
									return that.inflate_flush(z, r);
								}
								n--;
								b |= (z.read_byte(p++) & 0xff) << k;
								k += 8;
							}

							b >>>= (t);
							k -= (t);

							j += (b & inflate_mask[i]);

							b >>>= (i);
							k -= (i);

							i = index;
							t = table;
							if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {
								blens = null;
								mode = BADBLOCKS;
								z.msg = "invalid bit length repeat";
								r = Z_DATA_ERROR$3;

								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}

							c = c == 16 ? blens[i - 1] : 0;
							do {
								blens[i++] = c;
							} while (--j !== 0);
							index = i;
						}
					}

					tb[0] = -1;
					// {
					bl_ = []; // new Array(1);
					bd_ = []; // new Array(1);
					tl_ = []; // new Array(1);
					td_ = []; // new Array(1);
					bl_[0] = 9; // must be <= 9 for lookahead assumptions
					bd_[0] = 6; // must be <= 9 for lookahead assumptions

					t = table;
					t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);

					if (t != Z_OK$4) {
						if (t == Z_DATA_ERROR$3) {
							blens = null;
							mode = BADBLOCKS;
						}
						r = t;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
					// }
					mode = CODES$2;
				/* falls through */
				case CODES$2:
					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;

					if ((r = codes.proc(that, z, r)) != Z_STREAM_END$4) {
						return that.inflate_flush(z, r);
					}
					r = Z_OK$4;
					codes.free(z);

					p = z.next_in_index;
					n = z.avail_in;
					b = that.bitb;
					k = that.bitk;
					q = that.write;
					m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);

					if (last === 0) {
						mode = TYPE$2;
						break;
					}
					mode = DRY;
				/* falls through */
				case DRY:
					that.write = q;
					r = that.inflate_flush(z, r);
					q = that.write;
					m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
					if (that.read != that.write) {
						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					mode = DONELOCKS;
				/* falls through */
				case DONELOCKS:
					r = Z_STREAM_END$4;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);
				case BADBLOCKS:
					r = Z_DATA_ERROR$3;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);

				default:
					r = Z_STREAM_ERROR$3;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);
			}
		}
	};

	that.free = function (z) {
		that.reset(z, null);
		that.win = null;
		hufts = null;
		// ZFREE(z, s);
	};

	that.set_dictionary = function (d, start, n) {
		that.win.set(d.subarray(start, start + n), 0);
		that.read = that.write = n;
	};

	// Returns true if inflate is currently at the end of a block generated
	// by Z_SYNC_FLUSH or Z_FULL_FLUSH.
	that.sync_point = function () {
		return mode == LENS$2 ? 1 : 0;
	};

}

// Inflate

// preset dictionary flag in zlib header
const PRESET_DICT$1 = 0x20;

const Z_DEFLATED$3 = 8;

const METHOD = 0; // waiting for method byte
const FLAG = 1; // waiting for flag byte
const DICT4 = 2; // four dictionary check bytes to go
const DICT3 = 3; // three dictionary check bytes to go
const DICT2 = 4; // two dictionary check bytes to go
const DICT1 = 5; // one dictionary check byte to go
const DICT0 = 6; // waiting for inflateSetDictionary
const BLOCKS = 7; // decompressing blocks
const DONE$1 = 12; // finished check, done
const BAD$2 = 13; // got an error--stay here

const mark = [0, 0, 0xff, 0xff];

function Inflate$2() {
	const that = this;

	that.mode = 0; // current inflate mode

	// mode dependent information
	that.method = 0; // if FLAGS, method byte

	// if CHECK, check values to compare
	that.was = [0]; // new Array(1); // computed check value
	that.need = 0; // stream check value

	// if BAD, inflateSync's marker bytes count
	that.marker = 0;

	// mode independent information
	that.wbits = 0; // log2(win size) (8..15, defaults to 15)

	// this.blocks; // current inflate_blocks state

	function inflateReset(z) {
		if (!z || !z.istate)
			return Z_STREAM_ERROR$3;

		z.total_in = z.total_out = 0;
		z.msg = null;
		z.istate.mode = BLOCKS;
		z.istate.blocks.reset(z, null);
		return Z_OK$4;
	}

	that.inflateEnd = function (z) {
		if (that.blocks)
			that.blocks.free(z);
		that.blocks = null;
		// ZFREE(z, z->state);
		return Z_OK$4;
	};

	that.inflateInit = function (z, w) {
		z.msg = null;
		that.blocks = null;

		// set win size
		if (w < 8 || w > 15) {
			that.inflateEnd(z);
			return Z_STREAM_ERROR$3;
		}
		that.wbits = w;

		z.istate.blocks = new InfBlocks(z, 1 << w);

		// reset state
		inflateReset(z);
		return Z_OK$4;
	};

	that.inflate = function (z, f) {
		let r;
		let b;

		if (!z || !z.istate || !z.next_in)
			return Z_STREAM_ERROR$3;
		const istate = z.istate;
		f = f == Z_FINISH$4 ? Z_BUF_ERROR$2 : Z_OK$4;
		r = Z_BUF_ERROR$2;
		while (true) {
			switch (istate.mode) {
				case METHOD:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					if (((istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED$3) {
						istate.mode = BAD$2;
						z.msg = "unknown compression method";
						istate.marker = 5; // can't try inflateSync
						break;
					}
					if ((istate.method >> 4) + 8 > istate.wbits) {
						istate.mode = BAD$2;
						z.msg = "invalid win size";
						istate.marker = 5; // can't try inflateSync
						break;
					}
					istate.mode = FLAG;
				/* falls through */
				case FLAG:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					b = (z.read_byte(z.next_in_index++)) & 0xff;

					if ((((istate.method << 8) + b) % 31) !== 0) {
						istate.mode = BAD$2;
						z.msg = "incorrect header check";
						istate.marker = 5; // can't try inflateSync
						break;
					}

					if ((b & PRESET_DICT$1) === 0) {
						istate.mode = BLOCKS;
						break;
					}
					istate.mode = DICT4;
				/* falls through */
				case DICT4:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;
					istate.mode = DICT3;
				/* falls through */
				case DICT3:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;
					istate.mode = DICT2;
				/* falls through */
				case DICT2:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;
					istate.mode = DICT1;
				/* falls through */
				case DICT1:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need += (z.read_byte(z.next_in_index++) & 0xff);
					istate.mode = DICT0;
					return Z_NEED_DICT$2;
				case DICT0:
					istate.mode = BAD$2;
					z.msg = "need dictionary";
					istate.marker = 0; // can try inflateSync
					return Z_STREAM_ERROR$3;
				case BLOCKS:

					r = istate.blocks.proc(z, r);
					if (r == Z_DATA_ERROR$3) {
						istate.mode = BAD$2;
						istate.marker = 0; // can try inflateSync
						break;
					}
					if (r == Z_OK$4) {
						r = f;
					}
					if (r != Z_STREAM_END$4) {
						return r;
					}
					r = f;
					istate.blocks.reset(z, istate.was);
					istate.mode = DONE$1;
				/* falls through */
				case DONE$1:
					z.avail_in = 0;
					return Z_STREAM_END$4;
				case BAD$2:
					return Z_DATA_ERROR$3;
				default:
					return Z_STREAM_ERROR$3;
			}
		}
	};

	that.inflateSetDictionary = function (z, dictionary, dictLength) {
		let index = 0, length = dictLength;
		if (!z || !z.istate || z.istate.mode != DICT0)
			return Z_STREAM_ERROR$3;
		const istate = z.istate;
		if (length >= (1 << istate.wbits)) {
			length = (1 << istate.wbits) - 1;
			index = dictLength - length;
		}
		istate.blocks.set_dictionary(dictionary, index, length);
		istate.mode = BLOCKS;
		return Z_OK$4;
	};

	that.inflateSync = function (z) {
		let n; // number of bytes to look at
		let p; // pointer to bytes
		let m; // number of marker bytes found in a row
		let r, w; // temporaries to save total_in and total_out

		// set up
		if (!z || !z.istate)
			return Z_STREAM_ERROR$3;
		const istate = z.istate;
		if (istate.mode != BAD$2) {
			istate.mode = BAD$2;
			istate.marker = 0;
		}
		if ((n = z.avail_in) === 0)
			return Z_BUF_ERROR$2;
		p = z.next_in_index;
		m = istate.marker;

		// search
		while (n !== 0 && m < 4) {
			if (z.read_byte(p) == mark[m]) {
				m++;
			} else if (z.read_byte(p) !== 0) {
				m = 0;
			} else {
				m = 4 - m;
			}
			p++;
			n--;
		}

		// restore
		z.total_in += p - z.next_in_index;
		z.next_in_index = p;
		z.avail_in = n;
		istate.marker = m;

		// return no joy or set up to restart on a new block
		if (m != 4) {
			return Z_DATA_ERROR$3;
		}
		r = z.total_in;
		w = z.total_out;
		inflateReset(z);
		z.total_in = r;
		z.total_out = w;
		istate.mode = BLOCKS;
		return Z_OK$4;
	};

	// Returns true if inflate is currently at the end of a block generated
	// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
	// implementation to provide an additional safety check. PPP uses
	// Z_SYNC_FLUSH
	// but removes the length bytes of the resulting empty stored block. When
	// decompressing, PPP checks that at the end of input packet, inflate is
	// waiting for these length bytes.
	that.inflateSyncPoint = function (z) {
		if (!z || !z.istate || !z.istate.blocks)
			return Z_STREAM_ERROR$3;
		return z.istate.blocks.sync_point();
	};
}

// ZStream

function ZStream$1() {
}

ZStream$1.prototype = {
	inflateInit(bits) {
		const that = this;
		that.istate = new Inflate$2();
		if (!bits)
			bits = MAX_BITS$2;
		return that.istate.inflateInit(that, bits);
	},

	inflate(f) {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR$3;
		return that.istate.inflate(that, f);
	},

	inflateEnd() {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR$3;
		const ret = that.istate.inflateEnd(that);
		that.istate = null;
		return ret;
	},

	inflateSync() {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR$3;
		return that.istate.inflateSync(that);
	},
	inflateSetDictionary(dictionary, dictLength) {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR$3;
		return that.istate.inflateSetDictionary(that, dictionary, dictLength);
	},
	read_byte(start) {
		const that = this;
		return that.next_in[start];
	},
	read_buf(start, size) {
		const that = this;
		return that.next_in.subarray(start, start + size);
	}
};

// Inflater

function ZipInflate(options) {
	const that = this;
	const z = new ZStream$1();
	const bufsize = options && options.chunkSize ? Math.floor(options.chunkSize * 2) : 128 * 1024;
	const flush = Z_NO_FLUSH$3;
	const buf = new Uint8Array(bufsize);
	let nomoreinput = false;

	z.inflateInit();
	z.next_out = buf;

	that.append = function (data, onprogress) {
		const buffers = [];
		let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
		if (data.length === 0)
			return;
		z.next_in_index = 0;
		z.next_in = data;
		z.avail_in = data.length;
		do {
			z.next_out_index = 0;
			z.avail_out = bufsize;
			if ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it
				z.next_in_index = 0;
				nomoreinput = true;
			}
			err = z.inflate(flush);
			if (nomoreinput && (err === Z_BUF_ERROR$2)) {
				if (z.avail_in !== 0)
					throw new Error("inflating: bad input");
			} else if (err !== Z_OK$4 && err !== Z_STREAM_END$4)
				throw new Error("inflating: " + z.msg);
			if ((nomoreinput || err === Z_STREAM_END$4) && (z.avail_in === data.length))
				throw new Error("inflating: bad input");
			if (z.next_out_index)
				if (z.next_out_index === bufsize)
					buffers.push(new Uint8Array(buf));
				else
					buffers.push(buf.subarray(0, z.next_out_index));
			bufferSize += z.next_out_index;
			if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
				onprogress(z.next_in_index);
				lastIndex = z.next_in_index;
			}
		} while (z.avail_in > 0 || z.avail_out === 0);
		if (buffers.length > 1) {
			array = new Uint8Array(bufferSize);
			buffers.forEach(function (chunk) {
				array.set(chunk, bufferIndex);
				bufferIndex += chunk.length;
			});
		} else {
			array = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
		}
		return array;
	};
	that.flush = function () {
		z.inflateEnd();
	};
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const MAX_32_BITS = 0xffffffff;
const MAX_16_BITS = 0xffff;
const COMPRESSION_METHOD_DEFLATE = 0x08;
const COMPRESSION_METHOD_STORE = 0x00;
const COMPRESSION_METHOD_AES = 0x63;

const LOCAL_FILE_HEADER_SIGNATURE = 0x04034b50;
const SPLIT_ZIP_FILE_SIGNATURE = 0x08074b50;
const DATA_DESCRIPTOR_RECORD_SIGNATURE = SPLIT_ZIP_FILE_SIGNATURE;
const CENTRAL_FILE_HEADER_SIGNATURE = 0x02014b50;
const END_OF_CENTRAL_DIR_SIGNATURE = 0x06054b50;
const ZIP64_END_OF_CENTRAL_DIR_SIGNATURE = 0x06064b50;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE = 0x07064b50;
const END_OF_CENTRAL_DIR_LENGTH = 22;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH = 20;
const ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;
const ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH = END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LENGTH;

const EXTRAFIELD_TYPE_ZIP64 = 0x0001;
const EXTRAFIELD_TYPE_AES = 0x9901;
const EXTRAFIELD_TYPE_NTFS = 0x000a;
const EXTRAFIELD_TYPE_NTFS_TAG1 = 0x0001;
const EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP = 0x5455;
const EXTRAFIELD_TYPE_UNICODE_PATH = 0x7075;
const EXTRAFIELD_TYPE_UNICODE_COMMENT = 0x6375;
const EXTRAFIELD_TYPE_USDZ = 0x1986;

const BITFLAG_ENCRYPTED = 0x01;
const BITFLAG_LEVEL = 0x06;
const BITFLAG_DATA_DESCRIPTOR = 0x0008;
const BITFLAG_LANG_ENCODING_FLAG = 0x0800;
const FILE_ATTR_MSDOS_DIR_MASK = 0x10;
const FILE_ATTR_UNIX_DIR_MASK =  0x4000;
const FILE_ATTR_UNIX_EXECUTABLE_MASK = 0o111;
const FILE_ATTR_UNIX_DEFAULT_MASK = 0o644;

const VERSION_DEFLATE = 0x14;
const VERSION_ZIP64 = 0x2D;
const VERSION_AES = 0x33;

const DIRECTORY_SIGNATURE = "/";

const MAX_DATE = new Date(2107, 11, 31);
const MIN_DATE = new Date(1980, 0, 1);

const UNDEFINED_VALUE = undefined;
const UNDEFINED_TYPE = "undefined";
const FUNCTION_TYPE = "function";

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


class StreamAdapter {

	constructor(Codec) {
		return class extends TransformStream {
			constructor(_format, options) {
				const codec = new Codec(options);
				super({
					transform(chunk, controller) {
						controller.enqueue(codec.append(chunk));
					},
					flush(controller) {
						const chunk = codec.flush();
						if (chunk) {
							controller.enqueue(chunk);
						}
					}
				});
			}
		};
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const MINIMUM_CHUNK_SIZE = 64;
let maxWorkers = 2;
try {
	if (typeof navigator != UNDEFINED_TYPE && navigator.hardwareConcurrency) {
		maxWorkers = navigator.hardwareConcurrency;
	}
	// eslint-disable-next-line no-unused-vars
} catch (_) {
	// ignored
}
const DEFAULT_CONFIGURATION = {
	chunkSize: 512 * 1024,
	maxWorkers,
	terminateWorkerTimeout: 5000,
	useWebWorkers: true,
	useCompressionStream: true,
	workerScripts: UNDEFINED_VALUE,
	CompressionStreamNative: typeof CompressionStream != UNDEFINED_TYPE && CompressionStream,
	DecompressionStreamNative: typeof DecompressionStream != UNDEFINED_TYPE && DecompressionStream
};

const config = Object.assign({}, DEFAULT_CONFIGURATION);

function getConfiguration() {
	return config;
}

function getChunkSize(config) {
	return Math.max(config.chunkSize, MINIMUM_CHUNK_SIZE);
}

function configure(configuration) {
	const {
		baseURL,
		chunkSize,
		maxWorkers,
		terminateWorkerTimeout,
		useCompressionStream,
		useWebWorkers,
		Deflate,
		Inflate,
		CompressionStream,
		DecompressionStream,
		workerScripts
	} = configuration;
	setIfDefined("baseURL", baseURL);
	setIfDefined("chunkSize", chunkSize);
	setIfDefined("maxWorkers", maxWorkers);
	setIfDefined("terminateWorkerTimeout", terminateWorkerTimeout);
	setIfDefined("useCompressionStream", useCompressionStream);
	setIfDefined("useWebWorkers", useWebWorkers);
	if (Deflate) {
		config.CompressionStream = new StreamAdapter(Deflate);
	}
	if (Inflate) {
		config.DecompressionStream = new StreamAdapter(Inflate);
	}
	setIfDefined("CompressionStream", CompressionStream);
	setIfDefined("DecompressionStream", DecompressionStream);
	if (workerScripts !== UNDEFINED_VALUE) {
		const { deflate, inflate } = workerScripts;
		if (deflate || inflate) {
			if (!config.workerScripts) {
				config.workerScripts = {};
			}
		}
		if (deflate) {
			if (!Array.isArray(deflate)) {
				throw new Error("workerScripts.deflate must be an array");
			}
			config.workerScripts.deflate = deflate;
		}
		if (inflate) {
			if (!Array.isArray(inflate)) {
				throw new Error("workerScripts.inflate must be an array");
			}
			config.workerScripts.inflate = inflate;
		}
	}
}

function setIfDefined(propertyName, propertyValue) {
	if (propertyValue !== UNDEFINED_VALUE) {
		config[propertyName] = propertyValue;
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const table$1 = {
	"application": {
		"andrew-inset": "ez",
		"annodex": "anx",
		"atom+xml": "atom",
		"atomcat+xml": "atomcat",
		"atomserv+xml": "atomsrv",
		"bbolin": "lin",
		"cu-seeme": "cu",
		"davmount+xml": "davmount",
		"dsptype": "tsp",
		"ecmascript": [
			"es",
			"ecma"
		],
		"futuresplash": "spl",
		"hta": "hta",
		"java-archive": "jar",
		"java-serialized-object": "ser",
		"java-vm": "class",
		"m3g": "m3g",
		"mac-binhex40": "hqx",
		"mathematica": [
			"nb",
			"ma",
			"mb"
		],
		"msaccess": "mdb",
		"msword": [
			"doc",
			"dot",
			"wiz"
		],
		"mxf": "mxf",
		"oda": "oda",
		"ogg": "ogx",
		"pdf": "pdf",
		"pgp-keys": "key",
		"pgp-signature": [
			"asc",
			"sig"
		],
		"pics-rules": "prf",
		"postscript": [
			"ps",
			"ai",
			"eps",
			"epsi",
			"epsf",
			"eps2",
			"eps3"
		],
		"rar": "rar",
		"rdf+xml": "rdf",
		"rss+xml": "rss",
		"rtf": "rtf",
		"xhtml+xml": [
			"xhtml",
			"xht"
		],
		"xml": [
			"xml",
			"xsl",
			"xsd",
			"xpdl"
		],
		"xspf+xml": "xspf",
		"zip": "zip",
		"vnd.android.package-archive": "apk",
		"vnd.cinderella": "cdy",
		"vnd.google-earth.kml+xml": "kml",
		"vnd.google-earth.kmz": "kmz",
		"vnd.mozilla.xul+xml": "xul",
		"vnd.ms-excel": [
			"xls",
			"xlb",
			"xlt",
			"xlm",
			"xla",
			"xlc",
			"xlw"
		],
		"vnd.ms-pki.seccat": "cat",
		"vnd.ms-pki.stl": "stl",
		"vnd.ms-powerpoint": [
			"ppt",
			"pps",
			"pot",
			"ppa",
			"pwz"
		],
		"vnd.oasis.opendocument.chart": "odc",
		"vnd.oasis.opendocument.database": "odb",
		"vnd.oasis.opendocument.formula": "odf",
		"vnd.oasis.opendocument.graphics": "odg",
		"vnd.oasis.opendocument.graphics-template": "otg",
		"vnd.oasis.opendocument.image": "odi",
		"vnd.oasis.opendocument.presentation": "odp",
		"vnd.oasis.opendocument.presentation-template": "otp",
		"vnd.oasis.opendocument.spreadsheet": "ods",
		"vnd.oasis.opendocument.spreadsheet-template": "ots",
		"vnd.oasis.opendocument.text": "odt",
		"vnd.oasis.opendocument.text-master": [
			"odm",
			"otm"
		],
		"vnd.oasis.opendocument.text-template": "ott",
		"vnd.oasis.opendocument.text-web": "oth",
		"vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
		"vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
		"vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
		"vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
		"vnd.openxmlformats-officedocument.presentationml.template": "potx",
		"vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
		"vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
		"vnd.smaf": "mmf",
		"vnd.stardivision.calc": "sdc",
		"vnd.stardivision.chart": "sds",
		"vnd.stardivision.draw": "sda",
		"vnd.stardivision.impress": "sdd",
		"vnd.stardivision.math": [
			"sdf",
			"smf"
		],
		"vnd.stardivision.writer": [
			"sdw",
			"vor"
		],
		"vnd.stardivision.writer-global": "sgl",
		"vnd.sun.xml.calc": "sxc",
		"vnd.sun.xml.calc.template": "stc",
		"vnd.sun.xml.draw": "sxd",
		"vnd.sun.xml.draw.template": "std",
		"vnd.sun.xml.impress": "sxi",
		"vnd.sun.xml.impress.template": "sti",
		"vnd.sun.xml.math": "sxm",
		"vnd.sun.xml.writer": "sxw",
		"vnd.sun.xml.writer.global": "sxg",
		"vnd.sun.xml.writer.template": "stw",
		"vnd.symbian.install": [
			"sis",
			"sisx"
		],
		"vnd.visio": [
			"vsd",
			"vst",
			"vss",
			"vsw",
			"vsdx",
			"vssx",
			"vstx",
			"vssm",
			"vstm"
		],
		"vnd.wap.wbxml": "wbxml",
		"vnd.wap.wmlc": "wmlc",
		"vnd.wap.wmlscriptc": "wmlsc",
		"vnd.wordperfect": "wpd",
		"vnd.wordperfect5.1": "wp5",
		"x-123": "wk",
		"x-7z-compressed": "7z",
		"x-abiword": "abw",
		"x-apple-diskimage": "dmg",
		"x-bcpio": "bcpio",
		"x-bittorrent": "torrent",
		"x-cbr": [
			"cbr",
			"cba",
			"cbt",
			"cb7"
		],
		"x-cbz": "cbz",
		"x-cdf": [
			"cdf",
			"cda"
		],
		"x-cdlink": "vcd",
		"x-chess-pgn": "pgn",
		"x-cpio": "cpio",
		"x-csh": "csh",
		"x-director": [
			"dir",
			"dxr",
			"cst",
			"cct",
			"cxt",
			"w3d",
			"fgd",
			"swa"
		],
		"x-dms": "dms",
		"x-doom": "wad",
		"x-dvi": "dvi",
		"x-httpd-eruby": "rhtml",
		"x-font": "pcf.Z",
		"x-freemind": "mm",
		"x-gnumeric": "gnumeric",
		"x-go-sgf": "sgf",
		"x-graphing-calculator": "gcf",
		"x-gtar": [
			"gtar",
			"taz"
		],
		"x-hdf": "hdf",
		"x-httpd-php": [
			"phtml",
			"pht",
			"php"
		],
		"x-httpd-php-source": "phps",
		"x-httpd-php3": "php3",
		"x-httpd-php3-preprocessed": "php3p",
		"x-httpd-php4": "php4",
		"x-httpd-php5": "php5",
		"x-ica": "ica",
		"x-info": "info",
		"x-internet-signup": [
			"ins",
			"isp"
		],
		"x-iphone": "iii",
		"x-iso9660-image": "iso",
		"x-java-jnlp-file": "jnlp",
		"x-jmol": "jmz",
		"x-killustrator": "kil",
		"x-latex": "latex",
		"x-lyx": "lyx",
		"x-lzx": "lzx",
		"x-maker": [
			"frm",
			"fb",
			"fbdoc"
		],
		"x-ms-wmd": "wmd",
		"x-msdos-program": [
			"com",
			"exe",
			"bat",
			"dll"
		],
		"x-netcdf": [
			"nc"
		],
		"x-ns-proxy-autoconfig": [
			"pac",
			"dat"
		],
		"x-nwc": "nwc",
		"x-object": "o",
		"x-oz-application": "oza",
		"x-pkcs7-certreqresp": "p7r",
		"x-python-code": [
			"pyc",
			"pyo"
		],
		"x-qgis": [
			"qgs",
			"shp",
			"shx"
		],
		"x-quicktimeplayer": "qtl",
		"x-redhat-package-manager": [
			"rpm",
			"rpa"
		],
		"x-ruby": "rb",
		"x-sh": "sh",
		"x-shar": "shar",
		"x-shockwave-flash": [
			"swf",
			"swfl"
		],
		"x-silverlight": "scr",
		"x-stuffit": "sit",
		"x-sv4cpio": "sv4cpio",
		"x-sv4crc": "sv4crc",
		"x-tar": "tar",
		"x-tex-gf": "gf",
		"x-tex-pk": "pk",
		"x-texinfo": [
			"texinfo",
			"texi"
		],
		"x-trash": [
			"~",
			"%",
			"bak",
			"old",
			"sik"
		],
		"x-ustar": "ustar",
		"x-wais-source": "src",
		"x-wingz": "wz",
		"x-x509-ca-cert": [
			"crt",
			"der",
			"cer"
		],
		"x-xcf": "xcf",
		"x-xfig": "fig",
		"x-xpinstall": "xpi",
		"applixware": "aw",
		"atomsvc+xml": "atomsvc",
		"ccxml+xml": "ccxml",
		"cdmi-capability": "cdmia",
		"cdmi-container": "cdmic",
		"cdmi-domain": "cdmid",
		"cdmi-object": "cdmio",
		"cdmi-queue": "cdmiq",
		"docbook+xml": "dbk",
		"dssc+der": "dssc",
		"dssc+xml": "xdssc",
		"emma+xml": "emma",
		"epub+zip": "epub",
		"exi": "exi",
		"font-tdpfr": "pfr",
		"gml+xml": "gml",
		"gpx+xml": "gpx",
		"gxf": "gxf",
		"hyperstudio": "stk",
		"inkml+xml": [
			"ink",
			"inkml"
		],
		"ipfix": "ipfix",
		"jsonml+json": "jsonml",
		"lost+xml": "lostxml",
		"mads+xml": "mads",
		"marc": "mrc",
		"marcxml+xml": "mrcx",
		"mathml+xml": [
			"mathml",
			"mml"
		],
		"mbox": "mbox",
		"mediaservercontrol+xml": "mscml",
		"metalink+xml": "metalink",
		"metalink4+xml": "meta4",
		"mets+xml": "mets",
		"mods+xml": "mods",
		"mp21": [
			"m21",
			"mp21"
		],
		"mp4": "mp4s",
		"oebps-package+xml": "opf",
		"omdoc+xml": "omdoc",
		"onenote": [
			"onetoc",
			"onetoc2",
			"onetmp",
			"onepkg"
		],
		"oxps": "oxps",
		"patch-ops-error+xml": "xer",
		"pgp-encrypted": "pgp",
		"pkcs10": "p10",
		"pkcs7-mime": [
			"p7m",
			"p7c"
		],
		"pkcs7-signature": "p7s",
		"pkcs8": "p8",
		"pkix-attr-cert": "ac",
		"pkix-crl": "crl",
		"pkix-pkipath": "pkipath",
		"pkixcmp": "pki",
		"pls+xml": "pls",
		"prs.cww": "cww",
		"pskc+xml": "pskcxml",
		"reginfo+xml": "rif",
		"relax-ng-compact-syntax": "rnc",
		"resource-lists+xml": "rl",
		"resource-lists-diff+xml": "rld",
		"rls-services+xml": "rs",
		"rpki-ghostbusters": "gbr",
		"rpki-manifest": "mft",
		"rpki-roa": "roa",
		"rsd+xml": "rsd",
		"sbml+xml": "sbml",
		"scvp-cv-request": "scq",
		"scvp-cv-response": "scs",
		"scvp-vp-request": "spq",
		"scvp-vp-response": "spp",
		"sdp": "sdp",
		"set-payment-initiation": "setpay",
		"set-registration-initiation": "setreg",
		"shf+xml": "shf",
		"sparql-query": "rq",
		"sparql-results+xml": "srx",
		"srgs": "gram",
		"srgs+xml": "grxml",
		"sru+xml": "sru",
		"ssdl+xml": "ssdl",
		"ssml+xml": "ssml",
		"tei+xml": [
			"tei",
			"teicorpus"
		],
		"thraud+xml": "tfi",
		"timestamped-data": "tsd",
		"vnd.3gpp.pic-bw-large": "plb",
		"vnd.3gpp.pic-bw-small": "psb",
		"vnd.3gpp.pic-bw-var": "pvb",
		"vnd.3gpp2.tcap": "tcap",
		"vnd.3m.post-it-notes": "pwn",
		"vnd.accpac.simply.aso": "aso",
		"vnd.accpac.simply.imp": "imp",
		"vnd.acucobol": "acu",
		"vnd.acucorp": [
			"atc",
			"acutc"
		],
		"vnd.adobe.air-application-installer-package+zip": "air",
		"vnd.adobe.formscentral.fcdt": "fcdt",
		"vnd.adobe.fxp": [
			"fxp",
			"fxpl"
		],
		"vnd.adobe.xdp+xml": "xdp",
		"vnd.adobe.xfdf": "xfdf",
		"vnd.ahead.space": "ahead",
		"vnd.airzip.filesecure.azf": "azf",
		"vnd.airzip.filesecure.azs": "azs",
		"vnd.amazon.ebook": "azw",
		"vnd.americandynamics.acc": "acc",
		"vnd.amiga.ami": "ami",
		"vnd.anser-web-certificate-issue-initiation": "cii",
		"vnd.anser-web-funds-transfer-initiation": "fti",
		"vnd.antix.game-component": "atx",
		"vnd.apple.installer+xml": "mpkg",
		"vnd.apple.mpegurl": "m3u8",
		"vnd.aristanetworks.swi": "swi",
		"vnd.astraea-software.iota": "iota",
		"vnd.audiograph": "aep",
		"vnd.blueice.multipass": "mpm",
		"vnd.bmi": "bmi",
		"vnd.businessobjects": "rep",
		"vnd.chemdraw+xml": "cdxml",
		"vnd.chipnuts.karaoke-mmd": "mmd",
		"vnd.claymore": "cla",
		"vnd.cloanto.rp9": "rp9",
		"vnd.clonk.c4group": [
			"c4g",
			"c4d",
			"c4f",
			"c4p",
			"c4u"
		],
		"vnd.cluetrust.cartomobile-config": "c11amc",
		"vnd.cluetrust.cartomobile-config-pkg": "c11amz",
		"vnd.commonspace": "csp",
		"vnd.contact.cmsg": "cdbcmsg",
		"vnd.cosmocaller": "cmc",
		"vnd.crick.clicker": "clkx",
		"vnd.crick.clicker.keyboard": "clkk",
		"vnd.crick.clicker.palette": "clkp",
		"vnd.crick.clicker.template": "clkt",
		"vnd.crick.clicker.wordbank": "clkw",
		"vnd.criticaltools.wbs+xml": "wbs",
		"vnd.ctc-posml": "pml",
		"vnd.cups-ppd": "ppd",
		"vnd.curl.car": "car",
		"vnd.curl.pcurl": "pcurl",
		"vnd.dart": "dart",
		"vnd.data-vision.rdz": "rdz",
		"vnd.dece.data": [
			"uvf",
			"uvvf",
			"uvd",
			"uvvd"
		],
		"vnd.dece.ttml+xml": [
			"uvt",
			"uvvt"
		],
		"vnd.dece.unspecified": [
			"uvx",
			"uvvx"
		],
		"vnd.dece.zip": [
			"uvz",
			"uvvz"
		],
		"vnd.denovo.fcselayout-link": "fe_launch",
		"vnd.dna": "dna",
		"vnd.dolby.mlp": "mlp",
		"vnd.dpgraph": "dpg",
		"vnd.dreamfactory": "dfac",
		"vnd.ds-keypoint": "kpxx",
		"vnd.dvb.ait": "ait",
		"vnd.dvb.service": "svc",
		"vnd.dynageo": "geo",
		"vnd.ecowin.chart": "mag",
		"vnd.enliven": "nml",
		"vnd.epson.esf": "esf",
		"vnd.epson.msf": "msf",
		"vnd.epson.quickanime": "qam",
		"vnd.epson.salt": "slt",
		"vnd.epson.ssf": "ssf",
		"vnd.eszigno3+xml": [
			"es3",
			"et3"
		],
		"vnd.ezpix-album": "ez2",
		"vnd.ezpix-package": "ez3",
		"vnd.fdf": "fdf",
		"vnd.fdsn.mseed": "mseed",
		"vnd.fdsn.seed": [
			"seed",
			"dataless"
		],
		"vnd.flographit": "gph",
		"vnd.fluxtime.clip": "ftc",
		"vnd.framemaker": [
			"fm",
			"frame",
			"maker",
			"book"
		],
		"vnd.frogans.fnc": "fnc",
		"vnd.frogans.ltf": "ltf",
		"vnd.fsc.weblaunch": "fsc",
		"vnd.fujitsu.oasys": "oas",
		"vnd.fujitsu.oasys2": "oa2",
		"vnd.fujitsu.oasys3": "oa3",
		"vnd.fujitsu.oasysgp": "fg5",
		"vnd.fujitsu.oasysprs": "bh2",
		"vnd.fujixerox.ddd": "ddd",
		"vnd.fujixerox.docuworks": "xdw",
		"vnd.fujixerox.docuworks.binder": "xbd",
		"vnd.fuzzysheet": "fzs",
		"vnd.genomatix.tuxedo": "txd",
		"vnd.geogebra.file": "ggb",
		"vnd.geogebra.tool": "ggt",
		"vnd.geometry-explorer": [
			"gex",
			"gre"
		],
		"vnd.geonext": "gxt",
		"vnd.geoplan": "g2w",
		"vnd.geospace": "g3w",
		"vnd.gmx": "gmx",
		"vnd.grafeq": [
			"gqf",
			"gqs"
		],
		"vnd.groove-account": "gac",
		"vnd.groove-help": "ghf",
		"vnd.groove-identity-message": "gim",
		"vnd.groove-injector": "grv",
		"vnd.groove-tool-message": "gtm",
		"vnd.groove-tool-template": "tpl",
		"vnd.groove-vcard": "vcg",
		"vnd.hal+xml": "hal",
		"vnd.handheld-entertainment+xml": "zmm",
		"vnd.hbci": "hbci",
		"vnd.hhe.lesson-player": "les",
		"vnd.hp-hpgl": "hpgl",
		"vnd.hp-hpid": "hpid",
		"vnd.hp-hps": "hps",
		"vnd.hp-jlyt": "jlt",
		"vnd.hp-pcl": "pcl",
		"vnd.hp-pclxl": "pclxl",
		"vnd.hydrostatix.sof-data": "sfd-hdstx",
		"vnd.ibm.minipay": "mpy",
		"vnd.ibm.modcap": [
			"afp",
			"listafp",
			"list3820"
		],
		"vnd.ibm.rights-management": "irm",
		"vnd.ibm.secure-container": "sc",
		"vnd.iccprofile": [
			"icc",
			"icm"
		],
		"vnd.igloader": "igl",
		"vnd.immervision-ivp": "ivp",
		"vnd.immervision-ivu": "ivu",
		"vnd.insors.igm": "igm",
		"vnd.intercon.formnet": [
			"xpw",
			"xpx"
		],
		"vnd.intergeo": "i2g",
		"vnd.intu.qbo": "qbo",
		"vnd.intu.qfx": "qfx",
		"vnd.ipunplugged.rcprofile": "rcprofile",
		"vnd.irepository.package+xml": "irp",
		"vnd.is-xpr": "xpr",
		"vnd.isac.fcs": "fcs",
		"vnd.jam": "jam",
		"vnd.jcp.javame.midlet-rms": "rms",
		"vnd.jisp": "jisp",
		"vnd.joost.joda-archive": "joda",
		"vnd.kahootz": [
			"ktz",
			"ktr"
		],
		"vnd.kde.karbon": "karbon",
		"vnd.kde.kchart": "chrt",
		"vnd.kde.kformula": "kfo",
		"vnd.kde.kivio": "flw",
		"vnd.kde.kontour": "kon",
		"vnd.kde.kpresenter": [
			"kpr",
			"kpt"
		],
		"vnd.kde.kspread": "ksp",
		"vnd.kde.kword": [
			"kwd",
			"kwt"
		],
		"vnd.kenameaapp": "htke",
		"vnd.kidspiration": "kia",
		"vnd.kinar": [
			"kne",
			"knp"
		],
		"vnd.koan": [
			"skp",
			"skd",
			"skt",
			"skm"
		],
		"vnd.kodak-descriptor": "sse",
		"vnd.las.las+xml": "lasxml",
		"vnd.llamagraphics.life-balance.desktop": "lbd",
		"vnd.llamagraphics.life-balance.exchange+xml": "lbe",
		"vnd.lotus-1-2-3": "123",
		"vnd.lotus-approach": "apr",
		"vnd.lotus-freelance": "pre",
		"vnd.lotus-notes": "nsf",
		"vnd.lotus-organizer": "org",
		"vnd.lotus-screencam": "scm",
		"vnd.lotus-wordpro": "lwp",
		"vnd.macports.portpkg": "portpkg",
		"vnd.mcd": "mcd",
		"vnd.medcalcdata": "mc1",
		"vnd.mediastation.cdkey": "cdkey",
		"vnd.mfer": "mwf",
		"vnd.mfmp": "mfm",
		"vnd.micrografx.flo": "flo",
		"vnd.micrografx.igx": "igx",
		"vnd.mif": "mif",
		"vnd.mobius.daf": "daf",
		"vnd.mobius.dis": "dis",
		"vnd.mobius.mbk": "mbk",
		"vnd.mobius.mqy": "mqy",
		"vnd.mobius.msl": "msl",
		"vnd.mobius.plc": "plc",
		"vnd.mobius.txf": "txf",
		"vnd.mophun.application": "mpn",
		"vnd.mophun.certificate": "mpc",
		"vnd.ms-artgalry": "cil",
		"vnd.ms-cab-compressed": "cab",
		"vnd.ms-excel.addin.macroenabled.12": "xlam",
		"vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
		"vnd.ms-excel.sheet.macroenabled.12": "xlsm",
		"vnd.ms-excel.template.macroenabled.12": "xltm",
		"vnd.ms-fontobject": "eot",
		"vnd.ms-htmlhelp": "chm",
		"vnd.ms-ims": "ims",
		"vnd.ms-lrm": "lrm",
		"vnd.ms-officetheme": "thmx",
		"vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
		"vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
		"vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
		"vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
		"vnd.ms-powerpoint.template.macroenabled.12": "potm",
		"vnd.ms-project": [
			"mpp",
			"mpt"
		],
		"vnd.ms-word.document.macroenabled.12": "docm",
		"vnd.ms-word.template.macroenabled.12": "dotm",
		"vnd.ms-works": [
			"wps",
			"wks",
			"wcm",
			"wdb"
		],
		"vnd.ms-wpl": "wpl",
		"vnd.ms-xpsdocument": "xps",
		"vnd.mseq": "mseq",
		"vnd.musician": "mus",
		"vnd.muvee.style": "msty",
		"vnd.mynfc": "taglet",
		"vnd.neurolanguage.nlu": "nlu",
		"vnd.nitf": [
			"ntf",
			"nitf"
		],
		"vnd.noblenet-directory": "nnd",
		"vnd.noblenet-sealer": "nns",
		"vnd.noblenet-web": "nnw",
		"vnd.nokia.n-gage.data": "ngdat",
		"vnd.nokia.n-gage.symbian.install": "n-gage",
		"vnd.nokia.radio-preset": "rpst",
		"vnd.nokia.radio-presets": "rpss",
		"vnd.novadigm.edm": "edm",
		"vnd.novadigm.edx": "edx",
		"vnd.novadigm.ext": "ext",
		"vnd.oasis.opendocument.chart-template": "otc",
		"vnd.oasis.opendocument.formula-template": "odft",
		"vnd.oasis.opendocument.image-template": "oti",
		"vnd.olpc-sugar": "xo",
		"vnd.oma.dd2+xml": "dd2",
		"vnd.openofficeorg.extension": "oxt",
		"vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
		"vnd.osgeo.mapguide.package": "mgp",
		"vnd.osgi.dp": "dp",
		"vnd.osgi.subsystem": "esa",
		"vnd.palm": [
			"pdb",
			"pqa",
			"oprc"
		],
		"vnd.pawaafile": "paw",
		"vnd.pg.format": "str",
		"vnd.pg.osasli": "ei6",
		"vnd.picsel": "efif",
		"vnd.pmi.widget": "wg",
		"vnd.pocketlearn": "plf",
		"vnd.powerbuilder6": "pbd",
		"vnd.previewsystems.box": "box",
		"vnd.proteus.magazine": "mgz",
		"vnd.publishare-delta-tree": "qps",
		"vnd.pvi.ptid1": "ptid",
		"vnd.quark.quarkxpress": [
			"qxd",
			"qxt",
			"qwd",
			"qwt",
			"qxl",
			"qxb"
		],
		"vnd.realvnc.bed": "bed",
		"vnd.recordare.musicxml": "mxl",
		"vnd.recordare.musicxml+xml": "musicxml",
		"vnd.rig.cryptonote": "cryptonote",
		"vnd.rn-realmedia": "rm",
		"vnd.rn-realmedia-vbr": "rmvb",
		"vnd.route66.link66+xml": "link66",
		"vnd.sailingtracker.track": "st",
		"vnd.seemail": "see",
		"vnd.sema": "sema",
		"vnd.semd": "semd",
		"vnd.semf": "semf",
		"vnd.shana.informed.formdata": "ifm",
		"vnd.shana.informed.formtemplate": "itp",
		"vnd.shana.informed.interchange": "iif",
		"vnd.shana.informed.package": "ipk",
		"vnd.simtech-mindmapper": [
			"twd",
			"twds"
		],
		"vnd.smart.teacher": "teacher",
		"vnd.solent.sdkm+xml": [
			"sdkm",
			"sdkd"
		],
		"vnd.spotfire.dxp": "dxp",
		"vnd.spotfire.sfs": "sfs",
		"vnd.stepmania.package": "smzip",
		"vnd.stepmania.stepchart": "sm",
		"vnd.sus-calendar": [
			"sus",
			"susp"
		],
		"vnd.svd": "svd",
		"vnd.syncml+xml": "xsm",
		"vnd.syncml.dm+wbxml": "bdm",
		"vnd.syncml.dm+xml": "xdm",
		"vnd.tao.intent-module-archive": "tao",
		"vnd.tcpdump.pcap": [
			"pcap",
			"cap",
			"dmp"
		],
		"vnd.tmobile-livetv": "tmo",
		"vnd.trid.tpt": "tpt",
		"vnd.triscape.mxs": "mxs",
		"vnd.trueapp": "tra",
		"vnd.ufdl": [
			"ufd",
			"ufdl"
		],
		"vnd.uiq.theme": "utz",
		"vnd.umajin": "umj",
		"vnd.unity": "unityweb",
		"vnd.uoml+xml": "uoml",
		"vnd.vcx": "vcx",
		"vnd.visionary": "vis",
		"vnd.vsf": "vsf",
		"vnd.webturbo": "wtb",
		"vnd.wolfram.player": "nbp",
		"vnd.wqd": "wqd",
		"vnd.wt.stf": "stf",
		"vnd.xara": "xar",
		"vnd.xfdl": "xfdl",
		"vnd.yamaha.hv-dic": "hvd",
		"vnd.yamaha.hv-script": "hvs",
		"vnd.yamaha.hv-voice": "hvp",
		"vnd.yamaha.openscoreformat": "osf",
		"vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
		"vnd.yamaha.smaf-audio": "saf",
		"vnd.yamaha.smaf-phrase": "spf",
		"vnd.yellowriver-custom-menu": "cmp",
		"vnd.zul": [
			"zir",
			"zirz"
		],
		"vnd.zzazz.deck+xml": "zaz",
		"voicexml+xml": "vxml",
		"widget": "wgt",
		"winhlp": "hlp",
		"wsdl+xml": "wsdl",
		"wspolicy+xml": "wspolicy",
		"x-ace-compressed": "ace",
		"x-authorware-bin": [
			"aab",
			"x32",
			"u32",
			"vox"
		],
		"x-authorware-map": "aam",
		"x-authorware-seg": "aas",
		"x-blorb": [
			"blb",
			"blorb"
		],
		"x-bzip": "bz",
		"x-bzip2": [
			"bz2",
			"boz"
		],
		"x-cfs-compressed": "cfs",
		"x-chat": "chat",
		"x-conference": "nsc",
		"x-dgc-compressed": "dgc",
		"x-dtbncx+xml": "ncx",
		"x-dtbook+xml": "dtb",
		"x-dtbresource+xml": "res",
		"x-eva": "eva",
		"x-font-bdf": "bdf",
		"x-font-ghostscript": "gsf",
		"x-font-linux-psf": "psf",
		"x-font-pcf": "pcf",
		"x-font-snf": "snf",
		"x-font-ttf": [
			"ttf",
			"ttc"
		],
		"x-font-type1": [
			"pfa",
			"pfb",
			"pfm",
			"afm"
		],
		"x-freearc": "arc",
		"x-gca-compressed": "gca",
		"x-glulx": "ulx",
		"x-gramps-xml": "gramps",
		"x-install-instructions": "install",
		"x-lzh-compressed": [
			"lzh",
			"lha"
		],
		"x-mie": "mie",
		"x-mobipocket-ebook": [
			"prc",
			"mobi"
		],
		"x-ms-application": "application",
		"x-ms-shortcut": "lnk",
		"x-ms-xbap": "xbap",
		"x-msbinder": "obd",
		"x-mscardfile": "crd",
		"x-msclip": "clp",
		"application/x-ms-installer": "msi",
		"x-msmediaview": [
			"mvb",
			"m13",
			"m14"
		],
		"x-msmetafile": [
			"wmf",
			"wmz",
			"emf",
			"emz"
		],
		"x-msmoney": "mny",
		"x-mspublisher": "pub",
		"x-msschedule": "scd",
		"x-msterminal": "trm",
		"x-mswrite": "wri",
		"x-nzb": "nzb",
		"x-pkcs12": [
			"p12",
			"pfx"
		],
		"x-pkcs7-certificates": [
			"p7b",
			"spc"
		],
		"x-research-info-systems": "ris",
		"x-silverlight-app": "xap",
		"x-sql": "sql",
		"x-stuffitx": "sitx",
		"x-subrip": "srt",
		"x-t3vm-image": "t3",
		"x-tex-tfm": "tfm",
		"x-tgif": "obj",
		"x-xliff+xml": "xlf",
		"x-xz": "xz",
		"x-zmachine": [
			"z1",
			"z2",
			"z3",
			"z4",
			"z5",
			"z6",
			"z7",
			"z8"
		],
		"xaml+xml": "xaml",
		"xcap-diff+xml": "xdf",
		"xenc+xml": "xenc",
		"xml-dtd": "dtd",
		"xop+xml": "xop",
		"xproc+xml": "xpl",
		"xslt+xml": "xslt",
		"xv+xml": [
			"mxml",
			"xhvml",
			"xvml",
			"xvm"
		],
		"yang": "yang",
		"yin+xml": "yin",
		"envoy": "evy",
		"fractals": "fif",
		"internet-property-stream": "acx",
		"olescript": "axs",
		"vnd.ms-outlook": "msg",
		"vnd.ms-pkicertstore": "sst",
		"x-compress": "z",
		"x-perfmon": [
			"pma",
			"pmc",
			"pmr",
			"pmw"
		],
		"ynd.ms-pkipko": "pko",
		"gzip": [
			"gz",
			"tgz"
		],
		"smil+xml": [
			"smi",
			"smil"
		],
		"vnd.debian.binary-package": [
			"deb",
			"udeb"
		],
		"vnd.hzn-3d-crossword": "x3d",
		"vnd.sqlite3": [
			"db",
			"sqlite",
			"sqlite3",
			"db-wal",
			"sqlite-wal",
			"db-shm",
			"sqlite-shm"
		],
		"vnd.wap.sic": "sic",
		"vnd.wap.slc": "slc",
		"x-krita": [
			"kra",
			"krz"
		],
		"x-perl": [
			"pm",
			"pl"
		],
		"yaml": [
			"yaml",
			"yml"
		]
	},
	"audio": {
		"amr": "amr",
		"amr-wb": "awb",
		"annodex": "axa",
		"basic": [
			"au",
			"snd"
		],
		"flac": "flac",
		"midi": [
			"mid",
			"midi",
			"kar",
			"rmi"
		],
		"mpeg": [
			"mpga",
			"mpega",
			"mp3",
			"m4a",
			"mp2a",
			"m2a",
			"m3a"
		],
		"mpegurl": "m3u",
		"ogg": [
			"oga",
			"ogg",
			"spx"
		],
		"prs.sid": "sid",
		"x-aiff": "aifc",
		"x-gsm": "gsm",
		"x-ms-wma": "wma",
		"x-ms-wax": "wax",
		"x-pn-realaudio": "ram",
		"x-realaudio": "ra",
		"x-sd2": "sd2",
		"adpcm": "adp",
		"mp4": "mp4a",
		"s3m": "s3m",
		"silk": "sil",
		"vnd.dece.audio": [
			"uva",
			"uvva"
		],
		"vnd.digital-winds": "eol",
		"vnd.dra": "dra",
		"vnd.dts": "dts",
		"vnd.dts.hd": "dtshd",
		"vnd.lucent.voice": "lvp",
		"vnd.ms-playready.media.pya": "pya",
		"vnd.nuera.ecelp4800": "ecelp4800",
		"vnd.nuera.ecelp7470": "ecelp7470",
		"vnd.nuera.ecelp9600": "ecelp9600",
		"vnd.rip": "rip",
		"webm": "weba",
		"x-caf": "caf",
		"x-matroska": "mka",
		"x-pn-realaudio-plugin": "rmp",
		"xm": "xm",
		"aac": "aac",
		"aiff": [
			"aiff",
			"aif",
			"aff"
		],
		"opus": "opus",
		"wav": "wav"
	},
	"chemical": {
		"x-alchemy": "alc",
		"x-cache": [
			"cac",
			"cache"
		],
		"x-cache-csf": "csf",
		"x-cactvs-binary": [
			"cbin",
			"cascii",
			"ctab"
		],
		"x-cdx": "cdx",
		"x-chem3d": "c3d",
		"x-cif": "cif",
		"x-cmdf": "cmdf",
		"x-cml": "cml",
		"x-compass": "cpa",
		"x-crossfire": "bsd",
		"x-csml": [
			"csml",
			"csm"
		],
		"x-ctx": "ctx",
		"x-cxf": [
			"cxf",
			"cef"
		],
		"x-embl-dl-nucleotide": [
			"emb",
			"embl"
		],
		"x-gamess-input": [
			"inp",
			"gam",
			"gamin"
		],
		"x-gaussian-checkpoint": [
			"fch",
			"fchk"
		],
		"x-gaussian-cube": "cub",
		"x-gaussian-input": [
			"gau",
			"gjc",
			"gjf"
		],
		"x-gaussian-log": "gal",
		"x-gcg8-sequence": "gcg",
		"x-genbank": "gen",
		"x-hin": "hin",
		"x-isostar": [
			"istr",
			"ist"
		],
		"x-jcamp-dx": [
			"jdx",
			"dx"
		],
		"x-kinemage": "kin",
		"x-macmolecule": "mcm",
		"x-macromodel-input": "mmod",
		"x-mdl-molfile": "mol",
		"x-mdl-rdfile": "rd",
		"x-mdl-rxnfile": "rxn",
		"x-mdl-sdfile": "sd",
		"x-mdl-tgf": "tgf",
		"x-mmcif": "mcif",
		"x-mol2": "mol2",
		"x-molconn-Z": "b",
		"x-mopac-graph": "gpt",
		"x-mopac-input": [
			"mop",
			"mopcrt",
			"zmt"
		],
		"x-mopac-out": "moo",
		"x-ncbi-asn1": "asn",
		"x-ncbi-asn1-ascii": [
			"prt",
			"ent"
		],
		"x-ncbi-asn1-binary": "val",
		"x-rosdal": "ros",
		"x-swissprot": "sw",
		"x-vamas-iso14976": "vms",
		"x-vmd": "vmd",
		"x-xtel": "xtel",
		"x-xyz": "xyz"
	},
	"font": {
		"otf": "otf",
		"woff": "woff",
		"woff2": "woff2"
	},
	"image": {
		"gif": "gif",
		"ief": "ief",
		"jpeg": [
			"jpeg",
			"jpg",
			"jpe",
			"jfif",
			"jfif-tbnl",
			"jif"
		],
		"pcx": "pcx",
		"png": "png",
		"svg+xml": [
			"svg",
			"svgz"
		],
		"tiff": [
			"tiff",
			"tif"
		],
		"vnd.djvu": [
			"djvu",
			"djv"
		],
		"vnd.wap.wbmp": "wbmp",
		"x-canon-cr2": "cr2",
		"x-canon-crw": "crw",
		"x-cmu-raster": "ras",
		"x-coreldraw": "cdr",
		"x-coreldrawpattern": "pat",
		"x-coreldrawtemplate": "cdt",
		"x-corelphotopaint": "cpt",
		"x-epson-erf": "erf",
		"x-icon": "ico",
		"x-jg": "art",
		"x-jng": "jng",
		"x-nikon-nef": "nef",
		"x-olympus-orf": "orf",
		"x-portable-anymap": "pnm",
		"x-portable-bitmap": "pbm",
		"x-portable-graymap": "pgm",
		"x-portable-pixmap": "ppm",
		"x-rgb": "rgb",
		"x-xbitmap": "xbm",
		"x-xpixmap": "xpm",
		"x-xwindowdump": "xwd",
		"bmp": "bmp",
		"cgm": "cgm",
		"g3fax": "g3",
		"ktx": "ktx",
		"prs.btif": "btif",
		"sgi": "sgi",
		"vnd.dece.graphic": [
			"uvi",
			"uvvi",
			"uvg",
			"uvvg"
		],
		"vnd.dwg": "dwg",
		"vnd.dxf": "dxf",
		"vnd.fastbidsheet": "fbs",
		"vnd.fpx": "fpx",
		"vnd.fst": "fst",
		"vnd.fujixerox.edmics-mmr": "mmr",
		"vnd.fujixerox.edmics-rlc": "rlc",
		"vnd.ms-modi": "mdi",
		"vnd.ms-photo": "wdp",
		"vnd.net-fpx": "npx",
		"vnd.xiff": "xif",
		"webp": "webp",
		"x-3ds": "3ds",
		"x-cmx": "cmx",
		"x-freehand": [
			"fh",
			"fhc",
			"fh4",
			"fh5",
			"fh7"
		],
		"x-pict": [
			"pic",
			"pct"
		],
		"x-tga": "tga",
		"cis-cod": "cod",
		"avif": "avifs",
		"heic": [
			"heif",
			"heic"
		],
		"pjpeg": [
			"pjpg"
		],
		"vnd.adobe.photoshop": "psd",
		"x-adobe-dng": "dng",
		"x-fuji-raf": "raf",
		"x-icns": "icns",
		"x-kodak-dcr": "dcr",
		"x-kodak-k25": "k25",
		"x-kodak-kdc": "kdc",
		"x-minolta-mrw": "mrw",
		"x-panasonic-raw": [
			"raw",
			"rw2",
			"rwl"
		],
		"x-pentax-pef": [
			"pef",
			"ptx"
		],
		"x-sigma-x3f": "x3f",
		"x-sony-arw": "arw",
		"x-sony-sr2": "sr2",
		"x-sony-srf": "srf"
	},
	"message": {
		"rfc822": [
			"eml",
			"mime",
			"mht",
			"mhtml",
			"nws"
		]
	},
	"model": {
		"iges": [
			"igs",
			"iges"
		],
		"mesh": [
			"msh",
			"mesh",
			"silo"
		],
		"vrml": [
			"wrl",
			"vrml"
		],
		"x3d+vrml": [
			"x3dv",
			"x3dvz"
		],
		"x3d+xml": "x3dz",
		"x3d+binary": [
			"x3db",
			"x3dbz"
		],
		"vnd.collada+xml": "dae",
		"vnd.dwf": "dwf",
		"vnd.gdl": "gdl",
		"vnd.gtw": "gtw",
		"vnd.mts": "mts",
		"vnd.usdz+zip": "usdz",
		"vnd.vtu": "vtu"
	},
	"text": {
		"cache-manifest": [
			"manifest",
			"appcache"
		],
		"calendar": [
			"ics",
			"icz",
			"ifb"
		],
		"css": "css",
		"csv": "csv",
		"h323": "323",
		"html": [
			"html",
			"htm",
			"shtml",
			"stm"
		],
		"iuls": "uls",
		"plain": [
			"txt",
			"text",
			"brf",
			"conf",
			"def",
			"list",
			"log",
			"in",
			"bas",
			"diff",
			"ksh"
		],
		"richtext": "rtx",
		"scriptlet": [
			"sct",
			"wsc"
		],
		"texmacs": "tm",
		"tab-separated-values": "tsv",
		"vnd.sun.j2me.app-descriptor": "jad",
		"vnd.wap.wml": "wml",
		"vnd.wap.wmlscript": "wmls",
		"x-bibtex": "bib",
		"x-boo": "boo",
		"x-c++hdr": [
			"h++",
			"hpp",
			"hxx",
			"hh"
		],
		"x-c++src": [
			"c++",
			"cpp",
			"cxx",
			"cc"
		],
		"x-component": "htc",
		"x-dsrc": "d",
		"x-diff": "patch",
		"x-haskell": "hs",
		"x-java": "java",
		"x-literate-haskell": "lhs",
		"x-moc": "moc",
		"x-pascal": [
			"p",
			"pas",
			"pp",
			"inc"
		],
		"x-pcs-gcd": "gcd",
		"x-python": "py",
		"x-scala": "scala",
		"x-setext": "etx",
		"x-tcl": [
			"tcl",
			"tk"
		],
		"x-tex": [
			"tex",
			"ltx",
			"sty",
			"cls"
		],
		"x-vcalendar": "vcs",
		"x-vcard": "vcf",
		"n3": "n3",
		"prs.lines.tag": "dsc",
		"sgml": [
			"sgml",
			"sgm"
		],
		"troff": [
			"t",
			"tr",
			"roff",
			"man",
			"me",
			"ms"
		],
		"turtle": "ttl",
		"uri-list": [
			"uri",
			"uris",
			"urls"
		],
		"vcard": "vcard",
		"vnd.curl": "curl",
		"vnd.curl.dcurl": "dcurl",
		"vnd.curl.scurl": "scurl",
		"vnd.curl.mcurl": "mcurl",
		"vnd.dvb.subtitle": "sub",
		"vnd.fly": "fly",
		"vnd.fmi.flexstor": "flx",
		"vnd.graphviz": "gv",
		"vnd.in3d.3dml": "3dml",
		"vnd.in3d.spot": "spot",
		"x-asm": [
			"s",
			"asm"
		],
		"x-c": [
			"c",
			"h",
			"dic"
		],
		"x-fortran": [
			"f",
			"for",
			"f77",
			"f90"
		],
		"x-opml": "opml",
		"x-nfo": "nfo",
		"x-sfv": "sfv",
		"x-uuencode": "uu",
		"webviewhtml": "htt",
		"javascript": "js",
		"json": "json",
		"markdown": [
			"md",
			"markdown",
			"mdown",
			"markdn"
		],
		"vnd.wap.si": "si",
		"vnd.wap.sl": "sl"
	},
	"video": {
		"avif": "avif",
		"3gpp": "3gp",
		"annodex": "axv",
		"dl": "dl",
		"dv": [
			"dif",
			"dv"
		],
		"fli": "fli",
		"gl": "gl",
		"mpeg": [
			"mpeg",
			"mpg",
			"mpe",
			"m1v",
			"m2v",
			"mp2",
			"mpa",
			"mpv2"
		],
		"mp4": [
			"mp4",
			"mp4v",
			"mpg4"
		],
		"quicktime": [
			"qt",
			"mov"
		],
		"ogg": "ogv",
		"vnd.mpegurl": [
			"mxu",
			"m4u"
		],
		"x-flv": "flv",
		"x-la-asf": [
			"lsf",
			"lsx"
		],
		"x-mng": "mng",
		"x-ms-asf": [
			"asf",
			"asx",
			"asr"
		],
		"x-ms-wm": "wm",
		"x-ms-wmv": "wmv",
		"x-ms-wmx": "wmx",
		"x-ms-wvx": "wvx",
		"x-msvideo": "avi",
		"x-sgi-movie": "movie",
		"x-matroska": [
			"mpv",
			"mkv",
			"mk3d",
			"mks"
		],
		"3gpp2": "3g2",
		"h261": "h261",
		"h263": "h263",
		"h264": "h264",
		"jpeg": "jpgv",
		"jpm": [
			"jpm",
			"jpgm"
		],
		"mj2": [
			"mj2",
			"mjp2"
		],
		"vnd.dece.hd": [
			"uvh",
			"uvvh"
		],
		"vnd.dece.mobile": [
			"uvm",
			"uvvm"
		],
		"vnd.dece.pd": [
			"uvp",
			"uvvp"
		],
		"vnd.dece.sd": [
			"uvs",
			"uvvs"
		],
		"vnd.dece.video": [
			"uvv",
			"uvvv"
		],
		"vnd.dvb.file": "dvb",
		"vnd.fvt": "fvt",
		"vnd.ms-playready.media.pyv": "pyv",
		"vnd.uvvu.mp4": [
			"uvu",
			"uvvu"
		],
		"vnd.vivo": "viv",
		"webm": "webm",
		"x-f4v": "f4v",
		"x-m4v": "m4v",
		"x-ms-vob": "vob",
		"x-smv": "smv",
		"mp2t": "ts"
	},
	"x-conference": {
		"x-cooltalk": "ice"
	},
	"x-world": {
		"x-vrml": [
			"vrm",
			"flr",
			"wrz",
			"xaf",
			"xof"
		]
	}
};

(() => {
	const mimeTypes = {};
	for (const type of Object.keys(table$1)) {
		for (const subtype of Object.keys(table$1[type])) {
			const value = table$1[type][subtype];
			if (typeof value == "string") {
				mimeTypes[value] = type + "/" + subtype;
			} else {
				for (let indexMimeType = 0; indexMimeType < value.length; indexMimeType++) {
					mimeTypes[value[indexMimeType]] = type + "/" + subtype;
				}
			}
		}
	}
	return mimeTypes;
})();

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const table = [];
for (let i = 0; i < 256; i++) {
	let t = i;
	for (let j = 0; j < 8; j++) {
		if (t & 1) {
			t = (t >>> 1) ^ 0xEDB88320;
		} else {
			t = t >>> 1;
		}
	}
	table[i] = t;
}

class Crc32 {

	constructor(crc) {
		this.crc = crc || -1;
	}

	append(data) {
		let crc = this.crc | 0;
		for (let offset = 0, length = data.length | 0; offset < length; offset++) {
			crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
		}
		this.crc = crc;
	}

	get() {
		return ~this.crc;
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


class Crc32Stream extends TransformStream {

	constructor() {
		// deno-lint-ignore prefer-const
		let stream;
		const crc32 = new Crc32();
		super({
			transform(chunk, controller) {
				crc32.append(chunk);
				controller.enqueue(chunk);
			},
			flush() {
				const value = new Uint8Array(4);
				const dataView = new DataView(value.buffer);
				dataView.setUint32(0, crc32.get());
				stream.value = value;
			}
		});
		stream = this;
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


function encodeText(value) {
	// deno-lint-ignore valid-typeof
	if (typeof TextEncoder == UNDEFINED_TYPE) {
		value = unescape(encodeURIComponent(value));
		const result = new Uint8Array(value.length);
		for (let i = 0; i < result.length; i++) {
			result[i] = value.charCodeAt(i);
		}
		return result;
	} else {
		return new TextEncoder().encode(value);
	}
}

// Derived from https://github.com/xqdoo00o/jszip/blob/master/lib/sjcl.js and https://github.com/bitwiseshiftleft/sjcl

// deno-lint-ignore-file no-this-alias

/*
 * SJCL is open. You can use, modify and redistribute it under a BSD
 * license or under the GNU GPL, version 2.0.
 */

/** @fileOverview Javascript cryptography implementation.
 *
 * Crush to remove comments, shorten variable names and
 * generally reduce transmission size.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */

/** @fileOverview Arrays of bits, encoded as arrays of Numbers.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Arrays of bits, encoded as arrays of Numbers.
 * @namespace
 * @description
 * <p>
 * These objects are the currency accepted by SJCL's crypto functions.
 * </p>
 *
 * <p>
 * Most of our crypto primitives operate on arrays of 4-byte words internally,
 * but many of them can take arguments that are not a multiple of 4 bytes.
 * This library encodes arrays of bits (whose size need not be a multiple of 8
 * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
 * array of words, 32 bits at a time.  Since the words are double-precision
 * floating point numbers, they fit some extra data.  We use this (in a private,
 * possibly-changing manner) to encode the number of bits actually  present
 * in the last word of the array.
 * </p>
 *
 * <p>
 * Because bitwise ops clear this out-of-band data, these arrays can be passed
 * to ciphers like AES which want arrays of words.
 * </p>
 */
const bitArray = {
	/**
	 * Concatenate two bit arrays.
	 * @param {bitArray} a1 The first array.
	 * @param {bitArray} a2 The second array.
	 * @return {bitArray} The concatenation of a1 and a2.
	 */
	concat(a1, a2) {
		if (a1.length === 0 || a2.length === 0) {
			return a1.concat(a2);
		}

		const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
		if (shift === 32) {
			return a1.concat(a2);
		} else {
			return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
		}
	},

	/**
	 * Find the length of an array of bits.
	 * @param {bitArray} a The array.
	 * @return {Number} The length of a, in bits.
	 */
	bitLength(a) {
		const l = a.length;
		if (l === 0) {
			return 0;
		}
		const x = a[l - 1];
		return (l - 1) * 32 + bitArray.getPartial(x);
	},

	/**
	 * Truncate an array.
	 * @param {bitArray} a The array.
	 * @param {Number} len The length to truncate to, in bits.
	 * @return {bitArray} A new array, truncated to len bits.
	 */
	clamp(a, len) {
		if (a.length * 32 < len) {
			return a;
		}
		a = a.slice(0, Math.ceil(len / 32));
		const l = a.length;
		len = len & 31;
		if (l > 0 && len) {
			a[l - 1] = bitArray.partial(len, a[l - 1] & 0x80000000 >> (len - 1), 1);
		}
		return a;
	},

	/**
	 * Make a partial word for a bit array.
	 * @param {Number} len The number of bits in the word.
	 * @param {Number} x The bits.
	 * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
	 * @return {Number} The partial word.
	 */
	partial(len, x, _end) {
		if (len === 32) {
			return x;
		}
		return (_end ? x | 0 : x << (32 - len)) + len * 0x10000000000;
	},

	/**
	 * Get the number of bits used by a partial word.
	 * @param {Number} x The partial word.
	 * @return {Number} The number of bits used by the partial word.
	 */
	getPartial(x) {
		return Math.round(x / 0x10000000000) || 32;
	},

	/** Shift an array right.
	 * @param {bitArray} a The array to shift.
	 * @param {Number} shift The number of bits to shift.
	 * @param {Number} [carry=0] A byte to carry in
	 * @param {bitArray} [out=[]] An array to prepend to the output.
	 * @private
	 */
	_shiftRight(a, shift, carry, out) {
		if (out === undefined) {
			out = [];
		}

		for (; shift >= 32; shift -= 32) {
			out.push(carry);
			carry = 0;
		}
		if (shift === 0) {
			return out.concat(a);
		}

		for (let i = 0; i < a.length; i++) {
			out.push(carry | a[i] >>> shift);
			carry = a[i] << (32 - shift);
		}
		const last2 = a.length ? a[a.length - 1] : 0;
		const shift2 = bitArray.getPartial(last2);
		out.push(bitArray.partial(shift + shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(), 1));
		return out;
	}
};

/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Arrays of bytes
 * @namespace
 */
const codec = {
	bytes: {
		/** Convert from a bitArray to an array of bytes. */
		fromBits(arr) {
			const bl = bitArray.bitLength(arr);
			const byteLength = bl / 8;
			const out = new Uint8Array(byteLength);
			let tmp;
			for (let i = 0; i < byteLength; i++) {
				if ((i & 3) === 0) {
					tmp = arr[i / 4];
				}
				out[i] = tmp >>> 24;
				tmp <<= 8;
			}
			return out;
		},
		/** Convert from an array of bytes to a bitArray. */
		toBits(bytes) {
			const out = [];
			let i;
			let tmp = 0;
			for (i = 0; i < bytes.length; i++) {
				tmp = tmp << 8 | bytes[i];
				if ((i & 3) === 3) {
					out.push(tmp);
					tmp = 0;
				}
			}
			if (i & 3) {
				out.push(bitArray.partial(8 * (i & 3), tmp));
			}
			return out;
		}
	}
};

const hash = {};

/**
 * Context for a SHA-1 operation in progress.
 * @constructor
 */
hash.sha1 = class {
	constructor(hash) {
		const sha1 = this;
		/**
		 * The hash's block size, in bits.
		 * @constant
		 */
		sha1.blockSize = 512;
		/**
		 * The SHA-1 initialization vector.
		 * @private
		 */
		sha1._init = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
		/**
		 * The SHA-1 hash key.
		 * @private
		 */
		sha1._key = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];
		if (hash) {
			sha1._h = hash._h.slice(0);
			sha1._buffer = hash._buffer.slice(0);
			sha1._length = hash._length;
		} else {
			sha1.reset();
		}
	}

	/**
	 * Reset the hash state.
	 * @return this
	 */
	reset() {
		const sha1 = this;
		sha1._h = sha1._init.slice(0);
		sha1._buffer = [];
		sha1._length = 0;
		return sha1;
	}

	/**
	 * Input several words to the hash.
	 * @param {bitArray|String} data the data to hash.
	 * @return this
	 */
	update(data) {
		const sha1 = this;
		if (typeof data === "string") {
			data = codec.utf8String.toBits(data);
		}
		const b = sha1._buffer = bitArray.concat(sha1._buffer, data);
		const ol = sha1._length;
		const nl = sha1._length = ol + bitArray.bitLength(data);
		if (nl > 9007199254740991) {
			throw new Error("Cannot hash more than 2^53 - 1 bits");
		}
		const c = new Uint32Array(b);
		let j = 0;
		for (let i = sha1.blockSize + ol - ((sha1.blockSize + ol) & (sha1.blockSize - 1)); i <= nl;
			i += sha1.blockSize) {
			sha1._block(c.subarray(16 * j, 16 * (j + 1)));
			j += 1;
		}
		b.splice(0, 16 * j);
		return sha1;
	}

	/**
	 * Complete hashing and output the hash value.
	 * @return {bitArray} The hash value, an array of 5 big-endian words. TODO
	 */
	finalize() {
		const sha1 = this;
		let b = sha1._buffer;
		const h = sha1._h;

		// Round out and push the buffer
		b = bitArray.concat(b, [bitArray.partial(1, 1)]);
		// Round out the buffer to a multiple of 16 words, less the 2 length words.
		for (let i = b.length + 2; i & 15; i++) {
			b.push(0);
		}

		// append the length
		b.push(Math.floor(sha1._length / 0x100000000));
		b.push(sha1._length | 0);

		while (b.length) {
			sha1._block(b.splice(0, 16));
		}

		sha1.reset();
		return h;
	}

	/**
	 * The SHA-1 logical functions f(0), f(1), ..., f(79).
	 * @private
	 */
	_f(t, b, c, d) {
		if (t <= 19) {
			return (b & c) | (~b & d);
		} else if (t <= 39) {
			return b ^ c ^ d;
		} else if (t <= 59) {
			return (b & c) | (b & d) | (c & d);
		} else if (t <= 79) {
			return b ^ c ^ d;
		}
	}

	/**
	 * Circular left-shift operator.
	 * @private
	 */
	_S(n, x) {
		return (x << n) | (x >>> 32 - n);
	}

	/**
	 * Perform one cycle of SHA-1.
	 * @param {Uint32Array|bitArray} words one block of words.
	 * @private
	 */
	_block(words) {
		const sha1 = this;
		const h = sha1._h;
		// When words is passed to _block, it has 16 elements. SHA1 _block
		// function extends words with new elements (at the end there are 80 elements). 
		// The problem is that if we use Uint32Array instead of Array, 
		// the length of Uint32Array cannot be changed. Thus, we replace words with a 
		// normal Array here.
		const w = Array(80); // do not use Uint32Array here as the instantiation is slower
		for (let j = 0; j < 16; j++) {
			w[j] = words[j];
		}

		let a = h[0];
		let b = h[1];
		let c = h[2];
		let d = h[3];
		let e = h[4];

		for (let t = 0; t <= 79; t++) {
			if (t >= 16) {
				w[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);
			}
			const tmp = (sha1._S(5, a) + sha1._f(t, b, c, d) + e + w[t] +
				sha1._key[Math.floor(t / 20)]) | 0;
			e = d;
			d = c;
			c = sha1._S(30, b);
			b = a;
			a = tmp;
		}

		h[0] = (h[0] + a) | 0;
		h[1] = (h[1] + b) | 0;
		h[2] = (h[2] + c) | 0;
		h[3] = (h[3] + d) | 0;
		h[4] = (h[4] + e) | 0;
	}
};

/** @fileOverview Low-level AES implementation.
 *
 * This file contains a low-level implementation of AES, optimized for
 * size and for efficiency on several browsers.  It is based on
 * OpenSSL's aes_core.c, a public-domain implementation by Vincent
 * Rijmen, Antoon Bosselaers and Paulo Barreto.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

const cipher = {};

/**
 * Schedule out an AES key for both encryption and decryption.  This
 * is a low-level class.  Use a cipher mode to do bulk encryption.
 *
 * @constructor
 * @param {Array} key The key as an array of 4, 6 or 8 words.
 */
cipher.aes = class {
	constructor(key) {
		/**
		 * The expanded S-box and inverse S-box tables.  These will be computed
		 * on the client so that we don't have to send them down the wire.
		 *
		 * There are two tables, _tables[0] is for encryption and
		 * _tables[1] is for decryption.
		 *
		 * The first 4 sub-tables are the expanded S-box with MixColumns.  The
		 * last (_tables[01][4]) is the S-box itself.
		 *
		 * @private
		 */
		const aes = this;
		aes._tables = [[[], [], [], [], []], [[], [], [], [], []]];

		if (!aes._tables[0][0][0]) {
			aes._precompute();
		}

		const sbox = aes._tables[0][4];
		const decTable = aes._tables[1];
		const keyLen = key.length;

		let i, encKey, decKey, rcon = 1;

		if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
			throw new Error("invalid aes key size");
		}

		aes._key = [encKey = key.slice(0), decKey = []];

		// schedule encryption keys
		for (i = keyLen; i < 4 * keyLen + 28; i++) {
			let tmp = encKey[i - 1];

			// apply sbox
			if (i % keyLen === 0 || (keyLen === 8 && i % keyLen === 4)) {
				tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];

				// shift rows and add rcon
				if (i % keyLen === 0) {
					tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
					rcon = rcon << 1 ^ (rcon >> 7) * 283;
				}
			}

			encKey[i] = encKey[i - keyLen] ^ tmp;
		}

		// schedule decryption keys
		for (let j = 0; i; j++, i--) {
			const tmp = encKey[j & 3 ? i : i - 4];
			if (i <= 4 || j < 4) {
				decKey[j] = tmp;
			} else {
				decKey[j] = decTable[0][sbox[tmp >>> 24]] ^
					decTable[1][sbox[tmp >> 16 & 255]] ^
					decTable[2][sbox[tmp >> 8 & 255]] ^
					decTable[3][sbox[tmp & 255]];
			}
		}
	}
	// public
	/* Something like this might appear here eventually
	name: "AES",
	blockSize: 4,
	keySizes: [4,6,8],
	*/

	/**
	 * Encrypt an array of 4 big-endian words.
	 * @param {Array} data The plaintext.
	 * @return {Array} The ciphertext.
	 */
	encrypt(data) {
		return this._crypt(data, 0);
	}

	/**
	 * Decrypt an array of 4 big-endian words.
	 * @param {Array} data The ciphertext.
	 * @return {Array} The plaintext.
	 */
	decrypt(data) {
		return this._crypt(data, 1);
	}

	/**
	 * Expand the S-box tables.
	 *
	 * @private
	 */
	_precompute() {
		const encTable = this._tables[0];
		const decTable = this._tables[1];
		const sbox = encTable[4];
		const sboxInv = decTable[4];
		const d = [];
		const th = [];
		let xInv, x2, x4, x8;

		// Compute double and third tables
		for (let i = 0; i < 256; i++) {
			th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
		}

		for (let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
			// Compute sbox
			let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
			s = s >> 8 ^ s & 255 ^ 99;
			sbox[x] = s;
			sboxInv[s] = x;

			// Compute MixColumns
			x8 = d[x4 = d[x2 = d[x]]];
			let tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
			let tEnc = d[s] * 0x101 ^ s * 0x1010100;

			for (let i = 0; i < 4; i++) {
				encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
				decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
			}
		}

		// Compactify.  Considerable speedup on Firefox.
		for (let i = 0; i < 5; i++) {
			encTable[i] = encTable[i].slice(0);
			decTable[i] = decTable[i].slice(0);
		}
	}

	/**
	 * Encryption and decryption core.
	 * @param {Array} input Four words to be encrypted or decrypted.
	 * @param dir The direction, 0 for encrypt and 1 for decrypt.
	 * @return {Array} The four encrypted or decrypted words.
	 * @private
	 */
	_crypt(input, dir) {
		if (input.length !== 4) {
			throw new Error("invalid aes block size");
		}

		const key = this._key[dir];

		const nInnerRounds = key.length / 4 - 2;
		const out = [0, 0, 0, 0];
		const table = this._tables[dir];

		// load up the tables
		const t0 = table[0];
		const t1 = table[1];
		const t2 = table[2];
		const t3 = table[3];
		const sbox = table[4];

		// state variables a,b,c,d are loaded with pre-whitened data
		let a = input[0] ^ key[0];
		let b = input[dir ? 3 : 1] ^ key[1];
		let c = input[2] ^ key[2];
		let d = input[dir ? 1 : 3] ^ key[3];
		let kIndex = 4;
		let a2, b2, c2;

		// Inner rounds.  Cribbed from OpenSSL.
		for (let i = 0; i < nInnerRounds; i++) {
			a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
			b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
			c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
			d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
			kIndex += 4;
			a = a2; b = b2; c = c2;
		}

		// Last round.
		for (let i = 0; i < 4; i++) {
			out[dir ? 3 & -i : i] =
				sbox[a >>> 24] << 24 ^
				sbox[b >> 16 & 255] << 16 ^
				sbox[c >> 8 & 255] << 8 ^
				sbox[d & 255] ^
				key[kIndex++];
			a2 = a; a = b; b = c; c = d; d = a2;
		}

		return out;
	}
};

/**
 * Random values
 * @namespace
 */
const random = {
	/** 
	 * Generate random words with pure js, cryptographically not as strong & safe as native implementation.
	 * @param {TypedArray} typedArray The array to fill.
	 * @return {TypedArray} The random values.
	 */
	getRandomValues(typedArray) {
		const words = new Uint32Array(typedArray.buffer);
		const r = (m_w) => {
			let m_z = 0x3ade68b1;
			const mask = 0xffffffff;
			return function () {
				m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
				m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
				const result = ((((m_z << 0x10) + m_w) & mask) / 0x100000000) + .5;
				return result * (Math.random() > .5 ? 1 : -1);
			};
		};
		for (let i = 0, rcache; i < typedArray.length; i += 4) {
			const _r = r((rcache || Math.random()) * 0x100000000);
			rcache = _r() * 0x3ade67b7;
			words[i / 4] = (_r() * 0x100000000) | 0;
		}
		return typedArray;
	}
};

/** @fileOverview CTR mode implementation.
 *
 * Special thanks to Roy Nicholson for pointing out a bug in our
 * implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** Brian Gladman's CTR Mode.
* @constructor
* @param {Object} _prf The aes instance to generate key.
* @param {bitArray} _iv The iv for ctr mode, it must be 128 bits.
*/

const mode = {};

/**
 * Brian Gladman's CTR Mode.
 * @namespace
 */
mode.ctrGladman = class {
	constructor(prf, iv) {
		this._prf = prf;
		this._initIv = iv;
		this._iv = iv;
	}

	reset() {
		this._iv = this._initIv;
	}

	/** Input some data to calculate.
	 * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.
	 */
	update(data) {
		return this.calculate(this._prf, data, this._iv);
	}

	incWord(word) {
		if (((word >> 24) & 0xff) === 0xff) { //overflow
			let b1 = (word >> 16) & 0xff;
			let b2 = (word >> 8) & 0xff;
			let b3 = word & 0xff;

			if (b1 === 0xff) { // overflow b1   
				b1 = 0;
				if (b2 === 0xff) {
					b2 = 0;
					if (b3 === 0xff) {
						b3 = 0;
					} else {
						++b3;
					}
				} else {
					++b2;
				}
			} else {
				++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
		} else {
			word += (0x01 << 24);
		}
		return word;
	}

	incCounter(counter) {
		if ((counter[0] = this.incWord(counter[0])) === 0) {
			// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
			counter[1] = this.incWord(counter[1]);
		}
	}

	calculate(prf, data, iv) {
		let l;
		if (!(l = data.length)) {
			return [];
		}
		const bl = bitArray.bitLength(data);
		for (let i = 0; i < l; i += 4) {
			this.incCounter(iv);
			const e = prf.encrypt(iv);
			data[i] ^= e[0];
			data[i + 1] ^= e[1];
			data[i + 2] ^= e[2];
			data[i + 3] ^= e[3];
		}
		return bitArray.clamp(data, bl);
	}
};

const misc = {
	importKey(password) {
		return new misc.hmacSha1(codec.bytes.toBits(password));
	},
	pbkdf2(prf, salt, count, length) {
		count = count || 10000;
		if (length < 0 || count < 0) {
			throw new Error("invalid params to pbkdf2");
		}
		const byteLength = ((length >> 5) + 1) << 2;
		let u, ui, i, j, k;
		const arrayBuffer = new ArrayBuffer(byteLength);
		const out = new DataView(arrayBuffer);
		let outLength = 0;
		const b = bitArray;
		salt = codec.bytes.toBits(salt);
		for (k = 1; outLength < (byteLength || 1); k++) {
			u = ui = prf.encrypt(b.concat(salt, [k]));
			for (i = 1; i < count; i++) {
				ui = prf.encrypt(ui);
				for (j = 0; j < ui.length; j++) {
					u[j] ^= ui[j];
				}
			}
			for (i = 0; outLength < (byteLength || 1) && i < u.length; i++) {
				out.setInt32(outLength, u[i]);
				outLength += 4;
			}
		}
		return arrayBuffer.slice(0, length / 8);
	}
};

/** @fileOverview HMAC implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** HMAC with the specified hash function.
 * @constructor
 * @param {bitArray} key the key for HMAC.
 * @param {Object} [Hash=hash.sha1] The hash function to use.
 */
misc.hmacSha1 = class {

	constructor(key) {
		const hmac = this;
		const Hash = hmac._hash = hash.sha1;
		const exKey = [[], []];
		hmac._baseHash = [new Hash(), new Hash()];
		const bs = hmac._baseHash[0].blockSize / 32;

		if (key.length > bs) {
			key = new Hash().update(key).finalize();
		}

		for (let i = 0; i < bs; i++) {
			exKey[0][i] = key[i] ^ 0x36363636;
			exKey[1][i] = key[i] ^ 0x5C5C5C5C;
		}

		hmac._baseHash[0].update(exKey[0]);
		hmac._baseHash[1].update(exKey[1]);
		hmac._resultHash = new Hash(hmac._baseHash[0]);
	}
	reset() {
		const hmac = this;
		hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
		hmac._updated = false;
	}

	update(data) {
		const hmac = this;
		hmac._updated = true;
		hmac._resultHash.update(data);
	}

	digest() {
		const hmac = this;
		const w = hmac._resultHash.finalize();
		const result = new (hmac._hash)(hmac._baseHash[1]).update(w).finalize();

		hmac.reset();

		return result;
	}

	encrypt(data) {
		if (!this._updated) {
			this.update(data);
			return this.digest(data);
		} else {
			throw new Error("encrypt on already updated hmac called!");
		}
	}
};

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const GET_RANDOM_VALUES_SUPPORTED = typeof crypto != UNDEFINED_TYPE && typeof crypto.getRandomValues == FUNCTION_TYPE;

const ERR_INVALID_PASSWORD = "Invalid password";
const ERR_INVALID_SIGNATURE = "Invalid signature";
const ERR_ABORT_CHECK_PASSWORD = "zipjs-abort-check-password";

function getRandomValues(array) {
	if (GET_RANDOM_VALUES_SUPPORTED) {
		return crypto.getRandomValues(array);
	} else {
		return random.getRandomValues(array);
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const BLOCK_LENGTH = 16;
const RAW_FORMAT = "raw";
const PBKDF2_ALGORITHM = { name: "PBKDF2" };
const HASH_ALGORITHM = { name: "HMAC" };
const HASH_FUNCTION = "SHA-1";
const BASE_KEY_ALGORITHM = Object.assign({ hash: HASH_ALGORITHM }, PBKDF2_ALGORITHM);
const DERIVED_BITS_ALGORITHM = Object.assign({ iterations: 1000, hash: { name: HASH_FUNCTION } }, PBKDF2_ALGORITHM);
const DERIVED_BITS_USAGE = ["deriveBits"];
const SALT_LENGTH = [8, 12, 16];
const KEY_LENGTH = [16, 24, 32];
const SIGNATURE_LENGTH = 10;
const COUNTER_DEFAULT_VALUE = [0, 0, 0, 0];
// deno-lint-ignore valid-typeof
const CRYPTO_API_SUPPORTED = typeof crypto != UNDEFINED_TYPE;
const subtle = CRYPTO_API_SUPPORTED && crypto.subtle;
const SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof subtle != UNDEFINED_TYPE;
const codecBytes = codec.bytes;
const Aes = cipher.aes;
const CtrGladman = mode.ctrGladman;
const HmacSha1 = misc.hmacSha1;

let IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.importKey == FUNCTION_TYPE;
let DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.deriveBits == FUNCTION_TYPE;

class AESDecryptionStream extends TransformStream {

	constructor({ password, rawPassword, signed, encryptionStrength, checkPasswordOnly }) {
		super({
			start() {
				Object.assign(this, {
					ready: new Promise(resolve => this.resolveReady = resolve),
					password: encodePassword(password, rawPassword),
					signed,
					strength: encryptionStrength - 1,
					pending: new Uint8Array()
				});
			},
			async transform(chunk, controller) {
				const aesCrypto = this;
				const {
					password,
					strength,
					resolveReady,
					ready
				} = aesCrypto;
				if (password) {
					await createDecryptionKeys(aesCrypto, strength, password, subarray(chunk, 0, SALT_LENGTH[strength] + 2));
					chunk = subarray(chunk, SALT_LENGTH[strength] + 2);
					if (checkPasswordOnly) {
						controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
					} else {
						resolveReady();
					}
				} else {
					await ready;
				}
				const output = new Uint8Array(chunk.length - SIGNATURE_LENGTH - ((chunk.length - SIGNATURE_LENGTH) % BLOCK_LENGTH));
				controller.enqueue(append(aesCrypto, chunk, output, 0, SIGNATURE_LENGTH, true));
			},
			async flush(controller) {
				const {
					signed,
					ctr,
					hmac,
					pending,
					ready
				} = this;
				if (hmac && ctr) {
					await ready;
					const chunkToDecrypt = subarray(pending, 0, pending.length - SIGNATURE_LENGTH);
					const originalSignature = subarray(pending, pending.length - SIGNATURE_LENGTH);
					let decryptedChunkArray = new Uint8Array();
					if (chunkToDecrypt.length) {
						const encryptedChunk = toBits(codecBytes, chunkToDecrypt);
						hmac.update(encryptedChunk);
						const decryptedChunk = ctr.update(encryptedChunk);
						decryptedChunkArray = fromBits(codecBytes, decryptedChunk);
					}
					if (signed) {
						const signature = subarray(fromBits(codecBytes, hmac.digest()), 0, SIGNATURE_LENGTH);
						for (let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++) {
							if (signature[indexSignature] != originalSignature[indexSignature]) {
								throw new Error(ERR_INVALID_SIGNATURE);
							}
						}
					}
					controller.enqueue(decryptedChunkArray);
				}
			}
		});
	}
}

class AESEncryptionStream extends TransformStream {

	constructor({ password, rawPassword, encryptionStrength }) {
		// deno-lint-ignore prefer-const
		let stream;
		super({
			start() {
				Object.assign(this, {
					ready: new Promise(resolve => this.resolveReady = resolve),
					password: encodePassword(password, rawPassword),
					strength: encryptionStrength - 1,
					pending: new Uint8Array()
				});
			},
			async transform(chunk, controller) {
				const aesCrypto = this;
				const {
					password,
					strength,
					resolveReady,
					ready
				} = aesCrypto;
				let preamble = new Uint8Array();
				if (password) {
					preamble = await createEncryptionKeys(aesCrypto, strength, password);
					resolveReady();
				} else {
					await ready;
				}
				const output = new Uint8Array(preamble.length + chunk.length - (chunk.length % BLOCK_LENGTH));
				output.set(preamble, 0);
				controller.enqueue(append(aesCrypto, chunk, output, preamble.length, 0));
			},
			async flush(controller) {
				const {
					ctr,
					hmac,
					pending,
					ready
				} = this;
				if (hmac && ctr) {
					await ready;
					let encryptedChunkArray = new Uint8Array();
					if (pending.length) {
						const encryptedChunk = ctr.update(toBits(codecBytes, pending));
						hmac.update(encryptedChunk);
						encryptedChunkArray = fromBits(codecBytes, encryptedChunk);
					}
					stream.signature = fromBits(codecBytes, hmac.digest()).slice(0, SIGNATURE_LENGTH);
					controller.enqueue(concat(encryptedChunkArray, stream.signature));
				}
			}
		});
		stream = this;
	}
}

function append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {
	const {
		ctr,
		hmac,
		pending
	} = aesCrypto;
	const inputLength = input.length - paddingEnd;
	if (pending.length) {
		input = concat(pending, input);
		output = expand(output, inputLength - (inputLength % BLOCK_LENGTH));
	}
	let offset;
	for (offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH) {
		const inputChunk = toBits(codecBytes, subarray(input, offset, offset + BLOCK_LENGTH));
		if (verifySignature) {
			hmac.update(inputChunk);
		}
		const outputChunk = ctr.update(inputChunk);
		if (!verifySignature) {
			hmac.update(outputChunk);
		}
		output.set(fromBits(codecBytes, outputChunk), offset + paddingStart);
	}
	aesCrypto.pending = subarray(input, offset);
	return output;
}

async function createDecryptionKeys(decrypt, strength, password, preamble) {
	const passwordVerificationKey = await createKeys$1(decrypt, strength, password, subarray(preamble, 0, SALT_LENGTH[strength]));
	const passwordVerification = subarray(preamble, SALT_LENGTH[strength]);
	if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
		throw new Error(ERR_INVALID_PASSWORD);
	}
}

async function createEncryptionKeys(encrypt, strength, password) {
	const salt = getRandomValues(new Uint8Array(SALT_LENGTH[strength]));
	const passwordVerification = await createKeys$1(encrypt, strength, password, salt);
	return concat(salt, passwordVerification);
}

async function createKeys$1(aesCrypto, strength, password, salt) {
	aesCrypto.password = null;
	const baseKey = await importKey(RAW_FORMAT, password, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
	const derivedBits = await deriveBits(Object.assign({ salt }, DERIVED_BITS_ALGORITHM), baseKey, 8 * ((KEY_LENGTH[strength] * 2) + 2));
	const compositeKey = new Uint8Array(derivedBits);
	const key = toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[strength]));
	const authentication = toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[strength], KEY_LENGTH[strength] * 2));
	const passwordVerification = subarray(compositeKey, KEY_LENGTH[strength] * 2);
	Object.assign(aesCrypto, {
		keys: {
			key,
			authentication,
			passwordVerification
		},
		ctr: new CtrGladman(new Aes(key), Array.from(COUNTER_DEFAULT_VALUE)),
		hmac: new HmacSha1(authentication)
	});
	return passwordVerification;
}

async function importKey(format, password, algorithm, extractable, keyUsages) {
	if (IMPORT_KEY_SUPPORTED) {
		try {
			return await subtle.importKey(format, password, algorithm, extractable, keyUsages);
			// eslint-disable-next-line no-unused-vars
		} catch (_) {
			IMPORT_KEY_SUPPORTED = false;
			return misc.importKey(password);
		}
	} else {
		return misc.importKey(password);
	}
}

async function deriveBits(algorithm, baseKey, length) {
	if (DERIVE_BITS_SUPPORTED) {
		try {
			return await subtle.deriveBits(algorithm, baseKey, length);
			// eslint-disable-next-line no-unused-vars
		} catch (_) {
			DERIVE_BITS_SUPPORTED = false;
			return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
		}
	} else {
		return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
	}
}

function encodePassword(password, rawPassword) {
	if (rawPassword === UNDEFINED_VALUE) {
		return encodeText(password);
	} else {
		return rawPassword;
	}
}

function concat(leftArray, rightArray) {
	let array = leftArray;
	if (leftArray.length + rightArray.length) {
		array = new Uint8Array(leftArray.length + rightArray.length);
		array.set(leftArray, 0);
		array.set(rightArray, leftArray.length);
	}
	return array;
}

function expand(inputArray, length) {
	if (length && length > inputArray.length) {
		const array = inputArray;
		inputArray = new Uint8Array(length);
		inputArray.set(array, 0);
	}
	return inputArray;
}

function subarray(array, begin, end) {
	return array.subarray(begin, end);
}

function fromBits(codecBytes, chunk) {
	return codecBytes.fromBits(chunk);
}
function toBits(codecBytes, chunk) {
	return codecBytes.toBits(chunk);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const HEADER_LENGTH = 12;

class ZipCryptoDecryptionStream extends TransformStream {

	constructor({ password, passwordVerification, checkPasswordOnly }) {
		super({
			start() {
				Object.assign(this, {
					password,
					passwordVerification
				});
				createKeys(this, password);
			},
			transform(chunk, controller) {
				const zipCrypto = this;
				if (zipCrypto.password) {
					const decryptedHeader = decrypt(zipCrypto, chunk.subarray(0, HEADER_LENGTH));
					zipCrypto.password = null;
					if (decryptedHeader[HEADER_LENGTH - 1] != zipCrypto.passwordVerification) {
						throw new Error(ERR_INVALID_PASSWORD);
					}
					chunk = chunk.subarray(HEADER_LENGTH);
				}
				if (checkPasswordOnly) {
					controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
				} else {
					controller.enqueue(decrypt(zipCrypto, chunk));
				}
			}
		});
	}
}

class ZipCryptoEncryptionStream extends TransformStream {

	constructor({ password, passwordVerification }) {
		super({
			start() {
				Object.assign(this, {
					password,
					passwordVerification
				});
				createKeys(this, password);
			},
			transform(chunk, controller) {
				const zipCrypto = this;
				let output;
				let offset;
				if (zipCrypto.password) {
					zipCrypto.password = null;
					const header = getRandomValues(new Uint8Array(HEADER_LENGTH));
					header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
					output = new Uint8Array(chunk.length + header.length);
					output.set(encrypt(zipCrypto, header), 0);
					offset = HEADER_LENGTH;
				} else {
					output = new Uint8Array(chunk.length);
					offset = 0;
				}
				output.set(encrypt(zipCrypto, chunk), offset);
				controller.enqueue(output);
			}
		});
	}
}

function decrypt(target, input) {
	const output = new Uint8Array(input.length);
	for (let index = 0; index < input.length; index++) {
		output[index] = getByte(target) ^ input[index];
		updateKeys(target, output[index]);
	}
	return output;
}

function encrypt(target, input) {
	const output = new Uint8Array(input.length);
	for (let index = 0; index < input.length; index++) {
		output[index] = getByte(target) ^ input[index];
		updateKeys(target, input[index]);
	}
	return output;
}

function createKeys(target, password) {
	const keys = [0x12345678, 0x23456789, 0x34567890];
	Object.assign(target, {
		keys,
		crcKey0: new Crc32(keys[0]),
		crcKey2: new Crc32(keys[2]),
	});
	for (let index = 0; index < password.length; index++) {
		updateKeys(target, password.charCodeAt(index));
	}
}

function updateKeys(target, byte) {
	let [key0, key1, key2] = target.keys;
	target.crcKey0.append([byte]);
	key0 = ~target.crcKey0.get();
	key1 = getInt32(Math.imul(getInt32(key1 + getInt8(key0)), 134775813) + 1);
	target.crcKey2.append([key1 >>> 24]);
	key2 = ~target.crcKey2.get();
	target.keys = [key0, key1, key2];
}

function getByte(target) {
	const temp = target.keys[2] | 2;
	return getInt8(Math.imul(temp, (temp ^ 1)) >>> 8);
}

function getInt8(number) {
	return number & 0xFF;
}

function getInt32(number) {
	return number & 0xFFFFFFFF;
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const COMPRESSION_FORMAT = "deflate-raw";

class DeflateStream extends TransformStream {

	constructor(options, { chunkSize, CompressionStream, CompressionStreamNative }) {
		super({});
		const { compressed, encrypted, useCompressionStream, zipCrypto, signed, level } = options;
		const stream = this;
		let crc32Stream, encryptionStream;
		let readable = filterEmptyChunks(super.readable);
		if ((!encrypted || zipCrypto) && signed) {
			crc32Stream = new Crc32Stream();
			readable = pipeThrough(readable, crc32Stream);
		}
		if (compressed) {
			readable = pipeThroughCommpressionStream(readable, useCompressionStream, { level, chunkSize }, CompressionStreamNative, CompressionStream);
		}
		if (encrypted) {
			if (zipCrypto) {
				readable = pipeThrough(readable, new ZipCryptoEncryptionStream(options));
			} else {
				encryptionStream = new AESEncryptionStream(options);
				readable = pipeThrough(readable, encryptionStream);
			}
		}
		setReadable(stream, readable, () => {
			let signature;
			if (encrypted && !zipCrypto) {
				signature = encryptionStream.signature;
			}
			if ((!encrypted || zipCrypto) && signed) {
				signature = new DataView(crc32Stream.value.buffer).getUint32(0);
			}
			stream.signature = signature;
		});
	}
}

class InflateStream extends TransformStream {

	constructor(options, { chunkSize, DecompressionStream, DecompressionStreamNative }) {
		super({});
		const { zipCrypto, encrypted, signed, signature, compressed, useCompressionStream } = options;
		let crc32Stream, decryptionStream;
		let readable = filterEmptyChunks(super.readable);
		if (encrypted) {
			if (zipCrypto) {
				readable = pipeThrough(readable, new ZipCryptoDecryptionStream(options));
			} else {
				decryptionStream = new AESDecryptionStream(options);
				readable = pipeThrough(readable, decryptionStream);
			}
		}
		if (compressed) {
			readable = pipeThroughCommpressionStream(readable, useCompressionStream, { chunkSize }, DecompressionStreamNative, DecompressionStream);
		}
		if ((!encrypted || zipCrypto) && signed) {
			crc32Stream = new Crc32Stream();
			readable = pipeThrough(readable, crc32Stream);
		}
		setReadable(this, readable, () => {
			if ((!encrypted || zipCrypto) && signed) {
				const dataViewSignature = new DataView(crc32Stream.value.buffer);
				if (signature != dataViewSignature.getUint32(0, false)) {
					throw new Error(ERR_INVALID_SIGNATURE);
				}
			}
		});
	}
}

function filterEmptyChunks(readable) {
	return pipeThrough(readable, new TransformStream({
		transform(chunk, controller) {
			if (chunk && chunk.length) {
				controller.enqueue(chunk);
			}
		}
	}));
}

function setReadable(stream, readable, flush) {
	readable = pipeThrough(readable, new TransformStream({ flush }));
	Object.defineProperty(stream, "readable", {
		get() {
			return readable;
		}
	});
}

function pipeThroughCommpressionStream(readable, useCompressionStream, options, CodecStreamNative, CodecStream) {
	try {
		const CompressionStream = useCompressionStream && CodecStreamNative ? CodecStreamNative : CodecStream;
		readable = pipeThrough(readable, new CompressionStream(COMPRESSION_FORMAT, options));
		// eslint-disable-next-line no-unused-vars
	} catch (_) {
		if (useCompressionStream) {
			try {
				readable = pipeThrough(readable, new CodecStream(COMPRESSION_FORMAT, options));
				// eslint-disable-next-line no-unused-vars
			} catch (_) {
				return readable;
			}
		} else {
			return readable;
		}
	}
	return readable;
}

function pipeThrough(readable, transformStream) {
	return readable.pipeThrough(transformStream);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const MESSAGE_EVENT_TYPE = "message";
const MESSAGE_START = "start";
const MESSAGE_PULL = "pull";
const MESSAGE_DATA = "data";
const MESSAGE_ACK_DATA = "ack";
const MESSAGE_CLOSE = "close";
const CODEC_DEFLATE = "deflate";
const CODEC_INFLATE = "inflate";

class CodecStream extends TransformStream {

	constructor(options, config) {
		super({});
		const codec = this;
		const { codecType } = options;
		let Stream;
		if (codecType.startsWith(CODEC_DEFLATE)) {
			Stream = DeflateStream;
		} else if (codecType.startsWith(CODEC_INFLATE)) {
			Stream = InflateStream;
		}
		let outputSize = 0;
		let inputSize = 0;
		const stream = new Stream(options, config);
		const readable = super.readable;
		const inputSizeStream = new TransformStream({
			transform(chunk, controller) {
				if (chunk && chunk.length) {
					inputSize += chunk.length;
					controller.enqueue(chunk);
				}
			},
			flush() {
				Object.assign(codec, {
					inputSize
				});
			}
		});
		const outputSizeStream = new TransformStream({
			transform(chunk, controller) {
				if (chunk && chunk.length) {
					outputSize += chunk.length;
					controller.enqueue(chunk);
				}
			},
			flush() {
				const { signature } = stream;
				Object.assign(codec, {
					signature,
					outputSize,
					inputSize
				});
			}
		});
		Object.defineProperty(codec, "readable", {
			get() {
				return readable.pipeThrough(inputSizeStream).pipeThrough(stream).pipeThrough(outputSizeStream);
			}
		});
	}
}

class ChunkStream extends TransformStream {

	constructor(chunkSize) {
		let pendingChunk;
		super({
			transform,
			flush(controller) {
				if (pendingChunk && pendingChunk.length) {
					controller.enqueue(pendingChunk);
				}
			}
		});

		function transform(chunk, controller) {
			if (pendingChunk) {
				const newChunk = new Uint8Array(pendingChunk.length + chunk.length);
				newChunk.set(pendingChunk);
				newChunk.set(chunk, pendingChunk.length);
				chunk = newChunk;
				pendingChunk = null;
			}
			if (chunk.length > chunkSize) {
				controller.enqueue(chunk.slice(0, chunkSize));
				transform(chunk.slice(chunkSize), controller);
			} else {
				pendingChunk = chunk;
			}
		}
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


// deno-lint-ignore valid-typeof
let WEB_WORKERS_SUPPORTED = typeof Worker != UNDEFINED_TYPE;

class CodecWorker {

	constructor(workerData, { readable, writable }, { options, config, streamOptions, useWebWorkers, transferStreams, scripts }, onTaskFinished) {
		const { signal } = streamOptions;
		Object.assign(workerData, {
			busy: true,
			readable: readable
				.pipeThrough(new ChunkStream(config.chunkSize))
				.pipeThrough(new ProgressWatcherStream(readable, streamOptions), { signal }),
			writable,
			options: Object.assign({}, options),
			scripts,
			transferStreams,
			terminate() {
				return new Promise(resolve => {
					const { worker, busy } = workerData;
					if (worker) {
						if (busy) {
							workerData.resolveTerminated = resolve;
						} else {
							worker.terminate();
							resolve();
						}
						workerData.interface = null;
					} else {
						resolve();
					}
				});
			},
			onTaskFinished() {
				const { resolveTerminated } = workerData;
				if (resolveTerminated) {
					workerData.resolveTerminated = null;
					workerData.terminated = true;
					workerData.worker.terminate();
					resolveTerminated();
				}
				workerData.busy = false;
				onTaskFinished(workerData);
			}
		});
		return (useWebWorkers && WEB_WORKERS_SUPPORTED ? createWebWorkerInterface : createWorkerInterface)(workerData, config);
	}
}

class ProgressWatcherStream extends TransformStream {

	constructor(readableSource, { onstart, onprogress, size, onend }) {
		let chunkOffset = 0;
		super({
			async start() {
				if (onstart) {
					await callHandler(onstart, size);
				}
			},
			async transform(chunk, controller) {
				chunkOffset += chunk.length;
				if (onprogress) {
					await callHandler(onprogress, chunkOffset, size);
				}
				controller.enqueue(chunk);
			},
			async flush() {
				readableSource.size = chunkOffset;
				if (onend) {
					await callHandler(onend, chunkOffset);
				}
			}
		});
	}
}

async function callHandler(handler, ...parameters) {
	try {
		await handler(...parameters);
		// eslint-disable-next-line no-unused-vars
	} catch (_) {
		// ignored
	}
}

function createWorkerInterface(workerData, config) {
	return {
		run: () => runWorker$1(workerData, config)
	};
}

function createWebWorkerInterface(workerData, config) {
	const { baseURL, chunkSize } = config;
	if (!workerData.interface) {
		let worker;
		try {
			worker = getWebWorker(workerData.scripts[0], baseURL, workerData);
			// eslint-disable-next-line no-unused-vars
		} catch (_) {
			WEB_WORKERS_SUPPORTED = false;
			return createWorkerInterface(workerData, config);
		}
		Object.assign(workerData, {
			worker,
			interface: {
				run: () => runWebWorker(workerData, { chunkSize })
			}
		});
	}
	return workerData.interface;
}

async function runWorker$1({ options, readable, writable, onTaskFinished }, config) {
	try {
		const codecStream = new CodecStream(options, config);
		await readable.pipeThrough(codecStream).pipeTo(writable, { preventClose: true, preventAbort: true });
		const {
			signature,
			inputSize,
			outputSize
		} = codecStream;
		return {
			signature,
			inputSize,
			outputSize
		};
	} finally {
		onTaskFinished();
	}
}

async function runWebWorker(workerData, config) {
	let resolveResult, rejectResult;
	const result = new Promise((resolve, reject) => {
		resolveResult = resolve;
		rejectResult = reject;
	});
	Object.assign(workerData, {
		reader: null,
		writer: null,
		resolveResult,
		rejectResult,
		result
	});
	const { readable, options, scripts } = workerData;
	const { writable, closed } = watchClosedStream(workerData.writable);
	const streamsTransferred = sendMessage({
		type: MESSAGE_START,
		scripts: scripts.slice(1),
		options,
		config,
		readable,
		writable
	}, workerData);
	if (!streamsTransferred) {
		Object.assign(workerData, {
			reader: readable.getReader(),
			writer: writable.getWriter()
		});
	}
	const resultValue = await result;
	if (!streamsTransferred) {
		await writable.getWriter().close();
	}
	await closed;
	return resultValue;
}

function watchClosedStream(writableSource) {
	let resolveStreamClosed;
	const closed = new Promise(resolve => resolveStreamClosed = resolve);
	const writable = new WritableStream({
		async write(chunk) {
			const writer = writableSource.getWriter();
			await writer.ready;
			await writer.write(chunk);
			writer.releaseLock();
		},
		close() {
			resolveStreamClosed();
		},
		abort(reason) {
			const writer = writableSource.getWriter();
			return writer.abort(reason);
		}
	});
	return { writable, closed };
}

let classicWorkersSupported = true;
let transferStreamsSupported = true;

function getWebWorker(url, baseURL, workerData) {
	const workerOptions = { type: "module" };
	let scriptUrl, worker;
	// deno-lint-ignore valid-typeof
	if (typeof url == FUNCTION_TYPE) {
		url = url();
	}
	try {
		scriptUrl = new URL(url, baseURL);
		// eslint-disable-next-line no-unused-vars
	} catch (_) {
		scriptUrl = url;
	}
	if (classicWorkersSupported) {
		try {
			worker = new Worker(scriptUrl);
			// eslint-disable-next-line no-unused-vars
		} catch (_) {
			classicWorkersSupported = false;
			worker = new Worker(scriptUrl, workerOptions);
		}
	} else {
		worker = new Worker(scriptUrl, workerOptions);
	}
	worker.addEventListener(MESSAGE_EVENT_TYPE, event => onMessage(event, workerData));
	return worker;
}

function sendMessage(message, { worker, writer, onTaskFinished, transferStreams }) {
	try {
		const { value, readable, writable } = message;
		const transferables = [];
		if (value) {
			if (value.byteLength < value.buffer.byteLength) {
				message.value = value.buffer.slice(0, value.byteLength);
			}
			else {
				message.value = value.buffer;
			}
			transferables.push(message.value);
		}
		if (transferStreams && transferStreamsSupported) {
			if (readable) {
				transferables.push(readable);
			}
			if (writable) {
				transferables.push(writable);
			}
		} else {
			message.readable = message.writable = null;
		}
		if (transferables.length) {
			try {
				worker.postMessage(message, transferables);
				return true;
				// eslint-disable-next-line no-unused-vars
			} catch (_) {
				transferStreamsSupported = false;
				message.readable = message.writable = null;
				worker.postMessage(message);
			}
		} else {
			worker.postMessage(message);
		}
	} catch (error) {
		if (writer) {
			writer.releaseLock();
		}
		onTaskFinished();
		throw error;
	}
}

async function onMessage({ data }, workerData) {
	const { type, value, messageId, result, error } = data;
	const { reader, writer, resolveResult, rejectResult, onTaskFinished } = workerData;
	try {
		if (error) {
			const { message, stack, code, name } = error;
			const responseError = new Error(message);
			Object.assign(responseError, { stack, code, name });
			close(responseError);
		} else {
			if (type == MESSAGE_PULL) {
				const { value, done } = await reader.read();
				sendMessage({ type: MESSAGE_DATA, value, done, messageId }, workerData);
			}
			if (type == MESSAGE_DATA) {
				await writer.ready;
				await writer.write(new Uint8Array(value));
				sendMessage({ type: MESSAGE_ACK_DATA, messageId }, workerData);
			}
			if (type == MESSAGE_CLOSE) {
				close(null, result);
			}
		}
	} catch (error) {
		sendMessage({ type: MESSAGE_CLOSE, messageId }, workerData);
		close(error);
	}

	function close(error, result) {
		if (error) {
			rejectResult(error);
		} else {
			resolveResult(result);
		}
		if (writer) {
			writer.releaseLock();
		}
		onTaskFinished();
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


let pool = [];
const pendingRequests = [];

let indexWorker = 0;

async function runWorker(stream, workerOptions) {
	const { options, config } = workerOptions;
	const { transferStreams, useWebWorkers, useCompressionStream, codecType, compressed, signed, encrypted } = options;
	const { workerScripts, maxWorkers } = config;
	workerOptions.transferStreams = transferStreams || transferStreams === UNDEFINED_VALUE;
	const streamCopy = !compressed && !signed && !encrypted && !workerOptions.transferStreams;
	workerOptions.useWebWorkers = !streamCopy && (useWebWorkers || (useWebWorkers === UNDEFINED_VALUE && config.useWebWorkers));
	workerOptions.scripts = workerOptions.useWebWorkers && workerScripts ? workerScripts[codecType] : [];
	options.useCompressionStream = useCompressionStream || (useCompressionStream === UNDEFINED_VALUE && config.useCompressionStream);
	return (await getWorker()).run();

	// deno-lint-ignore require-await
	async function getWorker() {
		const workerData = pool.find(workerData => !workerData.busy);
		if (workerData) {
			clearTerminateTimeout(workerData);
			return new CodecWorker(workerData, stream, workerOptions, onTaskFinished);
		} else if (pool.length < maxWorkers) {
			const workerData = { indexWorker };
			indexWorker++;
			pool.push(workerData);
			return new CodecWorker(workerData, stream, workerOptions, onTaskFinished);
		} else {
			return new Promise(resolve => pendingRequests.push({ resolve, stream, workerOptions }));
		}
	}

	function onTaskFinished(workerData) {
		if (pendingRequests.length) {
			const [{ resolve, stream, workerOptions }] = pendingRequests.splice(0, 1);
			resolve(new CodecWorker(workerData, stream, workerOptions, onTaskFinished));
		} else if (workerData.worker) {
			clearTerminateTimeout(workerData);
			terminateWorker(workerData, workerOptions);
		} else {
			pool = pool.filter(data => data != workerData);
		}
	}
}

function terminateWorker(workerData, workerOptions) {
	const { config } = workerOptions;
	const { terminateWorkerTimeout } = config;
	if (Number.isFinite(terminateWorkerTimeout) && terminateWorkerTimeout >= 0) {
		if (workerData.terminated) {
			workerData.terminated = false;
		} else {
			workerData.terminateTimeout = setTimeout(async () => {
				pool = pool.filter(data => data != workerData);
				try {
					await workerData.terminate();
					// eslint-disable-next-line no-unused-vars
				} catch (_) {
					// ignored
				}
			}, terminateWorkerTimeout);
		}
	}
}

function clearTerminateTimeout(workerData) {
	const { terminateTimeout } = workerData;
	if (terminateTimeout) {
		clearTimeout(terminateTimeout);
		workerData.terminateTimeout = null;
	}
}

function e(e,t={}){const n='const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self,k=void 0,v="undefined",S="function";class z{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const C=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;C[e]=t}class x{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^C[255&(t^e[n])];this.t=t}get(){return~this.t}}class A extends p{constructor(){let e;const t=new x;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new i(4);new l(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}const _={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=_.i(n);return 32===r?e.concat(t):_.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+_.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=_.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=_.i(s);return r.push(_.h(t+i&31,t+i>32?n:r.pop(),1)),r}},I={bytes:{p(e){const t=_.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)3&s||(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},m(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3&~n||(t.push(r),r=0);return 3&n&&t.push(_.h(8*(3&n),r)),t}}},P=class{constructor(e){const t=this;t.blockSize=512,t.k=[1732584193,4023233417,2562383102,271733878,3285377520],t.v=[1518500249,1859775393,2400959708,3395469782],e?(t.S=e.S.slice(0),t.C=e.C.slice(0),t.A=e.A):t.reset()}reset(){const e=this;return e.S=e.k.slice(0),e.C=[],e.A=0,e}update(e){const t=this;"string"==typeof e&&(e=I._.m(e));const n=t.C=_.concat(t.C,e),r=t.A,i=t.A=r+_.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.I(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}P(){const e=this;let t=e.C;const n=e.S;t=_.concat(t,[_.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e.A/4294967296)),t.push(0|e.A);t.length;)e.I(t.splice(0,16));return e.reset(),n}D(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}V(e,t){return t<<e|t>>>32-e}I(t){const n=this,s=n.S,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.V(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.V(5,o)+n.D(e,c,f,a)+l+i[e]+n.v[r.floor(e/20)]|0;l=a,a=f,f=n.V(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},D={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},V={importKey:e=>new V.R(I.bytes.m(e)),B(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=_;for(t=I.bytes.m(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},R:class{constructor(e){const t=this,n=t.M=P,r=[[],[]];t.U=[new n,new n];const s=t.U[0].blockSize/32;e.length>s&&(e=(new n).update(e).P());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.U[0].update(r[0]),t.U[1].update(r[1]),t.K=new n(t.U[0])}reset(){const e=this;e.K=new e.M(e.U[0]),e.N=!1}update(e){this.N=!0,this.K.update(e)}digest(){const e=this,t=e.K.P(),n=new e.M(e.U[1]).update(t).P();return e.reset(),n}encrypt(e){if(this.N)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},R=typeof h!=v&&typeof h.getRandomValues==S,B="Invalid password",E="Invalid signature",M="zipjs-abort-check-password";function U(e){return R?h.getRandomValues(e):D.getRandomValues(e)}const K=16,N={name:"PBKDF2"},O=t.assign({hash:{name:"HMAC"}},N),T=t.assign({iterations:1e3,hash:{name:"SHA-1"}},N),W=["deriveBits"],j=[8,12,16],H=[16,24,32],L=10,F=[0,0,0,0],q=typeof h!=v,G=q&&h.subtle,J=q&&typeof G!=v,Q=I.bytes,X=class{constructor(e){const t=this;t.O=[[[],[],[],[],[]],[[],[],[],[],[]]],t.O[0][0][0]||t.T();const n=t.O[0][4],r=t.O[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.v=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.W(e,0)}decrypt(e){return this.W(e,1)}T(){const e=this.O[0],t=this.O[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}W(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.v[t],r=n.length/4-2,i=[0,0,0,0],o=this.O[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},Y=class{constructor(e,t){this.j=e,this.H=t,this.L=t}reset(){this.L=this.H}update(e){return this.F(this.j,e,this.L)}q(e){if(255&~(e>>24))e+=1<<24;else{let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}return e}G(e){0===(e[0]=this.q(e[0]))&&(e[1]=this.q(e[1]))}F(e,t,n){let r;if(!(r=t.length))return[];const s=_.l(t);for(let s=0;r>s;s+=4){this.G(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return _.u(t,s)}},Z=V.R;let $=q&&J&&typeof G.importKey==S,ee=q&&J&&typeof G.deriveBits==S;class te extends p{constructor({password:e,rawPassword:n,signed:r,encryptionStrength:o,checkPasswordOnly:c}){super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),signed:r,X:o-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:o,J:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await se(e,t,n,ce(r,0,j[t])),o=ce(r,j[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(B)})(n,o,r,ce(e,0,j[o]+2)),e=ce(e,j[o]+2),c?t.error(new s(M)):f()):await a;const l=new i(e.length-L-(e.length-L)%K);t.enqueue(re(n,e,l,0,L,!0))},async flush(e){const{signed:t,Y:n,Z:r,pending:o,ready:c}=this;if(r&&n){await c;const f=ce(o,0,o.length-L),a=ce(o,o.length-L);let l=new i;if(f.length){const e=ae(Q,f);r.update(e);const t=n.update(e);l=fe(Q,t)}if(t){const e=ce(fe(Q,r.digest()),0,L);for(let t=0;L>t;t++)if(e[t]!=a[t])throw new s(E)}e.enqueue(l)}}})}}class ne extends p{constructor({password:e,rawPassword:n,encryptionStrength:r}){let s;super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),X:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:s,J:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=U(new i(j[t]));return oe(r,await se(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%K);a.set(f,0),t.enqueue(re(n,e,a,f.length,0))},async flush(e){const{Y:t,Z:n,pending:r,ready:o}=this;if(n&&t){await o;let c=new i;if(r.length){const e=t.update(ae(Q,r));n.update(e),c=fe(Q,e)}s.signature=fe(Q,n.digest()).slice(0,L),e.enqueue(oe(c,s.signature))}}}),s=this}}function re(e,t,n,r,s,o){const{Y:c,Z:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=oe(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%K)),u=0;l-K>=u;u+=K){const e=ae(Q,ce(t,u,u+K));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(fe(Q,s),u+r)}return e.pending=ce(t,u),n}async function se(n,r,s,o){n.password=null;const c=await(async(e,t,n,r,s)=>{if(!$)return V.importKey(t);try{return await G.importKey("raw",t,n,!1,s)}catch(e){return $=!1,V.importKey(t)}})(0,s,O,0,W),f=await(async(e,t,n)=>{if(!ee)return V.B(t,e.salt,T.iterations,n);try{return await G.deriveBits(e,t,n)}catch(r){return ee=!1,V.B(t,e.salt,T.iterations,n)}})(t.assign({salt:o},T),c,8*(2*H[r]+2)),a=new i(f),l=ae(Q,ce(a,0,H[r])),u=ae(Q,ce(a,H[r],2*H[r])),w=ce(a,2*H[r]);return t.assign(n,{keys:{key:l,$:u,passwordVerification:w},Y:new Y(new X(l),e.from(F)),Z:new Z(u)}),w}function ie(e,t){return t===k?(e=>{if(typeof w==v){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(e):t}function oe(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ce(e,t,n){return e.subarray(t,n)}function fe(e,t){return e.p(t)}function ae(e,t){return e.m(t)}class le extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;if(n.password){const t=we(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(B);e=e.subarray(12)}r?t.error(new s(M)):t.enqueue(we(n,e))}})}}class ue extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=U(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(he(n,t),0),s=12}else r=new i(e.length),s=0;r.set(he(n,e),s),t.enqueue(r)}})}}function we(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,n[r]);return n}function he(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,t[r]);return n}function de(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,ee:new x(r[0]),te:new x(r[2])});for(let t=0;t<n.length;t++)pe(e,n.charCodeAt(t))}function pe(e,t){let[n,s,i]=e.keys;e.ee.append([t]),n=~e.ee.get(),s=be(r.imul(be(s+me(n)),134775813)+1),e.te.append([s>>>24]),i=~e.te.get(),e.keys=[n,s,i]}function ye(e){const t=2|e.keys[2];return me(r.imul(t,1^t)>>>8)}function me(e){return 255&e}function be(e){return 4294967295&e}const ge="deflate-raw";class ke extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=Se(super.readable);i&&!c||!f||(w=new A,d=xe(d,w)),s&&(d=Ce(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=xe(d,new ue(e)):(h=new ne(e),d=xe(d,h))),ze(u,d,(()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=new l(w.value.buffer).getUint32(0)),u.signature=e}))}}class ve extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=Se(super.readable);o&&(i?d=xe(d,new le(e)):(h=new te(e),d=xe(d,h))),a&&(d=Ce(d,u,{chunkSize:t},r,n)),o&&!i||!c||(w=new A,d=xe(d,w)),ze(this,d,(()=>{if((!o||i)&&c){const e=new l(w.value.buffer);if(f!=e.getUint32(0,!1))throw new s(E)}}))}}function Se(e){return xe(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ze(e,n,r){n=xe(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Ce(e,t,n,r,s){try{e=xe(e,new(t&&r?r:s)(ge,n))}catch(r){if(!t)return e;try{e=xe(e,new s(ge,n))}catch(t){return e}}return e}function xe(e,t){return e.pipeThrough(t)}const Ae="data",_e="close";class Ie extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=ke:s.startsWith("inflate")&&(i=ve);let o=0,c=0;const f=new i(e,n),a=super.readable,l=new p({transform(e,t){e&&e.length&&(c+=e.length,t.enqueue(e))},flush(){t.assign(r,{inputSize:c})}}),u=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=f;t.assign(r,{signature:e,outputSize:o,inputSize:c})}});t.defineProperty(r,"readable",{get:()=>a.pipeThrough(l).pipeThrough(f).pipeThrough(u)})}}class Pe extends p{constructor(e){let t;super({transform:function n(r,s){if(t){const e=new i(t.length+r.length);e.set(t),e.set(r,t.length),r=e,t=null}r.length>e?(s.enqueue(r.slice(0,e)),n(r.slice(e),s)):t=r},flush(e){t&&t.length&&e.enqueue(t)}})}}const De=new a,Ve=new a;let Re,Be=0,Ee=!0;async function Me(e){try{const{options:t,scripts:r,config:s}=e;if(r&&r.length)try{Ee?importScripts.apply(k,r):await Ue(r)}catch(e){Ee=!1,await Ue(r)}self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new z(self.Deflate)),self.Inflate&&(s.DecompressionStream=new z(self.Inflate));const i={highWaterMark:1},o=e.readable||new y({async pull(e){const t=new u((e=>De.set(Be,e)));Ke({type:"pull",messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ve.set(Be,t),Ke({type:Ae,value:e,messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new Ie(t,s);Re=new AbortController;const{signal:a}=Re;await o.pipeThrough(f).pipeThrough(new Pe(s.chunkSize)).pipeTo(c,{signal:a,preventClose:!0,preventAbort:!0}),await c.getWriter().close();const{signature:l,inputSize:w,outputSize:h}=f;Ke({type:_e,result:{signature:l,inputSize:w,outputSize:h}})}catch(e){Ne(e)}}async function Ue(e){for(const t of e)await import(t)}function Ke(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Ne(e=new s("Unknown error")){const{message:t,stack:n,code:r,name:i}=e;d({error:{message:t,stack:n,code:r,name:i}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&Me(e),t==Ae){const e=De.get(n);De.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ve.get(n);Ve.delete(n),e()}t==_e&&Re.abort()}catch(e){Ne(e)}}));const Oe=-2;function Te(t){return We(t.map((([t,n])=>new e(t).fill(n,0,t))))}function We(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?We(n):n)),[])}const je=[0,1,2,3].concat(...Te([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function He(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.ne=n=>{const s=e.re,i=e.ie.se,o=e.ie.oe;let c,f,a,l=-1;for(n.ce=0,n.fe=573,c=0;o>c;c++)0!==s[2*c]?(n.ae[++n.ce]=l=c,n.le[c]=0):s[2*c+1]=0;for(;2>n.ce;)a=n.ae[++n.ce]=2>l?++l:0,s[2*a]=1,n.le[a]=0,n.ue--,i&&(n.we-=i[2*a+1]);for(e.he=l,c=r.floor(n.ce/2);c>=1;c--)n.de(s,c);a=o;do{c=n.ae[1],n.ae[1]=n.ae[n.ce--],n.de(s,1),f=n.ae[1],n.ae[--n.fe]=c,n.ae[--n.fe]=f,s[2*a]=s[2*c]+s[2*f],n.le[a]=r.max(n.le[c],n.le[f])+1,s[2*c+1]=s[2*f+1]=a,n.ae[1]=a++,n.de(s,1)}while(n.ce>=2);n.ae[--n.fe]=n.ae[1],(t=>{const n=e.re,r=e.ie.se,s=e.ie.pe,i=e.ie.ye,o=e.ie.me;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.be[l]=0;for(n[2*t.ae[t.fe]+1]=0,c=t.fe+1;573>c;c++)f=t.ae[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.he||(t.be[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.ue+=w*(l+u),r&&(t.we+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.be[l];)l--;t.be[l]--,t.be[l+1]+=2,t.be[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.be[l];0!==f;)a=t.ae[--c],a>e.he||(n[2*a+1]!=l&&(t.ue+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.he,n.be)}}function Le(e,t,n,r,s){const i=this;i.se=e,i.pe=t,i.ye=n,i.oe=r,i.me=s}He.ge=[0,1,2,3,4,5,6,7].concat(...Te([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),He.ke=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],He.ve=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],He.Se=e=>256>e?je[e]:je[256+(e>>>7)],He.ze=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],He.Ce=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],He.xe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],He.Ae=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Fe=Te([[144,8],[112,9],[24,7],[8,8]]);Le._e=We([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Fe[t]])));const qe=Te([[30,5]]);function Ge(e,t,n,r,s){const i=this;i.Ie=e,i.Pe=t,i.De=n,i.Ve=r,i.Re=s}Le.Be=We([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,qe[t]]))),Le.Ee=new Le(Le._e,He.ze,257,286,15),Le.Me=new Le(Le.Be,He.Ce,0,30,15),Le.Ue=new Le(null,He.xe,0,19,7);const Je=[new Ge(0,0,0,0,0),new Ge(4,4,8,4,1),new Ge(4,5,16,8,1),new Ge(4,6,32,32,1),new Ge(4,4,16,16,2),new Ge(8,16,32,32,2),new Ge(8,16,128,128,2),new Ge(8,32,128,256,2),new Ge(32,128,258,1024,2),new Ge(32,258,258,4096,2)],Qe=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],Xe=113,Ye=666,Ze=262;function $e(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function et(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,A,_,I,P,D,V,R,B,E,M,U;const K=new He,N=new He,O=new He;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)U[2*t]=0;E[512]=1,e.ue=e.we=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?U[2*n]+=i:0!==n?(n!=r&&U[2*n]++,U[32]++):i>10?U[36]++:U[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ke[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,U)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,U),o--),Y(16,U),X(o-3,2)):o>10?(Y(18,U),X(o-11,7)):(Y(17,U),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Ne[W]=t,e.Oe[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(He.ge[n]+256+1)]++,M[2*He.Se(t)]++),!(8191&W)&&D>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+He.Ce[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Ne[c],s=e.Oe[c],c++,0===r?Y(s,t):(i=He.ge[s],Y(i+256+1,t),o=He.ze[i],0!==o&&(s-=He.ke[i],X(s,o)),r--,i=He.Se(r),Y(i,n),o=He.Ce[i],0!==o&&(r-=He.ve[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ke.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;D>0?(K.ne(e),N.ne(e),o=(()=>{let t;for(G(E,K.he),G(M,N.he),O.ne(e),t=18;t>=3&&0===U[2*He.Ae[t]+1];t--);return e.ue+=14+3*(t+1),t})(),s=e.ue+3+7>>>3,i=e.we+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Le._e,Le.Be)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(U[2*He.Ae[r]+1],3);Z(E,e-1),Z(M,t-1)})(K.he+1,N.he+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.Te()}function ie(){let e,n,r,s;do{if(s=w-A-C,0===s&&0===C&&0===A)s=f;else if(-1==s)s--;else if(C>=f+f-Ze){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.We)return;e=t.je(u,C+A,s),A+=e,3>A||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Ze>A&&0!==t.We)}function oe(e){let t,n,r=I,s=C,i=_;const o=C>f-Ze?C-(f-Ze):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>_||(r>>=2),c>A&&(c=A);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>A?A:i}e.le=[],e.be=[],e.ae=[],E=[],M=[],U=[],e.de=(t,n)=>{const r=e.ae,s=r[n];let i=n<<1;for(;i<=e.ce&&(i<e.ce&&$e(t,r[i+1],r[i],e.le)&&i++,!$e(t,s,r[i],e.le));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.He=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Le=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Oe:(t.Fe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ke=new i(4*T),s=4*T,e.Ne=new o(T),e.Oe=new i(T),D=S,V=G,(t=>(t.qe=t.Ge=0,t.Le=null,e.pending=0,e.Je=0,n=Xe,c=0,K.re=E,K.ie=Le.Ee,N.re=M,N.ie=Le.Me,O.re=U,O.ie=Le.Ue,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve,C=0,k=0,A=0,v=_=2,z=0,p=0})(),0))(t))),e.Qe=()=>42!=n&&n!=Xe&&n!=Ye?Oe:(e.Oe=null,e.Ne=null,e.Ke=null,d=null,h=null,u=null,e.Fe=null,n==Xe?-3:0),e.Xe=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Oe:(Je[D].Re!=Je[t].Re&&0!==e.qe&&(r=e.Ye(1)),D!=t&&(D=t,P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve),V=n,r)},e.Ze=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Oe;if(3>i)return 0;for(i>f-Ze&&(i=f-Ze,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ye=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Oe;if(!r.$e||!r.et&&0!==r.We||n==Ye&&4!=i)return r.Le=Qe[4],Oe;if(0===r.tt)return r.Le=Qe[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(D-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=Xe,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.Te(),0===t.tt)return c=-1,0}else if(0===t.We&&I>=i&&4!=i)return t.Le=Qe[7],-5;if(n==Ye&&0!==t.We)return r.Le=Qe[7],-5;if(0!==t.We||0!==A||0!=i&&n!=Ye){switch(R=-1,Je[D].Re){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=A){if(ie(),0===A&&0==e)return 0;if(0===A)break}if(C+=A,A=0,n=k+r,(0===C||C>=n)&&(A=C-n,C=n,se(!1),0===t.tt))return 0;if(C-k>=f-Ze&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Ze||2!=V&&(v=oe(r)),3>v)n=ee(0,255&u[C]),A--,C++;else if(n=ee(C-x,v-3),A-=v,v>P||3>A)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),_=v,S=x,v=2,0!==s&&P>_&&f-Ze>=(C-s&65535)&&(2!=V&&(v=oe(s)),5>=v&&(1==V||3==v&&C-x>4096)&&(v=2)),3>_||v>_)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,A--,0===t.tt)return 0}else z=1,C++,A--;else{r=C+A-3,n=ee(C-1-S,_-3),A-=_-1,_-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--_);if(z=0,v=2,C++,n&&(se(!1),0===t.tt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Ye),0==R||2==R)return 0===t.tt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Le._e),$(),9>1+H+10-F&&(X(2,3),Y(256,Le._e),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.Te(),0===t.tt)return c=-1,0}}return 4!=i?0:1}}function tt(){const e=this;e.nt=0,e.rt=0,e.We=0,e.qe=0,e.tt=0,e.Ge=0}function nt(e){const t=new tt,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.He(f),t.$e=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,o=t.Ye(0),0!=o)throw new s("deflating: "+t.Le);t.rt&&(t.rt==n?w.push(new i(c)):w.push(c.subarray(0,t.rt))),u+=t.rt,r&&t.nt>0&&t.nt!=a&&(r(t.nt),a=t.nt)}while(t.We>0||0===t.tt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]?new i(w[0]):new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.rt=0,t.tt=n,e=t.Ye(4),1!=e&&0!=e)throw new s("deflating: "+t.Le);n-t.tt>0&&a.push(c.slice(0,t.rt)),f+=t.rt}while(t.We>0||0===t.tt);return t.Qe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}tt.prototype={He(e,t){const n=this;return n.Fe=new et,t||(t=15),n.Fe.He(n,e,t)},Ye(e){const t=this;return t.Fe?t.Fe.Ye(t,e):Oe},Qe(){const e=this;if(!e.Fe)return Oe;const t=e.Fe.Qe();return e.Fe=null,t},Xe(e,t){const n=this;return n.Fe?n.Fe.Xe(n,e,t):Oe},Ze(e,t){const n=this;return n.Fe?n.Fe.Ze(n,e,t):Oe},je(e,t,n){const r=this;let s=r.We;return s>n&&(s=n),0===s?0:(r.We-=s,e.set(r.et.subarray(r.nt,r.nt+s),t),r.nt+=s,r.qe+=s,s)},Te(){const e=this;let t=e.Fe.pending;t>e.tt&&(t=e.tt),0!==t&&(e.$e.set(e.Fe.Ke.subarray(e.Fe.Je,e.Fe.Je+t),e.rt),e.rt+=t,e.Fe.Je+=t,e.Ge+=t,e.tt-=t,e.Fe.pending-=t,0===e.Fe.pending&&(e.Fe.Je=0))}};const rt=-2,st=-3,it=-5,ot=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],ct=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],ft=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],at=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],lt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],ut=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],wt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ht(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,A,_,I,P;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return st;if(0>(I-=n[g]))return st;for(n[g]+=I,i[1]=k=0,C=1,_=2;0!=--g;)i[_]=k+=n[C],_++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,A=-S,s[0]=0,x=0,P=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>A+S;){if(b++,A+=S,P=m-A,P=P>S?S:P,(y=1<<(k=v-A))>p+1&&(y-=p+1,_=v,P>k))for(;++k<P&&(y<<=1)>n[++_];)y-=n[_];if(P=1<<k,h[0]+P>1440)return st;s[b]=x=h[0],h[0]+=P,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>A-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-A,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-A,k=g>>>A;P>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;g&k;k>>>=1)g^=k;for(g^=k,z=(1<<A)-1;(g&z)!=i[b];)b--,A-=S,z=(1<<A)-1}return 0!==I&&1!=m?it:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.st=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==st?f.Le="oversubscribed dynamic bit lengths tree":a!=it&&0!==r[0]||(f.Le="incomplete dynamic bit lengths tree",a=st),a},this.it=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,at,lt,a,i,u,e,t),0!=h||0===i[0]?(h==st?w.Le="oversubscribed literal/length tree":-4!=h&&(w.Le="incomplete literal/length tree",h=st),h):(c(288),h=o(s,n,r,0,ut,wt,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==st?w.Le="oversubscribed distance tree":h==it?(w.Le="incomplete distance tree",h=st):-4!=h&&(w.Le="empty distance tree with lengths",h=st),h):0)}}function dt(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.nt,p=c.We,w=o.ot,h=o.ct,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=ot[e],g=ot[t];do{for(;20>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15,k=a[z+2]+(w&ot[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15;u>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(v=a[z+2]+(w&ot[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--u);else o.lt.set(o.lt.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.lt[y++]=o.lt[S++],o.lt[y++]=o.lt[S++],k-=2):(o.lt.set(o.lt.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--k);else o.lt.set(o.lt.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(64&u)return c.Le="invalid distance code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st;f+=a[z+2],f+=w&ot[u],z=3*(l+f),u=a[z]}break}if(64&u)return 32&u?(k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,1):(c.Le="invalid literal/length code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st);if(f+=a[z+2],f+=w&ot[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.ut=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,A=0,_=0;for(_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,m=p(u,w,r,h,s,d,e,y),_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>>=n[g+1],A-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(16&k){a=15&k,i=n[g+2],t=2;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}if(32&k){t=7;break}return t=9,y.Le="invalid literal/length code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 2:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}i+=x&ot[b],x>>=b,A-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>=n[g+1],A-=n[g+1],k=n[g],16&k){a=15&k,l=n[g+2],t=4;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Le="invalid distance code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 4:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}l+=x&ot[b],x>>=b,A-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);e.lt[S++]=e.lt[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,e.lt[S++]=f,z--,t=0;break;case 7:if(A>7&&(A-=8,v++,_--),e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);t=8;case 8:return m=1,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 9:return m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);default:return m=rt,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m)}},e.ht=()=>{}}ht.dt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=ct,r[0]=ft,0);const pt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function yt(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new dt;let h=0,d=new f(4320);const p=new ht;n.ct=0,n.ot=0,n.lt=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.ht(e),s=0,n.ct=0,n.ot=0,n.read=n.write=0},n.reset(e,null),n.wt=(e,t)=>{let r,s,i;return s=e.rt,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r),e.rt=s,n.read=i,t},n.ut=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,A,_,I,P;switch(s){case 0:for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ht.dt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Le="invalid block type",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Le="invalid stored block lengths",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.lt.set(e.je(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Le="too many length or distance symbols",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}r[pt[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[pt[a++]]=0;if(l[0]=7,i=p.st(r,l,u,d,e),0!=i)return(t=i)==st&&(r=null,s=9),n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&ot[i]))+1],w=d[3*(u[0]+(f&ot[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&ot[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Le="invalid bit length repeat",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,A=[],_=[],I=[],P=[],A[0]=9,_[0]=6,i=c,i=p.it(257+(31&i),1+(i>>5&31),r,A,_,I,P,d,e),0!=i)return i==st&&(r=null,s=9),t=i,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w.init(A[0],_[0],d,I[0],d,P[0]),s=6;case 6:if(n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,1!=(t=w.ut(n,e,t)))return n.wt(e,t);if(t=0,w.ht(e),m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);s=8;case 8:return t=1,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);case 9:return t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);default:return t=rt,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}}},n.ht=e=>{n.reset(e,null),n.lt=null,d=null},n.yt=(e,t,r)=>{n.lt.set(e.subarray(t,t+r),0),n.read=n.write=r},n.bt=()=>1==s?1:0}const mt=13,bt=[0,0,255,255];function gt(){const e=this;function t(e){return e&&e.gt?(e.qe=e.Ge=0,e.Le=null,e.gt.mode=7,e.gt.kt.reset(e,null),0):rt}e.mode=0,e.method=0,e.vt=[0],e.St=0,e.marker=0,e.zt=0,e.Ct=t=>(e.kt&&e.kt.ht(t),e.kt=null,0),e.xt=(n,r)=>(n.Le=null,e.kt=null,8>r||r>15?(e.Ct(n),rt):(e.zt=r,n.gt.kt=new yt(n,1<<r),t(n),0)),e.At=(e,t)=>{let n,r;if(!e||!e.gt||!e.et)return rt;const s=e.gt;for(t=4==t?it:0,n=it;;)switch(s.mode){case 0:if(0===e.We)return n;if(n=t,e.We--,e.qe++,8!=(15&(s.method=e.ft(e.nt++)))){s.mode=mt,e.Le="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.zt){s.mode=mt,e.Le="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.We)return n;if(n=t,e.We--,e.qe++,r=255&e.ft(e.nt++),((s.method<<8)+r)%31!=0){s.mode=mt,e.Le="incorrect header check",s.marker=5;break}if(!(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St=(255&e.ft(e.nt++))<<24&4278190080,s.mode=3;case 3:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<16&16711680,s.mode=4;case 4:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<8&65280,s.mode=5;case 5:return 0===e.We?n:(n=t,e.We--,e.qe++,s.St+=255&e.ft(e.nt++),s.mode=6,2);case 6:return s.mode=mt,e.Le="need dictionary",s.marker=0,rt;case 7:if(n=s.kt.ut(e,n),n==st){s.mode=mt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.kt.reset(e,s.vt),s.mode=12;case 12:return e.We=0,1;case mt:return st;default:return rt}},e._t=(e,t,n)=>{let r=0,s=n;if(!e||!e.gt||6!=e.gt.mode)return rt;const i=e.gt;return s<1<<i.zt||(s=(1<<i.zt)-1,r=n-s),i.kt.yt(t,r,s),i.mode=7,0},e.It=e=>{let n,r,s,i,o;if(!e||!e.gt)return rt;const c=e.gt;if(c.mode!=mt&&(c.mode=mt,c.marker=0),0===(n=e.We))return it;for(r=e.nt,s=c.marker;0!==n&&4>s;)e.ft(r)==bt[s]?s++:s=0!==e.ft(r)?0:4-s,r++,n--;return e.qe+=r-e.nt,e.nt=r,e.We=n,c.marker=s,4!=s?st:(i=e.qe,o=e.Ge,t(e),e.qe=i,e.Ge=o,c.mode=7,0)},e.Pt=e=>e&&e.gt&&e.gt.kt?e.gt.kt.bt():rt}function kt(){}function vt(e){const t=new kt,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.xt(),t.$e=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,0!==t.We||c||(t.nt=0,c=!0),a=t.At(0),c&&a===it){if(0!==t.We)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Le);if((c||1===a)&&t.We===e.length)throw new s("inflating: bad input");t.rt&&(t.rt===n?f.push(new i(o)):f.push(o.subarray(0,t.rt))),h+=t.rt,r&&t.nt>0&&t.nt!=u&&(r(t.nt),u=t.nt)}while(t.We>0||0===t.tt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]?new i(f[0]):new i,l}},this.flush=()=>{t.Ct()}}kt.prototype={xt(e){const t=this;return t.gt=new gt,e||(e=15),t.gt.xt(t,e)},At(e){const t=this;return t.gt?t.gt.At(t,e):rt},Ct(){const e=this;if(!e.gt)return rt;const t=e.gt.Ct(e);return e.gt=null,t},It(){const e=this;return e.gt?e.gt.It(e):rt},_t(e,t){const n=this;return n.gt?n.gt._t(n,e,t):rt},ft(e){return this.et[e]},je(e,t){return this.et.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=nt,self.Inflate=vt};\n',r=()=>t.useDataURI?"data:text/javascript,"+encodeURIComponent(n):URL.createObjectURL(new Blob([n],{type:"text/javascript"}));e({workerScripts:{inflate:[r],deflate:[r]}});}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const ERR_ITERATOR_COMPLETED_TOO_SOON = "Writer iterator completed too soon";
const HTTP_HEADER_CONTENT_TYPE = "Content-Type";
const DEFAULT_CHUNK_SIZE = 64 * 1024;

const PROPERTY_NAME_WRITABLE = "writable";

class Stream {

	constructor() {
		this.size = 0;
	}

	init() {
		this.initialized = true;
	}
}

class Reader extends Stream {

	get readable() {
		const reader = this;
		const { chunkSize = DEFAULT_CHUNK_SIZE } = reader;
		const readable = new ReadableStream({
			start() {
				this.chunkOffset = 0;
			},
			async pull(controller) {
				const { offset = 0, size, diskNumberStart } = readable;
				const { chunkOffset } = this;
				controller.enqueue(await readUint8Array(reader, offset + chunkOffset, Math.min(chunkSize, size - chunkOffset), diskNumberStart));
				if (chunkOffset + chunkSize > size) {
					controller.close();
				} else {
					this.chunkOffset += chunkSize;
				}
			}
		});
		return readable;
	}
}

class Writer extends Stream {

	constructor() {
		super();
		const writer = this;
		const writable = new WritableStream({
			write(chunk) {
				return writer.writeUint8Array(chunk);
			}
		});
		Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
			get() {
				return writable;
			}
		});
	}

	writeUint8Array() {
		// abstract
	}
}

class BlobReader extends Reader {

	constructor(blob) {
		super();
		Object.assign(this, {
			blob,
			size: blob.size
		});
	}

	async readUint8Array(offset, length) {
		const reader = this;
		const offsetEnd = offset + length;
		const blob = offset || offsetEnd < reader.size ? reader.blob.slice(offset, offsetEnd) : reader.blob;
		let arrayBuffer = await blob.arrayBuffer();
		if (arrayBuffer.byteLength > length) {
			arrayBuffer = arrayBuffer.slice(offset, offsetEnd);
		}
		return new Uint8Array(arrayBuffer);
	}
}

class BlobWriter extends Stream {

	constructor(contentType) {
		super();
		const writer = this;
		const transformStream = new TransformStream();
		const headers = [];
		if (contentType) {
			headers.push([HTTP_HEADER_CONTENT_TYPE, contentType]);
		}
		Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
			get() {
				return transformStream.writable;
			}
		});
		writer.blob = new Response(transformStream.readable, { headers }).blob();
	}

	getData() {
		return this.blob;
	}
}


class Uint8ArrayReader extends Reader {

	constructor(array) {
		super();
		Object.assign(this, {
			array,
			size: array.length
		});
	}

	readUint8Array(index, length) {
		return this.array.slice(index, index + length);
	}
}

class Uint8ArrayWriter extends Writer {

	init(initSize = 0) {
		Object.assign(this, {
			offset: 0,
			array: new Uint8Array(initSize)
		});
		super.init();
	}

	writeUint8Array(array) {
		const writer = this;
		if (writer.offset + array.length > writer.array.length) {
			const previousArray = writer.array;
			writer.array = new Uint8Array(previousArray.length + array.length);
			writer.array.set(previousArray);
		}
		writer.array.set(array, writer.offset);
		writer.offset += array.length;
	}

	getData() {
		return this.array;
	}
}

class SplitDataReader extends Reader {

	constructor(readers) {
		super();
		this.readers = readers;
	}

	async init() {
		const reader = this;
		const { readers } = reader;
		reader.lastDiskNumber = 0;
		reader.lastDiskOffset = 0;
		await Promise.all(readers.map(async (diskReader, indexDiskReader) => {
			await diskReader.init();
			if (indexDiskReader != readers.length - 1) {
				reader.lastDiskOffset += diskReader.size;
			}
			reader.size += diskReader.size;
		}));
		super.init();
	}

	async readUint8Array(offset, length, diskNumber = 0) {
		const reader = this;
		const { readers } = this;
		let result;
		let currentDiskNumber = diskNumber;
		if (currentDiskNumber == -1) {
			currentDiskNumber = readers.length - 1;
		}
		let currentReaderOffset = offset;
		while (currentReaderOffset >= readers[currentDiskNumber].size) {
			currentReaderOffset -= readers[currentDiskNumber].size;
			currentDiskNumber++;
		}
		const currentReader = readers[currentDiskNumber];
		const currentReaderSize = currentReader.size;
		if (currentReaderOffset + length <= currentReaderSize) {
			result = await readUint8Array(currentReader, currentReaderOffset, length);
		} else {
			const chunkLength = currentReaderSize - currentReaderOffset;
			result = new Uint8Array(length);
			result.set(await readUint8Array(currentReader, currentReaderOffset, chunkLength));
			result.set(await reader.readUint8Array(offset + chunkLength, length - chunkLength, diskNumber), chunkLength);
		}
		reader.lastDiskNumber = Math.max(currentDiskNumber, reader.lastDiskNumber);
		return result;
	}
}

class SplitDataWriter extends Stream {

	constructor(writerGenerator, maxSize = 4294967295) {
		super();
		const writer = this;
		Object.assign(writer, {
			diskNumber: 0,
			diskOffset: 0,
			size: 0,
			maxSize,
			availableSize: maxSize
		});
		let diskSourceWriter, diskWritable, diskWriter;
		const writable = new WritableStream({
			async write(chunk) {
				const { availableSize } = writer;
				if (!diskWriter) {
					const { value, done } = await writerGenerator.next();
					if (done && !value) {
						throw new Error(ERR_ITERATOR_COMPLETED_TOO_SOON);
					} else {
						diskSourceWriter = value;
						diskSourceWriter.size = 0;
						if (diskSourceWriter.maxSize) {
							writer.maxSize = diskSourceWriter.maxSize;
						}
						writer.availableSize = writer.maxSize;
						await initStream(diskSourceWriter);
						diskWritable = value.writable;
						diskWriter = diskWritable.getWriter();
					}
					await this.write(chunk);
				} else if (chunk.length >= availableSize) {
					await writeChunk(chunk.slice(0, availableSize));
					await closeDisk();
					writer.diskOffset += diskSourceWriter.size;
					writer.diskNumber++;
					diskWriter = null;
					await this.write(chunk.slice(availableSize));
				} else {
					await writeChunk(chunk);
				}
			},
			async close() {
				await diskWriter.ready;
				await closeDisk();
			}
		});
		Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
			get() {
				return writable;
			}
		});

		async function writeChunk(chunk) {
			const chunkLength = chunk.length;
			if (chunkLength) {
				await diskWriter.ready;
				await diskWriter.write(chunk);
				diskSourceWriter.size += chunkLength;
				writer.size += chunkLength;
				writer.availableSize -= chunkLength;
			}
		}

		async function closeDisk() {
			diskWritable.size = diskSourceWriter.size;
			await diskWriter.close();
		}
	}
}

async function initStream(stream, initSize) {
	if (stream.init && !stream.initialized) {
		await stream.init(initSize);
	} else {
		return Promise.resolve();
	}
}

function initReader(reader) {
	if (Array.isArray(reader)) {
		reader = new SplitDataReader(reader);
	}
	if (reader instanceof ReadableStream) {
		reader = {
			readable: reader
		};
	}
	return reader;
}

function initWriter(writer) {
	if (writer.writable === UNDEFINED_VALUE && typeof writer.next == FUNCTION_TYPE) {
		writer = new SplitDataWriter(writer);
	}
	if (writer instanceof WritableStream) {
		writer = {
			writable: writer
		};
	}
	const { writable } = writer;
	if (writable.size === UNDEFINED_VALUE) {
		writable.size = 0;
	}
	if (!(writer instanceof SplitDataWriter)) {
		Object.assign(writer, {
			diskNumber: 0,
			diskOffset: 0,
			availableSize: Infinity,
			maxSize: Infinity
		});
	}
	return writer;
}

function readUint8Array(reader, offset, size, diskNumber) {
	return reader.readUint8Array(offset, size, diskNumber);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* global TextDecoder */

const CP437 = "\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ".split("");
const VALID_CP437 = CP437.length == 256;

function decodeCP437(stringValue) {
	if (VALID_CP437) {
		let result = "";
		for (let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++) {
			result += CP437[stringValue[indexCharacter]];
		}
		return result;
	} else {
		return new TextDecoder().decode(stringValue);
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


function decodeText(value, encoding) {
	if (encoding && encoding.trim().toLowerCase() == "cp437") {
		return decodeCP437(value);
	} else {
		return new TextDecoder(encoding).decode(value);
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const PROPERTY_NAME_FILENAME = "filename";
const PROPERTY_NAME_RAW_FILENAME = "rawFilename";
const PROPERTY_NAME_COMMENT = "comment";
const PROPERTY_NAME_RAW_COMMENT = "rawComment";
const PROPERTY_NAME_UNCOMPPRESSED_SIZE = "uncompressedSize";
const PROPERTY_NAME_COMPPRESSED_SIZE = "compressedSize";
const PROPERTY_NAME_OFFSET = "offset";
const PROPERTY_NAME_DISK_NUMBER_START = "diskNumberStart";
const PROPERTY_NAME_LAST_MODIFICATION_DATE = "lastModDate";
const PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE = "rawLastModDate";
const PROPERTY_NAME_LAST_ACCESS_DATE = "lastAccessDate";
const PROPERTY_NAME_RAW_LAST_ACCESS_DATE = "rawLastAccessDate";
const PROPERTY_NAME_CREATION_DATE = "creationDate";
const PROPERTY_NAME_RAW_CREATION_DATE = "rawCreationDate";
const PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE = "internalFileAttribute";
const PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES = "internalFileAttributes";
const PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE = "externalFileAttribute";
const PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES = "externalFileAttributes";
const PROPERTY_NAME_MS_DOS_COMPATIBLE = "msDosCompatible";
const PROPERTY_NAME_ZIP64 = "zip64";
const PROPERTY_NAME_ENCRYPTED = "encrypted";
const PROPERTY_NAME_VERSION = "version";
const PROPERTY_NAME_VERSION_MADE_BY = "versionMadeBy";
const PROPERTY_NAME_ZIPCRYPTO = "zipCrypto";
const PROPERTY_NAME_DIRECTORY = "directory";
const PROPERTY_NAME_EXECUTABLE = "executable";

const PROPERTY_NAMES = [
	PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, PROPERTY_NAME_COMPPRESSED_SIZE, PROPERTY_NAME_UNCOMPPRESSED_SIZE,
	PROPERTY_NAME_LAST_MODIFICATION_DATE, PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT,
	PROPERTY_NAME_LAST_ACCESS_DATE, PROPERTY_NAME_CREATION_DATE, PROPERTY_NAME_OFFSET, PROPERTY_NAME_DISK_NUMBER_START,
	PROPERTY_NAME_DISK_NUMBER_START, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES, PROPERTY_NAME_MS_DOS_COMPATIBLE, PROPERTY_NAME_ZIP64, PROPERTY_NAME_ENCRYPTED, PROPERTY_NAME_VERSION, PROPERTY_NAME_VERSION_MADE_BY, PROPERTY_NAME_ZIPCRYPTO, PROPERTY_NAME_DIRECTORY, PROPERTY_NAME_EXECUTABLE, "bitFlag", "signature", "filenameUTF8", "commentUTF8", "compressionMethod", "extraField", "rawExtraField", "extraFieldZip64", "extraFieldUnicodePath", "extraFieldUnicodeComment", "extraFieldAES", "extraFieldNTFS", "extraFieldExtendedTimestamp"];

class Entry {

	constructor(data) {
		PROPERTY_NAMES.forEach(name => this[name] = data[name]);
	}

}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const ERR_BAD_FORMAT = "File format is not recognized";
const ERR_EOCDR_NOT_FOUND = "End of central directory not found";
const ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
const ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
const ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
const ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
const ERR_ENCRYPTED = "File contains encrypted entry";
const ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
const ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
const ERR_SPLIT_ZIP_FILE = "Split zip file";
const CHARSET_UTF8 = "utf-8";
const CHARSET_CP437 = "cp437";
const ZIP64_PROPERTIES = [
	[PROPERTY_NAME_UNCOMPPRESSED_SIZE, MAX_32_BITS],
	[PROPERTY_NAME_COMPPRESSED_SIZE, MAX_32_BITS],
	[PROPERTY_NAME_OFFSET, MAX_32_BITS],
	[PROPERTY_NAME_DISK_NUMBER_START, MAX_16_BITS]
];
const ZIP64_EXTRACTION = {
	[MAX_16_BITS]: {
		getValue: getUint32,
		bytes: 4
	},
	[MAX_32_BITS]: {
		getValue: getBigUint64,
		bytes: 8
	}
};

class ZipReader {

	constructor(reader, options = {}) {
		Object.assign(this, {
			reader: initReader(reader),
			options,
			config: getConfiguration()
		});
	}

	async* getEntriesGenerator(options = {}) {
		const zipReader = this;
		let { reader } = zipReader;
		const { config } = zipReader;
		await initStream(reader);
		if (reader.size === UNDEFINED_VALUE || !reader.readUint8Array) {
			reader = new BlobReader(await new Response(reader.readable).blob());
			await initStream(reader);
		}
		if (reader.size < END_OF_CENTRAL_DIR_LENGTH) {
			throw new Error(ERR_BAD_FORMAT);
		}
		reader.chunkSize = getChunkSize(config);
		const endOfDirectoryInfo = await seekSignature(reader, END_OF_CENTRAL_DIR_SIGNATURE, reader.size, END_OF_CENTRAL_DIR_LENGTH, MAX_16_BITS * 16);
		if (!endOfDirectoryInfo) {
			const signatureArray = await readUint8Array(reader, 0, 4);
			const signatureView = getDataView$1(signatureArray);
			if (getUint32(signatureView) == SPLIT_ZIP_FILE_SIGNATURE) {
				throw new Error(ERR_SPLIT_ZIP_FILE);
			} else {
				throw new Error(ERR_EOCDR_NOT_FOUND);
			}
		}
		const endOfDirectoryView = getDataView$1(endOfDirectoryInfo);
		let directoryDataLength = getUint32(endOfDirectoryView, 12);
		let directoryDataOffset = getUint32(endOfDirectoryView, 16);
		const commentOffset = endOfDirectoryInfo.offset;
		const commentLength = getUint16(endOfDirectoryView, 20);
		const appendedDataOffset = commentOffset + END_OF_CENTRAL_DIR_LENGTH + commentLength;
		let lastDiskNumber = getUint16(endOfDirectoryView, 4);
		const expectedLastDiskNumber = reader.lastDiskNumber || 0;
		let diskNumber = getUint16(endOfDirectoryView, 6);
		let filesLength = getUint16(endOfDirectoryView, 8);
		let prependedDataLength = 0;
		let startOffset = 0;
		if (directoryDataOffset == MAX_32_BITS || directoryDataLength == MAX_32_BITS || filesLength == MAX_16_BITS || diskNumber == MAX_16_BITS) {
			const endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH);
			const endOfDirectoryLocatorView = getDataView$1(endOfDirectoryLocatorArray);
			if (getUint32(endOfDirectoryLocatorView, 0) == ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE) {
				directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
				let endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
				let endOfDirectoryView = getDataView$1(endOfDirectoryArray);
				const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH - ZIP64_END_OF_CENTRAL_DIR_LENGTH;
				if (getUint32(endOfDirectoryView, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
					const originalDirectoryDataOffset = directoryDataOffset;
					directoryDataOffset = expectedDirectoryDataOffset;
					prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
					endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
					endOfDirectoryView = getDataView$1(endOfDirectoryArray);
				}
				if (getUint32(endOfDirectoryView, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE) {
					throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
				}
				if (lastDiskNumber == MAX_16_BITS) {
					lastDiskNumber = getUint32(endOfDirectoryView, 16);
				}
				if (diskNumber == MAX_16_BITS) {
					diskNumber = getUint32(endOfDirectoryView, 20);
				}
				if (filesLength == MAX_16_BITS) {
					filesLength = getBigUint64(endOfDirectoryView, 32);
				}
				if (directoryDataLength == MAX_32_BITS) {
					directoryDataLength = getBigUint64(endOfDirectoryView, 40);
				}
				directoryDataOffset -= directoryDataLength;
			}
		}
		if (directoryDataOffset >= reader.size) {
			prependedDataLength = reader.size - directoryDataOffset - directoryDataLength - END_OF_CENTRAL_DIR_LENGTH;
			directoryDataOffset = reader.size - directoryDataLength - END_OF_CENTRAL_DIR_LENGTH;
		}
		if (expectedLastDiskNumber != lastDiskNumber) {
			throw new Error(ERR_SPLIT_ZIP_FILE);
		}
		if (directoryDataOffset < 0) {
			throw new Error(ERR_BAD_FORMAT);
		}
		let offset = 0;
		let directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
		let directoryView = getDataView$1(directoryArray);
		if (directoryDataLength) {
			const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;
			if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
				const originalDirectoryDataOffset = directoryDataOffset;
				directoryDataOffset = expectedDirectoryDataOffset;
				prependedDataLength += directoryDataOffset - originalDirectoryDataOffset;
				directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
				directoryView = getDataView$1(directoryArray);
			}
		}
		const expectedDirectoryDataLength = endOfDirectoryInfo.offset - directoryDataOffset - (reader.lastDiskOffset || 0);
		if (directoryDataLength != expectedDirectoryDataLength && expectedDirectoryDataLength >= 0) {
			directoryDataLength = expectedDirectoryDataLength;
			directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
			directoryView = getDataView$1(directoryArray);
		}
		if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
			throw new Error(ERR_BAD_FORMAT);
		}
		const filenameEncoding = getOptionValue$1(zipReader, options, "filenameEncoding");
		const commentEncoding = getOptionValue$1(zipReader, options, "commentEncoding");
		for (let indexFile = 0; indexFile < filesLength; indexFile++) {
			const fileEntry = new ZipEntry(reader, config, zipReader.options);
			if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE) {
				throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
			}
			readCommonHeader(fileEntry, directoryView, offset + 6);
			const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
			const filenameOffset = offset + 46;
			const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
			const commentOffset = extraFieldOffset + fileEntry.extraFieldLength;
			const versionMadeBy = getUint16(directoryView, offset + 4);
			const msDosCompatible = versionMadeBy >> 8 == 0;
			const unixCompatible = versionMadeBy >> 8 == 3;
			const rawFilename = directoryArray.subarray(filenameOffset, extraFieldOffset);
			const commentLength = getUint16(directoryView, offset + 32);
			const endOffset = commentOffset + commentLength;
			const rawComment = directoryArray.subarray(commentOffset, endOffset);
			const filenameUTF8 = languageEncodingFlag;
			const commentUTF8 = languageEncodingFlag;
			const externalFileAttributes = getUint32(directoryView, offset + 38);
			const directory =
				(msDosCompatible && ((getUint8(directoryView, offset + 38) & FILE_ATTR_MSDOS_DIR_MASK) == FILE_ATTR_MSDOS_DIR_MASK)) ||
				(unixCompatible && (((externalFileAttributes >> 16) & FILE_ATTR_UNIX_DIR_MASK) == FILE_ATTR_UNIX_DIR_MASK)) ||
				(rawFilename.length && rawFilename[rawFilename.length - 1] == DIRECTORY_SIGNATURE.charCodeAt(0));
			const executable = (unixCompatible && (((externalFileAttributes >> 16) & FILE_ATTR_UNIX_EXECUTABLE_MASK) == FILE_ATTR_UNIX_EXECUTABLE_MASK));
			const offsetFileEntry = getUint32(directoryView, offset + 42) + prependedDataLength;
			Object.assign(fileEntry, {
				versionMadeBy,
				msDosCompatible,
				compressedSize: 0,
				uncompressedSize: 0,
				commentLength,
				directory,
				offset: offsetFileEntry,
				diskNumberStart: getUint16(directoryView, offset + 34),
				internalFileAttributes: getUint16(directoryView, offset + 36),
				externalFileAttributes,
				rawFilename,
				filenameUTF8,
				commentUTF8,
				rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset),
				executable
			});
			fileEntry.internalFileAttribute = fileEntry.internalFileAttributes;
			fileEntry.externalFileAttribute = fileEntry.externalFileAttributes;
			const decode = getOptionValue$1(zipReader, options, "decodeText") || decodeText;
			const rawFilenameEncoding = filenameUTF8 ? CHARSET_UTF8 : filenameEncoding || CHARSET_CP437;
			const rawCommentEncoding = commentUTF8 ? CHARSET_UTF8 : commentEncoding || CHARSET_CP437;
			let filename = decode(rawFilename, rawFilenameEncoding);
			if (filename === UNDEFINED_VALUE) {
				filename = decodeText(rawFilename, rawFilenameEncoding);
			}
			let comment = decode(rawComment, rawCommentEncoding);
			if (comment === UNDEFINED_VALUE) {
				comment = decodeText(rawComment, rawCommentEncoding);
			}
			Object.assign(fileEntry, {
				rawComment,
				filename,
				comment,
				directory: directory || filename.endsWith(DIRECTORY_SIGNATURE)
			});
			startOffset = Math.max(offsetFileEntry, startOffset);
			readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
			fileEntry.zipCrypto = fileEntry.encrypted && !fileEntry.extraFieldAES;
			const entry = new Entry(fileEntry);
			entry.getData = (writer, options) => fileEntry.getData(writer, entry, options);
			offset = endOffset;
			const { onprogress } = options;
			if (onprogress) {
				try {
					await onprogress(indexFile + 1, filesLength, new Entry(fileEntry));
					// eslint-disable-next-line no-unused-vars
				} catch (_) {
					// ignored
				}
			}
			yield entry;
		}
		const extractPrependedData = getOptionValue$1(zipReader, options, "extractPrependedData");
		const extractAppendedData = getOptionValue$1(zipReader, options, "extractAppendedData");
		if (extractPrependedData) {
			zipReader.prependedData = startOffset > 0 ? await readUint8Array(reader, 0, startOffset) : new Uint8Array();
		}
		zipReader.comment = commentLength ? await readUint8Array(reader, commentOffset + END_OF_CENTRAL_DIR_LENGTH, commentLength) : new Uint8Array();
		if (extractAppendedData) {
			zipReader.appendedData = appendedDataOffset < reader.size ? await readUint8Array(reader, appendedDataOffset, reader.size - appendedDataOffset) : new Uint8Array();
		}
		return true;
	}

	async getEntries(options = {}) {
		const entries = [];
		for await (const entry of this.getEntriesGenerator(options)) {
			entries.push(entry);
		}
		return entries;
	}

	async close() {
	}
}

class ZipEntry {

	constructor(reader, config, options) {
		Object.assign(this, {
			reader,
			config,
			options
		});
	}

	async getData(writer, fileEntry, options = {}) {
		const zipEntry = this;
		const {
			reader,
			offset,
			diskNumberStart,
			extraFieldAES,
			compressionMethod,
			config,
			bitFlag,
			signature,
			rawLastModDate,
			uncompressedSize,
			compressedSize
		} = zipEntry;
		const localDirectory = fileEntry.localDirectory = {};
		const dataArray = await readUint8Array(reader, offset, 30, diskNumberStart);
		const dataView = getDataView$1(dataArray);
		let password = getOptionValue$1(zipEntry, options, "password");
		let rawPassword = getOptionValue$1(zipEntry, options, "rawPassword");
		const passThrough = getOptionValue$1(zipEntry, options, "passThrough");
		password = password && password.length && password;
		rawPassword = rawPassword && rawPassword.length && rawPassword;
		if (extraFieldAES) {
			if (extraFieldAES.originalCompressionMethod != COMPRESSION_METHOD_AES) {
				throw new Error(ERR_UNSUPPORTED_COMPRESSION);
			}
		}
		if ((compressionMethod != COMPRESSION_METHOD_STORE && compressionMethod != COMPRESSION_METHOD_DEFLATE) && !passThrough) {
			throw new Error(ERR_UNSUPPORTED_COMPRESSION);
		}
		if (getUint32(dataView, 0) != LOCAL_FILE_HEADER_SIGNATURE) {
			throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
		}
		readCommonHeader(localDirectory, dataView, 4);
		localDirectory.rawExtraField = localDirectory.extraFieldLength ?
			await readUint8Array(reader, offset + 30 + localDirectory.filenameLength, localDirectory.extraFieldLength, diskNumberStart) :
			new Uint8Array();
		readCommonFooter(zipEntry, localDirectory, dataView, 4, true);
		Object.assign(fileEntry, {
			lastAccessDate: localDirectory.lastAccessDate,
			creationDate: localDirectory.creationDate
		});
		const encrypted = zipEntry.encrypted && localDirectory.encrypted && !passThrough;
		const zipCrypto = encrypted && !extraFieldAES;
		if (!passThrough) {
			fileEntry.zipCrypto = zipCrypto;
		}
		if (encrypted) {
			if (!zipCrypto && extraFieldAES.strength === UNDEFINED_VALUE) {
				throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
			} else if (!password && !rawPassword) {
				throw new Error(ERR_ENCRYPTED);
			}
		}
		const dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;
		const size = compressedSize;
		const readable = reader.readable;
		Object.assign(readable, {
			diskNumberStart,
			offset: dataOffset,
			size
		});
		const signal = getOptionValue$1(zipEntry, options, "signal");
		const checkPasswordOnly = getOptionValue$1(zipEntry, options, "checkPasswordOnly");
		if (checkPasswordOnly) {
			writer = new WritableStream();
		}
		writer = initWriter(writer);
		await initStream(writer, passThrough ? compressedSize : uncompressedSize);
		const { writable } = writer;
		const { onstart, onprogress, onend } = options;
		const workerOptions = {
			options: {
				codecType: CODEC_INFLATE,
				password,
				rawPassword,
				zipCrypto,
				encryptionStrength: extraFieldAES && extraFieldAES.strength,
				signed: getOptionValue$1(zipEntry, options, "checkSignature") && !passThrough,
				passwordVerification: zipCrypto && (bitFlag.dataDescriptor ? ((rawLastModDate >>> 8) & 0xFF) : ((signature >>> 24) & 0xFF)),
				signature,
				compressed: compressionMethod != 0 && !passThrough,
				encrypted: zipEntry.encrypted && !passThrough,
				useWebWorkers: getOptionValue$1(zipEntry, options, "useWebWorkers"),
				useCompressionStream: getOptionValue$1(zipEntry, options, "useCompressionStream"),
				transferStreams: getOptionValue$1(zipEntry, options, "transferStreams"),
				checkPasswordOnly
			},
			config,
			streamOptions: { signal, size, onstart, onprogress, onend }
		};
		let outputSize = 0;
		try {
			({ outputSize } = (await runWorker({ readable, writable }, workerOptions)));
		} catch (error) {
			if (!checkPasswordOnly || error.message != ERR_ABORT_CHECK_PASSWORD) {
				throw error;
			}
		} finally {
			const preventClose = getOptionValue$1(zipEntry, options, "preventClose");
			writable.size += outputSize;
			if (!preventClose && !writable.locked) {
				await writable.getWriter().close();
			}
		}
		return checkPasswordOnly ? UNDEFINED_VALUE : writer.getData ? writer.getData() : writable;
	}
}

function readCommonHeader(directory, dataView, offset) {
	const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
	const encrypted = (rawBitFlag & BITFLAG_ENCRYPTED) == BITFLAG_ENCRYPTED;
	const rawLastModDate = getUint32(dataView, offset + 6);
	Object.assign(directory, {
		encrypted,
		version: getUint16(dataView, offset),
		bitFlag: {
			level: (rawBitFlag & BITFLAG_LEVEL) >> 1,
			dataDescriptor: (rawBitFlag & BITFLAG_DATA_DESCRIPTOR) == BITFLAG_DATA_DESCRIPTOR,
			languageEncodingFlag: (rawBitFlag & BITFLAG_LANG_ENCODING_FLAG) == BITFLAG_LANG_ENCODING_FLAG
		},
		rawLastModDate,
		lastModDate: getDate(rawLastModDate),
		filenameLength: getUint16(dataView, offset + 22),
		extraFieldLength: getUint16(dataView, offset + 24)
	});
}

function readCommonFooter(fileEntry, directory, dataView, offset, localDirectory) {
	const { rawExtraField } = directory;
	const extraField = directory.extraField = new Map();
	const rawExtraFieldView = getDataView$1(new Uint8Array(rawExtraField));
	let offsetExtraField = 0;
	try {
		while (offsetExtraField < rawExtraField.length) {
			const type = getUint16(rawExtraFieldView, offsetExtraField);
			const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
			extraField.set(type, {
				type,
				data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
			});
			offsetExtraField += 4 + size;
		}
		// eslint-disable-next-line no-unused-vars
	} catch (_) {
		// ignored
	}
	const compressionMethod = getUint16(dataView, offset + 4);
	Object.assign(directory, {
		signature: getUint32(dataView, offset + 10),
		uncompressedSize: getUint32(dataView, offset + 18),
		compressedSize: getUint32(dataView, offset + 14)
	});
	const extraFieldZip64 = extraField.get(EXTRAFIELD_TYPE_ZIP64);
	if (extraFieldZip64) {
		readExtraFieldZip64(extraFieldZip64, directory);
		directory.extraFieldZip64 = extraFieldZip64;
	}
	const extraFieldUnicodePath = extraField.get(EXTRAFIELD_TYPE_UNICODE_PATH);
	if (extraFieldUnicodePath) {
		readExtraFieldUnicode(extraFieldUnicodePath, PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, directory, fileEntry);
		directory.extraFieldUnicodePath = extraFieldUnicodePath;
	}
	const extraFieldUnicodeComment = extraField.get(EXTRAFIELD_TYPE_UNICODE_COMMENT);
	if (extraFieldUnicodeComment) {
		readExtraFieldUnicode(extraFieldUnicodeComment, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT, directory, fileEntry);
		directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
	}
	const extraFieldAES = extraField.get(EXTRAFIELD_TYPE_AES);
	if (extraFieldAES) {
		readExtraFieldAES(extraFieldAES, directory, compressionMethod);
		directory.extraFieldAES = extraFieldAES;
	} else {
		directory.compressionMethod = compressionMethod;
	}
	const extraFieldNTFS = extraField.get(EXTRAFIELD_TYPE_NTFS);
	if (extraFieldNTFS) {
		readExtraFieldNTFS(extraFieldNTFS, directory);
		directory.extraFieldNTFS = extraFieldNTFS;
	}
	const extraFieldExtendedTimestamp = extraField.get(EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
	if (extraFieldExtendedTimestamp) {
		readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory);
		directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
	}
	const extraFieldUSDZ = extraField.get(EXTRAFIELD_TYPE_USDZ);
	if (extraFieldUSDZ) {
		directory.extraFieldUSDZ = extraFieldUSDZ;
	}
}

function readExtraFieldZip64(extraFieldZip64, directory) {
	directory.zip64 = true;
	const extraFieldView = getDataView$1(extraFieldZip64.data);
	const missingProperties = ZIP64_PROPERTIES.filter(([propertyName, max]) => directory[propertyName] == max);
	for (let indexMissingProperty = 0, offset = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++) {
		const [propertyName, max] = missingProperties[indexMissingProperty];
		if (directory[propertyName] == max) {
			const extraction = ZIP64_EXTRACTION[max];
			directory[propertyName] = extraFieldZip64[propertyName] = extraction.getValue(extraFieldView, offset);
			offset += extraction.bytes;
		} else if (extraFieldZip64[propertyName]) {
			throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
		}
	}
}

function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
	const extraFieldView = getDataView$1(extraFieldUnicode.data);
	const crc32 = new Crc32();
	crc32.append(fileEntry[rawPropertyName]);
	const dataViewSignature = getDataView$1(new Uint8Array(4));
	dataViewSignature.setUint32(0, crc32.get(), true);
	const signature = getUint32(extraFieldView, 1);
	Object.assign(extraFieldUnicode, {
		version: getUint8(extraFieldView, 0),
		[propertyName]: decodeText(extraFieldUnicode.data.subarray(5)),
		valid: !fileEntry.bitFlag.languageEncodingFlag && signature == getUint32(dataViewSignature, 0)
	});
	if (extraFieldUnicode.valid) {
		directory[propertyName] = extraFieldUnicode[propertyName];
		directory[propertyName + "UTF8"] = true;
	}
}

function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
	const extraFieldView = getDataView$1(extraFieldAES.data);
	const strength = getUint8(extraFieldView, 4);
	Object.assign(extraFieldAES, {
		vendorVersion: getUint8(extraFieldView, 0),
		vendorId: getUint8(extraFieldView, 2),
		strength,
		originalCompressionMethod: compressionMethod,
		compressionMethod: getUint16(extraFieldView, 5)
	});
	directory.compressionMethod = extraFieldAES.compressionMethod;
}

function readExtraFieldNTFS(extraFieldNTFS, directory) {
	const extraFieldView = getDataView$1(extraFieldNTFS.data);
	let offsetExtraField = 4;
	let tag1Data;
	try {
		while (offsetExtraField < extraFieldNTFS.data.length && !tag1Data) {
			const tagValue = getUint16(extraFieldView, offsetExtraField);
			const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
			if (tagValue == EXTRAFIELD_TYPE_NTFS_TAG1) {
				tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
			}
			offsetExtraField += 4 + attributeSize;
		}
		// eslint-disable-next-line no-unused-vars
	} catch (_) {
		// ignored
	}
	try {
		if (tag1Data && tag1Data.length == 24) {
			const tag1View = getDataView$1(tag1Data);
			const rawLastModDate = tag1View.getBigUint64(0, true);
			const rawLastAccessDate = tag1View.getBigUint64(8, true);
			const rawCreationDate = tag1View.getBigUint64(16, true);
			Object.assign(extraFieldNTFS, {
				rawLastModDate,
				rawLastAccessDate,
				rawCreationDate
			});
			const lastModDate = getDateNTFS(rawLastModDate);
			const lastAccessDate = getDateNTFS(rawLastAccessDate);
			const creationDate = getDateNTFS(rawCreationDate);
			const extraFieldData = { lastModDate, lastAccessDate, creationDate };
			Object.assign(extraFieldNTFS, extraFieldData);
			Object.assign(directory, extraFieldData);
		}
		// eslint-disable-next-line no-unused-vars
	} catch (_) {
		// ignored
	}
}

function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory) {
	const extraFieldView = getDataView$1(extraFieldExtendedTimestamp.data);
	const flags = getUint8(extraFieldView, 0);
	const timeProperties = [];
	const timeRawProperties = [];
	if (localDirectory) {
		if ((flags & 0x1) == 0x1) {
			timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
			timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
		}
		if ((flags & 0x2) == 0x2) {
			timeProperties.push(PROPERTY_NAME_LAST_ACCESS_DATE);
			timeRawProperties.push(PROPERTY_NAME_RAW_LAST_ACCESS_DATE);
		}
		if ((flags & 0x4) == 0x4) {
			timeProperties.push(PROPERTY_NAME_CREATION_DATE);
			timeRawProperties.push(PROPERTY_NAME_RAW_CREATION_DATE);
		}
	} else if (extraFieldExtendedTimestamp.data.length >= 5) {
		timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
		timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
	}
	let offset = 1;
	timeProperties.forEach((propertyName, indexProperty) => {
		if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
			const time = getUint32(extraFieldView, offset);
			directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1000);
			const rawPropertyName = timeRawProperties[indexProperty];
			extraFieldExtendedTimestamp[rawPropertyName] = time;
		}
		offset += 4;
	});
}

async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
	const signatureArray = new Uint8Array(4);
	const signatureView = getDataView$1(signatureArray);
	setUint32$1(signatureView, 0, signature);
	const maximumBytes = minimumBytes + maximumLength;
	return (await seek(minimumBytes)) || await seek(Math.min(maximumBytes, startOffset));

	async function seek(length) {
		const offset = startOffset - length;
		const bytes = await readUint8Array(reader, offset, length);
		for (let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--) {
			if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] &&
				bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
				return {
					offset: offset + indexByte,
					buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
				};
			}
		}
	}
}

function getOptionValue$1(zipReader, options, name) {
	return options[name] === UNDEFINED_VALUE ? zipReader.options[name] : options[name];
}

function getDate(timeRaw) {
	const date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
	try {
		return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);
		// eslint-disable-next-line no-unused-vars
	} catch (_) {
		// ignored
	}
}

function getDateNTFS(timeRaw) {
	return new Date((Number((timeRaw / BigInt(10000)) - BigInt(11644473600000))));
}

function getUint8(view, offset) {
	return view.getUint8(offset);
}

function getUint16(view, offset) {
	return view.getUint16(offset, true);
}

function getUint32(view, offset) {
	return view.getUint32(offset, true);
}

function getBigUint64(view, offset) {
	return Number(view.getBigUint64(offset, true));
}

function setUint32$1(view, offset, value) {
	view.setUint32(offset, value, true);
}

function getDataView$1(array) {
	return new DataView(array.buffer);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const ERR_DUPLICATED_NAME = "File already exists";
const ERR_INVALID_COMMENT = "Zip file comment exceeds 64KB";
const ERR_INVALID_ENTRY_COMMENT = "File entry comment exceeds 64KB";
const ERR_INVALID_ENTRY_NAME = "File entry name exceeds 64KB";
const ERR_INVALID_VERSION = "Version exceeds 65535";
const ERR_INVALID_ENCRYPTION_STRENGTH = "The strength must equal 1, 2, or 3";
const ERR_INVALID_EXTRAFIELD_TYPE = "Extra field type exceeds 65535";
const ERR_INVALID_EXTRAFIELD_DATA = "Extra field data exceeds 64KB";
const ERR_UNSUPPORTED_FORMAT = "Zip64 is not supported (make sure 'keepOrder' is set to 'true')";
const ERR_UNDEFINED_UNCOMPRESSED_SIZE = "Undefined uncompressed size";

const EXTRAFIELD_DATA_AES = new Uint8Array([0x07, 0x00, 0x02, 0x00, 0x41, 0x45, 0x03, 0x00, 0x00]);

let workers = 0;
const pendingEntries = [];

class ZipWriter {

	constructor(writer, options = {}) {
		writer = initWriter(writer);
		const addSplitZipSignature =
			writer.availableSize !== UNDEFINED_VALUE && writer.availableSize > 0 && writer.availableSize !== Infinity &&
			writer.maxSize !== UNDEFINED_VALUE && writer.maxSize > 0 && writer.maxSize !== Infinity;
		Object.assign(this, {
			writer,
			addSplitZipSignature,
			options,
			config: getConfiguration(),
			files: new Map(),
			filenames: new Set(),
			offset: options.offset === UNDEFINED_VALUE ? writer.writable.size : options.offset,
			pendingEntriesSize: 0,
			pendingAddFileCalls: new Set(),
			bufferedWrites: 0
		});
	}

	async add(name = "", reader, options = {}) {
		const zipWriter = this;
		const {
			pendingAddFileCalls,
			config
		} = zipWriter;
		if (workers < config.maxWorkers) {
			workers++;
		} else {
			await new Promise(resolve => pendingEntries.push(resolve));
		}
		let promiseAddFile;
		try {
			name = name.trim();
			if (zipWriter.filenames.has(name)) {
				throw new Error(ERR_DUPLICATED_NAME);
			}
			zipWriter.filenames.add(name);
			promiseAddFile = addFile(zipWriter, name, reader, options);
			pendingAddFileCalls.add(promiseAddFile);
			return await promiseAddFile;
		} catch (error) {
			zipWriter.filenames.delete(name);
			throw error;
		} finally {
			pendingAddFileCalls.delete(promiseAddFile);
			const pendingEntry = pendingEntries.shift();
			if (pendingEntry) {
				pendingEntry();
			} else {
				workers--;
			}
		}
	}

	async close(comment = new Uint8Array(), options = {}) {
		const zipWriter = this;
		const { pendingAddFileCalls, writer } = this;
		const { writable } = writer;
		while (pendingAddFileCalls.size) {
			await Promise.allSettled(Array.from(pendingAddFileCalls));
		}
		await closeFile(this, comment, options);
		const preventClose = getOptionValue(zipWriter, options, "preventClose");
		if (!preventClose) {
			await writable.getWriter().close();
		}
		return writer.getData ? writer.getData() : writable;
	}
}

async function addFile(zipWriter, name, reader, options) {
	name = name.trim();
	const msDosCompatible = getOptionValue(zipWriter, options, PROPERTY_NAME_MS_DOS_COMPATIBLE);
	const versionMadeBy = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION_MADE_BY, msDosCompatible ? 20 : 768);
	const executable = getOptionValue(zipWriter, options, PROPERTY_NAME_EXECUTABLE);
	if (versionMadeBy > MAX_16_BITS) {
		throw new Error(ERR_INVALID_VERSION);
	}
	let externalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES, 0);
	if (externalFileAttributes === 0) {
		externalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE, 0);
	}
	if (!options.directory && name.endsWith(DIRECTORY_SIGNATURE)) {
		options.directory = true;
	}
	const directory = getOptionValue(zipWriter, options, PROPERTY_NAME_DIRECTORY);
	if (directory) {
		if (!name.endsWith(DIRECTORY_SIGNATURE)) {
			name += DIRECTORY_SIGNATURE;
		}
		if (externalFileAttributes === 0) {
			if (msDosCompatible) {
				externalFileAttributes = FILE_ATTR_MSDOS_DIR_MASK;
			} else {
				externalFileAttributes = FILE_ATTR_UNIX_DIR_MASK << 16;
			}
		}
	} else if (!msDosCompatible && externalFileAttributes === 0) {
		if (executable) {
			externalFileAttributes = (FILE_ATTR_UNIX_EXECUTABLE_MASK | FILE_ATTR_UNIX_DEFAULT_MASK) << 16;
		} else {
			externalFileAttributes = FILE_ATTR_UNIX_DEFAULT_MASK << 16;
		}
	}
	const encode = getOptionValue(zipWriter, options, "encodeText", encodeText);
	let rawFilename = encode(name);
	if (rawFilename === UNDEFINED_VALUE) {
		rawFilename = encodeText(name);
	}
	if (getLength(rawFilename) > MAX_16_BITS) {
		throw new Error(ERR_INVALID_ENTRY_NAME);
	}
	const comment = options.comment || "";
	let rawComment = encode(comment);
	if (rawComment === UNDEFINED_VALUE) {
		rawComment = encodeText(comment);
	}
	if (getLength(rawComment) > MAX_16_BITS) {
		throw new Error(ERR_INVALID_ENTRY_COMMENT);
	}
	const version = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION, VERSION_DEFLATE);
	if (version > MAX_16_BITS) {
		throw new Error(ERR_INVALID_VERSION);
	}
	const lastModDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_MODIFICATION_DATE, new Date());
	const lastAccessDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_ACCESS_DATE);
	const creationDate = getOptionValue(zipWriter, options, PROPERTY_NAME_CREATION_DATE);
	let internalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES, 0);
	if (internalFileAttributes === 0) {
		internalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE, 0);
	}
	const passThrough = getOptionValue(zipWriter, options, "passThrough");
	let password, rawPassword;
	if (!passThrough) {
		password = getOptionValue(zipWriter, options, "password");
		rawPassword = getOptionValue(zipWriter, options, "rawPassword");
	}
	const encryptionStrength = getOptionValue(zipWriter, options, "encryptionStrength", 3);
	const zipCrypto = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIPCRYPTO);
	const extendedTimestamp = getOptionValue(zipWriter, options, "extendedTimestamp", true);
	const keepOrder = getOptionValue(zipWriter, options, "keepOrder", true);
	const level = getOptionValue(zipWriter, options, "level");
	const useWebWorkers = getOptionValue(zipWriter, options, "useWebWorkers");
	const bufferedWrite = getOptionValue(zipWriter, options, "bufferedWrite");
	const dataDescriptorSignature = getOptionValue(zipWriter, options, "dataDescriptorSignature", false);
	const signal = getOptionValue(zipWriter, options, "signal");
	const useUnicodeFileNames = getOptionValue(zipWriter, options, "useUnicodeFileNames", true);
	const useCompressionStream = getOptionValue(zipWriter, options, "useCompressionStream");
	const compressionMethod = getOptionValue(zipWriter, options, "compressionMethod");
	let dataDescriptor = getOptionValue(zipWriter, options, "dataDescriptor", true);
	let zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);
	if (!zipCrypto && (password !== UNDEFINED_VALUE || rawPassword !== UNDEFINED_VALUE) && !(encryptionStrength >= 1 && encryptionStrength <= 3)) {
		throw new Error(ERR_INVALID_ENCRYPTION_STRENGTH);
	}
	let rawExtraField = new Uint8Array();
	const { extraField } = options;
	if (extraField) {
		let extraFieldSize = 0;
		let offset = 0;
		extraField.forEach(data => extraFieldSize += 4 + getLength(data));
		rawExtraField = new Uint8Array(extraFieldSize);
		extraField.forEach((data, type) => {
			if (type > MAX_16_BITS) {
				throw new Error(ERR_INVALID_EXTRAFIELD_TYPE);
			}
			if (getLength(data) > MAX_16_BITS) {
				throw new Error(ERR_INVALID_EXTRAFIELD_DATA);
			}
			arraySet(rawExtraField, new Uint16Array([type]), offset);
			arraySet(rawExtraField, new Uint16Array([getLength(data)]), offset + 2);
			arraySet(rawExtraField, data, offset + 4);
			offset += 4 + getLength(data);
		});
	}
	let maximumCompressedSize = 0;
	let maximumEntrySize = 0;
	let uncompressedSize = 0;
	if (passThrough) {
		({ uncompressedSize } = options);
		if (uncompressedSize === UNDEFINED_VALUE) {
			throw new Error(ERR_UNDEFINED_UNCOMPRESSED_SIZE);
		}
	}
	const zip64Enabled = zip64 === true;
	if (reader) {
		reader = initReader(reader);
		await initStream(reader);
		if (!passThrough) {
			if (reader.size === UNDEFINED_VALUE) {
				dataDescriptor = true;
				if (zip64 || zip64 === UNDEFINED_VALUE) {
					zip64 = true;
					uncompressedSize = maximumCompressedSize = MAX_32_BITS + 1;
				}
			} else {
				uncompressedSize = reader.size;
				maximumCompressedSize = getMaximumCompressedSize(uncompressedSize);
			}
		} else {
			maximumCompressedSize = getMaximumCompressedSize(uncompressedSize);
		}
	}
	const { diskOffset, diskNumber, maxSize } = zipWriter.writer;
	const zip64UncompressedSize = zip64Enabled || uncompressedSize > MAX_32_BITS;
	const zip64CompressedSize = zip64Enabled || maximumCompressedSize > MAX_32_BITS;
	const zip64Offset = zip64Enabled || zipWriter.offset + zipWriter.pendingEntriesSize - diskOffset > MAX_32_BITS;
	const supportZip64SplitFile = getOptionValue(zipWriter, options, "supportZip64SplitFile", true);
	const zip64DiskNumberStart = (supportZip64SplitFile && zip64Enabled) || diskNumber + Math.ceil(zipWriter.pendingEntriesSize / maxSize) > MAX_16_BITS;
	if (zip64Offset || zip64UncompressedSize || zip64CompressedSize || zip64DiskNumberStart) {
		if (zip64 === false || !keepOrder) {
			throw new Error(ERR_UNSUPPORTED_FORMAT);
		} else {
			zip64 = true;
		}
	}
	zip64 = zip64 || false;
	const encrypted = getOptionValue(zipWriter, options, PROPERTY_NAME_ENCRYPTED);
	const { signature } = options;
	options = Object.assign({}, options, {
		rawFilename,
		rawComment,
		version,
		versionMadeBy,
		lastModDate,
		lastAccessDate,
		creationDate,
		rawExtraField,
		zip64,
		zip64UncompressedSize,
		zip64CompressedSize,
		zip64Offset,
		zip64DiskNumberStart,
		password,
		rawPassword,
		level: !useCompressionStream && (zipWriter.config.CompressionStream === UNDEFINED_VALUE && zipWriter.config.CompressionStreamNative === UNDEFINED_VALUE) ? 0 : level,
		useWebWorkers,
		encryptionStrength,
		extendedTimestamp,
		zipCrypto,
		bufferedWrite,
		keepOrder,
		useUnicodeFileNames,
		dataDescriptor,
		dataDescriptorSignature,
		signal,
		msDosCompatible,
		internalFileAttribute: internalFileAttributes,
		internalFileAttributes,
		externalFileAttribute: externalFileAttributes,
		externalFileAttributes,
		useCompressionStream,
		passThrough,
		encrypted: Boolean((password && getLength(password)) || (rawPassword && getLength(rawPassword))) || (passThrough && encrypted),
		signature,
		compressionMethod
	});
	const headerInfo = getHeaderInfo(options);
	const dataDescriptorInfo = getDataDescriptorInfo(options);
	const metadataSize = getLength(headerInfo.localHeaderArray, dataDescriptorInfo.dataDescriptorArray);
	maximumEntrySize = metadataSize + maximumCompressedSize;
	if (zipWriter.options.usdz) {
		maximumEntrySize += maximumEntrySize + 64;
	}
	zipWriter.pendingEntriesSize += maximumEntrySize;
	let fileEntry;
	try {
		fileEntry = await getFileEntry(zipWriter, name, reader, { headerInfo, dataDescriptorInfo, metadataSize }, options);
	} finally {
		zipWriter.pendingEntriesSize -= maximumEntrySize;
	}
	Object.assign(fileEntry, { name, comment, extraField });
	return new Entry(fileEntry);
}

async function getFileEntry(zipWriter, name, reader, entryInfo, options) {
	const {
		files,
		writer
	} = zipWriter;
	const {
		keepOrder,
		dataDescriptor,
		signal
	} = options;
	const {
		headerInfo
	} = entryInfo;
	const { usdz } = zipWriter.options;
	const previousFileEntry = Array.from(files.values()).pop();
	let fileEntry = {};
	let bufferedWrite;
	let releaseLockWriter;
	let releaseLockCurrentFileEntry;
	let writingBufferedEntryData;
	let writingEntryData;
	let fileWriter;
	let blobPromise;
	files.set(name, fileEntry);
	try {
		let lockPreviousFileEntry;
		if (keepOrder) {
			lockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;
			requestLockCurrentFileEntry();
		}
		if ((options.bufferedWrite || zipWriter.writerLocked || (zipWriter.bufferedWrites && keepOrder) || !dataDescriptor) && !usdz) {
			fileWriter = new TransformStream();
			blobPromise = new Response(fileWriter.readable).blob();
			fileWriter.writable.size = 0;
			bufferedWrite = true;
			zipWriter.bufferedWrites++;
			await initStream(writer);
		} else {
			fileWriter = writer;
			await requestLockWriter();
		}
		await initStream(fileWriter);
		const { writable } = writer;
		let { diskOffset } = writer;
		if (zipWriter.addSplitZipSignature) {
			delete zipWriter.addSplitZipSignature;
			const signatureArray = new Uint8Array(4);
			const signatureArrayView = getDataView(signatureArray);
			setUint32(signatureArrayView, 0, SPLIT_ZIP_FILE_SIGNATURE);
			await writeData(writable, signatureArray);
			zipWriter.offset += 4;
		}
		if (usdz) {
			appendExtraFieldUSDZ(entryInfo, zipWriter.offset - diskOffset);
		}
		if (!bufferedWrite) {
			await lockPreviousFileEntry;
			await skipDiskIfNeeded(writable);
		}
		const { diskNumber } = writer;
		writingEntryData = true;
		fileEntry.diskNumberStart = diskNumber;
		fileEntry = await createFileEntry(reader, fileWriter, fileEntry, entryInfo, zipWriter.config, options);
		writingEntryData = false;
		files.set(name, fileEntry);
		fileEntry.filename = name;
		if (bufferedWrite) {
			await fileWriter.writable.getWriter().close();
			let blob = await blobPromise;
			await lockPreviousFileEntry;
			await requestLockWriter();
			writingBufferedEntryData = true;
			if (!dataDescriptor) {
				blob = await writeExtraHeaderInfo(fileEntry, blob, writable, options);
			}
			await skipDiskIfNeeded(writable);
			fileEntry.diskNumberStart = writer.diskNumber;
			diskOffset = writer.diskOffset;
			await blob.stream().pipeTo(writable, { preventClose: true, preventAbort: true, signal });
			writable.size += blob.size;
			writingBufferedEntryData = false;
		}
		fileEntry.offset = zipWriter.offset - diskOffset;
		if (fileEntry.zip64) {
			setZip64ExtraInfo(fileEntry, options);
		} else if (fileEntry.offset > MAX_32_BITS) {
			throw new Error(ERR_UNSUPPORTED_FORMAT);
		}
		zipWriter.offset += fileEntry.size;
		return fileEntry;
	} catch (error) {
		if ((bufferedWrite && writingBufferedEntryData) || (!bufferedWrite && writingEntryData)) {
			zipWriter.hasCorruptedEntries = true;
			if (error) {
				try {
					error.corruptedEntry = true;
					// eslint-disable-next-line no-unused-vars
				} catch (_) {
					// ignored
				}
			}
			if (bufferedWrite) {
				zipWriter.offset += fileWriter.writable.size;
			} else {
				zipWriter.offset = fileWriter.writable.size;
			}
		}
		files.delete(name);
		throw error;
	} finally {
		if (bufferedWrite) {
			zipWriter.bufferedWrites--;
		}
		if (releaseLockCurrentFileEntry) {
			releaseLockCurrentFileEntry();
		}
		if (releaseLockWriter) {
			releaseLockWriter();
		}
	}

	function requestLockCurrentFileEntry() {
		fileEntry.lock = new Promise(resolve => releaseLockCurrentFileEntry = resolve);
	}

	async function requestLockWriter() {
		zipWriter.writerLocked = true;
		const { lockWriter } = zipWriter;
		zipWriter.lockWriter = new Promise(resolve => releaseLockWriter = () => {
			zipWriter.writerLocked = false;
			resolve();
		});
		await lockWriter;
	}

	async function skipDiskIfNeeded(writable) {
		if (getLength(headerInfo.localHeaderArray) > writer.availableSize) {
			writer.availableSize = 0;
			await writeData(writable, new Uint8Array());
		}
	}
}

async function createFileEntry(reader, writer, { diskNumberStart, lock }, entryInfo, config, options) {
	const {
		headerInfo,
		dataDescriptorInfo,
		metadataSize
	} = entryInfo;
	const {
		localHeaderArray,
		headerArray,
		lastModDate,
		rawLastModDate,
		encrypted,
		compressed,
		version,
		compressionMethod,
		rawExtraFieldExtendedTimestamp,
		extraFieldExtendedTimestampFlag,
		rawExtraFieldNTFS,
		rawExtraFieldAES
	} = headerInfo;
	const { dataDescriptorArray } = dataDescriptorInfo;
	const {
		rawFilename,
		lastAccessDate,
		creationDate,
		password,
		rawPassword,
		level,
		zip64,
		zip64UncompressedSize,
		zip64CompressedSize,
		zip64Offset,
		zip64DiskNumberStart,
		zipCrypto,
		dataDescriptor,
		directory,
		executable,
		versionMadeBy,
		rawComment,
		rawExtraField,
		useWebWorkers,
		onstart,
		onprogress,
		onend,
		signal,
		encryptionStrength,
		extendedTimestamp,
		msDosCompatible,
		internalFileAttributes,
		externalFileAttributes,
		useCompressionStream,
		passThrough
	} = options;
	const fileEntry = {
		lock,
		versionMadeBy,
		zip64,
		directory: Boolean(directory),
		executable: Boolean(executable),
		filenameUTF8: true,
		rawFilename,
		commentUTF8: true,
		rawComment,
		rawExtraFieldExtendedTimestamp,
		rawExtraFieldNTFS,
		rawExtraFieldAES,
		rawExtraField,
		extendedTimestamp,
		msDosCompatible,
		internalFileAttributes,
		externalFileAttributes,
		diskNumberStart
	};
	let {
		signature,
		uncompressedSize
	} = options;
	let compressedSize = 0;
	if (!passThrough) {
		uncompressedSize = 0;
	}
	const { writable } = writer;
	if (reader) {
		reader.chunkSize = getChunkSize(config);
		await writeData(writable, localHeaderArray);
		const readable = reader.readable;
		const size = readable.size = reader.size;
		const workerOptions = {
			options: {
				codecType: CODEC_DEFLATE,
				level,
				rawPassword,
				password,
				encryptionStrength,
				zipCrypto: encrypted && zipCrypto,
				passwordVerification: encrypted && zipCrypto && (rawLastModDate >> 8) & 0xFF,
				signed: !passThrough,
				compressed: compressed && !passThrough,
				encrypted: encrypted && !passThrough,
				useWebWorkers,
				useCompressionStream,
				transferStreams: false
			},
			config,
			streamOptions: { signal, size, onstart, onprogress, onend }
		};
		const result = await runWorker({ readable, writable }, workerOptions);
		compressedSize = result.outputSize;
		if (!passThrough) {
			uncompressedSize = result.inputSize;
			signature = result.signature;
		}
		writable.size += uncompressedSize;
	} else {
		await writeData(writable, localHeaderArray);
	}
	let rawExtraFieldZip64;
	if (zip64) {
		let rawExtraFieldZip64Length = 4;
		if (zip64UncompressedSize) {
			rawExtraFieldZip64Length += 8;
		}
		if (zip64CompressedSize) {
			rawExtraFieldZip64Length += 8;
		}
		if (zip64Offset) {
			rawExtraFieldZip64Length += 8;
		}
		if (zip64DiskNumberStart) {
			rawExtraFieldZip64Length += 4;
		}
		rawExtraFieldZip64 = new Uint8Array(rawExtraFieldZip64Length);
	} else {
		rawExtraFieldZip64 = new Uint8Array();
	}
	setEntryInfo({
		signature,
		rawExtraFieldZip64,
		compressedSize,
		uncompressedSize,
		headerInfo,
		dataDescriptorInfo
	}, options);
	if (dataDescriptor) {
		await writeData(writable, dataDescriptorArray);
	}
	Object.assign(fileEntry, {
		uncompressedSize,
		compressedSize,
		lastModDate,
		rawLastModDate,
		creationDate,
		lastAccessDate,
		encrypted,
		zipCrypto,
		size: metadataSize + compressedSize,
		compressionMethod,
		version,
		headerArray,
		signature,
		rawExtraFieldZip64,
		extraFieldExtendedTimestampFlag,
		zip64UncompressedSize,
		zip64CompressedSize,
		zip64Offset,
		zip64DiskNumberStart
	});
	return fileEntry;
}

function getHeaderInfo(options) {
	const {
		rawFilename,
		lastModDate,
		lastAccessDate,
		creationDate,
		level,
		zip64,
		zipCrypto,
		useUnicodeFileNames,
		dataDescriptor,
		directory,
		rawExtraField,
		encryptionStrength,
		extendedTimestamp,
		encrypted
	} = options;
	let { version, compressionMethod } = options;
	const compressed = !directory && (level > 0 || (level === UNDEFINED_VALUE && compressionMethod !== 0));
	let rawExtraFieldAES;
	if (encrypted && !zipCrypto) {
		rawExtraFieldAES = new Uint8Array(getLength(EXTRAFIELD_DATA_AES) + 2);
		const extraFieldAESView = getDataView(rawExtraFieldAES);
		setUint16(extraFieldAESView, 0, EXTRAFIELD_TYPE_AES);
		arraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);
		setUint8(extraFieldAESView, 8, encryptionStrength);
	} else {
		rawExtraFieldAES = new Uint8Array();
	}
	let rawExtraFieldNTFS;
	let rawExtraFieldExtendedTimestamp;
	let extraFieldExtendedTimestampFlag;
	if (extendedTimestamp) {
		rawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));
		const extraFieldExtendedTimestampView = getDataView(rawExtraFieldExtendedTimestamp);
		setUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
		setUint16(extraFieldExtendedTimestampView, 2, getLength(rawExtraFieldExtendedTimestamp) - 4);
		extraFieldExtendedTimestampFlag = 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0);
		setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);
		let offset = 5;
		setUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastModDate.getTime() / 1000));
		offset += 4;
		if (lastAccessDate) {
			setUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastAccessDate.getTime() / 1000));
			offset += 4;
		}
		if (creationDate) {
			setUint32(extraFieldExtendedTimestampView, offset, Math.floor(creationDate.getTime() / 1000));
		}
		try {
			rawExtraFieldNTFS = new Uint8Array(36);
			const extraFieldNTFSView = getDataView(rawExtraFieldNTFS);
			const lastModTimeNTFS = getTimeNTFS(lastModDate);
			setUint16(extraFieldNTFSView, 0, EXTRAFIELD_TYPE_NTFS);
			setUint16(extraFieldNTFSView, 2, 32);
			setUint16(extraFieldNTFSView, 8, EXTRAFIELD_TYPE_NTFS_TAG1);
			setUint16(extraFieldNTFSView, 10, 24);
			setBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);
			setBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);
			setBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);
			// eslint-disable-next-line no-unused-vars
		} catch (_) {
			rawExtraFieldNTFS = new Uint8Array();
		}
	} else {
		rawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array();
	}
	let bitFlag = 0;
	if (useUnicodeFileNames) {
		bitFlag = bitFlag | BITFLAG_LANG_ENCODING_FLAG;
	}
	if (dataDescriptor) {
		bitFlag = bitFlag | BITFLAG_DATA_DESCRIPTOR;
	}
	if (compressionMethod === UNDEFINED_VALUE) {
		compressionMethod = compressed ? COMPRESSION_METHOD_DEFLATE : COMPRESSION_METHOD_STORE;
	}
	if (compressionMethod == COMPRESSION_METHOD_DEFLATE) {
		if (level >= 1 && level < 3) {
			bitFlag = bitFlag | 0b110;
		}
		if (level >= 3 && level < 5) {
			bitFlag = bitFlag | 0b01;
		}
		if (level === 9) {
			bitFlag = bitFlag | 0b10;
		}
	}
	if (zip64) {
		version = version > VERSION_ZIP64 ? version : VERSION_ZIP64;
	}
	if (encrypted) {
		bitFlag = bitFlag | BITFLAG_ENCRYPTED;
		if (!zipCrypto) {
			version = version > VERSION_AES ? version : VERSION_AES;
			rawExtraFieldAES[9] = compressionMethod;
			compressionMethod = COMPRESSION_METHOD_AES;
		}
	}
	const headerArray = new Uint8Array(26);
	const headerView = getDataView(headerArray);
	setUint16(headerView, 0, version);
	setUint16(headerView, 2, bitFlag);
	setUint16(headerView, 4, compressionMethod);
	const dateArray = new Uint32Array(1);
	const dateView = getDataView(dateArray);
	let lastModDateMsDos;
	if (lastModDate < MIN_DATE) {
		lastModDateMsDos = MIN_DATE;
	} else if (lastModDate > MAX_DATE) {
		lastModDateMsDos = MAX_DATE;
	} else {
		lastModDateMsDos = lastModDate;
	}
	setUint16(dateView, 0, (((lastModDateMsDos.getHours() << 6) | lastModDateMsDos.getMinutes()) << 5) | lastModDateMsDos.getSeconds() / 2);
	setUint16(dateView, 2, ((((lastModDateMsDos.getFullYear() - 1980) << 4) | (lastModDateMsDos.getMonth() + 1)) << 5) | lastModDateMsDos.getDate());
	const rawLastModDate = dateArray[0];
	setUint32(headerView, 6, rawLastModDate);
	setUint16(headerView, 22, getLength(rawFilename));
	const extraFieldLength = getLength(rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraField);
	setUint16(headerView, 24, extraFieldLength);
	const localHeaderArray = new Uint8Array(30 + getLength(rawFilename) + extraFieldLength);
	const localHeaderView = getDataView(localHeaderArray);
	setUint32(localHeaderView, 0, LOCAL_FILE_HEADER_SIGNATURE);
	arraySet(localHeaderArray, headerArray, 4);
	arraySet(localHeaderArray, rawFilename, 30);
	arraySet(localHeaderArray, rawExtraFieldAES, 30 + getLength(rawFilename));
	arraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, 30 + getLength(rawFilename, rawExtraFieldAES));
	arraySet(localHeaderArray, rawExtraFieldNTFS, 30 + getLength(rawFilename, rawExtraFieldAES, rawExtraFieldExtendedTimestamp));
	arraySet(localHeaderArray, rawExtraField, 30 + getLength(rawFilename, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS));
	return {
		localHeaderArray,
		headerArray,
		headerView,
		lastModDate,
		rawLastModDate,
		encrypted,
		compressed,
		version,
		compressionMethod,
		extraFieldExtendedTimestampFlag,
		rawExtraFieldExtendedTimestamp,
		rawExtraFieldNTFS,
		rawExtraFieldAES,
		extraFieldLength
	};
}

function appendExtraFieldUSDZ(entryInfo, zipWriterOffset) {
	const { headerInfo } = entryInfo;
	let { localHeaderArray, extraFieldLength } = headerInfo;
	let localHeaderArrayView = getDataView(localHeaderArray);
	let extraBytesLength = 64 - ((zipWriterOffset + getLength(localHeaderArray)) % 64);
	if (extraBytesLength < 4) {
		extraBytesLength += 64;
	}
	const rawExtraFieldUSDZ = new Uint8Array(extraBytesLength);
	const extraFieldUSDZView = getDataView(rawExtraFieldUSDZ);
	setUint16(extraFieldUSDZView, 0, EXTRAFIELD_TYPE_USDZ);
	setUint16(extraFieldUSDZView, 2, extraBytesLength - 2);
	const previousLocalHeaderArray = localHeaderArray;
	headerInfo.localHeaderArray = localHeaderArray = new Uint8Array(getLength(previousLocalHeaderArray) + extraBytesLength);
	arraySet(localHeaderArray, previousLocalHeaderArray);
	arraySet(localHeaderArray, rawExtraFieldUSDZ, getLength(previousLocalHeaderArray));
	localHeaderArrayView = getDataView(localHeaderArray);
	setUint16(localHeaderArrayView, 28, extraFieldLength + extraBytesLength);
	entryInfo.metadataSize += extraBytesLength;
}

function getDataDescriptorInfo(options) {
	const {
		zip64,
		dataDescriptor,
		dataDescriptorSignature
	} = options;
	let dataDescriptorArray = new Uint8Array();
	let dataDescriptorView, dataDescriptorOffset = 0;
	if (dataDescriptor) {
		dataDescriptorArray = new Uint8Array(zip64 ? (dataDescriptorSignature ? 24 : 20) : (dataDescriptorSignature ? 16 : 12));
		dataDescriptorView = getDataView(dataDescriptorArray);
		if (dataDescriptorSignature) {
			dataDescriptorOffset = 4;
			setUint32(dataDescriptorView, 0, DATA_DESCRIPTOR_RECORD_SIGNATURE);
		}
	}
	return {
		dataDescriptorArray,
		dataDescriptorView,
		dataDescriptorOffset
	};
}

function setEntryInfo(entryInfo, options) {
	const {
		signature,
		rawExtraFieldZip64,
		compressedSize,
		uncompressedSize,
		headerInfo,
		dataDescriptorInfo
	} = entryInfo;
	const {
		headerView,
		encrypted
	} = headerInfo;
	const {
		dataDescriptorView,
		dataDescriptorOffset
	} = dataDescriptorInfo;
	const {
		zip64,
		zip64UncompressedSize,
		zip64CompressedSize,
		zipCrypto,
		dataDescriptor
	} = options;
	if ((!encrypted || zipCrypto) && signature !== UNDEFINED_VALUE) {
		setUint32(headerView, 10, signature);
		if (dataDescriptor) {
			setUint32(dataDescriptorView, dataDescriptorOffset, signature);
		}
	}
	if (zip64) {
		const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);
		setUint16(rawExtraFieldZip64View, 0, EXTRAFIELD_TYPE_ZIP64);
		setUint16(rawExtraFieldZip64View, 2, getLength(rawExtraFieldZip64) - 4);
		let rawExtraFieldZip64Offset = 4;
		if (zip64UncompressedSize) {
			setUint32(headerView, 18, MAX_32_BITS);
			setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));
			rawExtraFieldZip64Offset += 8;
		}
		if (zip64CompressedSize) {
			setUint32(headerView, 14, MAX_32_BITS);
			setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(compressedSize));
		}
		if (dataDescriptor) {
			setBigUint64(dataDescriptorView, dataDescriptorOffset + 4, BigInt(compressedSize));
			setBigUint64(dataDescriptorView, dataDescriptorOffset + 12, BigInt(uncompressedSize));
		}
	} else {
		setUint32(headerView, 14, compressedSize);
		setUint32(headerView, 18, uncompressedSize);
		if (dataDescriptor) {
			setUint32(dataDescriptorView, dataDescriptorOffset + 4, compressedSize);
			setUint32(dataDescriptorView, dataDescriptorOffset + 8, uncompressedSize);
		}
	}
}

async function writeExtraHeaderInfo(fileEntry, entryData, writable, { zipCrypto }) {
	let arrayBuffer;
	arrayBuffer = await entryData.slice(0, 26).arrayBuffer();
	if (arrayBuffer.byteLength != 26) {
		arrayBuffer = arrayBuffer.slice(0, 26);
	}
	const arrayBufferView = new DataView(arrayBuffer);
	if (!fileEntry.encrypted || zipCrypto) {
		setUint32(arrayBufferView, 14, fileEntry.signature);
	}
	if (fileEntry.zip64) {
		setUint32(arrayBufferView, 18, MAX_32_BITS);
		setUint32(arrayBufferView, 22, MAX_32_BITS);
	} else {
		setUint32(arrayBufferView, 18, fileEntry.compressedSize);
		setUint32(arrayBufferView, 22, fileEntry.uncompressedSize);
	}
	await writeData(writable, new Uint8Array(arrayBuffer));
	return entryData.slice(arrayBuffer.byteLength);
}

function setZip64ExtraInfo(fileEntry, options) {
	const { rawExtraFieldZip64, offset, diskNumberStart } = fileEntry;
	const { zip64UncompressedSize, zip64CompressedSize, zip64Offset, zip64DiskNumberStart } = options;
	const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);
	let rawExtraFieldZip64Offset = 4;
	if (zip64UncompressedSize) {
		rawExtraFieldZip64Offset += 8;
	}
	if (zip64CompressedSize) {
		rawExtraFieldZip64Offset += 8;
	}
	if (zip64Offset) {
		setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));
		rawExtraFieldZip64Offset += 8;
	}
	if (zip64DiskNumberStart) {
		setUint32(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);
	}
}

async function closeFile(zipWriter, comment, options) {
	const { files, writer } = zipWriter;
	const { diskOffset, writable } = writer;
	let { diskNumber } = writer;
	let offset = 0;
	let directoryDataLength = 0;
	let directoryOffset = zipWriter.offset - diskOffset;
	let filesLength = files.size;
	for (const [, fileEntry] of files) {
		const {
			rawFilename,
			rawExtraFieldZip64,
			rawExtraFieldAES,
			rawComment,
			rawExtraFieldNTFS,
			rawExtraField,
			extendedTimestamp,
			extraFieldExtendedTimestampFlag,
			lastModDate
		} = fileEntry;
		let rawExtraFieldTimestamp;
		if (extendedTimestamp) {
			rawExtraFieldTimestamp = new Uint8Array(9);
			const extraFieldExtendedTimestampView = getDataView(rawExtraFieldTimestamp);
			setUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
			setUint16(extraFieldExtendedTimestampView, 2, 5);
			setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);
			setUint32(extraFieldExtendedTimestampView, 5, Math.floor(lastModDate.getTime() / 1000));
		} else {
			rawExtraFieldTimestamp = new Uint8Array();
		}
		fileEntry.rawExtraFieldCDExtendedTimestamp = rawExtraFieldTimestamp;
		directoryDataLength += 46 +
			getLength(
				rawFilename,
				rawComment,
				rawExtraFieldZip64,
				rawExtraFieldAES,
				rawExtraFieldNTFS,
				rawExtraFieldTimestamp,
				rawExtraField);
	}
	const directoryArray = new Uint8Array(directoryDataLength);
	const directoryView = getDataView(directoryArray);
	await initStream(writer);
	let directoryDiskOffset = 0;
	for (const [indexFileEntry, fileEntry] of Array.from(files.values()).entries()) {
		const {
			offset: fileEntryOffset,
			rawFilename,
			rawExtraFieldZip64,
			rawExtraFieldAES,
			rawExtraFieldCDExtendedTimestamp,
			rawExtraFieldNTFS,
			rawExtraField,
			rawComment,
			versionMadeBy,
			headerArray,
			zip64,
			zip64UncompressedSize,
			zip64CompressedSize,
			zip64DiskNumberStart,
			zip64Offset,
			internalFileAttributes,
			externalFileAttributes,
			diskNumberStart,
			uncompressedSize,
			compressedSize
		} = fileEntry;
		const extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp, rawExtraFieldNTFS, rawExtraField);
		setUint32(directoryView, offset, CENTRAL_FILE_HEADER_SIGNATURE);
		setUint16(directoryView, offset + 4, versionMadeBy);
		const headerView = getDataView(headerArray);
		if (!zip64UncompressedSize) {
			setUint32(headerView, 18, uncompressedSize);
		}
		if (!zip64CompressedSize) {
			setUint32(headerView, 14, compressedSize);
		}
		arraySet(directoryArray, headerArray, offset + 6);
		setUint16(directoryView, offset + 30, extraFieldLength);
		setUint16(directoryView, offset + 32, getLength(rawComment));
		setUint16(directoryView, offset + 34, zip64 && zip64DiskNumberStart ? MAX_16_BITS : diskNumberStart);
		setUint16(directoryView, offset + 36, internalFileAttributes);
		if (externalFileAttributes) {
			setUint32(directoryView, offset + 38, externalFileAttributes);
		}
		setUint32(directoryView, offset + 42, zip64 && zip64Offset ? MAX_32_BITS : fileEntryOffset);
		arraySet(directoryArray, rawFilename, offset + 46);
		arraySet(directoryArray, rawExtraFieldZip64, offset + 46 + getLength(rawFilename));
		arraySet(directoryArray, rawExtraFieldAES, offset + 46 + getLength(rawFilename, rawExtraFieldZip64));
		arraySet(directoryArray, rawExtraFieldCDExtendedTimestamp, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES));
		arraySet(directoryArray, rawExtraFieldNTFS, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp));
		arraySet(directoryArray, rawExtraField, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp, rawExtraFieldNTFS));
		arraySet(directoryArray, rawComment, offset + 46 + getLength(rawFilename) + extraFieldLength);
		const directoryEntryLength = 46 + getLength(rawFilename, rawComment) + extraFieldLength;
		if (offset - directoryDiskOffset > writer.availableSize) {
			writer.availableSize = 0;
			await writeData(writable, directoryArray.slice(directoryDiskOffset, offset));
			directoryDiskOffset = offset;
		}
		offset += directoryEntryLength;
		if (options.onprogress) {
			try {
				await options.onprogress(indexFileEntry + 1, files.size, new Entry(fileEntry));
				// eslint-disable-next-line no-unused-vars
			} catch (_) {
				// ignored
			}
		}
	}
	await writeData(writable, directoryDiskOffset ? directoryArray.slice(directoryDiskOffset) : directoryArray);
	let lastDiskNumber = writer.diskNumber;
	const { availableSize } = writer;
	if (availableSize < END_OF_CENTRAL_DIR_LENGTH) {
		lastDiskNumber++;
	}
	let zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);
	if (directoryOffset > MAX_32_BITS || directoryDataLength > MAX_32_BITS || filesLength > MAX_16_BITS || lastDiskNumber > MAX_16_BITS) {
		if (zip64 === false) {
			throw new Error(ERR_UNSUPPORTED_FORMAT);
		} else {
			zip64 = true;
		}
	}
	const endOfdirectoryArray = new Uint8Array(zip64 ? ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH : END_OF_CENTRAL_DIR_LENGTH);
	const endOfdirectoryView = getDataView(endOfdirectoryArray);
	offset = 0;
	if (zip64) {
		setUint32(endOfdirectoryView, 0, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE);
		setBigUint64(endOfdirectoryView, 4, BigInt(44));
		setUint16(endOfdirectoryView, 12, 45);
		setUint16(endOfdirectoryView, 14, 45);
		setUint32(endOfdirectoryView, 16, lastDiskNumber);
		setUint32(endOfdirectoryView, 20, diskNumber);
		setBigUint64(endOfdirectoryView, 24, BigInt(filesLength));
		setBigUint64(endOfdirectoryView, 32, BigInt(filesLength));
		setBigUint64(endOfdirectoryView, 40, BigInt(directoryDataLength));
		setBigUint64(endOfdirectoryView, 48, BigInt(directoryOffset));
		setUint32(endOfdirectoryView, 56, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE);
		setBigUint64(endOfdirectoryView, 64, BigInt(directoryOffset) + BigInt(directoryDataLength));
		setUint32(endOfdirectoryView, 72, lastDiskNumber + 1);
		const supportZip64SplitFile = getOptionValue(zipWriter, options, "supportZip64SplitFile", true);
		if (supportZip64SplitFile) {
			lastDiskNumber = MAX_16_BITS;
			diskNumber = MAX_16_BITS;
		}
		filesLength = MAX_16_BITS;
		directoryOffset = MAX_32_BITS;
		directoryDataLength = MAX_32_BITS;
		offset += ZIP64_END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH;
	}
	setUint32(endOfdirectoryView, offset, END_OF_CENTRAL_DIR_SIGNATURE);
	setUint16(endOfdirectoryView, offset + 4, lastDiskNumber);
	setUint16(endOfdirectoryView, offset + 6, diskNumber);
	setUint16(endOfdirectoryView, offset + 8, filesLength);
	setUint16(endOfdirectoryView, offset + 10, filesLength);
	setUint32(endOfdirectoryView, offset + 12, directoryDataLength);
	setUint32(endOfdirectoryView, offset + 16, directoryOffset);
	const commentLength = getLength(comment);
	if (commentLength) {
		if (commentLength <= MAX_16_BITS) {
			setUint16(endOfdirectoryView, offset + 20, commentLength);
		} else {
			throw new Error(ERR_INVALID_COMMENT);
		}
	}
	await writeData(writable, endOfdirectoryArray);
	if (commentLength) {
		await writeData(writable, comment);
	}
}

async function writeData(writable, array) {
	const streamWriter = writable.getWriter();
	try {
		await streamWriter.ready;
		writable.size += getLength(array);
		await streamWriter.write(array);
	} finally {
		streamWriter.releaseLock();
	}
}

function getTimeNTFS(date) {
	if (date) {
		return ((BigInt(date.getTime()) + BigInt(11644473600000)) * BigInt(10000));
	}
}

function getOptionValue(zipWriter, options, name, defaultValue) {
	const result = options[name] === UNDEFINED_VALUE ? zipWriter.options[name] : options[name];
	return result === UNDEFINED_VALUE ? defaultValue : result;
}

function getMaximumCompressedSize(uncompressedSize) {
	return uncompressedSize + (5 * (Math.floor(uncompressedSize / 16383) + 1));
}

function setUint8(view, offset, value) {
	view.setUint8(offset, value);
}

function setUint16(view, offset, value) {
	view.setUint16(offset, value, true);
}

function setUint32(view, offset, value) {
	view.setUint32(offset, value, true);
}

function setBigUint64(view, offset, value) {
	view.setBigUint64(offset, value, true);
}

function arraySet(array, typedArray, offset) {
	array.set(typedArray, offset);
}

function getDataView(array) {
	return new DataView(array.buffer);
}

function getLength(...arrayLikes) {
	let result = 0;
	arrayLikes.forEach(arrayLike => arrayLike && (result += arrayLike.length));
	return result;
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


let baseURL;
try {
	baseURL = import.meta.url;
	// eslint-disable-next-line no-unused-vars
} catch (_) {
	// ignored
}
configure({ baseURL });
e(configure);

/// <reference types="./index.d.ts" />


configure({ Deflate: ZipDeflate, Inflate: ZipInflate });

/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1             = 2;

/*============================================================================*/


function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH$1    = 3;
const MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1      = 256;
/* number of literal bytes 0..255 */

const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1       = 30;
/* number of distance codes */

const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */

  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Tracev((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) => {
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */

  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = (code + bl_count[bits - 1]) << 1;
    next_code[bits] = code;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) => {
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */

  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) => {
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */

  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let sx = 0;         /* running index in sym_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and sym_buf is ok: */
      //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");

    } while (sx < s.sym_next);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */

  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */

  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "block list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* block_mask is the bit mask of block-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let block_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("block-listed") bytes. */
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("allow-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "block-listed" or "allow-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  bi_windup(s);        /* align on byte boundary */
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and write out the encoded block.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->sym_next / 3));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) => {
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

  return (s.sym_next === s.sym_end);
};

var _tr_init_1  = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1  = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */
//#ifdef GZIP
const GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */
//#endif
const EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */
const NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */
const COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */
const HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */
const BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */
const FINISH_STATE  = 666;    /* stream complete */

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) * 2) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};

/* ===========================================================================
 * Slide the hash table when sliding the window down (could be avoided with 32
 * bit values at the expense of memory usage). We slide even when level == 0 to
 * keep the hash table consistent if we switch back to level > 0 later.
 */
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;

  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = (m >= wsize ? m - wsize : 0);
  } while (--n);
  n = wsize;
//#ifndef FASTEST
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = (m >= wsize ? m - wsize : 0);
    /* If n is not on any hash chain, prev[n] is garbage but
     * its value will never be used.
     */
  } while (--n);
//#endif
};

/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output, except for
 * some deflate_stored() output, goes through this function so some
 * applications may wish to modify it to avoid allocating a large
 * strm->next_out buffer and copying into it. (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out  += len;
  s.pending_out  += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending      -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let n, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 *
 * In case deflateParams() is used to later switch to a non-zero compression
 * level, s->matches (otherwise unused when storing) keeps track of the number
 * of hash table slides to perform. If s->matches is 1, then one hash table
 * slide will be done when switching. If s->matches is 2, the maximum value
 * allowed here, then the hash table will be cleared, since two or more slides
 * is the same as a clear.
 *
 * deflate_stored() is written to minimize the number of times an input byte is
 * copied. It is most efficient with large input and output buffers, which
 * maximizes the opportunites to have a single copy from next_in to next_out.
 */
const deflate_stored = (s, flush) => {

  /* Smallest worthy block size when not flushing or finishing. By default
   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
   * large input and output buffers, the stored block size will be larger.
   */
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

  /* Copy as many min_block or larger stored blocks directly to next_out as
   * possible. If flushing, copy the remaining available input to next_out as
   * stored blocks, if there is enough space.
   */
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    /* Set len to the maximum size block that we can copy directly with the
     * available input data and output space. Set left to how much of that
     * would be copied from what's left in the window.
     */
    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */
    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    if (s.strm.avail_out < have) {         /* need room for header */
      break;
    }
      /* maximum stored block length that will fit in avail_out: */
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;  /* bytes left in window */
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;   /* limit len to the input */
    }
    if (len > have) {
      len = have;             /* limit len to the output */
    }

    /* If the stored block would be less than min_block in length, or if
     * unable to copy all of the available input when flushing, then try
     * copying to the window and the pending buffer instead. Also don't
     * write an empty block when flushing -- deflate() does that.
     */
    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||
                        flush === Z_NO_FLUSH$2 ||
                        len !== left + s.strm.avail_in)) {
      break;
    }

    /* Make a dummy stored block in pending to get the header bytes,
     * including any pending bits. This also updates the debugging counts.
     */
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);

    /* Replace the lengths in the dummy stored block with len. */
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;

    /* Write the stored block header bytes. */
    flush_pending(s.strm);

//#ifdef ZLIB_DEBUG
//    /* Update debugging counts for the data about to be copied. */
//    s->compressed_len += len << 3;
//    s->bits_sent += len << 3;
//#endif

    /* Copy uncompressed bytes from the window to next_out. */
    if (left) {
      if (left > len) {
        left = len;
      }
      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }

    /* Copy uncompressed bytes directly from next_in to next_out, updating
     * the check value.
     */
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);

  /* Update the sliding window with the last s->w_size bytes of the copied
   * data, or append all of the copied data to the existing window if less
   * than s->w_size bytes were copied. Also update the number of bytes to
   * insert in the hash tables, in the event that deflateParams() switches to
   * a non-zero compression level.
   */
  used -= s.strm.avail_in;    /* number of input bytes directly copied */
  if (used) {
    /* If any input was used, then no unused input remains in the window,
     * therefore s->block_start == s->strstart.
     */
    if (used >= s.w_size) {  /* supplant the previous history */
      s.matches = 2;     /* clear hash */
      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    }
    else {
      if (s.window_size - s.strstart <= used) {
        /* Slide the window down. */
        s.strstart -= s.w_size;
        //zmemcpy(s->window, s->window + s->w_size, s->strstart);
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;   /* add a pending slide_hash() */
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* If the last block was written to next_out, then done. */
  if (last) {
    return BS_FINISH_DONE;
  }

  /* If flushing and all input has been consumed, then done. */
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&
    s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }

  /* Fill the window with any remaining input. */
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    /* Slide the window down. */
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    //zmemcpy(s->window, s->window + s->w_size, s->strstart);
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;       /* add a pending slide_hash() */
    }
    have += s.w_size;      /* more space now */
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* There was not enough avail_out to write a complete worthy or flushed
   * stored block to next_out. Write a stored block to pending instead, if we
   * have enough input for a worthy block, or if flushing and there is enough
   * room for the remaining input as a stored block in the pending buffer.
   */
  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    /* maximum stored block length that will fit in pending: */
  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block ||
     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&
     s.strm.avail_in === 0 && left <= have)) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&
         len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }

  /* We've done all we can with the available input and output. */
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};


/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.sym_buf = 0;        /* buffer for distances and literals/lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.sym_next = 0;      /* running index in sym_buf */
  this.sym_end = 0;       /* symbol table full when sym_next reaches this */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


/* =========================================================================
 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
 */
const deflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&
//#ifdef GZIP
                                s.status !== GZIP_STATE &&
//#endif
                                s.status !== EXTRA_STATE &&
                                s.status !== NAME_STATE &&
                                s.status !== COMMENT_STATE &&
                                s.status !== HCRC_STATE &&
                                s.status !== BUSY_STATE &&
                                s.status !== FINISH_STATE)) {
    return 1;
  }
  return 0;
};


const deflateResetKeep = (strm) => {

  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status =
//#ifdef GZIP
    s.wrap === 2 ? GZIP_STATE :
//#endif
    s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {
    return err(strm, Z_STREAM_ERROR$2);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;     /* to pass state test in deflateReset() */

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  /* We overlay pending_buf and sym_buf. This works since the average size
   * for length/distance pairs over any compressed block is assured to be 31
   * bits or less.
   *
   * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   * possible fixed-codes length/distance pair is then 31 bits total.
   *
   * sym_buf starts one-fourth of the way into pending_buf. So there are
   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   * in sym_buf is three bytes -- two for the distance and one for the
   * literal/length. As each symbol is consumed, the pointer to the next
   * sym_buf value to read moves forward three bytes. From that symbol, up to
   * 31 bits are written to pending_buf. The closest the written pending_buf
   * bits gets to the next sym_buf symbol to read is just before the last
   * code is written. At that time, 31*(n-2) bits have been written, just
   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
   * symbols are written.) The closest the writing gets to what is unread is
   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
   * can range from 128 to 32768.
   *
   * Therefore, at a minimum, there are 142 bits of space between what is
   * written and what is read in the overlain buffers, so the symbols cannot
   * be overwritten by the compressed data. That space is actually 139 bits,
   * due to the three-bit fixed-code block header.
   *
   * That covers the case where either Z_FIXED is specified, forcing fixed
   * codes, or when the use of fixed codes is chosen, because that choice
   * results in a smaller compressed block than dynamic codes. That latter
   * condition then assures that the above analysis also covers all dynamic
   * blocks. A dynamic-code block will only be chosen to be emitted if it has
   * fewer bits than a fixed-code block would for the same set of symbols.
   * Therefore its average symbol length is assured to be less than 31. So
   * the compressed data for a dynamic block also cannot overwrite the
   * symbols from which it is being constructed.
   */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->sym_buf = s->pending_buf + s->lit_bufsize;
  s.sym_buf = s.lit_bufsize;

  //s->sym_end = (s->lit_bufsize - 1) * 3;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};


/* ========================================================================= */
const deflate$2 = (strm, flush) => {

  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }

  const s = strm.state;

  if (!strm.output ||
      (strm.avail_in !== 0 && !strm.input) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }

  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* Write the header */
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    /* zlib header */
    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
    let level_flags = -1;

    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= (level_flags << 6);
    if (s.strstart !== 0) { header |= PRESET_DICT; }
    header += 31 - (header % 31);

    putShortMSB(s, header);

    /* Save the adler32 of the preset dictionary: */
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }
    strm.adler = 1; // adler32(0L, Z_NULL, 0);
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
//#ifdef GZIP
  if (s.status === GZIP_STATE) {
    /* gzip header */
    strm.adler = 0;  //crc32(0L, Z_NULL, 0);
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) { // s->gzhead == Z_NULL
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
    else {
      put_byte(s, (s.gzhead.text ? 1 : 0) +
                  (s.gzhead.hcrc ? 2 : 0) +
                  (!s.gzhead.extra ? 0 : 4) +
                  (!s.gzhead.name ? 0 : 8) +
                  (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 0xff);
      put_byte(s, (s.gzhead.time >> 8) & 0xff);
      put_byte(s, (s.gzhead.time >> 16) & 0xff);
      put_byte(s, (s.gzhead.time >> 24) & 0xff);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, s.gzhead.os & 0xff);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 0xff);
        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        // zmemcpy(s.pending_buf + s.pending,
        //    s.gzhead.extra + s.gzindex, copy);
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      // zmemcpy(s->pending_buf + s->pending,
      //     s->gzhead->extra + s->gzindex, left);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 0xff);
      put_byte(s, (strm.adler >> 8) & 0xff);
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
    }
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
//#endif

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) :
                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                 s.strategy === Z_RLE ? deflate_rle(s, flush) :
                 configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }

  if (flush !== Z_FINISH$3) { return Z_OK$3; }
  if (s.wrap <= 0) { return Z_STREAM_END$3; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};


const deflateEnd = (strm) => {

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }

  const status = strm.state.status;

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateGetDictionary = deflateGetDictionary;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1$2.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}


var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;

var deflate_1$1 = {
	Deflate: Deflate_1$1,
	deflate: deflate_2,
	deflateRaw: deflateRaw_1$1,
	gzip: gzip_1$1};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 16209;       /* got a data error -- remain here until reset */
const TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
//  let shoextra;    /* extra bits table to use */
  let match;                  /* use base and extra for symbol >= match */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    match = 20;

  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    match = 0;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 16180;       /* i: waiting for magic header */
const    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */
const    TIME = 16182;       /* i: waiting for modification time (gzip) */
const    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 16184;      /* i: waiting for extra length (gzip) */
const    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */
const    NAME = 16186;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */
const    HCRC = 16188;       /* i: waiting for header crc (gzip) */
const    DICTID = 16189;    /* i: waiting for dictionary check value */
const    DICT = 16190;      /* waiting for inflateSetDictionary() call */
const        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 16193;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 16196;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 16197;   /* i: waiting for code length code lengths */
const        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 16199;      /* i: same as LEN below, but only first time in */
const            LEN = 16200;       /* i: waiting for length/lit/eob code */
const            LENEXT = 16201;    /* i: waiting for length extra bits */
const            DIST = 16202;      /* i: waiting for distance code */
const            DISTEXT = 16203;   /* i: waiting for distance extra bits */
const            MATCH = 16204;     /* o: waiting for output space to copy string */
const            LIT = 16205;       /* o: waiting for output space to write literal */
const    CHECK = 16206;     /* i: waiting for 32-bit check value */
const    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 16208;      /* finished check, done -- remain here until reset */
const    BAD = 16209;       /* got a data error -- remain here until reset */
const    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.strm = null;           /* pointer back to this zlib stream */
  this.mode = 0;              /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,
                                 bit 2 true to validate check value */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib), or
                                 -1 if raw or no header yet */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm ||
    state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};


const inflateResetKeep = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};


const inflateReset = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.strm = strm;
  state.window = null/*Z_NULL*/;
  state.mode = HEAD;     /* to pass state test in inflateReset2() */
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate$2 = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (inflateStateCheck(strm) || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          if (state.wbits === 0) {
            state.wbits = 15;
          }
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        if (len > 15 || len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        state.flags = 0;               /* indicate zlib header */
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if ((state.wrap & 4) && _out) {
            strm.adler = state.check =
                /*UPDATE_CHECK(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH$1))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if ((state.wrap & 4) && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCodesUsed = inflateCodesUsed;
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
module.exports.inflateValidate = inflateValidate;
*/

var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$2.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;

var inflate_1$1 = {
	Inflate: Inflate_1$1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip$1};

const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;

const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;



var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;

var pako = {
	Deflate: Deflate_1,
	deflate: deflate_1,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1,
	Inflate: Inflate_1,
	inflate: inflate_1,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip_1,
	constants: constants_1
};

class SerializerTool {
  static objectToString(value) {
    return JSON.stringify(value);
  }
  static stringToObject(value) {
    return JSON.parse(value);
  }
  static pakoDeflate(value) {
    return pako.deflate(value);
  }
  static pakoInflate(uint8ArrayWriter) {
    return pako.inflate(uint8ArrayWriter, { to: "string" });
  }
  static parseUint8ArrayReaderPack(value) {
    return flow([SerializerTool.pakoInflate, SerializerTool.stringToObject])(value);
  }
  static createPakoPack(value) {
    return flow([SerializerTool.objectToString, SerializerTool.pakoDeflate])(value);
  }
  static createUint8ArrayReader(value) {
    return new Uint8ArrayReader(value);
  }
  static createUint8ArrayReaderPack(value) {
    return flow([SerializerTool.objectToString, SerializerTool.pakoDeflate, SerializerTool.createUint8ArrayReader])(value);
  }
}

var __defProp$4 = Object.defineProperty;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, key + "" , value);
const _ChunkSerialize = class _ChunkSerialize extends Package {
  constructor(options) {
    super(options);
  }
  loadScene() {
    console.log(new Error("\u52A0\u8F7D\u573A\u666F\u4E2D").stack);
    this.viewer.sceneLoadProgressSubject.next({
      type: ESceneLoadType.Load,
      name: `\u52A0\u8F7D\u573A\u666F\u4E2D`,
      total: 1,
      loaded: 0
    });
    const options = this.viewer.options;
    const { appId, packagePath } = options;
    let Key = `${this.viewer.options.ossBaseUrl}/scene/${appId}/${appId}.${_ChunkSerialize.Type}`;
    if (isNil(appId)) {
      throw new Error("appId \u4E3A\u7A7A");
    }
    if (isNil(packagePath) && !isNil(this.viewer.ossApi)) {
      this.viewer.ossApi.head(Key).then((data) => {
        const url = this.viewer.ossApi.signatureUrl(Key);
        console.log("\u83B7\u53D6 url", url);
        axios.get(url, {
          responseType: "blob",
          onDownloadProgress: (progressEvent) => {
            const total = progressEvent.total;
            const loaded = progressEvent.loaded;
            if (total) {
              this.viewer.sceneLoadProgressSubject.next({
                type: ESceneLoadType.Down,
                name: "\u4E0B\u8F7D\u573A\u666F\u5305\u4E2D",
                total,
                loaded
              });
            }
          }
        }).then(async (res) => {
          await this.unpack(res.data);
        }).catch((err) => {
          console.log(err);
          this.viewer.setInitState();
        });
      }).catch((error) => {
        if (Reflect.get(error, "code") === "NoSuchKey") {
          console.log("\u6587\u4EF6\u4E0D\u5B58\u5728");
        }
        this.viewer.setInitState();
      });
    } else {
      this.getPackByPath();
    }
  }
  async pack() {
    this.viewer.sceneSaveProgressSubject.next({
      type: ESceneSaveType.Save,
      name: `\u573A\u666F\u4FDD\u5B58\u4E2D`,
      total: 1,
      loaded: 0
    });
    let viewerJson = this.viewer.toJSON();
    const sceneJson = viewerJson.scene;
    const { geometries, materials } = sceneJson;
    const geometriesBlob = await this.packMaterialsOrVertexData(geometries, "geometries", 100);
    const materialsBlob = await this.packMaterialsOrVertexData(materials, "materials", 300);
    console.log("viewerJson", viewerJson);
    const zipWriter = new ZipWriter(new BlobWriter());
    const viewerInfo = this.packSceneInfo(viewerJson);
    await zipWriter.add("viewerInfo.bin", viewerInfo, {
      onprogress: (progress, total) => {
        this.viewer.sceneSaveProgressSubject.next({
          type: ESceneSaveType.Zip,
          name: `\u5236\u4F5C\u573A\u666F\u5305\u4E2D`,
          total,
          loaded: progress
        });
        return void 0;
      }
    });
    await zipWriter.add("geometries.zip", new BlobReader(geometriesBlob), {
      onprogress: (progress, total) => {
        this.viewer.sceneSaveProgressSubject.next({
          type: ESceneSaveType.Zip,
          name: `\u5236\u4F5C\u9876\u70B9\u5305\u4E2D`,
          total,
          loaded: progress
        });
        return void 0;
      }
    });
    await zipWriter.add("materials.zip", new BlobReader(materialsBlob), {
      onprogress: (progress, total) => {
        this.viewer.sceneSaveProgressSubject.next({
          type: ESceneSaveType.Zip,
          name: `\u5236\u4F5C\u6750\u8D28\u5305\u4E2D`,
          total,
          loaded: progress
        });
        return void 0;
      }
    });
    const blob = new Blob([await zipWriter.close(void 0)], { type: "octet/stream" });
    this.uploadPack(blob);
  }
  async unpack(blob) {
    const zipFileReader = new BlobReader(blob);
    const zipReader = new ZipReader(zipFileReader);
    const entries = await zipReader.getEntries();
    let viewerInfo = {};
    let materials = [];
    let geometries = [];
    for (let i = 0; i < entries.length; i++) {
      let entry = entries[i];
      if (entry.filename === "viewerInfo.bin" && entry.getData) {
        viewerInfo = await this.unPackSceneInfo(entry);
      }
      if (entry.filename === "geometries.zip" && entry.getData) {
        geometries = await this.unPackMaterialsOrVertexData(entry, "geometries");
      }
      if (entry.filename === "materials.zip" && entry.getData) {
        materials = await this.unPackMaterialsOrVertexData(entry, "materials");
      }
    }
    await zipReader.close();
    viewerInfo.scene.geometries = geometries;
    viewerInfo.scene.materials = materials;
    console.log("\u8FD8\u539F\u573A\u666F\u6570\u636E", viewerInfo);
    const asset = new Asset({
      result: viewerInfo.scene,
      extension: "object"
    });
    const scene = await this.assetManager.loadObject(asset);
    this.viewer.scene.copy(scene);
    await this.viewer.cameraManager.fromJSON(viewerInfo.cameraManager);
    this.viewer.setInitState();
  }
  uploadPack(blob) {
    const appId = this.viewer.options.appId;
    if (!isNil(this.viewer.ossApi)) {
      const name = `${this.viewer.options.ossBaseUrl}/scene/${appId}/${appId}.${_ChunkSerialize.Type}`;
      this.viewer.ossApi.put(name, blob).then((data) => {
        console.log(data);
        this.viewer.sceneSaveProgressSubject.next({
          type: ESceneSaveType.Save,
          name: `\u573A\u666F\u4FDD\u5B58\u4E2D`,
          total: 1,
          loaded: 1
        });
      });
    }
  }
  packSceneInfo(viewerJson) {
    viewerJson.scene.geometries = [];
    viewerJson.scene.materials = [];
    return SerializerTool.createUint8ArrayReaderPack(viewerJson);
  }
  // 打包材质或顶点
  async packMaterialsOrVertexData(materials, packName, size) {
    const chunkedArray = chunk(materials, size);
    const zipWriter = new ZipWriter(new BlobWriter());
    for (let i = 0; i < chunkedArray.length; i++) {
      const chunk2 = chunkedArray[i];
      const uint8ArrayReader = SerializerTool.createUint8ArrayReaderPack(chunk2);
      await zipWriter.add(`${packName}-chunk-${i}.bin`, uint8ArrayReader, {
        onprogress: (progress, total) => {
          let isMaterials = packName === "materials";
          let name = isMaterials ? `\u538B\u7F29\u6750\u8D28\u5206\u5305 ${i}` : `\u538B\u7F29\u9876\u70B9\u5206\u5305 ${i}`;
          this.viewer.sceneSaveProgressSubject.next({
            type: ESceneSaveType.Zip,
            name,
            total,
            loaded: progress
          });
          return void 0;
        }
      });
    }
    return new Blob([await zipWriter.close(void 0)], { type: "octet/stream" });
  }
  async unPackSceneInfo(entry) {
    const uint8ArrayWriter = await entry.getData(new Uint8ArrayWriter(), {
      onprogress: (progress, total) => {
        return void 0;
      }
    });
    return SerializerTool.parseUint8ArrayReaderPack(uint8ArrayWriter);
  }
  /**
   * 解包材质或顶点
   */
  async unPackMaterialsOrVertexData(entry, type) {
    let isMaterials = type === "materials";
    const blob = await entry.getData(new BlobWriter(), {
      onprogress: (progress, total) => {
        let name = isMaterials ? `\u89E3\u538B\u6750\u8D28\u5305\u4E2D` : `\u89E3\u538B\u9876\u70B9\u5305\u4E2D`;
        this.viewer.sceneLoadProgressSubject.next({
          type: ESceneLoadType.UnZip,
          name,
          total,
          loaded: progress
        });
        return void 0;
      }
    });
    const zipFileReader = new BlobReader(blob);
    const zipReader = new ZipReader(zipFileReader);
    const entries = await zipReader.getEntries();
    let jsonArray = [];
    for (let i = 0; i < entries.length; i++) {
      let entry2 = entries[i];
      if (entry2.getData) {
        const uint8ArrayWriter = await entry2.getData(new Uint8ArrayWriter(), {
          onprogress: (progress, total) => {
            const parts = split(entry2.filename, "-");
            const filename = parts[parts.length - 1];
            const index = filename.slice(0, -4);
            let name = isMaterials ? `\u63D0\u53D6\u6750\u8D28\u5206\u5305 ${index}` : `\u63D0\u53D6\u9876\u70B9\u5206\u5305 ${index}`;
            this.viewer.sceneLoadProgressSubject.next({
              type: ESceneLoadType.UnZip,
              name,
              total,
              loaded: progress
            });
            return void 0;
          }
        });
        let json = SerializerTool.parseUint8ArrayReaderPack(uint8ArrayWriter);
        jsonArray.push(...json);
      }
    }
    await zipReader.close();
    return jsonArray;
  }
  /**
   * 获取远程场景文件, 可加载离线场景
   */
  getPackByPath() {
    const options = this.viewer.options;
    const { appId, packagePath } = options;
    fetch(`${packagePath}/${appId}.chunk`).then((res) => res.blob()).then(async (blob) => {
      await this.unpack(blob);
    }).catch((err) => {
      console.log(err);
      this.viewer.setInitState();
    });
  }
};
__publicField$4(_ChunkSerialize, "Type", "chunk");
let ChunkSerialize = _ChunkSerialize;

var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, key + "" , value);
class PartPackage extends Package {
  loadScene() {
  }
  pack() {
  }
  unpack(blob) {
  }
}
__publicField$3(PartPackage, "Type", "PartPackage");

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, key + "" , value);
const _SourcePackage = class _SourcePackage extends Package {
  constructor(options) {
    super(options);
  }
  loadScene() {
    this.viewer.sceneLoadProgressSubject.next({
      type: ESceneLoadType.Load,
      name: `\u52A0\u8F7D\u573A\u666F\u4E2D`,
      total: 1,
      loaded: 0
    });
    const options = this.viewer.options;
    const { appId, packagePath } = options;
    let Key = `${appId}/${appId}.${_SourcePackage.Type}`;
    if (isNil(appId)) {
      throw new Error("appId \u4E3A\u7A7A");
    }
    if (isNil(packagePath) && !isNil(this.viewer.ossApi)) {
      this.viewer.ossApi.head(Key).then((data) => {
        const url = this.viewer.ossApi.signatureUrl(Key);
        axios.get(url, {
          responseType: "blob",
          onDownloadProgress: (progressEvent) => {
            const total = progressEvent.total;
            const loaded = progressEvent.loaded;
            if (total) {
              this.viewer.sceneLoadProgressSubject.next({
                type: ESceneLoadType.Down,
                name: "\u4E0B\u8F7D\u573A\u666F\u5305\u4E2D",
                total,
                loaded
              });
            }
          }
        }).then(async (res) => {
          await this.unpack(res.data);
        }).catch((err) => {
          console.log(err);
          this.viewer.setInitState();
        });
      }).catch((error) => {
        if (Reflect.get(error, "code") === "NoSuchKey") {
          console.log("\u6587\u4EF6\u4E0D\u5B58\u5728");
        }
        this.viewer.setInitState();
      });
    } else {
      this.getPackByPath();
    }
  }
  /**
   * 获取远程场景文件, 可加载离线场景
   */
  getPackByPath() {
    const options = this.viewer.options;
    const { appId, packagePath } = options;
    fetch(`${packagePath}/${appId}.${_SourcePackage.Type}`).then((res) => res.blob()).then(async (blob) => {
      await this.unpack(blob);
    }).catch((err) => {
      console.log(err);
      this.viewer.setInitState();
    });
  }
  // 获取 three 场景的json数据
  toJson() {
    const sceneJson = this.viewer.scene.toJSON();
    return {
      scene: sceneJson
    };
  }
  uploadPack(blob) {
    const appId = this.viewer.options.appId;
    if (!isNil(this.viewer.ossApi)) {
      const name = `${appId}/${appId}.${_SourcePackage.Type}`;
      this.viewer.ossApi.put(name, blob).then((data) => {
        console.log(data);
        this.viewer.sceneSaveProgressSubject.next({
          type: ESceneSaveType.Save,
          name: `\u573A\u666F\u4FDD\u5B58\u4E2D`,
          total: 1,
          loaded: 1
        });
      });
    }
  }
  getSceneBlob() {
    const json = this.toJson();
    return new Blob([JSON.stringify(json)], { type: "application/json" });
  }
  downJson(name = "scene.json") {
    const blob = this.getSceneBlob();
    DownloadTool.save(blob, "scene.json");
  }
  async pack() {
    const blob = this.getSceneBlob();
    this.uploadPack(blob);
  }
  async unpack(blob) {
    const reader = new FileReader();
    reader.onload = (event) => {
      const json = event.target.result;
      console.log(json);
      const asset = new Asset({
        result: json.scene,
        extension: "object"
      });
      this.assetManager.loadAsset(asset).then((scene) => {
        let _scene = scene;
        this.viewer.scene.copy(_scene);
        _scene = null;
      });
    };
    reader.readAsText(blob);
  }
};
__publicField$2(_SourcePackage, "Type", "three");
let SourcePackage = _SourcePackage;

const packageMap = /* @__PURE__ */ new Map();
packageMap.set(ChunkSerialize.Type, ChunkSerialize);
packageMap.set(PartPackage.Type, PartPackage);
packageMap.set(SourcePackage.Type, SourcePackage);
function getPackage(viewer) {
  const { packageType } = viewer.options;
  if (packageType) {
    const serializer = packageMap.get(packageType);
    if (serializer) {
      return Reflect.construct(serializer, [{ viewer }]);
    }
    return null;
  }
  return null;
}

/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */
const _hasBuffer = typeof Buffer === 'function';
const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a) => {
    let tab = {};
    a.forEach((c, i) => tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === 'function'
    ? Uint8Array.from.bind(Uint8Array)
    : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
const _mkUriSafe = (src) => src
    .replace(/=/g, '').replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_');
const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
/**
 * polyfill version of `btoa`
 */
const btoaPolyfill = (bin) => {
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = '';
    const pad = bin.length % 3;
    for (let i = 0; i < bin.length;) {
        if ((c0 = bin.charCodeAt(i++)) > 255 ||
            (c1 = bin.charCodeAt(i++)) > 255 ||
            (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError('invalid character found');
        u32 = (c0 << 16) | (c1 << 8) | c2;
        asc += b64chs[u32 >> 18 & 63]
            + b64chs[u32 >> 12 & 63]
            + b64chs[u32 >> 6 & 63]
            + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */
const _btoa = typeof btoa === 'function' ? (bin) => btoa(bin)
    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')
        : btoaPolyfill;
const _fromUint8Array = _hasBuffer
    ? (u8a) => Buffer.from(u8a).toString('base64')
    : (u8a) => {
        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
        const maxargs = 0x1000;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(''));
    };
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c) => {
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c
            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                + _fromCC(0x80 | (cc & 0x3f)))
                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                    + _fromCC(0x80 | (cc & 0x3f)));
    }
    else {
        var cc = 0x10000
            + (c.charCodeAt(0) - 0xD800) * 0x400
            + (c.charCodeAt(1) - 0xDC00);
        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
            + _fromCC(0x80 | (cc & 0x3f)));
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */
const utob = (u) => u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer
    ? (s) => Buffer.from(s, 'utf8').toString('base64')
    : _TE
        ? (s) => _fromUint8Array(_TE.encode(s))
        : (s) => _btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */
const encode = (src, urlsafe = false) => urlsafe
    ? _mkUriSafe(_encode(src))
    : _encode(src);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
    switch (cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                | ((0x3f & cccc.charCodeAt(1)) << 12)
                | ((0x3f & cccc.charCodeAt(2)) << 6)
                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
            return (_fromCC((offset >>> 10) + 0xD800)
                + _fromCC((offset & 0x3FF) + 0xDC00));
        case 3:
            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                | ((0x3f & cccc.charCodeAt(1)) << 6)
                | (0x3f & cccc.charCodeAt(2)));
        default:
            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                | (0x3f & cccc.charCodeAt(1)));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */
const btou = (b) => b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */
const atobPolyfill = (asc) => {
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc))
        throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    let u24, bin = '', r1, r2;
    for (let i = 0; i < asc.length;) {
        u24 = b64tab[asc.charAt(i++)] << 18
            | b64tab[asc.charAt(i++)] << 12
            | (r1 = b64tab[asc.charAt(i++)]) << 6
            | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */
const _atob = typeof atob === 'function' ? (asc) => atob(_tidyB64(asc))
    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')
        : atobPolyfill;
//
const _toUint8Array = _hasBuffer
    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))
    : (a) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));
//
const _decode = _hasBuffer
    ? (a) => Buffer.from(a, 'base64').toString('utf8')
    : _TD
        ? (a) => _TD.decode(_toUint8Array(a))
        : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */
const decode = (src) => _decode(_unURI(src));

const unZipObject = (base64Data, needDecode = true) => {
  let strData = atob(base64Data);
  let charData = strData.split("").map(function(x) {
    return x.charCodeAt(0);
  });
  let binData = new Uint8Array(charData);
  let data = pako.ungzip(binData);
  let str = "";
  const chunk = 8 * 1024;
  let i;
  for (i = 0; i < data.length / chunk; i++) {
    str += String.fromCharCode.apply(null, data.slice(i * chunk, (i + 1) * chunk));
  }
  str += String.fromCharCode.apply(null, data.slice(i * chunk));
  const unzipStr = needDecode ? decode(str) : str;
  let result;
  try {
    result = JSON.parse(unzipStr);
  } catch (error) {
    if (/Unexpected token o in JSON at position 0/.test(error)) {
      result = unzipStr;
    }
  }
  return result;
};

const zipObject = (data, needEncode = true) => {
  if (isNil(data)) {
    return data;
  }
  const dataJson = !isString(data) ? JSON.stringify(data) : data;
  const str = needEncode ? encode(dataJson) : dataJson;
  let binaryString = pako.gzip(str);
  let arr = Array.from(binaryString);
  let s = "";
  arr.forEach((item) => {
    s += String.fromCharCode(item);
  });
  return btoa(s);
};

class PScene extends Scene {
  constructor() {
    super();
  }
  add(...object) {
    if (this.name === "sceneHelpers") ; else {
      console.log(new Error("\u6DFB\u52A0\u7269\u4F53").stack);
    }
    return super.add(...object);
  }
}

var oe = Object.defineProperty;
var re = (s, e, t) => e in s ? oe(s, e, { enumerable: true, configurable: true, writable: true, value: t }) : s[e] = t;
var m = (s, e, t) => re(s, typeof e != "symbol" ? e + "" : e, t);
const Qt = (s, e) => {
  const [t, n] = e.split("-");
  return Object.assign(s.style, {
    left: n === "left" ? "0" : n === "center" ? "50%" : "",
    right: n === "right" ? "0" : "",
    top: t === "top" ? "0" : t === "bottom" ? "" : "50%",
    bottom: t === "bottom" ? "0" : "",
    transform: `${n === "center" ? "translateX(-50%)" : ""} ${t === "center" ? "translateY(-50%)" : ""}`
  }), e;
}, Se = ({
  placement: s,
  size: e,
  offset: t,
  id: n,
  className: i
}) => {
  const o = document.createElement("div"), { top: a, left: l, right: d, bottom: h } = t;
  return Object.assign(o.style, {
    id: n,
    position: "absolute",
    zIndex: "1000",
    height: `${e}px`,
    width: `${e}px`,
    margin: `${a}px ${d}px ${h}px ${l}px`,
    borderRadius: "100%"
  }), Qt(o, s), n && (o.id = n), i && (o.className = i), o;
}, xe = (s) => {
  const e = typeof s == "string" ? document.querySelector(s) : s;
  if (!e) throw Error("Invalid DOM element");
  return e;
};
function mt(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
const Ee = [
  ["x", 0, 3],
  ["y", 1, 4],
  ["z", 2, 5]
], Ct = /* @__PURE__ */ new Vector3();
function Ot({ isSphere: s }, e, t) {
  s && (Ct.set(0, 0, 1).applyQuaternion(t.quaternion), Ee.forEach(([n, i, o]) => {
    const a = Ct[n];
    let l = e[i], d = l.userData.opacity;
    l.material.opacity = mt(a >= 0 ? d : d / 2, 0, 1), l = e[o], d = l.userData.opacity, l.material.opacity = mt(a >= 0 ? d / 2 : d, 0, 1);
  }));
}
const Ae = (s, e, t = 10) => Math.abs(s.clientX - e.x) < t && Math.abs(s.clientY - e.y) < t, Dt = /* @__PURE__ */ new Raycaster(), Pt = /* @__PURE__ */ new Vector2(), Gt = (s, e, t, n) => {
  Pt.set(
    (s.clientX - e.left) / e.width * 2 - 1,
    -((s.clientY - e.top) / e.height) * 2 + 1
  ), Dt.setFromCamera(Pt, t);
  const i = Dt.intersectObjects(
    n,
    false
  ), o = i.length ? i[0] : null;
  return !o || !o.object.visible ? null : o;
}, lt = 1e-6, Me = 2 * Math.PI, Jt = ["x", "y", "z"], Y = [...Jt, "nx", "ny", "nz"], Te = ["x", "z", "y", "nx", "nz", "ny"], Ue = ["z", "x", "y", "nz", "nx", "ny"], gt = "Right", ot = "Top", yt = "Front", _t = "Left", rt = "Bottom", vt = "Back", Le = [
  gt,
  ot,
  yt,
  _t,
  rt,
  vt
].map((s) => s.toLocaleLowerCase()), Kt = 1.3, Rt = (s, e = true) => {
  const { material: t, userData: n } = s, { color: i, opacity: o } = e ? n.hover : n;
  t.color.set(i), t.opacity = o;
}, k = (s) => JSON.parse(JSON.stringify(s)), ze = (s) => {
  const e = s.type || "sphere", t = e === "sphere", n = s.resolution || t ? 64 : 128, i = Object3D.DEFAULT_UP, o = i.z === 1, a = i.x === 1, { container: l } = s;
  s.container = void 0, s = JSON.parse(JSON.stringify(s)), s.container = l;
  const d = o ? Te : a ? Ue : Y;
  Le.forEach((c, f) => {
    s[c] && (s[d[f]] = s[c]);
  });
  const h = {
    enabled: true,
    color: 16777215,
    opacity: 1,
    scale: 0.7,
    labelColor: 2236962,
    line: false,
    border: {
      size: 0,
      color: 14540253
    },
    hover: {
      color: t ? 16777215 : 9688043,
      labelColor: 2236962,
      opacity: 1,
      scale: 0.7,
      border: {
        size: 0,
        color: 14540253
      }
    }
  }, r = {
    line: false,
    scale: t ? 0.45 : 0.7,
    hover: {
      scale: t ? 0.5 : 0.7
    }
  }, u = {
    type: e,
    container: document.body,
    size: 128,
    placement: "top-right",
    resolution: n,
    lineWidth: 4,
    radius: t ? 1 : 0.2,
    smoothness: 18,
    animated: true,
    speed: 1,
    background: {
      enabled: true,
      color: t ? 16777215 : 14739180,
      opacity: t ? 0 : 1,
      hover: {
        color: t ? 16777215 : 14739180,
        opacity: t ? 0.2 : 1
      }
    },
    font: {
      family: "sans-serif",
      weight: 900
    },
    offset: {
      top: 10,
      left: 10,
      bottom: 10,
      right: 10
    },
    corners: {
      enabled: !t,
      color: t ? 15915362 : 16777215,
      opacity: 1,
      scale: t ? 0.15 : 0.2,
      radius: 1,
      smoothness: 18,
      hover: {
        color: t ? 16777215 : 9688043,
        opacity: 1,
        scale: t ? 0.2 : 0.225
      }
    },
    edges: {
      enabled: !t,
      color: t ? 15915362 : 16777215,
      opacity: t ? 1 : 0,
      radius: t ? 1 : 0.125,
      smoothness: 18,
      scale: t ? 0.15 : 1,
      hover: {
        color: t ? 16777215 : 9688043,
        opacity: 1,
        scale: t ? 0.2 : 1
      }
    },
    x: {
      ...k(h),
      ...t ? { label: "X", color: 16725587, line: true } : { label: a ? ot : gt }
    },
    y: {
      ...k(h),
      ...t ? { label: "Y", color: 9100032, line: true } : { label: o || a ? yt : ot }
    },
    z: {
      ...k(h),
      ...t ? { label: "Z", color: 2920447, line: true } : {
        label: o ? ot : a ? gt : yt
      }
    },
    nx: {
      ...k(r),
      label: t ? "" : a ? rt : _t
    },
    ny: {
      ...k(r),
      label: t ? "" : o || a ? vt : rt
    },
    nz: {
      ...k(r),
      label: t ? "" : o ? rt : a ? _t : vt
    }
  };
  return wt(s, u), Jt.forEach(
    (c) => wt(
      s[`n${c}`],
      k(s[c])
    )
  ), { ...s, isSphere: t };
};
function wt(s, ...e) {
  if (s instanceof HTMLElement || typeof s != "object" || s === null)
    return s;
  for (const t of e)
    for (const n in t)
      n !== "container" && n in t && (s[n] === void 0 ? s[n] = t[n] : typeof t[n] == "object" && !Array.isArray(t[n]) && (s[n] = wt(
        s[n] || {},
        t[n]
      )));
  return s;
}
const Be = (s, e = 2) => {
  const t = new Color(), n = e * 2, { isSphere: i, resolution: o, radius: a, font: l, corners: d, edges: h } = s, r = Y.map((p) => ({ ...s[p], radius: a }));
  i && d.enabled && r.push(d), i && h.enabled && r.push(h);
  const u = document.createElement("canvas"), c = u.getContext("2d");
  u.width = o * 2 + n * 2, u.height = o * r.length + n * r.length;
  const [f, y] = Z(r, o, l);
  r.forEach(
    ({
      radius: p,
      label: x,
      color: I,
      labelColor: _,
      border: b,
      hover: {
        color: F,
        labelColor: B,
        border: C
      }
    }, G) => {
      const R = o * G + G * n + e;
      L(
        e,
        R,
        e,
        o,
        p,
        x,
        b,
        I,
        _
      ), L(
        o + e * 3,
        R,
        e,
        o,
        p,
        x,
        C ?? b,
        F ?? I,
        B ?? _
      );
    }
  );
  const v = r.length, g = e / (o * 2), S = e / (o * 6), w = 1 / v, E = new CanvasTexture(u);
  return E.repeat.set(0.5 - 2 * g, w - 2 * S), E.offset.set(g, 1 - S), Object.assign(E, {
    colorSpace: SRGBColorSpace,
    wrapS: RepeatWrapping,
    wrapT: RepeatWrapping,
    userData: {
      offsetX: g,
      offsetY: S,
      cellHeight: w
    }
  }), E;
  function L(p, x, I, _, b, F, B, C, G) {
    if (b = b * (_ / 2), C != null && C !== "" && (R(), c.fillStyle = t.set(C).getStyle(), c.fill()), B && B.size) {
      const W = B.size * _ / 2;
      p += W, x += W, _ -= B.size * _, b = Math.max(0, b - W), R(), c.strokeStyle = t.set(B.color).getStyle(), c.lineWidth = B.size * _, c.stroke();
    }
    F && z(
      c,
      p + _ / 2,
      x + (_ + I) / 2,
      F,
      t.set(G).getStyle()
    );
    function R() {
      c.beginPath(), c.moveTo(p + b, x), c.lineTo(p + _ - b, x), c.arcTo(p + _, x, p + _, x + b, b), c.lineTo(p + _, x + _ - b), c.arcTo(p + _, x + _, p + _ - b, x + _, b), c.lineTo(p + b, x + _), c.arcTo(p, x + _, p, x + _ - b, b), c.lineTo(p, x + b), c.arcTo(p, x, p + b, x, b), c.closePath();
    }
  }
  function Z(p, x, I) {
    const b = [...p].sort((J, se) => {
      var Ut, Lt;
      return (((Ut = J.label) == null ? void 0 : Ut.length) || 0) - (((Lt = se.label) == null ? void 0 : Lt.length) || 0);
    }).pop().label, { family: F, weight: B } = I, C = i ? Math.sqrt(Math.pow(x * 0.7, 2) / 2) : x;
    let G = C, R = 0, W = 0;
    do {
      c.font = `${B} ${G}px ${F}`;
      const J = c.measureText(b);
      R = J.width, W = J.fontBoundingBoxDescent, G--;
    } while (R > C && G > 0);
    const Tt = C / W, ne = Math.min(C / R, Tt), ie = Math.floor(G * ne);
    return [`${B} ${ie}px ${F}`, Tt];
  }
  function z(p, x, I, _, b) {
    p.font = f, p.textAlign = "center", p.textBaseline = "middle", p.fillStyle = b, p.fillText(_, x, I + (i ? y : 0));
  }
}, Ce = (s, e) => s.offset.x = (e ? 0.5 : 0) + s.userData.offsetX, Et = (s, e) => {
  const {
    offset: t,
    userData: { offsetY: n, cellHeight: i }
  } = s;
  t.y = 1 - (e + 1) * i + n;
};
function At(s, e, t = 2, n = 2) {
  const i = t / 2 - s, o = n / 2 - s, a = s / t, l = (t - s) / t, d = s / n, h = (n - s) / n, r = [i, o, 0, -i, o, 0, -i, -o, 0, i, -o, 0], u = [l, h, a, h, a, d, l, d], c = [
    3 * (e + 1) + 3,
    3 * (e + 1) + 4,
    e + 4,
    e + 5,
    2 * (e + 1) + 4,
    2,
    1,
    2 * (e + 1) + 3,
    3,
    4 * (e + 1) + 3,
    4,
    0
  ], f = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11].map(
    (z) => c[z]
  );
  let y, v, g, S, w, E, L, Z;
  for (let z = 0; z < 4; z++) {
    S = z < 1 || z > 2 ? i : -i, w = z < 2 ? o : -o, E = z < 1 || z > 2 ? l : a, L = z < 2 ? h : d;
    for (let p = 0; p <= e; p++)
      y = Math.PI / 2 * (z + p / e), v = Math.cos(y), g = Math.sin(y), r.push(S + s * v, w + s * g, 0), u.push(E + a * v, L + d * g), p < e && (Z = (e + 1) * z + p + 4, f.push(z, Z, Z + 1));
  }
  return new BufferGeometry().setIndex(new BufferAttribute(new Uint32Array(f), 1)).setAttribute(
    "position",
    new BufferAttribute(new Float32Array(r), 3)
  ).setAttribute("uv", new BufferAttribute(new Float32Array(u), 2));
}
const Oe = (s, e) => {
  const t = new Vector3(), { isSphere: n, radius: i, smoothness: o } = s, a = At(i, o);
  return Y.map((l, d) => {
    const h = d < 3, r = Y[d], u = d ? e.clone() : e;
    Et(u, d);
    const { enabled: c, scale: f, opacity: y, hover: v } = s[r], g = {
      map: u,
      opacity: y,
      transparent: true
    }, S = n ? new Sprite$1(new SpriteMaterial(g)) : new Mesh(a, new MeshBasicMaterial(g)), w = h ? r : r[1];
    return S.position[w] = (h ? 1 : -1) * (n ? Kt : 1), n || S.lookAt(t.copy(S.position).multiplyScalar(1.7)), S.scale.setScalar(f), S.renderOrder = 1, S.visible = c, S.userData = {
      scale: f,
      opacity: y,
      hover: v
    }, S;
  });
}, De = (s, e) => {
  const { isSphere: t, corners: n } = s;
  if (!n.enabled) return [];
  const { color: i, opacity: o, scale: a, radius: l, smoothness: d, hover: h } = n, r = t ? null : At(l, d), u = {
    transparent: true,
    opacity: o
  }, c = [
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1
  ].map((y) => y * 0.85), f = new Vector3();
  return Array(c.length / 3).fill(0).map((y, v) => {
    if (t) {
      const w = e.clone();
      Et(w, 6), u.map = w;
    } else
      u.color = i;
    const g = t ? new Sprite$1(new SpriteMaterial(u)) : new Mesh(r, new MeshBasicMaterial(u)), S = v * 3;
    return g.position.set(c[S], c[S + 1], c[S + 2]), t && g.position.normalize().multiplyScalar(1.7), g.scale.setScalar(a), g.lookAt(f.copy(g.position).multiplyScalar(2)), g.renderOrder = 1, g.userData = {
      color: i,
      opacity: o,
      scale: a,
      hover: h
    }, g;
  });
}, Pe = (s, e, t) => {
  const { isSphere: n, edges: i } = s;
  if (!i.enabled) return [];
  const { color: o, opacity: a, scale: l, hover: d, radius: h, smoothness: r } = i, u = n ? null : At(h, r, 1.2, 0.25), c = {
    transparent: true,
    opacity: a
  }, f = [
    0,
    1,
    1,
    0,
    -1,
    1,
    1,
    0,
    1,
    -1,
    0,
    1,
    0,
    1,
    -1,
    0,
    -1,
    -1,
    1,
    0,
    -1,
    -1,
    0,
    -1,
    1,
    1,
    0,
    1,
    -1,
    0,
    -1,
    1,
    0,
    -1,
    -1,
    0
  ].map((g) => g * 0.925), y = new Vector3(), v = new Vector3(0, 1, 0);
  return Array(f.length / 3).fill(0).map((g, S) => {
    if (n) {
      const L = e.clone();
      Et(L, t), c.map = L;
    } else
      c.color = o;
    const w = n ? new Sprite$1(new SpriteMaterial(c)) : new Mesh(u, new MeshBasicMaterial(c)), E = S * 3;
    return w.position.set(f[E], f[E + 1], f[E + 2]), n && w.position.normalize().multiplyScalar(1.7), w.scale.setScalar(l), w.up.copy(v), w.lookAt(y.copy(w.position).multiplyScalar(2)), !n && !w.position.y && (w.rotation.z = Math.PI / 2), w.renderOrder = 1, w.userData = {
      color: o,
      opacity: a,
      scale: l,
      hover: d
    }, w;
  });
};
function Ge(s, e = false) {
  const t = s[0].index !== null, n = new Set(Object.keys(s[0].attributes)), i = new Set(Object.keys(s[0].morphAttributes)), o = {}, a = {}, l = s[0].morphTargetsRelative, d = new BufferGeometry();
  let h = 0;
  for (let r = 0; r < s.length; ++r) {
    const u = s[r];
    let c = 0;
    if (t !== (u.index !== null))
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (const f in u.attributes) {
      if (!n.has(f))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'), null;
      o[f] === void 0 && (o[f] = []), o[f].push(u.attributes[f]), c++;
    }
    if (c !== n.size)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". Make sure all geometries have the same number of attributes."), null;
    if (l !== u.morphTargetsRelative)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (const f in u.morphAttributes) {
      if (!i.has(f))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ".  .morphAttributes must be consistent throughout all geometries."), null;
      a[f] === void 0 && (a[f] = []), a[f].push(u.morphAttributes[f]);
    }
    if (e) {
      let f;
      if (t)
        f = u.index.count;
      else if (u.attributes.position !== void 0)
        f = u.attributes.position.count;
      else
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". The geometry must have either an index or a position attribute"), null;
      d.addGroup(h, f, r), h += f;
    }
  }
  if (t) {
    let r = 0;
    const u = [];
    for (let c = 0; c < s.length; ++c) {
      const f = s[c].index;
      for (let y = 0; y < f.count; ++y)
        u.push(f.getX(y) + r);
      r += s[c].attributes.position.count;
    }
    d.setIndex(u);
  }
  for (const r in o) {
    const u = It(o[r]);
    if (!u)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + r + " attribute."), null;
    d.setAttribute(r, u);
  }
  for (const r in a) {
    const u = a[r][0].length;
    if (u === 0) break;
    d.morphAttributes = d.morphAttributes || {}, d.morphAttributes[r] = [];
    for (let c = 0; c < u; ++c) {
      const f = [];
      for (let v = 0; v < a[r].length; ++v)
        f.push(a[r][v][c]);
      const y = It(f);
      if (!y)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + r + " morphAttribute."), null;
      d.morphAttributes[r].push(y);
    }
  }
  return d;
}
function It(s) {
  let e, t, n, i = -1, o = 0;
  for (let h = 0; h < s.length; ++h) {
    const r = s[h];
    if (e === void 0 && (e = r.array.constructor), e !== r.array.constructor)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (t === void 0 && (t = r.itemSize), t !== r.itemSize)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (n === void 0 && (n = r.normalized), n !== r.normalized)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    if (i === -1 && (i = r.gpuType), i !== r.gpuType)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
    o += r.count * t;
  }
  const a = new e(o), l = new BufferAttribute(a, t, n);
  let d = 0;
  for (let h = 0; h < s.length; ++h) {
    const r = s[h];
    if (r.isInterleavedBufferAttribute) {
      const u = d / t;
      for (let c = 0, f = r.count; c < f; c++)
        for (let y = 0; y < t; y++) {
          const v = r.getComponent(c, y);
          l.setComponent(c + u, y, v);
        }
    } else
      a.set(r.array, d);
    d += r.count * t;
  }
  return i !== void 0 && (l.gpuType = i), l;
}
const Re = (s, e) => {
  const {
    isSphere: t,
    background: { enabled: n, color: i, opacity: o, hover: a }
  } = e;
  let l;
  const d = new MeshBasicMaterial({
    color: i,
    side: BackSide,
    opacity: o,
    transparent: true,
    depthWrite: false
  });
  if (!n) return null;
  if (t)
    l = new Mesh(
      new SphereGeometry(1.8, 64, 64),
      d
    );
  else {
    let h;
    s.forEach((r) => {
      const u = r.scale.x;
      r.scale.setScalar(0.9), r.updateMatrix();
      const c = r.geometry.clone();
      c.applyMatrix4(r.matrix), h = h ? Ge([h, c]) : c, r.scale.setScalar(u);
    }), l = new Mesh(h, d);
  }
  return l.userData = {
    color: i,
    opacity: o,
    hover: a
  }, l;
}, Ft = new Box3(), K = new Vector3();
class te extends InstancedBufferGeometry {
  constructor() {
    super(), this.isLineSegmentsGeometry = true, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n), this.setAttribute("position", new Float32BufferAttribute(e, 3)), this.setAttribute("uv", new Float32BufferAttribute(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new InstancedInterleavedBuffer(t, 6, 1);
    return this.setAttribute("instanceStart", new InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceEnd", new InterleavedBufferAttribute(n, 3, 3)), this.instanceCount = this.attributes.instanceStart.count, this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new InstancedInterleavedBuffer(t, 6, 1);
    return this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(n, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new WireframeGeometry(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Ft.setFromBufferAttribute(t), this.boundingBox.union(Ft));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let i = 0;
      for (let o = 0, a = e.count; o < a; o++)
        K.fromBufferAttribute(e, o), i = Math.max(i, n.distanceToSquared(K)), K.fromBufferAttribute(t, o), i = Math.max(i, n.distanceToSquared(K));
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib.line = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class Mt extends ShaderMaterial {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib.line.uniforms),
      vertexShader: ShaderLib.line.vertexShader,
      fragmentShader: ShaderLib.line.fragmentShader,
      clipping: true
      // required for clipping support
    }), this.isLineMaterial = true, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === true ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === true !== this.dashed && (this.needsUpdate = true), e === true ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === true !== this.alphaToCoverage && (this.needsUpdate = true), e === true ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
}
const dt = new Vector4(), kt = new Vector3(), Ht = new Vector3(), A = new Vector4(), M = new Vector4(), O = new Vector4(), ut = new Vector3(), ht = new Matrix4(), T = new Line3(), jt = new Vector3(), tt = new Box3(), et = new Sphere(), D = new Vector4();
let P, j;
function Wt(s, e, t) {
  return D.set(0, 0, -e, 1).applyMatrix4(s.projectionMatrix), D.multiplyScalar(1 / D.w), D.x = j / t.width, D.y = j / t.height, D.applyMatrix4(s.projectionMatrixInverse), D.multiplyScalar(1 / D.w), Math.abs(Math.max(D.x, D.y));
}
function Ie(s, e) {
  const t = s.matrixWorld, n = s.geometry, i = n.attributes.instanceStart, o = n.attributes.instanceEnd, a = Math.min(n.instanceCount, i.count);
  for (let l = 0, d = a; l < d; l++) {
    T.start.fromBufferAttribute(i, l), T.end.fromBufferAttribute(o, l), T.applyMatrix4(t);
    const h = new Vector3(), r = new Vector3();
    P.distanceSqToSegment(T.start, T.end, r, h), r.distanceTo(h) < j * 0.5 && e.push({
      point: r,
      pointOnLine: h,
      distance: P.origin.distanceTo(r),
      object: s,
      face: null,
      faceIndex: l,
      uv: null,
      uv1: null
    });
  }
}
function Fe(s, e, t) {
  const n = e.projectionMatrix, o = s.material.resolution, a = s.matrixWorld, l = s.geometry, d = l.attributes.instanceStart, h = l.attributes.instanceEnd, r = Math.min(l.instanceCount, d.count), u = -e.near;
  P.at(1, O), O.w = 1, O.applyMatrix4(e.matrixWorldInverse), O.applyMatrix4(n), O.multiplyScalar(1 / O.w), O.x *= o.x / 2, O.y *= o.y / 2, O.z = 0, ut.copy(O), ht.multiplyMatrices(e.matrixWorldInverse, a);
  for (let c = 0, f = r; c < f; c++) {
    if (A.fromBufferAttribute(d, c), M.fromBufferAttribute(h, c), A.w = 1, M.w = 1, A.applyMatrix4(ht), M.applyMatrix4(ht), A.z > u && M.z > u)
      continue;
    if (A.z > u) {
      const E = A.z - M.z, L = (A.z - u) / E;
      A.lerp(M, L);
    } else if (M.z > u) {
      const E = M.z - A.z, L = (M.z - u) / E;
      M.lerp(A, L);
    }
    A.applyMatrix4(n), M.applyMatrix4(n), A.multiplyScalar(1 / A.w), M.multiplyScalar(1 / M.w), A.x *= o.x / 2, A.y *= o.y / 2, M.x *= o.x / 2, M.y *= o.y / 2, T.start.copy(A), T.start.z = 0, T.end.copy(M), T.end.z = 0;
    const v = T.closestPointToPointParameter(ut, true);
    T.at(v, jt);
    const g = MathUtils.lerp(A.z, M.z, v), S = g >= -1 && g <= 1, w = ut.distanceTo(jt) < j * 0.5;
    if (S && w) {
      T.start.fromBufferAttribute(d, c), T.end.fromBufferAttribute(h, c), T.start.applyMatrix4(a), T.end.applyMatrix4(a);
      const E = new Vector3(), L = new Vector3();
      P.distanceSqToSegment(T.start, T.end, L, E), t.push({
        point: L,
        pointOnLine: E,
        distance: P.origin.distanceTo(L),
        object: s,
        face: null,
        faceIndex: c,
        uv: null,
        uv1: null
      });
    }
  }
}
class ke extends Mesh {
  constructor(e = new te(), t = new Mt({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = true, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, i = new Float32Array(2 * t.count);
    for (let a = 0, l = 0, d = t.count; a < d; a++, l += 2)
      kt.fromBufferAttribute(t, a), Ht.fromBufferAttribute(n, a), i[l] = l === 0 ? 0 : i[l - 1], i[l + 1] = i[l] + kt.distanceTo(Ht);
    const o = new InstancedInterleavedBuffer(i, 2, 1);
    return e.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(o, 1, 0)), e.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(o, 1, 1)), this;
  }
  raycast(e, t) {
    const n = this.material.worldUnits, i = e.camera;
    i === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const o = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    P = e.ray;
    const a = this.matrixWorld, l = this.geometry, d = this.material;
    j = d.linewidth + o, l.boundingSphere === null && l.computeBoundingSphere(), et.copy(l.boundingSphere).applyMatrix4(a);
    let h;
    if (n)
      h = j * 0.5;
    else {
      const u = Math.max(i.near, et.distanceToPoint(P.origin));
      h = Wt(i, u, d.resolution);
    }
    if (et.radius += h, P.intersectsSphere(et) === false)
      return;
    l.boundingBox === null && l.computeBoundingBox(), tt.copy(l.boundingBox).applyMatrix4(a);
    let r;
    if (n)
      r = j * 0.5;
    else {
      const u = Math.max(i.near, tt.distanceToPoint(P.origin));
      r = Wt(i, u, d.resolution);
    }
    tt.expandByScalar(r), P.intersectsBox(tt) !== false && (n ? Ie(this, t) : Fe(this, i, t));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t && t.resolution && (e.getViewport(dt), this.material.uniforms.resolution.value.set(dt.z, dt.w));
  }
}
class ee extends te {
  constructor() {
    super(), this.isLineGeometry = true, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let i = 0; i < t; i += 3)
      n[2 * i] = e[i], n[2 * i + 1] = e[i + 1], n[2 * i + 2] = e[i + 2], n[2 * i + 3] = e[i + 3], n[2 * i + 4] = e[i + 4], n[2 * i + 5] = e[i + 5];
    return super.setPositions(n), this;
  }
  setColors(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let i = 0; i < t; i += 3)
      n[2 * i] = e[i], n[2 * i + 1] = e[i + 1], n[2 * i + 2] = e[i + 2], n[2 * i + 3] = e[i + 3], n[2 * i + 4] = e[i + 4], n[2 * i + 5] = e[i + 5];
    return super.setColors(n), this;
  }
  setFromPoints(e) {
    const t = e.length - 1, n = new Float32Array(6 * t);
    for (let i = 0; i < t; i++)
      n[6 * i] = e[i].x, n[6 * i + 1] = e[i].y, n[6 * i + 2] = e[i].z || 0, n[6 * i + 3] = e[i + 1].x, n[6 * i + 4] = e[i + 1].y, n[6 * i + 5] = e[i + 1].z || 0;
    return super.setPositions(n), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class He extends ke {
  constructor(e = new ee(), t = new Mt({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = true, this.type = "Line2";
  }
}
const je = (s) => {
  const e = new Color(), t = [], n = [], { isSphere: i } = s;
  if (Y.forEach((l, d) => {
    const { enabled: h, line: r, scale: u, color: c } = s[l];
    if (!h || !r) return;
    const f = d < 3 ? 1 : -1, v = (i ? Kt - u / 2 : 0.975) * f;
    t.push(
      l.includes("x") ? v : 0,
      l.includes("y") ? v : 0,
      l.includes("z") ? v : 0,
      0,
      0,
      0
    );
    const g = e.set(c).toArray();
    n.push(...g, ...g);
  }), !t.length) return null;
  const o = new ee().setPositions(t).setColors(n), a = new Mt({
    linewidth: s.lineWidth,
    vertexColors: true,
    resolution: new Vector2(window.innerWidth, window.innerHeight)
  });
  return new He(o, a).computeLineDistances();
}, We = (s) => {
  const { corners: e, edges: t } = s, n = [], i = Be(s), o = Oe(s, i);
  n.push(...o), e.enabled && n.push(...De(s, i)), t.enabled && n.push(...Pe(s, i, e.enabled ? 7 : 6));
  const a = Re(o, s), l = je(s);
  return [n, a, l];
}, $ = (s, e = true) => {
  const { material: t, userData: n } = s, { opacity: i, color: o, scale: a } = e ? n.hover : n;
  s.scale.setScalar(a), t.opacity = i, t.map ? Ce(t.map, e) : t.color.set(o);
}, q = /* @__PURE__ */ new Matrix4(), qt = /* @__PURE__ */ new Spherical(), qe = /* @__PURE__ */ new Vector2(), H = /* @__PURE__ */ new Vector3(), Nt = /* @__PURE__ */ new Vector4();
class Xe extends Object3D {
  /**
   * Creates a new ViewportGizmo instance.
   *
   * @param camera - The camera to be controlled by this gizmo
   * @param renderer - The WebGL renderer used to render the scene
   * @param options - {@link GizmoOptions}, Configuration options for the gizmo.
   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string
   * @param options.type - The gizmo configuration type. Either 'sphere' or 'cube', defaults to 'sphere'
   * @param options.size - Size of the gizmo widget in pixels. Defaults to 128
   * @param options.placement - Position of the gizmo in the viewport
   *    Options include:
   *    - `"top-left"`
   *    - `"top-center"`
   *    - `"top-right"`
   *    - `"center-left"`
   *    - `"center-center"`
   *    - `"center-right"`
   *    - `"bottom-left"`
   *    - `"bottom-center"`
   *    - `"bottom-right"`
   * @param options.offset - Offset of the gizmo from container edges in pixels
   * @param options.offset.left - Offset from the left edge
   * @param options.offset.top - Offset from the top edge
   * @param options.offset.right - Offset from the right edge
   * @param options.offset.bottom - Offset from the bottom edge
   * @param options.animated - Whether view changes should be animated. Defaults to true
   * @param options.speed - Animation speed multiplier. Defaults to 1
   * @param options.resolution - Texture resolution. Defaults to 64 for sphere, 128 for cube
   * @param options.lineWidth - Width of the axes lines in pixels
   * @param options.id - HTML `id` attribute for the gizmo container
   * @param options.className - HTML `class` attribute for the gizmo container
   * @param options.font - Font configuration for axis labels
   * @param options.font.family - Font family for axis labels
   * @param options.font.weight - Font weight for axis labels
   * @param options.background - Configuration for the background sphere/cube
   * @param options.background.enabled - Whether to display the background
   * @param options.background.color - Color of the background in normal state
   * @param options.background.opacity - Opacity of the background in normal state
   * @param options.background.hover.color - Color of the background when hovered
   * @param options.background.hover.opacity - Opacity of the background when hovered
   * @param options.corners - Configuration for corner indicators
   * @param options.corners.enabled - Whether to display corner indicators
   * @param options.corners.color - Base color of corner indicators
   * @param options.corners.opacity - Opacity of corner indicators
   * @param options.corners.scale - Scale multiplier for corner indicators
   * @param options.corners.radius - Radius of corner indicators
   * @param options.corners.smoothness - Smoothness of corner indicators
   * @param options.corners.hover.color - Color of corner indicators when hovered
   * @param options.corners.hover.opacity - Opacity of corner indicators when hovered
   * @param options.corners.hover.scale - Scale of corner indicators when hovered
   * @param options.edges - Configuration for edge indicators
   * @param options.edges.enabled - Whether to display edge indicators
   * @param options.edges.color - Base color of edge indicators
   * @param options.edges.opacity - Opacity of edge indicators
   * @param options.edges.scale - Scale multiplier for edge indicators
   * @param options.edges.radius - Radius of edge indicators
   * @param options.edges.smoothness - Smoothness of edge indicators
   * @param options.edges.hover.color - Color of edge indicators when hovered
   * @param options.edges.hover.opacity - Opacity of edge indicators when hovered
   * @param options.edges.hover.scale - Scale of edge indicators when hovered
   * @param options.x - Configuration for positive X axis/face
   * @param options.y - Configuration for positive Y axis/face
   * @param options.z - Configuration for positive Z axis/face
   * @param options.nx - Configuration for negative X axis/face
   * @param options.ny - Configuration for negative Y axis/face
   * @param options.nz - Configuration for negative Z axis/face
   *
   * @remarks Axis-specific configuration can also use alias names for cube mode:
   * - `right` (same as `x`)
   * - `left` (same as `nx`)
   * - `top` (same as `y`)
   * - `bottom` (same as `ny`)
   * - `front` (same as `z`)
   * - `back` (same as `nz`)
   *
   * For each axis/face configuration, the following options are available:
   * @param options.AXIS.enabled - Whether to draw the axis
   * @param options.AXIS.label - Custom text label for the axis
   * @param options.AXIS.opacity - Axis opacity
   * @param options.AXIS.scale - Scale multiplier for indicator size
   * @param options.AXIS.line - Whether to draw the axis line
   * @param options.AXIS.color - Axis indicator background color
   * @param options.AXIS.labelColor - Axis label color
   * @param options.AXIS.border.size - Border size around the axis indicator
   * @param options.AXIS.border.color - Border color around the axis indicator
   * @param options.AXIS.hover.color - Fill color on hover
   * @param options.AXIS.hover.labelColor - Label text color on hover
   * @param options.AXIS.hover.opacity - Opacity when hovered
   * @param options.AXIS.hover.scale - Indicator scale when hovered
   * @param options.AXIS.hover.border.size - Hover border size
   * @param options.AXIS.hover.border.color - Hover border color
   */
  constructor(t, n, i = {}) {
    super();
    /** Whether the gizmo is currently active and responding to user input */
    m(this, "enabled", true);
    /** The camera being controlled by this gizmo */
    m(this, "camera");
    /** The WebGLRenderer rendering the gizmo */
    m(this, "renderer");
    /** The configuration options */
    m(this, "options");
    /** The point around which the camera rotates */
    m(this, "target", new Vector3());
    /** Whether view changes should be animated */
    m(this, "animated", true);
    /** The speed of view change animations. Higher values result in faster animations */
    m(this, "speed", 1);
    /**
     * Indicates whether the gizmo is currently being animated or not,
     * Useful when interacting with other camera controllers
     *
     * @readonly This value is set internally.
     **/
    m(this, "animating", false);
    m(this, "_options");
    m(this, "_intersections");
    m(this, "_background", null);
    m(this, "_viewport", [0, 0, 0, 0]);
    m(this, "_originalViewport", [0, 0, 0, 0]);
    m(this, "_originalScissor", [0, 0, 0, 0]);
    m(this, "_scene");
    m(this, "_camera");
    m(this, "_container");
    m(this, "_domElement");
    m(this, "_domRect");
    m(this, "_dragging", false);
    m(this, "_distance", 0);
    m(this, "_clock", new Clock());
    m(this, "_targetQuaternion", new Quaternion());
    m(this, "_quaternionStart", new Quaternion());
    m(this, "_quaternionEnd", new Quaternion());
    m(this, "_pointerStart", new Vector2());
    m(this, "_focus", null);
    m(this, "_placement");
    m(this, "_controls");
    m(this, "_controlsListeners");
    this.camera = t, this.renderer = n, this._scene = new Scene().add(this), this.set(i);
  }
  /** Gets the current placement of the gizmo relative to its container. */
  get placement() {
    return this._placement;
  }
  /**
   * Sets and update the placement of the gizmo relative to its container.
   *
   * @param placement - The new placement position
   */
  set placement(t) {
    this._placement = Qt(this._domElement, t), this.domUpdate();
  }
  /**
   * Regenerates the gizmo with the new options.
   *
   * @remarks
   * - Not recommended for use in real-time rendering or animation loops
   * - Provides a way to completely rebuild the gizmo with new options
   * - Can be computationally expensive, so use sparingly
   */
  set(t = {}) {
    this.dispose(), this.options = t, this._options = ze(t), this._camera = this._options.isSphere ? new OrthographicCamera(-1.8, 1.8, 1.8, -1.8, 5, 10) : new PerspectiveCamera(26, 1, 5, 10), this._camera.position.set(0, 0, 7);
    const [n, i, o] = We(this._options);
    i && this.add(i), o && this.add(o), this.add(...n), this._background = i, this._intersections = n;
    const { container: a, animated: l, speed: d } = this._options;
    return this.animated = l, this.speed = d, this._container = a ? xe(a) : document.body, this._domElement = Se(this._options), this._domElement.onpointerdown = (h) => this._onPointerDown(h), this._domElement.onpointermove = (h) => this._onPointerMove(h), this._domElement.onpointerleave = () => this._onPointerLeave(), this._container.appendChild(this._domElement), this._controls && this.attachControls(this._controls), this.update(), this._updateOrientation(true), this;
  }
  /**
   * Renders the gizmo to the screen.
   * This method handles viewport and scissor management to ensure the gizmo
   * renders correctly without affecting the main scene rendering.
   *
   * @returns The gizmo instance for method chaining
   */
  render() {
    this.animating && this._animate();
    const { renderer: t, _viewport: n } = this, i = t.getScissorTest(), o = t.autoClear;
    return t.autoClear = false, t.setViewport(...n), i && t.setScissor(...n), t.clear(false, true, false), t.render(this._scene, this._camera), t.setViewport(...this._originalViewport), i && t.setScissor(...this._originalScissor), t.autoClear = o, this;
  }
  /**
   * Updates the gizmo's DOM-related properties based on its current position
   * and size in the document.
   *
   * @returns The gizmo instance for method chaining
   */
  domUpdate() {
    this._domRect = this._domElement.getBoundingClientRect();
    const t = this.renderer, n = this._domRect, i = t.domElement.getBoundingClientRect();
    return this._viewport.splice(
      0,
      4,
      n.left - i.left,
      t.domElement.clientHeight - (n.top - i.top + n.height),
      n.width,
      n.height
    ), t.getViewport(Nt).toArray(this._originalViewport), t.getScissorTest() && t.getScissor(Nt).toArray(this._originalScissor), this;
  }
  /**
   * Updates the gizmo's orientation to match the current camera orientation.
   *
   * @returns The gizmo instance for method chaining
   */
  cameraUpdate() {
    return this._updateOrientation(), this;
  }
  /**
   * Performs a complete update of the gizmo, including both DOM and camera-related updates.
   *
   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.
   *
   * @returns The gizmo instance for method chaining
   */
  update(t = true) {
    return t && this._controls && this._controls.update(), this.domUpdate().cameraUpdate();
  }
  /**
   * Connects OrbitControls with the gizmo, handling interaction states and updates.
   * Automatically detaches any previously attached controls.
   *
   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}
   */
  attachControls(t) {
    return this.detachControls(), this.target = t.target, this._controlsListeners = {
      start: () => t.enabled = false,
      end: () => t.enabled = true,
      change: () => this.update(false)
    }, this.addEventListener("start", this._controlsListeners.start), this.addEventListener("end", this._controlsListeners.end), t.addEventListener("change", this._controlsListeners.change), this._controls = t, this;
  }
  /** Removes all control event listeners and references. Safe to call multiple times. */
  detachControls() {
    if (!(!this._controlsListeners || !this._controls))
      return this.target = new Vector3().copy(this._controls.target), this.removeEventListener("start", this._controlsListeners.start), this.removeEventListener("end", this._controlsListeners.end), this._controls.removeEventListener(
        "change",
        this._controlsListeners.change
      ), this._controlsListeners = void 0, this._controls = void 0, this;
  }
  /** Cleans up all resources including geometries, materials, textures, and event listeners. */
  dispose() {
    var t;
    this.detachControls(), this.children.forEach((n) => {
      var o, a, l, d;
      this.remove(n);
      const i = n;
      (o = i.material) == null || o.dispose(), (l = (a = i.material) == null ? void 0 : a.map) == null || l.dispose(), (d = i.geometry) == null || d.dispose();
    }), (t = this._domElement) == null || t.remove();
  }
  /**
   * Updates the gizmo's orientation either based on the camera or internal state.
   *
   * @private
   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)
   */
  _updateOrientation(t = true) {
    t && (this.quaternion.copy(this.camera.quaternion).invert(), this.updateMatrixWorld()), Ot(this._options, this._intersections, this.camera);
  }
  /**
   * Handles the animation of camera position and orientation changes.
   *
   * @private
   */
  _animate() {
    const { position: t, quaternion: n } = this.camera;
    if (t.set(0, 0, 1), !this.animated) {
      t.applyQuaternion(this._quaternionEnd).multiplyScalar(this._distance).add(this.target), n.copy(this._targetQuaternion), this._updateOrientation(), this.animating = false, this.dispatchEvent({ type: "change" }), this.dispatchEvent({ type: "end" });
      return;
    }
    this._controls && (this._controls.enabled = false);
    const o = this._clock.getDelta() * Me * this.speed;
    this._quaternionStart.rotateTowards(this._quaternionEnd, o), t.applyQuaternion(this._quaternionStart).multiplyScalar(this._distance).add(this.target), n.rotateTowards(this._targetQuaternion, o), this._updateOrientation(), requestAnimationFrame(() => this.dispatchEvent({ type: "change" })), this._quaternionStart.angleTo(this._quaternionEnd) < lt && (this._controls && (this._controls.enabled = true), this.animating = false, this.dispatchEvent({ type: "end" }));
  }
  /**
   * Sets the camera orientation to look at the target from a specific axis.
   *
   * @private
   * @param position - The axis point position
   */
  _setOrientation(t) {
    const n = this.camera, i = this.target;
    H.copy(t).multiplyScalar(this._distance), q.setPosition(H).lookAt(H, this.position, this.up), this._targetQuaternion.setFromRotationMatrix(q), H.add(i), q.lookAt(H, i, this.up), this._quaternionEnd.setFromRotationMatrix(q), q.setPosition(n.position).lookAt(n.position, i, this.up), this._quaternionStart.setFromRotationMatrix(q), this.animating = true, this._clock.start(), this.dispatchEvent({ type: "start" });
  }
  /**
   * Handles the pointer down event for starting drag operations.
   *
   * @private
   * @param e - The pointer event
   */
  _onPointerDown(t) {
    if (!this.enabled) return;
    const n = (h) => {
      if (!this._dragging) {
        if (Ae(h, this._pointerStart)) return;
        this._dragging = true;
      }
      const r = qe.set(h.clientX, h.clientY).sub(this._pointerStart).multiplyScalar(1 / this._domRect.width * Math.PI), u = this.coordinateConversion(
        H.subVectors(this.camera.position, this.target)
      ), c = qt.setFromVector3(u);
      c.theta = l - r.x, c.phi = mt(
        d - r.y,
        lt,
        Math.PI - lt
      ), this.coordinateConversion(
        this.camera.position.setFromSpherical(c),
        true
      ).add(this.target), this.camera.lookAt(this.target), this.quaternion.copy(this.camera.quaternion).invert(), this._updateOrientation(false), this.dispatchEvent({ type: "change" });
    }, i = () => {
      if (document.removeEventListener("pointermove", n, false), document.removeEventListener("pointerup", i, false), !this._dragging) return this._handleClick(t);
      this._focus && ($(this._focus, false), this._focus = null), this._dragging = false, this.dispatchEvent({ type: "end" });
    };
    if (this.animating) return;
    t.preventDefault(), this._pointerStart.set(t.clientX, t.clientY);
    const o = this.coordinateConversion(
      H.subVectors(this.camera.position, this.target)
    ), a = qt.setFromVector3(o), l = a.theta, d = a.phi;
    this._distance = a.radius, document.addEventListener("pointermove", n, false), document.addEventListener("pointerup", i, false), this.dispatchEvent({ type: "start" });
  }
  /**
   * Converts the input-coordinates from the standard Y-axis up to what is set in Object3D.DEFAULT_UP.
   *
   * @private
   * @param target      - The target Vector3 to be converted
   * @param isSpherical - Whether or not the coordinates are for a sphere
   * @returns The converted coordinates
   */
  coordinateConversion(t, n = false) {
    const { x: i, y: o, z: a } = t, l = Object3D.DEFAULT_UP;
    return l.x === 1 ? n ? t.set(o, a, i) : t.set(a, i, o) : l.z === 1 ? n ? t.set(a, i, o) : t.set(o, a, i) : t;
  }
  /**
   * Handles pointer move events for hover effects and drag operations.
   *
   * @private
   * @param e - The pointer event
   */
  _onPointerMove(t) {
    !this.enabled || this._dragging || (this._background && Rt(this._background, true), this._handleHover(t));
  }
  /**
   * Handles pointer leave events to reset hover states.
   *
   * @private
   */
  _onPointerLeave() {
    !this.enabled || this._dragging || (this._background && Rt(this._background, false), this._focus && $(this._focus, false), this._domElement.style.cursor = "");
  }
  /**
   * Handles click events for axis selection.
   *
   * @private
   * @param e - The pointer event
   */
  _handleClick(t) {
    const n = Gt(
      t,
      this._domRect,
      this._camera,
      this._intersections
    );
    this._focus && ($(this._focus, false), this._focus = null), n && (this._setOrientation(n.object.position), this.dispatchEvent({ type: "change" }));
  }
  /**
   * Handles hover effects for interactive elements.
   *
   * @private
   * @param e - The pointer event
   */
  _handleHover(t) {
    const n = Gt(
      t,
      this._domRect,
      this._camera,
      this._intersections
    ), i = (n == null ? void 0 : n.object) || null;
    this._focus !== i && (this._domElement.style.cursor = i ? "pointer" : "", this._focus && $(this._focus, false), (this._focus = i) ? $(i, true) : Ot(this._options, this._intersections, this.camera));
  }
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
class GizmoManager extends Component {
  constructor(options) {
    super(options);
    __publicField$1(this, "cubeGizmo");
    __publicField$1(this, "sphereGizmo");
  }
  initSphereGizmo() {
    this.sphereGizmo = new Xe(this.camera, this.renderer, {
      container: this.container,
      placement: "top-right",
      lineWidth: 10,
      corners: {
        // enabled: true,
      },
      edges: {
        // enabled: true,
      }
    });
    const cameraControls = this.cameraControls;
    const camera = this.camera;
    this.sphereGizmo.addEventListener("start", () => {
      cameraControls.enabled = false;
    });
    this.sphereGizmo.addEventListener("end", () => {
      cameraControls.enabled = true;
    });
    this.sphereGizmo.addEventListener("change", () => {
      cameraControls.setPosition(...camera.position.toArray()).then();
    });
    cameraControls.addEventListener("update", () => {
      cameraControls.getTarget(this.sphereGizmo.target);
      this.sphereGizmo.update();
    });
    this.eventManager.renderSubject.subscribe(() => {
      this.sphereGizmo.render();
    });
    this.eventManager.resizeSubject.subscribe(() => {
      this.sphereGizmo.update();
    });
  }
  initCubeGizmo() {
    const darkColors = {
      color: 3355443,
      labelColor: 14540253,
      hover: {
        color: 4959364,
        labelColor: 16777215
      }
    };
    const darkBackground = {
      color: 4473924,
      hover: { color: 4473924 }
    };
    const darkCubeConfig = {
      container: this.container,
      type: "cube",
      background: darkBackground,
      corners: darkColors,
      edges: darkColors,
      placement: "bottom-right",
      right: {
        label: "\u53F3\u4FA7",
        ...darkColors
      },
      top: {
        label: "\u9876\u90E8",
        ...darkColors
      },
      front: {
        label: "\u6B63\u9762",
        ...darkColors
      },
      left: {
        label: "\u5DE6\u4FA7"
      },
      bottom: {
        label: "\u5E95\u90E8"
      },
      back: {
        label: "\u80CC\u9762"
      }
    };
    this.cubeGizmo = new Xe(this.camera, this.renderer, darkCubeConfig);
    const cameraControls = this.cameraControls;
    const camera = this.camera;
    this.cubeGizmo.addEventListener("start", () => {
      cameraControls.enabled = false;
    });
    this.cubeGizmo.addEventListener("end", () => {
      cameraControls.enabled = true;
    });
    this.cubeGizmo.addEventListener("change", () => {
      cameraControls.setPosition(...camera.position.toArray()).then();
    });
    cameraControls.addEventListener("update", () => {
      cameraControls.getTarget(this.cubeGizmo.target);
      this.cubeGizmo.update();
    });
    this.eventManager.renderSubject.subscribe(() => {
      this.cubeGizmo.render();
    });
    this.eventManager.resizeSubject.subscribe(() => {
      this.cubeGizmo.update();
    });
  }
}

var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var _enableGrid;
var ESceneLoadType = /* @__PURE__ */ ((ESceneLoadType2) => {
  ESceneLoadType2[ESceneLoadType2["Load"] = 0] = "Load";
  ESceneLoadType2[ESceneLoadType2["Down"] = 1] = "Down";
  ESceneLoadType2[ESceneLoadType2["UnZip"] = 2] = "UnZip";
  return ESceneLoadType2;
})(ESceneLoadType || {});
var ESceneSaveType = /* @__PURE__ */ ((ESceneSaveType2) => {
  ESceneSaveType2[ESceneSaveType2["Save"] = 0] = "Save";
  ESceneSaveType2[ESceneSaveType2["Put"] = 1] = "Put";
  ESceneSaveType2[ESceneSaveType2["Zip"] = 2] = "Zip";
  return ESceneSaveType2;
})(ESceneSaveType || {});
const _Viewer = class _Viewer {
  constructor(container, options = {}) {
    __publicField(this, "options");
    // 存储选项
    __publicField(this, "container");
    // 容器元素
    __publicField(this, "clock");
    // 定时器
    __publicField(this, "animationMixer");
    // 动画混合器
    __publicField(this, "scene");
    // 主场景
    // 各种管理类
    __publicField(this, "eventManager");
    // 事件管理
    __publicField(this, "assetManager");
    // 资源管理
    __publicField(this, "renderManager");
    // 渲染管理
    __publicField(this, "helperManager");
    // 辅助管理
    __publicField(this, "gizmoManager");
    __publicField(this, "postProcessingComponent");
    // 后处理管理
    __publicField(this, "debug");
    // 调试管理
    __publicField(this, "loop");
    // 循环管理
    __publicField(this, "cssRenderer");
    // CSS 渲染器
    //-----------------
    __publicField(this, "cameraManager");
    // 相机控制
    __publicField(this, "sceneHelpers");
    // 场景辅助
    __publicField(this, "pick");
    // 拾取
    __publicField(this, "environmentManage");
    // 环境
    // @ts-ignore
    __publicField(this, "drawLine");
    // 绘制直线
    __publicField(this, "measureTool");
    // 测量工具
    __publicField(this, "editor");
    // 编辑器
    // 阿里对象存储
    __publicField(this, "ossApi", null);
    //=----------------------- 辅组对象
    __publicField(this, "grid");
    __publicField(this, "axesHelper");
    // 初始化组件完成
    __publicField(this, "initComponentSubject", new BehaviorSubject(true));
    // 场景初始化完成
    __publicField(this, "initSubject", new BehaviorSubject(true));
    //---------- 事件
    // 场景加载进度
    __publicField(this, "sceneLoadProgressSubject", new Subject());
    // 场景保存进度
    __publicField(this, "sceneSaveProgressSubject", new Subject());
    __publicField(this, "serializer");
    __privateAdd(this, _enableGrid, false);
    //------------------
    __publicField(this, "isLoad", false);
    //------------------------- 添加网格 开始 -------------------
    __publicField(this, "gridOptions");
    __publicField(this, "axesOptions");
    this.options = deepMergeRetain$1({
      ossBaseUrl: "three",
      isGizmo: false,
      scene: {
        background: new THREE$2.Color("black")
      }
    }, options);
    this.initContainer(container);
    this.clock = new THREE$2.Clock();
    this.scene = new PScene();
    this.scene.name = "scene";
    if (this.options?.scene?.background) {
      this.scene.background = this.options.scene.background;
    }
    this.sceneHelpers = new PScene();
    this.sceneHelpers.name = "sceneHelpers";
    this.eventManager = new EventManager({ viewer: this });
    this.renderManager = new RenderManager({ viewer: this });
    this.cameraManager = new CameraManager({ viewer: this });
    this.postProcessingComponent = new PostProcessingComponent({ viewer: this });
    this.helperManager = new HelperManager({ viewer: this });
    this.assetManager = new AssetManager({ viewer: this });
    this.pick = new Pick({ viewer: this });
    this.cssRenderer = new CssRenderer({ viewer: this });
    this.environmentManage = new EnvironmentManage({ viewer: this });
    this.drawLine = new DrawLine({ viewer: this });
    this.measureTool = new MeasureTool({ viewer: this });
    this.gizmoManager = new GizmoManager({ viewer: this });
    this.animationMixer = new THREE$2.AnimationMixer(this.scene);
    this.addCanvasToContainer();
    this.setSize();
    this.eventManager.resizeSubject.subscribe(() => {
      this.setSize();
    });
    this.debug = new DebugManager({ viewer: this });
    this.loop = new Loop({ viewer: this });
    this.editor = new Editor({ viewer: this });
    this.editor.initComponent();
    this.loop.startLoop();
    this.initComponent().then();
  }
  get isEnableGrid() {
    return this.grid !== void 0;
  }
  setGrid(inOptions) {
    const options = defaults(inOptions, {
      visible: true
    });
    const { visible } = options;
    if (visible) {
      if (this.grid) {
        this.sceneHelpers.remove(this.grid);
        this.grid.dispose();
      }
      this.grid = new Grid(options);
      this.grid.name = "grid";
      this.sceneHelpers.add(this.grid);
      this.loop.addEffect(() => {
        this.grid.tick(this.cameraManager.camera);
      });
    } else {
      if (!this.grid) return;
      this.sceneHelpers.remove(this.grid);
      this.grid.dispose();
    }
    this.gridOptions = options;
  }
  get isEnableAxes() {
    return this.axesHelper !== void 0;
  }
  setAxes(inOptions) {
    const options = defaults(inOptions, {
      size: 2e3,
      visible: true,
      dispose: false
    });
    const { size, visible, dispose } = options;
    if (this.axesHelper && this.axesOptions) {
      const isSizeChanged = this.axesOptions.size !== size;
      const isVisibleChanged = this.axesOptions.visible !== visible;
      if (isSizeChanged) {
        const vertices = [
          0,
          0,
          0,
          size,
          0,
          0,
          0,
          0,
          0,
          0,
          size,
          0,
          0,
          0,
          0,
          0,
          0,
          size
        ];
        this.axesHelper.geometry.setAttribute("position", new THREE$2.Float32BufferAttribute(vertices, 3));
        this.axesHelper.geometry.attributes.position.needsUpdate = true;
      }
      if (isVisibleChanged) {
        this.axesHelper.visible = visible;
      }
      if (dispose) {
        this.sceneHelpers.remove(this.axesHelper);
        this.axesHelper.dispose();
      }
    } else {
      this.axesHelper = new THREE$2.AxesHelper(size);
      this.sceneHelpers.add(this.axesHelper);
      this.axesHelper.visible = visible;
    }
    this.axesOptions = options;
  }
  /**
   * 创建 Viewer
   * @param container 容器
   * @param options 配置项
   */
  static async create(container, options) {
    return new Promise((resolve) => {
      const viewer = new _Viewer(container, options);
      viewer.initComponentSubject.subscribe(() => {
        resolve(viewer);
      });
    });
  }
  /**
   * 初始化场景
   */
  loadScene() {
    const serializer = getPackage(this);
    if (serializer) {
      this.serializer = serializer;
      serializer.loadScene();
    } else {
      this.setInitState();
    }
  }
  setInitState() {
    this.sceneLoadProgressSubject.next({
      type: 0 /* Load */,
      name: `\u52A0\u8F7D\u573A\u666F\u4E2D`,
      total: 1,
      loaded: 1
    });
    this.isLoad = true;
    console.log("\u6D3E\u53D1");
    this.initSubject.next(true);
  }
  async initComponent() {
    if (this.options.ossApiOptions) {
      this.ossApi = await OssApi.create(this.options.ossApiOptions);
      this.initComponentSubject.next(true);
    }
    if (this.options.isCubeGizmo) {
      this.gizmoManager.initCubeGizmo();
    }
    if (this.options.isSphereGizmo) {
      this.gizmoManager.initSphereGizmo();
    }
    this.initSubject.subscribe(() => {
      if (this.options.isCreateDefaultLight) {
        this.environmentManage.createDefaultLight();
      }
      if (this.options.isCreateDefaultEnvironment) {
        this.environmentManage.createDefaultEnvironment();
      }
      if (this.editor) {
        this.editor.editorEventManager.sceneGraphChanged.next(true);
      }
      this.eventManager.resizeSubject.next(true);
    });
    this.loadScene();
  }
  // 将画布添加到容器
  addCanvasToContainer() {
    const defaultWebGLRenderer = this.renderManager.defaultWebGLRenderer;
    const domElement = defaultWebGLRenderer.domElement;
    this.container.appendChild(domElement);
  }
  // 初始化容器
  initContainer(container) {
    if (isString(container)) {
      const divDom = document.getElementById(container);
      if (divDom !== null) {
        this.container = divDom;
      } else {
        throw new Error(`\u5F53\u524D\u6CA1\u6709\u627E\u5230 id \u4E3A ${container} \u7684 div \u6807\u7B7E`);
      }
    } else {
      this.container = container;
    }
  }
  // 获取容器的大小
  getSize() {
    const container = this.container;
    const width = container.offsetWidth;
    const height = container.offsetHeight;
    return { width, height };
  }
  // 获取大小的 Vector2 对象
  getSizeVector2() {
    const { width, height } = this.getSize();
    return new THREE$2.Vector2(width, height);
  }
  // 设置渲染器和控制器的大小
  setSize() {
    const { width, height } = this.getSize();
    this.cameraManager.setSize(width, height);
    this.renderManager.setSize(width, height);
    this.cssRenderer.setSize(width, height);
    this.postProcessingComponent.setSize(width, height);
    this.renderManager.render();
  }
  //--------------------- 截屏
  capture() {
    this.renderManager.render();
    return this.renderManager.defaultWebGLRenderer.domElement.toDataURL("image/png");
  }
  captureDown(name) {
    const data = this.capture();
    DownloadTool.saveImg(data, name);
  }
  //---------------- 查找节点---------------------
  getObjectByUuid(uuid) {
    return this.scene.getObjectByProperty("uuid", uuid);
  }
  search(array, searchMode = ESearchMode.MatchAll) {
    const search = new Search(array, searchMode);
    let result = [];
    this.scene.traverse((target) => {
      const isMatch = search.matching(target);
      if (isMatch) {
        result.push(target);
      }
    });
    return result;
  }
  //-------------------
  toJSON() {
    const sceneJson = this.scene.toJSON();
    const cameraManager = this.cameraManager.toJSON();
    return {
      scene: sceneJson,
      cameraManager
    };
  }
};
_enableGrid = new WeakMap();
let Viewer = _Viewer;

export { Asset, AssetManager, CameraManager, CatmullRomLine, CatmullRomLine2, CatmullRomLine2DefaultsOptions, CatmullRomLineDefaultsOptions, ChunkSerialize, Component, CssRenderer, CubicBezierLine, CubicBezierLineLine, CurveType, DebugManager, DebugPosition, DistanceMeasure, DownloadTool, DrawLine, DrawType, ECameraType, ECameraViewType, EDistanceMeasureTextModel, ESceneLoadType, ESceneSaveType, ESearchMode, Edges, EnvironmentManage, EnvironmentMode, EventManager, ExporterTool, GeometryMap, Grid, HeatMap2dMesh, HeatMap3dMesh, HelperManager, HtmlMesh, HtmlMeshType, Line, Line2, Line2DefaultsOptions, Line2Type, LineDefaultsOptions, LineMaterialType, LineTool, LineType, Loop, Measure, MeasureMode, MeasureTool, Outlines, Package, PartPackage, Path, PathMesh, PathTube, PathTubeMesh, Pick, PlumSky, PostProcessingComponent, QuadraticBezierLine, QuadraticBezierLine2, RenderManager, Search, SearchOperator, SelectiveBloomEffectOptionsDefault, SerializerTool, SourcePackage, Sprite, TextSprite, Tool$1 as Tool, Viewer, Wall, buildGraph, calcPosFromAngles, compareObjects, deepMergeRetain$1 as deepMergeRetain, extractFileNameAndExtension, getPackage, getStatistics, isUrl, logStack, normalize, packageMap, presetsObj, reflectGet, reflectSet, setByPath, shaderMaterial, throwDebug, throwNum, unZipObject, version, zipObject };
